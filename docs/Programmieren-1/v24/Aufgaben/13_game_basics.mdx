import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Game Basics - Sterne Fangen

![](images/12-game-basics/game_basics.gif)

Die Funktionalit√§t der mit einem \* markierten Abschnitte sollten in Eurem Spiel enthalten sein.

## 0. Vorbereitung \*

Auf OneDrive einen neuen Ordner `12_game` erstellen und diesen in VS Code √∂ffnen. Dort ein neues Programm erstellen, bspw. mit dem Namen `01_game.py`

## 1. Spieler \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'}]}
>
<TabItem value="step-0">

Das erste Spiel startet mit der bekannten Ausgangslage.

- **wichtig**: DeviceId so anpassen, dass sie mit derjenigen auf der Website [https://io.gbsl.website](https://io.gbsl.website) √ºbereinstimmt.

**Code laufen lassen und schauen ob alles funktioniert**

```py
from smartphone_connector import *
device = Connector('https://io.gbsl.website', 'FooBar')
device.configure_playground(
    width=100,
    height=180,
    origin_x=50,
    origin_y=0,
    color=Colors.BLACK
)

# der weitere Code wird hier eingef√ºgt...

device.disconnect()
```

</TabItem>

<TabItem value="step-1">

Damit bei √Ñnderungen der aktuelle Playground zuerst aufger√§umt wird, sollte dieser vor dem Konfigurieren gel√∂scht werden:

```py

device = Connector('https://io.gbsl.website', 'FooBar')

device.clear_playground()

device.configure_playground(
    width=100,
    height=180,
    origin_x=50,
    origin_y=0,
    color=Colors.BLACK
)
```

</TabItem>

<TabItem value="step-2">

Nun wird ein Spieler hinzugef√ºgt - ein Balken welcher sp√§ter durch Kippen des Smartphones bewegt werden soll.

```py
device.add_rectangle(
    width=20,
    height=10,
    color=Colors.WHITE,
    pos_x=0,
    pos_y=20
)
```

</TabItem>

<TabItem value="step-3">

Die Position stimmt noch nicht - der Balken soll zentral unten in der Mitte positioniert sein. √úber den **Parameter** `anchor` kann bestimmt werden, welcher Punkt im Rechteck positioniert wird.

- `[0, 0]` bedeutet unten links,
- `[1, 1]` oben rechts...
- Was bewirkt der untenstehende Wert f√ºr `anchor`?

Vorerst reicht diese Vorbereitung aus, im Abschnitt "Steuerung" wird die Kontrolle des Rechtecks vorgenommen. Zuerst aber wirds etwas bunt - wir lassen Sterne vom Himmel fallen üåü

```py
device.add_rectangle(
    width=20,
    height=10,
    color=Colors.WHITE,
    pos_x=0,
    pos_y=20,
    anchor=[0.5, 0]
)
```

</TabItem>
</Tabs>

---

## 2. Sterne \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'},
    {label: 'Schritt 4', value: 'step-4'}]}
>
<TabItem value="step-0">

Der Stern wird als Text-Zeichen `‚òÖ` mitgegeben. Damit nur der Stern angezeigt wird, werden keine `color` oder `border_color` Parameter √ºbergeben.

Der Stern soll vom oberen Rand des Bildschirms nach unten fallen. Wie?

```py
device.add_circle(
    text='‚òÖ',
    font_color=Colors.GOLD,
    font_size=10,
    pos_x=0,
    pos_y=180,
    radius=3
)
```

</TabItem>

<TabItem value="step-1">

... der Stern bekommt eine Richtung, in welche er sich mit der Geschwindigkeit `4` bewegen soll.

N√§chster Schritt: regelm√§ssig neue Sterne erzeugen

```py
device.add_circle(
    text='‚òÖ',
    font_color=Colors.GOLD,
    font_size=10,
    pos_x=0,
    pos_y=180,
    radius=3,
    direction=[0, -1],
    speed=4
)
```

</TabItem>

<TabItem value="step-2">

Um regelm√§ssig neue Sterne zu erzeugen, kann die Bibliothek `smartphone_connector` angewiesen werden, regelm√§ssig eine von uns definierte Funktion auszuf√ºhren. Dies geschieht √ºber die Methode `device.subscriby_async`. Das `async` steht f√ºr "Asynchron" und bedeutet, dass parallel zum regelm√§ssigen Aufrufen unserer Funktion weitergearbeitet werden kann.

Unten wird eine neue Funktion erstellt. Diese soll nun alle `2` Sekunden ausgef√ºhrt werden.

**Aufgabe**: Verwende bei deinem Skript einen passenden, deutschen Funktionsnamen.

(_Hinweis_: Das Programm erzeugt zwar keinen Fehler, aber es werden noch keine Sterne hinzugef√ºgt üò¢. Wieso? ‚ñ∂Ô∏è)

```py
def add_star():
    device.add_circle(
        text='‚òÖ',
        font_color=Colors.GOLD,
        font_size=10,
        pos_x=0,
        pos_y=180,
        radius=3,
        direction=[0, -1],
        speed=4
    )


device.subscribe_async(add_star, 2)
```

</TabItem>

<TabItem value="step-3">

Wir erleben die direkten Konsequenzen davon, dass `device.subscriby_async` asynchron l√§uft! Obwohl die Aufgabe (n√§mlich alle `2` Sekunden einen Stern hinzuzuf√ºgen) abgeschlossen ist, wird mit der n√§chsten Zeile weitergefahren.

Und auf der letzten Zeile steht `device.disconnect()` - also die Verbindung wird abgebrochen. Besser sollte dort gewartet werden, bis das Programm vom Benutzer gestoppt wird (mit dem üóëÔ∏è-Symbol).

```py
def add_star():
    device.add_circle(
        text='‚òÖ',
        font_color=Colors.GOLD,
        font_size=10,
        pos_x=0,
        pos_y=180,
        radius=3,
        direction=[0, -1],
        speed=4
    )


device.subscribe_async(add_star, 2)

device.wait()
```

</TabItem>

<TabItem value="step-4">

Yeah üéä üåü ü§©

Weiteres Vorgehen:

- Die Start-Position der Sterne **zuf√§llig** √ºber die ganze Playground-Breite verteilen.
- Zuf√§llige Farben f√ºr die Schriftfarbe verwenden
- (evtl. zuf√§llige Gr√∂ssen der Sterne?)

```py
from random import randint
```

</TabItem>
</Tabs>

---

## 3. Controller \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'},
    {label: 'Schritt 4', value: 'step-4'}]}
>
<TabItem value="step-0">

**Achtung!!**: F√ºr die Kontrolle werden die Beschleunigungssensoren des Smartphones ausgelesen. Deshalb sollte f√ºr diesen Schritt jeweils auf dem Smartphone [https://io.gbsl.website](https://io.gbsl.website/playground) aufgerufen werden und die Option _"Stream Acceleration"_ angeschaltet werden.

Nun soll das Rechteck kontrollierbar werden. Dazu schreiben wir eine √§hnliche Logik wie beim interaktiven Zeichnen mit den Turtles. Auch hier starten wir wieder eine asynchrone Subscription.

Vorerst wird nur das Grundger√ºst erstellt, die Funktion tut aktuell aber noch nichts.

**Wichtig** Der eingef√ºgte Code muss oberhalb von `device.wait()` eingef√ºgt werden.

**Aufgabe**:

- √úberpr√ºfe ob beim Starten des Programms im Terminal in hoher Frequenz "Controller Update" ausgegeben wird.
- Verwende einen deutschen Funktionsnamen f√ºr die Update Funktion.

```py
def on_update():
    print('Controller Update')


device.subscribe_async(on_update, 0.05)

device.wait()
```

</TabItem>

<TabItem value="step-1">

Um zu wissen, in welche Richtung das Rechteck verschoben werden soll, m√ºssen wir irgendwie an die aktuellen Sensor-Daten unseres Smartphones rankommen.

Der beim `subscribe_async` angegebenen Funktion (hier `on_update`) werden optional die aktuellen Daten des Smartphones √ºbergeben. Damit das Autovervollst√§ndigung im Editor richtig funktioniert, wird beim Parameter `data` nach einem Doppelpunkt der Typ angegeben.

Nun k√∂nnen auf die Beschleunigungswerte zugegriffen werden.

**Aufgabe**:

- √úberpr√ºfe, ob sich die Werte im Terminal √§ndern, wenn das Smartphone bewegt wird.

```py
def on_update(data: DataFrame):
    print('acceleration x', data.acceleration.x)


device.subscribe_async(on_update, 0.05)

device.wait()
```

</TabItem>

<TabItem value="step-2">

Um die Position des Rechtecks zu aktualisieren, muss bekannt sein, welches der vielen Objekte auf dem Bildschirm aktualisiert werden soll. Jedes dieser Objekte hat eine eindeutige (zuf√§llig generierte) `id`. Wir k√∂nnen diese Identifikation aber auch selber beim Erstellen des Rechtecks vergeben, so dass wir dieses Objekt kennen.

Funktioniert die Steuerung schon wunschgem√§ss? K√∂nnen beide R√§nder erreicht werden?

**Achtung!**: der weisse Balken f√ºr den Spieler wurde bereits hinzugef√ºgt (im Programm suchen wo...) - nun muss lediglich die `id` hinzugef√ºgt werden.

```py

device.add_rectangle(
    id='player',
    width=20,
    height=10,
    color=Colors.WHITE,
    pos_x=0,
    pos_y=20
)


def on_update(data: DataFrame):
    pos_x = data.acceleration.x
    device.update_rectangle(
        id='player',
        pos_x=pos_x
    )
```

</TabItem>

<TabItem value="step-3">

Um die Steuerung brauchbar zu machen, muss die aktuelle Position des Rechtecks zwischengespeichert werden - und zwar ausserhalb der Funktion `on_update`, damit sie nicht st√§ndig auf den Ausgangswert zur√ºckgesetzt wird.

Nun gibt es aber eine Art verspiegelte Scheibe zwischen einger√ºckten- und nicht einger√ºckten Code-Teilen:

![scopes](images/12-game-basics/scopes.png)

Diese verspiegelte Scheibe verhindert zudem, dass von Innerhalb eine Variable von Ausserhalb ge√§ndert wird.

Dieses Prinzip wird "Kapselung" genannt und ist enorm wichtig, um das Zusammespiel von Bibliotheken zu erm√∂glichen. Stellen Sie sich das Chaos vor, wenn Sie ein neues Programm schreiben, und dann immer ausprobieren m√ºssen, ob Sie beim Erstellen einer Variable nicht pl√∂tzlich eine wichtige Variable einer Bibliothek √ºberschreiben...

In gewissen Situationen m√∂chten wir aber Variablen der Aussenwelt √§ndern. Um dies zu tun, muss die Variable innerhalb des einger√ºckten Codeblocks als `global` gekennzeichnet werden.

**Achtung!**: Es reicht aus, wenn nur eine Funktion im Programm `on_update` heisst. √Ñndern Sie also diese Funktion ab, statt eine neue hinzuzuf√ºgen.

```py
player_pos_x = 0


def on_update(data: DataFrame):
    global player_pos_x
    player_pos_x = player_pos_x + data.acceleration.x
    device.update_rectangle(
        id='player',
        pos_x=player_pos_x
    )
```

</TabItem>

<TabItem value="step-4">

Und zu guter letzt: Das Rechteck soll nicht abhauen k√∂nnen...

**Aufgabe**: √úberpr√ºfe auch, dass das Rechteck links nicht komplett √ºber den Rand hinausschiesst.

```py
player_pos_x = 0


def on_update(data: DataFrame):
    global player_pos_x
    player_pos_x = player_pos_x + data.acceleration.x
    if player_pos_x > 50:
        player_pos_x = 50
    device.update_rectangle(
        id='player',
        pos_x=player_pos_x
    )
```

</TabItem>
</Tabs>

---

## 4. Highscore \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'},
    {label: 'Schritt 4', value: 'step-4'},
    {label: 'Schritt 5', value: 'step-5'}]}
>
<TabItem value="step-0">

Der aktuelle Score wird als Text angezeigt.
Nach der Konfiguration des Playgrounds f√ºgen wir dem Spiel einen Highscore hinzu.

```py
device.add_text(
    pos_x=-40,
    pos_y=160,
    font_color='white',
    font_size=2,
    text='Score: 3'
)
```

</TabItem>

<TabItem value="step-1">

Wie soll gez√§hlt werden?

**Vorschlag**:

- Fangen wir einen Stern: `+1` Leben
- Geht uns ein Stern durch die Lappen: `-1` Leben

Um herauszufinden, ob wir einen Stern gefangen haben, m√ºssen wir Kollisionen detektieren. Das √ºber die Eigenschaft `collision_detection` bei unserem Controller aktiviert werden. Danach wird jedes mal, wenn ein Objekt mit dem Controller kollidiert, eine Nachricht an uns geschickt.

```py
device.add_rectangle(
    id='player',
    width=20,
    height=10,
    color=Colors.WHITE,
    pos_x=0,
    pos_y=20,
    collision_detection=True
)
```

</TabItem>

<TabItem value="step-2">

Ganz unten im Programm (aber noch vor dem `device.wait()`) wird die Funktion `on_collision` definiert, welche bei jeder Kollision eines Objekts mit unserem Controller aufgerufen wird.

Das √ºbertragene Datenpaket wird unserer Funktion √ºbergeben - es hat den Type `SpriteCollisionMsg`.

**Aufgabe**: Wiederum einen eigenen, deutschen Namen f√ºr die Funktion verwenden.

**N√§chster Schritt**: Wir wollen den Score anpassen. Auch hier m√ºssen wir diesen Score wieder ausserhalb der Funktion abspeichern. Kannst du das Konzept von der `player_pos_x` hier selber anwenden? Versuche es bevor du zum n√§chsten Schritt gehst. **Hinweis**: `3` Schritte m√ºssen vorgenommen werden.

```py
def on_collision(data: SpriteCollisionMsg):
    print('score!')


device.on('collision', on_collision)
```

</TabItem>

<TabItem value="step-3">

Wenn die Variable f√ºrs Z√§hlen der Leben bei dir anders heisst, ist das kein Problem.

Nun m√∂chten wir den Stern von der Spielfl√§che entfernen, so dass er nicht pl√∂tzlich am unteren Rand ankommt und dann ein Leben abgezogen wird.

```py
device.add_text(
    id='score',             # Schritt 3a
    pos_x=-40,
    pos_y=160,
    font_color='white',
    font_size=2,
    text='Score: 3'
)

score = 3                   # Schritt 1


def on_collision(data: SpriteCollisionMsg):
    global score            # Schritt 2a
    score = score + 1       # 2b

    device.update_text(     # Schritt 3b
        id='score',
        text=f'Score: {score}'
    )
```

</TabItem>

<TabItem value="step-4">

_Wenn die Variable f√ºrs Z√§hlen der Leben bei dir anders heisst, ist das kein Problem._

Nun m√∂chten wir den Stern von der Spielfl√§che entfernen, so dass er nicht pl√∂tzlich am unteren Rand ankommt und dann ein Leben abgezogen wird.

Im Parameter `data` sind die beiden kollidierten Objekte unter dem Feld `data.objects` verf√ºgbar. Der kollidierte Stern ist an der zweiten Stelle abgespeichert. Etwas gew√∂hnungsbed√ºrftig: in Python beginnt das Z√§hlen in Listen bei `0`. Das erste Objekt (der Kontroller) wird also mit `data.objects[0]` abgefragt, `data.objects[1]` gibt das zweite Objekt, den Stern, zur√ºck.

Um diesen zu entfernen, brauchen wir wiederum seine `id`.

```py
def on_collision(data: SpriteCollisionMsg):
    global score
    score = score + 1

    object = data.objects[1]
    device.remove_object(object.id)

    device.update_text(
        id='score',
        text=f'Score: {score}'
    )
```

</TabItem>

<TabItem value="step-5">

Der name `collision` ist etwas verf√§nglich, in Wahrheit wird diese Funktion n√§hmlich auch dann benachrichtigt, wenn eine Kollision wieder aufgel√∂st wurde. Wir sollten deshalb √ºberpr√ºfen, ob die Kollision neu aufgetreten ist und nur dann den Score erh√∂hen.

```py
def on_collision(data: SpriteCollisionMsg):
    global score
    if data.overlap == 'in':
        score = score + 1

        object = data.objects[1]
        device.remove_object(object.id)

        device.update_text(
            id='score',
            text=f'Score: {score}'
        )
```

</TabItem>
</Tabs>

---

### 4.1 Stern ber√ºhrt den Boden \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'}]}
>
<TabItem value="step-0">

Sobald ein Objekt den Spielfeldrand ber√ºhrt/√ºberlappt wird eine Nachricht an das laufende Python-Programm geschickt.

Mit `device.on('overlap', overlap_function)` kann die Nachricht an die Funktion `overlap_function` in unserem Programm weitergeleitet werden.

Jedes Mal wenn ein Stern den Boden ber√ºhrt, soll ein Punkt abgezogen werden.

**Aufgabe**: Was passiert aktuell, wenn:

- ein Monster den Boden ber√ºhrt?
- der Spieler (weisser Balken) den Spielfeldrand ber√ºhrt?

```py
def overlap_function(data: BorderOverlapMsg):
    global score
    score = score - 1
    device.update_text(
        id='score',
        text=f'Score: {score}'
    )


device.on('border_overlap', overlap_function)
```

</TabItem>

<TabItem value="step-1">

Die √ºbergebene `BorderOverlapMsg` Nachricht enth√§lt auch ein Feld `border`, welches anzeigt welcher Rand vom Objekt ber√ºhrt wurde:

- `bottom`: der untere Rand
- `top`: der obere Rand
- `left`: der linke Rand
- `right`: der rechte Rand

Es soll aber nur dann ein Punkt abgezogen werden, wenn der **untere Rand** ber√ºhrt wurde.

```py
def overlap_function(data: BorderOverlapMsg):
    global score
    if data.border == 'bottom':
        score = score - 1

        device.update_text(
            id='score',
            text=f'Score: {score}'
        )
```

</TabItem>
</Tabs>

### 4.2 Zuf√§llige Stern-Symbole

<a className="theorie" href="https://jupyter.gbsl.website" target="_blank">Kapitel 4.2.1</a>

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'}]}
>
<TabItem value="step-0">

Sollen unterschiedliche Emojis/Bilder f√ºr die Sterne zum Einsatz kommen, brauchen wir zwei Dinge:

- Eine Liste welche alle Sterne, Emojis oder Namen der Bilder ent√§hlt.
- Eine M√∂glichkeit, ein Zuf√§lliges Element aus einer Liste auszuw√§hlen.

√úbrigens: Eine Liste von Symbol-Zeichen kann bspw. unter [https://utf8-chartable.de](https://utf8-chartable.de/unicode-utf8-table.pl?start=9920&number=128&names=2&utf8=char) gefunden werden.

**Bemerke**:

- Mit `choice` kann ein zuf√§lliges Element einer Liste abgefragt werden.
- Passen Sie ihre Existierende Funktion f√ºrs Hinzuf√ºgen von Sternen an, es braucht keine neue...

```py
from random import choice
star_symbols = ['‚ú©', '‚ú™', '‚ú´', '‚ú¨', '‚ú≠', '‚úÆ', '‚úØ', '‚ú∂', '‚ú∫']


def add_star():
    symbol = choice(star_symbols)
    device.add_circle(
        text=symbol,
        font_color=Colors.GOLD,
        # ...
    )
```

</TabItem>
</Tabs>

---

## 5. Monster \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'},
    {label: 'Schritt 4', value: 'step-4'},
    {label: 'Schritt 5', value: 'step-5'},
    {label: 'Schritt 6', value: 'step-6'}]}
>
<TabItem value="step-0">

Nun haben wir ein funktionierendes Spiel, aber es ist noch nicht so anspruchsvoll.

Deshalb soll dem Spiel ein Hindernis eingebaut werden - weniger regelm√§ssig als die Sterne sollen Monster herunterfallen. Monster fallen schneller und ziehen Leben ab, wenn sie den Controller erwischen. Fallen sie aus dem Spielfeld heraus, dann entsteht kein Schaden.

Versuche analog zu den Sternen, eine automatische Monster-Erzeuger zu machen.

```py
def add_monster():
    ...
```

</TabItem>

<TabItem value="step-1">

**Aufgabe**:

- Die Monster sollen _zuf√§llig_ √ºber die ganze Spielbreite verstreut werden
- Die Monster sollen eine zuf√§llige Farbe bekommen
- Die Monster sollen eine zuf√§llige Geschwindigkeit zwischen 5 und 10 haben.

```py
def add_monster():
    device.add_circle(
        text='‚ò¢',
        font_color='red',
        font_size=10,
        radius=3,
        direction=[0, -1],
        speed=6,
        pos_x=0,
        pos_y=0
    )


device.subscribe_async(add_monster, 5)
```

</TabItem>

<TabItem value="step-2">

Wie entscheiden wir uns in der Funktion `on_collision` ob wir eine Monster oder ein Stern eingefangen haben? Aktuell k√∂nnen wir das (noch) nicht.

Haben Sie eine Idee?

**Hinweise**:

- Wie werden in der Schweiz die Autokennzeichen vergeben?
- Wie l√§sst sich vom Kennzeichen ableiten, in welchem Kanton ein Auto zugelassen ist?

![nummernschilder](images/12-game-basics/nummernschilder.jpg)

```py
...
```

</TabItem>

<TabItem value="step-3">

Die Kennzeichnung der verschiedenen Objekte auf dem Playground werden aktuell automatisch vergeben - wir k√∂nnen diese aber auch so anpassen, dass Sterne bspw. immer mit `star` beginnen und Monster mit `monster`.

Um eindeutige ID's zu vergeben, schreiben wir eine Funktion:

- die einen Text entgegennimmt (`star` oder `monster`)
- eine eindeutige Zahl zum Text hinzuf√ºgt
- ... und diese ID alss Resultat zur√ºckgibt

**Aufgabe**: Bei der angegebenen Funktion gibt es noch ein Problem. Woran liegt das? (_Tipp_: Denke an die verspiegelte Scheibe, oder schaue bei Schritt 4 bei "Controller" nach.)

```py
id_counter = 0


def next_id(name):
    id = f'{name}-{id_counter}'
    id_counter = id_counter + 1
    return id
```

</TabItem>

<TabItem value="step-4">

Nun werden beim Sterne- und Monster-Generator diese neuen ID's verwendet.

**Aufgabe**: Verwende andere Namen f√ºr die Unterscheidung zwischen Stern und Monster (also nicht `star` und `monster`).

```py
def add_star():
    device.add_circle(
        id=next_id('star'),
        text='‚òÖ',
        ...
    )


def add_monster():
    device.add_circle(
        id=next_id('monster'),
        text='‚ò¢',
        ...
    )
```

</TabItem>

<TabItem value="step-5">

In der Funktion `on_collision` wird nun untersucht, ob es sich um einen aufgefangenen Stern oder um ein Monster handelt.

Die Funktion `startswith` √ºberpr√ºft, ob ein Text mit dem √ºbergebenen Textteil startet.

**Aufgabe**: Wird ein Monster erwischt, soll dessen Text-Gr√∂sse (`font_size=`) auf `20` erh√∂ht werden.

```py
def on_collision(data: SpriteCollisionMsg):
    global score
    if data.overlap == 'in':
        object = data.objects[1]
        if object.id.startswith('star'):
            score = score + 1
            device.remove_object(object.id)
        elif object.id.startswith('monster'):
            score = score - 5

        device.update_text(
            id='score',
            text=f'Score: {score}'
        )
```

</TabItem>

<TabItem value="step-6">

Aktuell werden Punkte abgezogen, wenn ein Stern oder aber auch ein Monster den Boden ber√ºhrt (Schritt 4.1). Es soll aber nur dann ein Punkt abgezogen werden, wenn ein Stern den Boden ber√ºhrt - das k√∂nnen wir auch wieder mit dem `startswith('star')` √ºberpr√ºfen.

**Aufgabe**: √Ñndern Sie die Funktion `overlap_function` entsprechend dem untenstehenden Beispiel ab.

```py
def overlap_function(data: BorderOverlapMsg):
    global score
    if data.border == 'bottom':
        if data.id.startswith('star'):
            score = score - 1

        device.update_text(
            id='score',
            text=f'Score: {score}'
        )
```

</TabItem>
</Tabs>

---

## 6. Tastensteuerung \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'}]}
>
<TabItem value="step-0">

Je nach Spiel ist eine Tastensteuerung besser geeignet als die Kontrolle √ºber die Beschleunigungs-Daten des Smartphones. Zudem haben viele Laptops keine Beschleunigungssensoren, so dass wir dort ohnehin eine alternative Kontroll-M√∂glichkeit brauchen. Um das zu bewerkstelligen, fangen wir die Tastenanschl√§ge ab.

Vorerst erzeugen wir das Grundger√ºst:

- sobald eine Taste (`key`) empfangen wird, soll die Nachricht an eine Funktion weitergeleitet werden. Diese Funktion heisst im Beispiel `on_key` und mit `device.on('key', on_key)` wird die Weiterleitung der Nachricht festgelegt.
- `on_key` macht vorerst noch nicht mehr, als zu √ºberpr√ºfen ob die gedr√ºckte Taste `left` oder `right` war und gibt dann im Terminal einen Text aus.

**Aufgabe**:

1. √úberpr√ºfe ob die Tastenanschl√§ge ankommen und ob im Terminal die Texte ausgegeben werden.
2. Wie kann nun der weisse Balken aktualisiert werden? (√úberlege selber, bevor du zum n√§chsten Schritt gehst)

```py
def on_key(data: KeyMsg):
    if data.key == 'left':
        print('Nach links')
    elif data.key == 'right':
        print('Nach rechts')


device.on('key', on_key)
```

</TabItem>

<TabItem value="step-1">

Die Funktion `on_key` wurde so angepasst, dass nun die Variable mit der aktuellen Spielerposition `player_pos_x` in unserem Programm aktualisiert wird. Die neue Position wird dann mit `device.updat_rectangle` ans Ger√§t √ºbertragen.

**Beachte**:

> es wird wieder die Variable `player_pos_x` aktualisiert - also muss diese wieder mit `global` f√ºr die Funktion zug√§nglich gemacht werden.

**Aufgabe**:

- Implementiere, dass auch nach rechts gesteuert werden kann
- Aktuell kann das Rechteck auch √ºber den Rand hinaustreten - verhindere dies. (Schaue bei "3. Controller" im Schritt **5** nach, wie wir es da gemacht haben).

```py
def on_key(data: KeyMsg):
    global player_pos_x
    if data.key == 'left':
        player_pos_x = player_pos_x - 5
    elif data.key == 'right':
        print('Nach rechts')

    device.update_rectangle(id='player', pos_x=player_pos_x)
```

</TabItem>
</Tabs>

---

### 6.1 Tastensteuerung √ºber Kn√∂pfe

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'}]}
>
<TabItem value="step-0">

Nicht auf jedem Ger√§t gibt es eine Tastatur (Tablet, Smartphone). Um Dennoch Tasten verf√ºgbar zu machen, k√∂nnen wir klickbare Elemente auf dem Spielfeld positionieren.

![](images/12-game-basics/buttton_controls.png)

**Beachte**:

- Durch `clickable=True` wird das Rechteck zu einem Klickbaren Knopf.


**Aufgabe**:
- F√ºge auch eine `Rechts`-Taste mit dem Symbol `‚á®` hinzu.

```py
device.add_square(
    id='left',
    pos_x=-45,
    pos_y=5,
    text='‚á¶',
    font_color='white',
    border_color='white',
    size=10,
    clickable=True
)
```

</TabItem>

<TabItem value="step-1">

Sobald die Taste geklickt wurde, wird eine Nachricht an das Programm geschickt. Diese `ObjectClickedMsg` Nachricht kann an eine von uns definierte Funktion weitergeleitet werden, indem die Funktion mit `device.on('object_clicked', <funktions-name>)` registriert wird (nat√ºrlich muss `<funktions-name>` mit dem wirklichen Funktionsnamen ersetzt werden, unten also `on_button`).

**Bemerke**:
- `on_button` verwendet wiederum die Vairable `player_pos_x` um die Spieler-Position zu aktualisieren. Dazu ist wieder die Markierung `global` n√∂tig!
- Falls die `id` des geklickten Objekts nicht `left` ist, wird der `else` Codeblock ausgef√ºhrt - die Funktion wird aus der Funktion gesprungen, ohne `update_rectangle` aufzurufen.

**Aufgabe**:
- Probiere aus, ob mit der Taste nach links gesteuert werden kann.
- F√ºge die Logik hinzu, um den Spieler auch nach rechts zu bewegen.

```py
def on_button(data: ObjectClickedMsg):
    global player_pos_x
    if data.id == 'left':
        player_pos_x = player_pos_x - 5
    else:
        return

    device.update_rectangle(
        id='player',
        pos_x=player_pos_x
    )


device.on('object_clicked', on_button)
```

</TabItem>
</Tabs>

---

## 7. Bilder

![](images/12-game-basics/game_with_images.gif)

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'}]}
>
<TabItem value="step-0">

Damit Bilder als Hintergrund des Playgrounds oder von Objekten verwendet werden k√∂nnen, m√ºssen diese zuerst an die Website √ºbertragen werden. Dazu muss ein neuer Ordner f√ºr alle Bilder erstellt werden. Der Name dieses Ordners muss dann beim Konfigurieren des Playgrounds angegeben werden.

Die Projektstruktur sollte in VS Code also etwa so aussehen:

[](images/12-game-basics/images_structure.png)

**Achtung**: Der Befehl `device.configure_playground` sollte im gesamten Programm nur einmal aufgerufen werden. Passe also den vorhanden Befehl an.

**Bemerke**:

- Mit `images=` (Mehrzahl) wird der Name des Bilder-Ordners angegeben.
- Mit `image=` (Einzahl) wird der Name des Bildes (ohne Dateteiendung!) angegeben, welches als Hintergrund f√ºr den Playground verwendet werden soll.

```py
device.configure_playground(
    width=100,
    height=180,
    origin_x=50,
    origin_y=0,
    color=Colors.BLACK,
    images='Bilder',
    image='Hintergrund'
)
```

</TabItem>

<TabItem value="step-1">

Alle Bilder im Ordner `Bilder` k√∂nnen nun f√ºr Objekte auf dem Playground verwendet werden, indem beim Erstellen die Option `image=` mitgegeben wird. Im Beispiel wird nun √ºber dem weissen Balken das Bild `Spieler` angezeigt.

**Beachte**:

- Das Bild muss ggf. auf dem Laptop so zugeschnitten werden, dass die H√∂he und die Breite des Bildes gerade mit den Dimensionen des Rechtecks/Kreises √ºbereinstimmen.

```py
device.add_rectangle(
    id='player',
    pos_x=0,
    pos_y=0,
    width=20,
    height=10,
    image='Spieler'
)
```

</TabItem>

<TabItem value="step-2">

Die Bilder eines Objekts k√∂nnen auch aktualisiert werden, indem bei `update_rectangle`, `update_circle`, `update_square` oder allgemein bei `update_object` ein neues Bild mit `image=` spezifiziert wird. Nat√ºrlich m√ºssen alle referenzierten Bilder im Ordner `Bilder` abgelegt sein.

```py
device.update_rectangle(
    id='player',
    image='Rennen'
)
```

</TabItem>

<TabItem value="step-3">

Damit wirklich nur das Bild-Objekt (und nicht der Hintergrund des Bildes) angezeigt wird, sollten Bilder mit m√∂glichst gleichm√§ssigem Hintergrund gew√§hlt werden - denn dann kann der Hintergrund weggeschnitten werden. Eine Anleitung, wie man das machen kann, findet sich hier:

- Windows: [Paint 3D](https://www.laptopmag.com/articles/remove-background-paint-3d)
- Mac OS X: [Image Preview](https://support.apple.com/guide/preview/extract-an-image-or-remove-a-background-prvw15636/mac)

```py
...
```

</TabItem>
</Tabs>

---

## 8. Springen

<a className="theorie" href="https://jupyter.gbsl.website" target="_blank">kapitel 7.14</a>

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'}]}
>
<TabItem value="step-0">

Um mit einer Spielfigur animiert an eine neue Position zu verschieben, kann die Funktion `move_to` verwendet werden. Diese Funktion kann mit der `via` Option gekoppelt werden, so dass bspw. auch Sprungeffekte erzeugt werden k√∂nnen.

**Achtung**: Diese Option ist nur dann geeignet, wenn w√§hrend der Animation bzw. w√§hrend des Sprungs keine andere Positionsaktualisierung vorgenommen wird. F√ºr den Spieler (`id = player`) ist dies also _nicht_ geeignet. Schaue dazu die zweite Option auf der n√§chsten Seite.

**Bemerke**:

- `pos=` gibt die Endposition an
- `via=` gibt eine Zwischenposition an, via welcher dann zur Endposition gefahren wird.
- `time=` gibt die Zeit in Sekunden an, bis die Endposition erreicht wird. Alternativ kann auch mit `speed=` die Geschwindigkeit angegeben werden, mit welcher die Strecke zur√ºckgelegt wird.

Im Beispiel ist die aktuelle Position mit der End-Position identisch. Durch das `via` entsteht aber eine Art "Sprung"-Effekt, da zuerst die `via`-Position erreicht wird.

```py
device.move_to(
    id='player',
    pos=[player_pos_x, 20],
    via=[player_pos_x, 50],
    time=1
)
```

</TabItem>

<TabItem value="step-1">

Um eine Positionsunabh√§ngige Animation zu starten, braucht es

- eine Richtung `direction=`
- eine Geschwindigkeit `speed=`
- eine Distanz `distance=` ODER eine Zeitspanne in welcher sich vorw√§rtsbewegt wird `time_span=`

Solche Bewegungen lassen sich koppeln - dazu ist eine neue Schreibweise n√∂tig mit dem Schl√ºsselwort `with` n√∂tig. Im Beispiel unten wird ein Sprung gemacht, wobei zuerst `10` Einheiten nach oben gefahren wird (erstes `movement`) und dann wieder `10` Einheiten nach unten (zweites `movement`).

Weitere M√∂glichkeiten sind auf Jupyterhub erkl√§rt:

<a className="theorie" href="https://jupyter.gbsl.website" target="_blank">Kapitel 7.14.1&2</a>

```py
with device.apply_movements(id='player') as movement:
    movement(direction=[0, 1], speed=10, distance=10)
    movement(direction=[0, -1], speed=10, distance=10)
```

</TabItem>
</Tabs>

---

## 9. Sound

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'}]}
>
<TabItem value="step-0">

Genau so wie bei den Bildern m√ºssen auch wieder zuerst die Soundtracks (`.mp3` Dateien) an die Website geschickt werden. Lade dazu passende Soundtracks herunter (**Achtung**! Beachte die Lizenzen, nicht alle Lieder & Effekte d√ºrfen heruntergladen werden) und verschiebe Sie in einen Ordner "Sound" in deinem Game-Projekt Ordner.

Viele verschiedene Sound-Tracks k√∂nnen zum Beispiel unter [https://www.zapsplat.com](https://www.zapsplat.com/sound-effect-category/game-sounds/) kostenlos heruntergalden werden.

M√∂gliche Sounds mit direktem Download-Link finden sich hier: [Sound-Links](/skeletons/12_game/sounds.html)

Die Projektstruktur sollte in VS Code also etwa so aussehen:

[](images/12-game-basics/sound_structure.png)

**Achtung**: Der Befehl `device.configure_playground` sollte im gesamten Programm nur einmal aufgerufen werden. Passe also den vorhanden Befehl an.

```py
device.configure_playground(
    audio_tracks='Sound'
)
```

</TabItem>

<TabItem value="step-1">

Mit `device.play` kann ein Sound abgespielt werden, optional kann auch noch die Lautst√§rke festgelegt werden:

- `volume=0` -> lautlos
- `volume=0.5` -> halbe Laust√§rke
- `volume=1` -> volle Lautst√§rke

Zudem kann mit `device.stop_sound` ein abgespielter Sound gestoppt werden.

```py
device.play_sound('playback', volume=0.5)

# sp√§ter...

device.stop_sound('playback')
```

</TabItem>

<TabItem value="step-2">

Beispiel: Jedes mal wenn ein Stern gefangen wird, soll der Sound `catch` abgespielt werden. Ein Sound kann also auch mehrfach abgespielt werden.

```py
def on_collision(data: SpriteCollisionMsg):
    global score
    if data.overlap == 'in':
        object = data.objects[1]
        if object.id.startswith('star'):
            device.play_sound('catch')
```

</TabItem>
</Tabs>

---

## 10. Levels \*

<Tabs
    defaultValue="step-1"
    values={[{label: 'Schritt 0', value: 'step-0'},
    {label: 'Schritt 1', value: 'step-1'},
    {label: 'Schritt 2', value: 'step-2'},
    {label: 'Schritt 3', value: 'step-3'},
    {label: 'Schritt 4', value: 'step-4'}]}
>
<TabItem value="step-0">

Wie beim Highscore wird zu Beginn ein neues Textfeld f√ºr das Level hinzugef√ºgt. Bereits jetzt vergeben wir eine `id`, damit der Text sp√§ter aktualisiert werden kann.

**Aufgabe**: √úberpr√ºfe ob das Level angezeigt wird.

```py
device.add_text(
    id='level',
    pos_x=-40,
    pos_y=170,
    font_color='white',
    font_size=2,
    text='Level: 1'
)
```

</TabItem>

<TabItem value="step-1">

Wo liegen die Unterschiede zwischen den einzelnen Spiel-Levels? In diesem Game √§ndern sich:
- die Frequenz des Stern-Regens
- die Geschwindigkeit der Sterne

Da im voraus nicht klar ist, wann das Level 2 beginnt, wird das Aufsetzen der Levels innerhalb einer Funktion vorbereitet, welche dann zum gegebenen Zeitpunkt aufgerufen werden kann.

**Beachte**:
- Mit `device.cancel_async_subscriptions()` werden alle aktuell geplanten Ausf√ºhrungen (alle Funktionen die mit `device.subscribe_async()` zugewiesen wurden) gestoppt. Deshalb m√ºssen danach `device.subscribe_async` im Programm wieder aufgebaut werden.
- Die Variable `speed` wird nun beim Hinzuf√ºgen eines Sterns verwendet.


**Aufgaben**:
- Suche im Programm nach allen Zeilen mit `device.subscribe_async` und verschiebe in die `level` Funktionen.
- √Ñndere deine Funktion `add_star()`
- Rufe am Ende des Programms (aber noch vor der Zeile `device.wait()`!!) `level_1()` auf, um das erste Level zu konfigurieren.
- **√úberpr√ºfe** ob das Spiel noch funktioniert (auch wenn die Levels noch nicht funktionieren).

```py
speed = 4


def level_1():
    global speed
    speed = 4
    device.cancel_async_subscriptions()
    device.subscribe_async(add_star, 2)
    device.subscribe_async(add_monster, 5)
    device.subscribe_async(on_update, 0.05)


def level_2():
    global speed
    speed = 8
    device.cancel_async_subscriptions()
    device.subscribe_async(add_star, 1)
    device.subscribe_async(add_monster, 5)
    device.subscribe_async(on_update, 0.05)


def add_star():
    device.add_circle(
        id=next_id('star'),
        speed=speed,
        ...  # alle anderen Optionen bleiben gleich...
    )
```

</TabItem>

<TabItem value="step-2">

Aktuell wird das Level noch nicht aktualisiert. Wann kann der Level-Zustand √§ndern? Grunds√§tzlich immer wenn sich der Score √§ndert!

Wir k√∂nnten nun also an jeder Stelle, wo der Score √§ndert, √ºberpr√ºfen, ob ein neues Level erreicht wurde oder nicht. Dann m√ºssten wir an vielen Stellen viel Code hinzuf√ºgen. Das wird **un√ºbersichtlich** und **fehleranf√§llig**. Deshalb schreiben wir das Programm so um, dass der Score nur noch an einer Stelle im Programm ge√§ndert wird - in einer Funktion `set_score(new_score)`

**Bemerke**:
- Die √Ñnderung wird auch direkt auf dem Smartphone/Device aktualisiert (`update_text`).
- Bspw. bei `on_collision` wird `score` nicht mehr direkt ver√§ndert, weshalb das `global score`, die √Ñnderung am Score und auch das Updaten des Scores gel√∂scht werden k√∂nnen.

**Aufgabe**:
- Suche alle Orte, an welchen der Score aktualisiert wird, und verwende direkt die `set_score` Funktion
- L√∂sche alle `device.update_text` Passagen, welche zum Score geh√∂ren.
- **Stelle sicher dass dein Programm immer noch funktioniert.**

```py
def set_score(new_score):
    global score
    score = new_score

    device.update_text(
        id='score',
        text=f'Score: {score}'
    )


def on_collision(data: SpriteCollisionMsg):
    gÃ∂Ã∂lÃ∂Ã∂oÃ∂Ã∂bÃ∂Ã∂aÃ∂Ã∂lÃ∂Ã∂ Ã∂Ã∂sÃ∂Ã∂cÃ∂Ã∂oÃ∂Ã∂rÃ∂Ã∂eÃ∂
    if data.overlap == 'in':
        set_score(score + 1)
        sÃ∂Ã∂cÃ∂Ã∂oÃ∂Ã∂rÃ∂Ã∂eÃ∂Ã∂ Ã∂=Ã∂ Ã∂Ã∂sÃ∂Ã∂cÃ∂Ã∂oÃ∂Ã∂rÃ∂Ã∂eÃ∂Ã∂ Ã∂+Ã∂ Ã∂Ã∂1Ã∂
    Ã∂dÃ∂Ã∂eÃ∂Ã∂vÃ∂Ã∂iÃ∂Ã∂cÃ∂Ã∂eÃ∂Ã∂.Ã∂Ã∂uÃ∂Ã∂pÃ∂Ã∂dÃ∂Ã∂aÃ∂Ã∂tÃ∂Ã∂eÃ∂Ã∂_Ã∂Ã∂tÃ∂Ã∂eÃ∂Ã∂xÃ∂Ã∂tÃ∂(Ã∂
     Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂iÃ∂Ã∂dÃ∂='Ã∂sÃ∂Ã∂cÃ∂Ã∂oÃ∂Ã∂rÃ∂Ã∂eÃ∂'Ã∂, Ã∂
     Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂ Ã∂Ã∂tÃ∂Ã∂eÃ∂Ã∂xÃ∂Ã∂tÃ∂=Ã∂fÃ∂'Ã∂sÃ∂Ã∂cÃ∂Ã∂oÃ∂Ã∂rÃ∂Ã∂eÃ∂Ã∂:Ã∂Ã∂ Ã∂{Ã∂sÃ∂Ã∂cÃ∂Ã∂oÃ∂Ã∂rÃ∂Ã∂eÃ∂}'
    )Ã∂ Ã∂
```

</TabItem>

<TabItem value="step-3">

Aktuell wird bei jedem Aufruf von `set_score` ein Level konfiguriert. Das ist aber gar nicht n√∂tig, sondern soll nur dann gemacht werden, wenn das aktuelle Level nicht schon dem neuen Level entspricht. Um das zu √ºberpr√ºfen, ist eine weitere Variable `level` n√∂tig, welche das aktuelle Level enth√§lt.

**Aufgabe**
- √úberpr√ºfe ob die Levels funktionieren
- Aktuell wird der Text des Levels noch nicht aktualisiert. Schaue bei `set_score` wie der Score Wert aktualisiert wird, und verwende dasselbe Prinzip bei `level_1` und `level_2`.
- (*Optional*: schreibe eine Funktion `set_level(new_level)` welche das `new_level` in der Variable `level` speichert und den Text auf dem Smartphone/Device aktualisiert.)

```py
speed = 4
level = 1

def level_1():
    global speed, level
    level = 1
    ...


def level_2():
    global speed, level
    level = 2
    ...



def set_score(new_score):
    global score
    score = new_score
    if score < 20 and level != 1:
        level_1()
    elif score > 20 and level != 2:
        level_2()

    device.update_text(
        id='score',
        text=f'Score: {score}'
    )
```

</TabItem>

<TabItem value="step-4">

Nun kann ganz einfach in der Funktion `set_score` √ºberpr√ºft werden, ob ein neues Level geladen werden soll oder nicht.

Kannst du ein Problem beim untenstehenden Code vermuten?

```py

def set_score(new_score):
    global score
    score = new_score
    if score < 20:
        level_1()
    elif score > 20:
        level_2()

    device.update_text(
        id='score',
        text=f'Score: {score}'
    )
```

</TabItem>
</Tabs>
