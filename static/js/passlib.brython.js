__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1629386463392, "passlib.totp": [".py", "''\n\n\n\nfrom __future__ import absolute_import,division,print_function\nfrom passlib.utils.compat import PY3\n\nimport base64\nimport calendar\nimport json\nimport logging ;log=logging.getLogger(__name__)\nimport math\nimport struct\nimport sys\nimport time as _time\nimport re\nif PY3:\n from urllib.parse import urlparse,parse_qsl,quote,unquote\nelse :\n from urllib import quote,unquote\n from urlparse import urlparse,parse_qsl\nfrom warnings import warn\n\ntry :\n\n from cryptography.hazmat.backends import default_backend as _cg_default_backend\n import cryptography.hazmat.primitives.ciphers.algorithms\n import cryptography.hazmat.primitives.ciphers.modes\n from cryptography.hazmat.primitives import ciphers as _cg_ciphers\n del cryptography\nexcept ImportError:\n log.debug(\"can't import 'cryptography' package, totp encryption disabled\")\n _cg_ciphers=_cg_default_backend=None\n \nfrom passlib import exc\nfrom passlib.exc import TokenError,MalformedTokenError,InvalidTokenError,UsedTokenError\nfrom passlib.utils import (to_unicode,to_bytes,consteq,\ngetrandbytes,rng,SequenceMixin,xor_bytes,getrandstr)\nfrom passlib.utils.binary import BASE64_CHARS,b32encode,b32decode\nfrom passlib.utils.compat import (u,unicode,native_string_types,bascii_to_str,int_types,num_types,\nirange,byte_elem_value,UnicodeIO,suppress_cause)\nfrom passlib.utils.decor import hybrid_method,memoized_property\nfrom passlib.crypto.digest import lookup_hash,compile_hmac,pbkdf2_hmac\nfrom passlib.hash import pbkdf2_sha256\n\n__all__=[\n\n\"AppWallet\",\n\"TOTP\",\n\n\n\"TokenError\",\n\"MalformedTokenError\",\n\"InvalidTokenError\",\n\"UsedTokenError\",\n\n\n\"TotpToken\",\n\"TotpMatch\",\n]\n\n\n\n\n\n\n\n\nif sys.version_info <(2,7,4):\n from urlparse import uses_query\n if \"otpauth\"not in uses_query:\n  uses_query.append(\"otpauth\")\n  log.debug(\"registered 'otpauth' scheme with urlparse.uses_query\")\n del uses_query\n \n \n \n \n \n \n \n \n \n \n_clean_re=re.compile(u(r\"\\s|[-=]\"),re.U)\n\n_chunk_sizes=[4,6,5]\n\ndef _get_group_size(klen):\n ''\n\n\n \n \n for size in _chunk_sizes:\n  if not klen %size:\n   return size\n   \n   \n best=_chunk_sizes[0]\n rem=0\n for size in _chunk_sizes:\n  if klen %size >rem:\n   best=size\n   rem=klen %size\n return best\n \ndef group_string(value,sep=\"-\"):\n ''\n\n\n \n klen=len(value)\n size=_get_group_size(klen)\n return sep.join(value[o:o+size]for o in irange(0,klen,size))\n \n \n \n \n \ndef _decode_bytes(key,format):\n ''\n\n\n \n if format ==\"raw\":\n  if not isinstance(key,bytes):\n   raise exc.ExpectedTypeError(key,\"bytes\",\"key\")\n  return key\n  \n  \n key=to_unicode(key,param=\"key\")\n key=_clean_re.sub(\"\",key).encode(\"utf-8\")\n if format ==\"hex\"or format ==\"base16\":\n  return base64.b16decode(key.upper())\n elif format ==\"base32\":\n  return b32decode(key)\n  \n else :\n  raise ValueError(\"unknown byte-encoding format: %r\"%(format,))\n  \n  \n  \n  \n  \n  \nAES_SUPPORT=bool(_cg_ciphers)\n\n\n_tag_re=re.compile(\"(?i)^[a-z0-9][a-z0-9_.-]*$\")\n\nclass AppWallet(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n salt_size=12\n \n \n \n \n encrypt_cost=14\n \n \n _secrets=None\n \n \n default_tag=None\n \n \n \n \n def __init__(self,secrets=None ,default_tag=None ,encrypt_cost=None ,\n secrets_path=None ):\n \n \n \n \n \n \n \n  if encrypt_cost is not None :\n   if isinstance(encrypt_cost,native_string_types):\n    encrypt_cost=int(encrypt_cost)\n   assert encrypt_cost >=0\n   self.encrypt_cost=encrypt_cost\n   \n   \n   \n   \n   \n   \n  if secrets_path is not None :\n   if secrets is not None :\n    raise TypeError(\"'secrets' and 'secrets_path' are mutually exclusive\")\n   secrets=open(secrets_path,\"rt\").read()\n   \n   \n  secrets=self._secrets=self._parse_secrets(secrets)\n  \n  \n  \n  \n  if secrets:\n   if default_tag is not None :\n   \n    self.get_secret(default_tag)\n   elif all(tag.isdigit()for tag in secrets):\n    default_tag=max(secrets,key=int)\n   else :\n    default_tag=max(secrets)\n   self.default_tag=default_tag\n   \n def _parse_secrets(self,source):\n  ''\n\n\n\n\n  \n  \n  \n  \n  check_type=True\n  if isinstance(source,native_string_types):\n   if source.lstrip().startswith((\"[\",\"{\")):\n   \n    source=json.loads(source)\n   elif \"\\n\"in source and \":\"in source:\n   \n   \n    def iter_pairs(source):\n     for line in source.splitlines():\n      line=line.strip()\n      if line and not line.startswith(\"#\"):\n       tag,secret=line.split(\":\",1)\n       yield tag.strip(),secret.strip()\n    source=iter_pairs(source)\n    check_type=False\n   else :\n    raise ValueError(\"unrecognized secrets string format\")\n    \n    \n  if source is None :\n   return {}\n  elif isinstance(source,dict):\n   source=source.items()\n   \n   \n  elif check_type:\n   raise TypeError(\"'secrets' must be mapping, or list of items\")\n   \n   \n  return dict(self._parse_secret_pair(tag,value)\n  for tag,value in source)\n  \n def _parse_secret_pair(self,tag,value):\n  if isinstance(tag,native_string_types):\n   pass\n  elif isinstance(tag,int):\n   tag=str(tag)\n  else :\n   raise TypeError(\"tag must be unicode/string: %r\"%(tag,))\n  if not _tag_re.match(tag):\n   raise ValueError(\"tag contains invalid characters: %r\"%(tag,))\n  if not isinstance(value,bytes):\n   value=to_bytes(value,param=\"secret %r\"%(tag,))\n  if not value:\n   raise ValueError(\"tag contains empty secret: %r\"%(tag,))\n  return tag,value\n  \n  \n  \n  \n  \n @property\n def has_secrets(self):\n  ''\n  return self.default_tag is not None\n  \n def get_secret(self,tag):\n  ''\n\n\n  \n  secrets=self._secrets\n  if not secrets:\n   raise KeyError(\"no application secrets configured\")\n  try :\n   return secrets[tag]\n  except KeyError:\n   raise suppress_cause(KeyError(\"unknown secret tag: %r\"%(tag,)))\n   \n   \n   \n   \n   \n @staticmethod\n def _cipher_aes_key(value,secret,salt,cost,decrypt=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if _cg_ciphers is None :\n   raise RuntimeError(\"TOTP encryption requires 'cryptography' package \"\n   \"(https://cryptography.io)\")\n   \n   \n   \n  keyiv=pbkdf2_hmac(\"sha256\",secret,salt=salt,rounds=(1 <<cost),keylen=48)\n  \n  \n  cipher=_cg_ciphers.Cipher(_cg_ciphers.algorithms.AES(keyiv[:32]),\n  _cg_ciphers.modes.CTR(keyiv[32:]),\n  _cg_default_backend())\n  ctx=cipher.decryptor()if decrypt else cipher.encryptor()\n  return ctx.update(value)+ctx.finalize()\n  \n def encrypt_key(self,key):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not key:\n   raise ValueError(\"no key provided\")\n  salt=getrandbytes(rng,self.salt_size)\n  cost=self.encrypt_cost\n  tag=self.default_tag\n  if not tag:\n   raise TypeError(\"no application secrets configured, can't encrypt OTP key\")\n  ckey=self._cipher_aes_key(key,self.get_secret(tag),salt,cost)\n  \n  return dict(v=1,c=cost,t=tag,s=b32encode(salt),k=b32encode(ckey))\n  \n def decrypt_key(self,enckey):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(enckey,dict):\n   raise TypeError(\"'enckey' must be dictionary\")\n  version=enckey.get(\"v\",None )\n  needs_recrypt=False\n  if version ==1:\n   _cipher_key=self._cipher_aes_key\n  else :\n   raise ValueError(\"missing / unrecognized 'enckey' version: %r\"%(version,))\n  tag=enckey['t']\n  cost=enckey['c']\n  key=_cipher_key(\n  value=b32decode(enckey['k']),\n  secret=self.get_secret(tag),\n  salt=b32decode(enckey['s']),\n  cost=cost,\n  )\n  if cost !=self.encrypt_cost or tag !=self.default_tag:\n   needs_recrypt=True\n  return key,needs_recrypt\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_pack_uint64=struct.Struct(\">Q\").pack\n\n\n_unpack_uint32=struct.Struct(\">I\").unpack\n\n\n_DUMMY_KEY=b\"\\x00\"*16\n\nclass TOTP(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n _min_key_size=10\n \n \n min_json_version=json_version=1\n \n \n \n wallet=None\n \n \n \n now=_time.time\n \n \n \n \n \n \n \n \n \n \n \n _key=None\n \n \n \n _encrypted_key=None\n \n \n \n \n _keyed_hmac=None\n \n \n digits=6\n \n \n alg=\"sha1\"\n \n \n label=None\n \n \n issuer=None\n \n \n \n \n period=30\n \n \n \n \n \n \n \n \n changed=False\n \n \n \n \n @classmethod\n def using(cls,digits=None ,alg=None ,period=None ,\n issuer=None ,wallet=None ,now=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  subcls=type(\"TOTP\",(cls,),{})\n  \n  def norm_param(attr,value):\n   ''\n\n\n   \n   \n   \n   \n   kwds=dict(key=_DUMMY_KEY,format=\"raw\")\n   kwds[attr]=value\n   obj=subcls(**kwds)\n   return getattr(obj,attr)\n   \n  if digits is not None :\n   subcls.digits=norm_param(\"digits\",digits)\n   \n  if alg is not None :\n   subcls.alg=norm_param(\"alg\",alg)\n   \n  if period is not None :\n   subcls.period=norm_param(\"period\",period)\n   \n   \n   \n  if issuer is not None :\n   subcls.issuer=norm_param(\"issuer\",issuer)\n   \n  if kwds:\n   subcls.wallet=AppWallet(**kwds)\n   if wallet:\n    raise TypeError(\"'wallet' and 'secrets' keywords are mutually exclusive\")\n  elif wallet is not None :\n   if not isinstance(wallet,AppWallet):\n    raise exc.ExpectedTypeError(wallet,AppWallet,\"wallet\")\n   subcls.wallet=wallet\n   \n  if now is not None :\n   assert isinstance(now(),num_types)and now()>=0,\\\n   \"now() function must return non-negative int/float\"\n   subcls.now=staticmethod(now)\n   \n  return subcls\n  \n  \n  \n  \n  \n @classmethod\n def new(cls,**kwds):\n  ''\n\n  \n  return cls(new=True ,**kwds)\n  \n def __init__(self,key=None ,format=\"base32\",\n \n new=False ,digits=None ,alg=None ,size=None ,period=None ,\n label=None ,issuer=None ,changed=False ,\n **kwds):\n  super(TOTP,self).__init__(**kwds)\n  if changed:\n   self.changed=changed\n   \n   \n  info=lookup_hash(alg or self.alg)\n  self.alg=info.name\n  digest_size=info.digest_size\n  if digest_size <4:\n   raise RuntimeError(\"%r hash digest too small\"%alg)\n   \n   \n  if new:\n  \n   if key:\n    raise TypeError(\"'key' and 'new=True' are mutually exclusive\")\n   if size is None :\n   \n    size=digest_size\n   elif size >digest_size:\n   \n   \n    raise ValueError(\"'size' should be less than digest size \"\n    \"(%d)\"%digest_size)\n   self.key=getrandbytes(rng,size)\n  elif not key:\n   raise TypeError(\"must specify either an existing 'key', or 'new=True'\")\n  elif format ==\"encrypted\":\n  \n   self.encrypted_key=key\n  elif key:\n  \n   self.key=_decode_bytes(key,format)\n   \n   \n  if len(self.key)<self._min_key_size:\n  \n  \n   msg=\"for security purposes, secret key must be >= %d bytes\"%self._min_key_size\n   if new:\n    raise ValueError(msg)\n   else :\n    warn(msg,exc.PasslibSecurityWarning,stacklevel=1)\n    \n    \n  if digits is None :\n   digits=self.digits\n  if not isinstance(digits,int_types):\n   raise TypeError(\"digits must be an integer, not a %r\"%type(digits))\n  if digits <6 or digits >10:\n   raise ValueError(\"digits must in range(6,11)\")\n  self.digits=digits\n  \n  \n  if label:\n   self._check_label(label)\n   self.label=label\n   \n   \n  if issuer:\n   self._check_issuer(issuer)\n   self.issuer=issuer\n   \n   \n  if period is not None :\n   self._check_serial(period,\"period\",minval=1)\n   self.period=period\n   \n   \n   \n   \n   \n @staticmethod\n def _check_serial(value,param,minval=0):\n  ''\n\n  \n  if not isinstance(value,int_types):\n   raise exc.ExpectedTypeError(value,\"int\",param)\n  if value <minval:\n   raise ValueError(\"%s must be >= %d\"%(param,minval))\n   \n @staticmethod\n def _check_label(label):\n  ''\n\n  \n  if label and \":\"in label:\n   raise ValueError(\"label may not contain ':'\")\n   \n @staticmethod\n def _check_issuer(issuer):\n  ''\n\n  \n  if issuer and \":\"in issuer:\n   raise ValueError(\"issuer may not contain ':'\")\n   \n   \n   \n   \n   \n   \n   \n   \n @property\n def key(self):\n  ''\n\n  \n  return self._key\n  \n @key.setter\n def key(self,value):\n \n  if not isinstance(value,bytes):\n   raise exc.ExpectedTypeError(value,bytes,\"key\")\n  self._key=value\n  \n  \n  self._encrypted_key=self._keyed_hmac=None\n  \n  \n  \n  \n @property\n def encrypted_key(self):\n  ''\n\n\n\n  \n  enckey=self._encrypted_key\n  if enckey is None :\n   wallet=self.wallet\n   if not wallet:\n    raise TypeError(\"no application secrets present, can't encrypt TOTP key\")\n   enckey=self._encrypted_key=wallet.encrypt_key(self.key)\n  return enckey\n  \n @encrypted_key.setter\n def encrypted_key(self,value):\n  wallet=self.wallet\n  if not wallet:\n   raise TypeError(\"no application secrets present, can't decrypt TOTP key\")\n  self.key,needs_recrypt=wallet.decrypt_key(value)\n  if needs_recrypt:\n  \n   self.changed=True\n  else :\n  \n   self._encrypted_key=value\n   \n   \n   \n   \n   \n @property\n def hex_key(self):\n  ''\n\n  \n  return bascii_to_str(base64.b16encode(self.key)).lower()\n  \n @property\n def base32_key(self):\n  ''\n\n  \n  return b32encode(self.key)\n  \n def pretty_key(self,format=\"base32\",sep=\"-\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if format ==\"hex\"or format ==\"base16\":\n   key=self.hex_key\n  elif format ==\"base32\":\n   key=self.base32_key\n  else :\n   raise ValueError(\"unknown byte-encoding format: %r\"%(format,))\n  if sep:\n   key=group_string(key,sep)\n  return key\n  \n  \n  \n  \n  \n @classmethod\n def normalize_time(cls,time):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(time,int_types):\n   return time\n  elif isinstance(time,float):\n   return int(time)\n  elif time is None :\n   return int(cls.now())\n  elif hasattr(time,\"utctimetuple\"):\n  \n  \n  \n   return calendar.timegm(time.utctimetuple())\n  else :\n   raise exc.ExpectedTypeError(time,\"int, float, or datetime\",\"time\")\n   \n def _time_to_counter(self,time):\n  ''\n\n  \n  return time //self.period\n  \n def _counter_to_time(self,counter):\n  ''\n\n  \n  return counter *self.period\n  \n @hybrid_method\n def normalize_token(self_or_cls,token):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  digits=self_or_cls.digits\n  if isinstance(token,int_types):\n   token=u(\"%0*d\")%(digits,token)\n  else :\n   token=to_unicode(token,param=\"token\")\n   token=_clean_re.sub(u(\"\"),token)\n   if not token.isdigit():\n    raise MalformedTokenError(\"Token must contain only the digits 0-9\")\n  if len(token)!=digits:\n   raise MalformedTokenError(\"Token must have exactly %d digits\"%digits)\n  return token\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def generate(self,time=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  time=self.normalize_time(time)\n  counter=self._time_to_counter(time)\n  if counter <0:\n   raise ValueError(\"timestamp must be >= 0\")\n  token=self._generate(counter)\n  return TotpToken(self,token,counter)\n  \n def _generate(self,counter):\n  ''\n\n\n\n\n  \n  \n  assert isinstance(counter,int_types),\"counter must be integer\"\n  assert counter >=0,\"counter must be non-negative\"\n  keyed_hmac=self._keyed_hmac\n  if keyed_hmac is None :\n   keyed_hmac=self._keyed_hmac=compile_hmac(self.alg,self.key)\n  digest=keyed_hmac(_pack_uint64(counter))\n  digest_size=keyed_hmac.digest_info.digest_size\n  assert len(digest)==digest_size,\"digest_size: sanity check failed\"\n  \n  \n  assert digest_size >=20,\"digest_size: sanity check 2 failed\"\n  offset=byte_elem_value(digest[-1])&0xF\n  value=_unpack_uint32(digest[offset:offset+4])[0]&0x7fffffff\n  \n  \n  \n  \n  \n  digits=self.digits\n  assert 0 <digits <11,\"digits: sanity check failed\"\n  return (u(\"%0*d\")%(digits,value))[-digits:]\n  \n  \n  \n  \n  \n @classmethod\n def verify(cls,token,source,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return cls.from_source(source).match(token,**kwds)\n  \n def match(self,token,time=None ,window=30,skew=0,last_counter=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  time=self.normalize_time(time)\n  self._check_serial(window,\"window\")\n  \n  client_time=time+skew\n  if last_counter is None :\n   last_counter=-1\n  start=max(last_counter,self._time_to_counter(client_time -window))\n  end=self._time_to_counter(client_time+window)+1\n  \n  \n  \n  counter=self._find_match(token,start,end)\n  assert counter >=last_counter,\"sanity check failed: counter went backward\"\n  \n  if counter ==last_counter:\n   raise UsedTokenError(expire_time=(last_counter+1)*self.period)\n   \n   \n   \n   \n   \n  return TotpMatch(self,counter,time,window)\n  \n def _find_match(self,token,start,end,expected=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  token=self.normalize_token(token)\n  if start <0:\n   start=0\n  if end <=start:\n   raise InvalidTokenError()\n  generate=self._generate\n  if not (expected is None or expected <start)and consteq(token,generate(expected)):\n   return expected\n   \n   \n   \n   \n   \n  counter=start\n  while counter <end:\n   if consteq(token,generate(counter)):\n    return counter\n   counter +=1\n  raise InvalidTokenError()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def from_source(cls,source):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(source,TOTP):\n  \n  \n   if cls.wallet ==source.wallet:\n    return source\n   source=source.to_dict(encrypt=False )\n  if isinstance(source,dict):\n   return cls.from_dict(source)\n   \n  source=to_unicode(source,param=\"totp source\")\n  if source.startswith(\"otpauth://\"):\n   return cls.from_uri(source)\n  else :\n   return cls.from_json(source)\n   \n   \n   \n   \n @classmethod\n def from_uri(cls,uri):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  uri=to_unicode(uri,param=\"uri\").strip()\n  result=urlparse(uri)\n  if result.scheme !=\"otpauth\":\n   raise cls._uri_parse_error(\"wrong uri scheme\")\n   \n   \n  cls._check_otp_type(result.netloc)\n  return cls._from_parsed_uri(result)\n  \n @classmethod\n def _check_otp_type(cls,type):\n  ''\n\n\n  \n  if type ==\"totp\":\n   return True\n  if type ==\"hotp\":\n   raise NotImplementedError(\"HOTP not supported\")\n  raise ValueError(\"unknown otp type: %r\"%type)\n  \n @classmethod\n def _from_parsed_uri(cls,result):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  \n  label=result.path\n  if label.startswith(\"/\")and len(label)>1:\n   label=unquote(label[1:])\n  else :\n   raise cls._uri_parse_error(\"missing label\")\n   \n   \n  if \":\"in label:\n   try :\n    issuer,label=label.split(\":\")\n   except ValueError:\n    raise cls._uri_parse_error(\"malformed label\")\n  else :\n   issuer=None\n  if label:\n  \n   label=label.strip()or None\n   \n   \n  params=dict(label=label)\n  for k,v in parse_qsl(result.query):\n   if k in params:\n    raise cls._uri_parse_error(\"duplicate parameter (%r)\"%k)\n   params[k]=v\n   \n   \n  if issuer:\n   if \"issuer\"not in params:\n    params['issuer']=issuer\n   elif params['issuer']!=issuer:\n    raise cls._uri_parse_error(\"conflicting issuer identifiers\")\n    \n    \n  return cls(**cls._adapt_uri_params(**params))\n  \n @classmethod\n def _adapt_uri_params(cls,label=None ,secret=None ,issuer=None ,\n digits=None ,algorithm=None ,period=None ,\n **extra):\n  ''\n\n\n  \n  assert label,\"from_uri() failed to provide label\"\n  if not secret:\n   raise cls._uri_parse_error(\"missing 'secret' parameter\")\n  kwds=dict(label=label,issuer=issuer,key=secret,format=\"base32\")\n  if digits:\n   kwds['digits']=cls._uri_parse_int(digits,\"digits\")\n  if algorithm:\n   kwds['alg']=algorithm\n  if period:\n   kwds['period']=cls._uri_parse_int(period,\"period\")\n  if extra:\n  \n  \n   warn(\"%s: unexpected parameters encountered in otp uri: %r\"%\n   (cls,extra),exc.PasslibRuntimeWarning)\n  return kwds\n  \n @staticmethod\n def _uri_parse_error(reason):\n  ''\n  return ValueError(\"Invalid otpauth uri: %s\"%(reason,))\n  \n @classmethod\n def _uri_parse_int(cls,source,param):\n  ''\n  try :\n   return int(source)\n  except ValueError:\n   raise cls._uri_parse_error(\"Malformed %r parameter\"%param)\n   \n   \n   \n   \n def to_uri(self,label=None ,issuer=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if label is None :\n   label=self.label\n  if not label:\n   raise ValueError(\"a label must be specified as argument, or in the constructor\")\n  self._check_label(label)\n  \n  \n  \n  label=quote(label,'@')\n  \n  \n  params=self._to_uri_params()\n  if issuer is None :\n   issuer=self.issuer\n  if issuer:\n   self._check_issuer(issuer)\n   \n   \n   \n   \n   label=\"%s:%s\"%(quote(issuer,'@'),label)\n   params.append((\"issuer\",issuer))\n   \n   \n   \n  param_str=u(\"&\").join(u(\"%s=%s\")%(key,quote(value,''))for key,value in params)\n  assert param_str,\"param_str should never be empty\"\n  \n  \n  return u(\"otpauth://totp/%s?%s\")%(label,param_str)\n  \n def _to_uri_params(self):\n  ''\n  args=[(\"secret\",self.base32_key)]\n  if self.alg !=\"sha1\":\n   args.append((\"algorithm\",self.alg.upper()))\n  if self.digits !=6:\n   args.append((\"digits\",str(self.digits)))\n  if self.period !=30:\n   args.append((\"period\",str(self.period)))\n  return args\n  \n  \n  \n  \n  \n @classmethod\n def from_json(cls,source):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  source=to_unicode(source,param=\"json source\")\n  return cls.from_dict(json.loads(source))\n  \n def to_json(self,encrypt=None ):\n  ''\n\n\n\n\n\n\n  \n  state=self.to_dict(encrypt=encrypt)\n  return json.dumps(state,sort_keys=True ,separators=(\",\",\":\"))\n  \n  \n  \n  \n  \n @classmethod\n def from_dict(cls,source):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(source,dict)or \"type\"not in source:\n   raise cls._dict_parse_error(\"unrecognized format\")\n  return cls(**cls._adapt_dict_kwds(**source))\n  \n @classmethod\n def _adapt_dict_kwds(cls,type,**kwds):\n  ''\n\n\n  \n  \n  \n  \n  assert cls._check_otp_type(type)\n  ver=kwds.pop(\"v\",None )\n  if not ver or ver <cls.min_json_version or ver >cls.json_version:\n   raise cls._dict_parse_error(\"missing/unsupported version (%r)\"%(ver,))\n  elif ver !=cls.json_version:\n  \n   kwds['changed']=True\n  if 'enckey'in kwds:\n  \n  \n  \n  \n  \n   assert 'key'not in kwds\n   kwds.update(key=kwds.pop(\"enckey\"),format=\"encrypted\")\n  elif 'key'not in kwds:\n   raise cls._dict_parse_error(\"missing 'enckey' / 'key'\")\n   \n   \n  kwds.pop(\"last_counter\",None )\n  return kwds\n  \n @staticmethod\n def _dict_parse_error(reason):\n  ''\n  return ValueError(\"Invalid totp data: %s\"%(reason,))\n  \n def to_dict(self,encrypt=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  state=dict(v=self.json_version,type=\"totp\")\n  if self.alg !=\"sha1\":\n   state['alg']=self.alg\n  if self.digits !=6:\n   state['digits']=self.digits\n  if self.period !=30:\n   state['period']=self.period\n   \n  if self.label:\n   state['label']=self.label\n  issuer=self.issuer\n  if issuer and issuer !=type(self).issuer:\n  \n   state['issuer']=issuer\n  if encrypt is None :\n   wallet=self.wallet\n   encrypt=wallet and wallet.has_secrets\n  if encrypt:\n   state['enckey']=self.encrypted_key\n  else :\n   state['key']=self.base32_key\n   \n   \n   \n   \n  return state\n  \n  \n  \n  \n  \n  \n  \n  \nclass TotpToken(SequenceMixin):\n ''\n\n\n\n\n\n\n\n\n\n \n \n totp=None\n \n \n token=None\n \n \n counter=None\n \n def __init__(self,totp,token,counter):\n  ''\n\n\n  \n  self.totp=totp\n  self.token=token\n  self.counter=counter\n  \n @memoized_property\n def start_time(self):\n  ''\n  return self.totp._counter_to_time(self.counter)\n  \n @memoized_property\n def expire_time(self):\n  ''\n  return self.totp._counter_to_time(self.counter+1)\n  \n @property\n def remaining(self):\n  ''\n  return max(0,self.expire_time -self.totp.now())\n  \n @property\n def valid(self):\n  ''\n  return bool(self.remaining)\n  \n def _as_tuple(self):\n  return self.token,self.expire_time\n  \n def __repr__(self):\n  expired=\"\"if self.remaining else \" expired\"\n  return \"<TotpToken token='%s' expire_time=%d%s>\"%\\\n  (self.token,self.expire_time,expired)\n  \n  \nclass TotpMatch(SequenceMixin):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n totp=None\n \n \n \n \n counter=0\n \n \n time=0\n \n \n window=30\n \n def __init__(self,totp,counter,time,window=30):\n  ''\n\n\n  \n  self.totp=totp\n  self.counter=counter\n  self.time=time\n  self.window=window\n  \n @memoized_property\n def expected_counter(self):\n  ''\n\n  \n  return self.totp._time_to_counter(self.time)\n  \n @memoized_property\n def skipped(self):\n  ''\n\n\n  \n  return self.counter -self.expected_counter\n  \n  \n  \n  \n  \n  \n @memoized_property\n def expire_time(self):\n  ''\n  return self.totp._counter_to_time(self.counter+1)\n  \n @memoized_property\n def cache_seconds(self):\n  ''\n\n\n  \n  \n  \n  return self.totp.period+self.window\n  \n @memoized_property\n def cache_time(self):\n  ''\n\n  \n  return self.expire_time+self.window\n  \n def _as_tuple(self):\n  return self.counter,self.time\n  \n def __repr__(self):\n  args=(self.counter,self.time,self.cache_seconds)\n  return \"<TotpMatch counter=%d time=%d cache_seconds=%d>\"%args\n  \n  \n  \n  \n  \ndef generate_secret(entropy=256,charset=BASE64_CHARS[:-2]):\n ''\n\n\n\n\n\n \n assert entropy >0\n assert len(charset)>1\n count=int(math.ceil(entropy *math.log(2,len(charset))))\n return getrandstr(rng,charset,count)\n \n \n \n \n", ["__future__", "base64", "calendar", "cryptography.hazmat.backends", "cryptography.hazmat.primitives", "cryptography.hazmat.primitives.ciphers.algorithms", "cryptography.hazmat.primitives.ciphers.modes", "json", "logging", "math", "passlib", "passlib.crypto.digest", "passlib.exc", "passlib.hash", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "re", "struct", "sys", "time", "urllib", "urllib.parse", "urlparse", "warnings"]], "passlib.registry": [".py", "''\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\nfrom passlib import exc\nfrom passlib.exc import ExpectedTypeError,PasslibWarning\nfrom passlib.ifc import PasswordHash\nfrom passlib.utils import (\nis_crypt_handler,has_crypt as os_crypt_present,\nunix_crypt_schemes as os_crypt_schemes,\n)\nfrom passlib.utils.compat import unicode_or_str\nfrom passlib.utils.decor import memoize_single_value\n\n__all__=[\n\"register_crypt_handler_path\",\n\"register_crypt_handler\",\n\"get_crypt_handler\",\n\"list_crypt_handlers\",\n]\n\n\n\n\nclass _PasslibRegistryProxy(object):\n ''\n\n\n\n\n \n __name__=\"passlib.hash\"\n __package__=None\n \n def __getattr__(self,attr):\n  if attr.startswith(\"_\"):\n   raise AttributeError(\"missing attribute: %r\"%(attr,))\n  handler=get_crypt_handler(attr,None )\n  if handler:\n   return handler\n  else :\n   raise AttributeError(\"unknown password hash: %r\"%(attr,))\n   \n def __setattr__(self,attr,value):\n  if attr.startswith(\"_\"):\n  \n  \n   object.__setattr__(self,attr,value)\n  else :\n  \n  \n   register_crypt_handler(value,_attr=attr)\n   \n def __repr__(self):\n  return \"<proxy module 'passlib.hash'>\"\n  \n def __dir__(self):\n \n \n  attrs=set(dir(self.__class__))\n  attrs.update(self.__dict__)\n  attrs.update(_locations)\n  return sorted(attrs)\n  \n  \n_proxy=_PasslibRegistryProxy()\n\n\n\n\n\n\n_UNSET=object()\n\n\n_handlers=_proxy.__dict__\n\n\n\n\n_locations=dict(\n\n\napr_md5_crypt=\"passlib.handlers.md5_crypt\",\nargon2=\"passlib.handlers.argon2\",\natlassian_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\nbcrypt=\"passlib.handlers.bcrypt\",\nbcrypt_sha256=\"passlib.handlers.bcrypt\",\nbigcrypt=\"passlib.handlers.des_crypt\",\nbsd_nthash=\"passlib.handlers.windows\",\nbsdi_crypt=\"passlib.handlers.des_crypt\",\ncisco_pix=\"passlib.handlers.cisco\",\ncisco_asa=\"passlib.handlers.cisco\",\ncisco_type7=\"passlib.handlers.cisco\",\ncta_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\ncrypt16=\"passlib.handlers.des_crypt\",\ndes_crypt=\"passlib.handlers.des_crypt\",\ndjango_argon2=\"passlib.handlers.django\",\ndjango_bcrypt=\"passlib.handlers.django\",\ndjango_bcrypt_sha256=\"passlib.handlers.django\",\ndjango_pbkdf2_sha256=\"passlib.handlers.django\",\ndjango_pbkdf2_sha1=\"passlib.handlers.django\",\ndjango_salted_sha1=\"passlib.handlers.django\",\ndjango_salted_md5=\"passlib.handlers.django\",\ndjango_des_crypt=\"passlib.handlers.django\",\ndjango_disabled=\"passlib.handlers.django\",\ndlitz_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\nfshp=\"passlib.handlers.fshp\",\ngrub_pbkdf2_sha512=\"passlib.handlers.pbkdf2\",\nhex_md4=\"passlib.handlers.digests\",\nhex_md5=\"passlib.handlers.digests\",\nhex_sha1=\"passlib.handlers.digests\",\nhex_sha256=\"passlib.handlers.digests\",\nhex_sha512=\"passlib.handlers.digests\",\nhtdigest=\"passlib.handlers.digests\",\nldap_plaintext=\"passlib.handlers.ldap_digests\",\nldap_md5=\"passlib.handlers.ldap_digests\",\nldap_sha1=\"passlib.handlers.ldap_digests\",\nldap_hex_md5=\"passlib.handlers.roundup\",\nldap_hex_sha1=\"passlib.handlers.roundup\",\nldap_salted_md5=\"passlib.handlers.ldap_digests\",\nldap_salted_sha1=\"passlib.handlers.ldap_digests\",\nldap_salted_sha256=\"passlib.handlers.ldap_digests\",\nldap_salted_sha512=\"passlib.handlers.ldap_digests\",\nldap_des_crypt=\"passlib.handlers.ldap_digests\",\nldap_bsdi_crypt=\"passlib.handlers.ldap_digests\",\nldap_md5_crypt=\"passlib.handlers.ldap_digests\",\nldap_bcrypt=\"passlib.handlers.ldap_digests\",\nldap_sha1_crypt=\"passlib.handlers.ldap_digests\",\nldap_sha256_crypt=\"passlib.handlers.ldap_digests\",\nldap_sha512_crypt=\"passlib.handlers.ldap_digests\",\nldap_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\nldap_pbkdf2_sha256=\"passlib.handlers.pbkdf2\",\nldap_pbkdf2_sha512=\"passlib.handlers.pbkdf2\",\nlmhash=\"passlib.handlers.windows\",\nmd5_crypt=\"passlib.handlers.md5_crypt\",\nmsdcc=\"passlib.handlers.windows\",\nmsdcc2=\"passlib.handlers.windows\",\nmssql2000=\"passlib.handlers.mssql\",\nmssql2005=\"passlib.handlers.mssql\",\nmysql323=\"passlib.handlers.mysql\",\nmysql41=\"passlib.handlers.mysql\",\nnthash=\"passlib.handlers.windows\",\noracle10=\"passlib.handlers.oracle\",\noracle11=\"passlib.handlers.oracle\",\npbkdf2_sha1=\"passlib.handlers.pbkdf2\",\npbkdf2_sha256=\"passlib.handlers.pbkdf2\",\npbkdf2_sha512=\"passlib.handlers.pbkdf2\",\nphpass=\"passlib.handlers.phpass\",\nplaintext=\"passlib.handlers.misc\",\npostgres_md5=\"passlib.handlers.postgres\",\nroundup_plaintext=\"passlib.handlers.roundup\",\nscram=\"passlib.handlers.scram\",\nscrypt=\"passlib.handlers.scrypt\",\nsha1_crypt=\"passlib.handlers.sha1_crypt\",\nsha256_crypt=\"passlib.handlers.sha2_crypt\",\nsha512_crypt=\"passlib.handlers.sha2_crypt\",\nsun_md5_crypt=\"passlib.handlers.sun_md5_crypt\",\nunix_disabled=\"passlib.handlers.misc\",\nunix_fallback=\"passlib.handlers.misc\",\n)\n\n\n_name_re=re.compile(\"^[a-z][a-z0-9_]+[a-z0-9]$\")\n\n\n\n_forbidden_names=frozenset([\"onload\",\"policy\",\"context\",\"all\",\n\"default\",\"none\",\"auto\"])\n\n\n\n\ndef _validate_handler_name(name):\n ''\n\n\n\n\n\n\n \n if not name:\n  raise ValueError(\"handler name cannot be empty: %r\"%(name,))\n if name.lower()!=name:\n  raise ValueError(\"name must be lower-case: %r\"%(name,))\n if not _name_re.match(name):\n  raise ValueError(\"invalid name (must be 3+ characters, \"\n  \" begin with a-z, and contain only underscore, a-z, \"\n  \"0-9): %r\"%(name,))\n if '__'in name:\n  raise ValueError(\"name may not contain double-underscores: %r\"%\n  (name,))\n if name in _forbidden_names:\n  raise ValueError(\"that name is not allowed: %r\"%(name,))\n return True\n \ndef register_crypt_handler_path(name,path):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _validate_handler_name(name)\n \n \n if path.startswith(\".\"):\n  raise ValueError(\"path cannot start with '.'\")\n if ':'in path:\n  if path.count(':')>1:\n   raise ValueError(\"path cannot have more than one ':'\")\n  if path.find('.',path.index(':'))>-1:\n   raise ValueError(\"path cannot have '.' to right of ':'\")\n   \n   \n _locations[name]=path\n log.debug(\"registered path to %r handler: %r\",name,path)\n \ndef register_crypt_handler(handler,force=False ,_attr=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not is_crypt_handler(handler):\n  raise ExpectedTypeError(handler,\"password hash handler\",\"handler\")\n if not handler:\n  raise AssertionError(\"``bool(handler)`` must be True\")\n  \n  \n name=handler.name\n _validate_handler_name(name)\n if _attr and _attr !=name:\n  raise ValueError(\"handlers must be stored only under their own name (%r != %r)\"%\n  (_attr,name))\n  \n  \n other=_handlers.get(name)\n if other:\n  if other is handler:\n   log.debug(\"same %r handler already registered: %r\",name,handler)\n   return\n  elif force:\n   log.warning(\"overriding previously registered %r handler: %r\",\n   name,other)\n  else :\n   raise KeyError(\"another %r handler has already been registered: %r\"%\n   (name,other))\n   \n   \n _handlers[name]=handler\n log.debug(\"registered %r handler: %r\",name,handler)\n \ndef get_crypt_handler(name,default=_UNSET):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n if name.startswith(\"_\"):\n  if default is _UNSET:\n   raise KeyError(\"invalid handler name: %r\"%(name,))\n  else :\n   return default\n   \n   \n try :\n  return _handlers[name]\n except KeyError:\n  pass\n  \n  \n assert isinstance(name,unicode_or_str),\"name must be string instance\"\n alt=name.replace(\"-\",\"_\").lower()\n if alt !=name:\n  warn(\"handler names should be lower-case, and use underscores instead \"\n  \"of hyphens: %r => %r\"%(name,alt),PasslibWarning,\n  stacklevel=2)\n  name=alt\n  \n  \n  try :\n   return _handlers[name]\n  except KeyError:\n   pass\n   \n   \n path=_locations.get(name)\n if path:\n  if ':'in path:\n   modname,modattr=path.split(\":\")\n  else :\n   modname,modattr=path,name\n   \n   \n   \n   \n  mod=__import__(modname,fromlist=[modattr],level=0)\n  \n  \n  \n  handler=_handlers.get(name)\n  if handler:\n  \n   assert is_crypt_handler(handler),\"unexpected object: name=%r object=%r\"%(name,handler)\n   return handler\n   \n   \n  handler=getattr(mod,modattr)\n  register_crypt_handler(handler,_attr=name)\n  return handler\n  \n  \n if default is _UNSET:\n  raise KeyError(\"no crypt handler found for algorithm: %r\"%(name,))\n else :\n  return default\n  \ndef list_crypt_handlers(loaded_only=False ):\n ''\n\n\n\n\n \n names=set(_handlers)\n if not loaded_only:\n  names.update(_locations)\n  \n  \n return sorted(name for name in names if not name.startswith(\"_\"))\n \n \n \ndef _has_crypt_handler(name,loaded_only=False ):\n ''\n\n\n\n\n\n\n\n\n \n return (name in _handlers)or (not loaded_only and name in _locations)\n \ndef _unload_handler_name(name,locations=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if name in _handlers:\n  del _handlers[name]\n if locations and name in _locations:\n  del _locations[name]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef _resolve(hasher,param=\"value\"):\n ''\n\n \n if is_crypt_handler(hasher):\n  return hasher\n elif isinstance(hasher,unicode_or_str):\n  return get_crypt_handler(hasher)\n else :\n  raise exc.ExpectedTypeError(hasher,unicode_or_str,param)\n  \n  \n  \nANY=\"any\"\nBUILTIN=\"builtin\"\nOS_CRYPT=\"os_crypt\"\n\n\ndef has_backend(hasher,backend=ANY,safe=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n hasher=_resolve(hasher)\n \n if backend ==ANY:\n  if not hasattr(hasher,\"get_backend\"):\n  \n   return True\n   \n   \n  try :\n   hasher.get_backend()\n   return True\n  except exc.MissingBackendError:\n   return False\n   \n   \n if hasattr(hasher,\"has_backend\"):\n \n  if safe and backend not in hasher.backends:\n   return None\n  return hasher.has_backend(backend)\n  \n  \n if backend ==BUILTIN:\n  return True\n elif safe:\n  return None\n else :\n  raise exc.UnknownBackendError(hasher,backend)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n@memoize_single_value\ndef get_supported_os_crypt_schemes():\n ''\n\n \n if not os_crypt_present:\n  return ()\n cache=tuple(name for name in os_crypt_schemes\n if get_crypt_handler(name).has_backend(OS_CRYPT))\n if not cache:\n \n  import platform\n  warn(\"crypt.crypt() function is present, but doesn't support any \"\n  \"formats known to passlib! (system=%r release=%r)\"%\n  (platform.system(),platform.release()),\n  exc.PasslibRuntimeWarning)\n return cache\n \n \n \ndef has_os_crypt_support(hasher):\n ''\n\n\n\n\n\n\n\n\n \n return os_crypt_present and has_backend(hasher,OS_CRYPT,safe=True )\n \n \n \n \n", ["logging", "passlib", "passlib.exc", "passlib.ifc", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "platform", "re", "warnings"]], "passlib.apache": [".py", "''\n\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport os\nfrom warnings import warn\n\n\nfrom passlib import exc,registry\nfrom passlib.context import CryptContext\nfrom passlib.exc import ExpectedStringError\nfrom passlib.hash import htdigest\nfrom passlib.utils import render_bytes,to_bytes,is_ascii_codec\nfrom passlib.utils.decor import deprecated_method\nfrom passlib.utils.compat import join_bytes,unicode,BytesIO,PY3\n\n__all__=[\n'HtpasswdFile',\n'HtdigestFile',\n]\n\n\n\n\n_UNSET=object()\n\n_BCOLON=b\":\"\n_BHASH=b\"#\"\n\n\n_INVALID_FIELD_CHARS=b\":\\n\\r\\t\\x00\"\n\n\n_SKIPPED=\"skipped\"\n_RECORD=\"record\"\n\n\n\n\nclass _CommonFile(object):\n ''\n \n \n \n \n \n encoding=None\n \n \n \n return_unicode=None\n \n \n _path=None\n _mtime=None\n \n \n autosave=False\n \n \n \n _records=None\n \n \n \n _source=None\n \n \n \n \n @classmethod\n def from_string(cls,data,**kwds):\n  ''\n\n\n\n\n\n\n\n  \n  if 'path'in kwds:\n   raise TypeError(\"'path' not accepted by from_string()\")\n  self=cls(**kwds)\n  self.load_string(data)\n  return self\n  \n @classmethod\n def from_path(cls,path,**kwds):\n  ''\n\n\n\n\n\n\n\n  \n  self=cls(**kwds)\n  self.load(path)\n  return self\n  \n  \n  \n  \n def __init__(self,path=None ,new=False ,autoload=True ,autosave=False ,\n encoding=\"utf-8\",return_unicode=PY3,\n ):\n \n  if not encoding:\n   warn(\"``encoding=None`` is deprecated as of Passlib 1.6, \"\n   \"and will cause a ValueError in Passlib 1.8, \"\n   \"use ``return_unicode=False`` instead.\",\n   DeprecationWarning,stacklevel=2)\n   encoding=\"utf-8\"\n   return_unicode=False\n  elif not is_ascii_codec(encoding):\n  \n  \n   raise ValueError(\"encoding must be 7-bit ascii compatible\")\n  self.encoding=encoding\n  \n  \n  self.return_unicode=return_unicode\n  self.autosave=autosave\n  self._path=path\n  self._mtime=0\n  \n  \n  if not autoload:\n   warn(\"``autoload=False`` is deprecated as of Passlib 1.6, \"\n   \"and will be removed in Passlib 1.8, use ``new=True`` instead\",\n   DeprecationWarning,stacklevel=2)\n   new=True\n  if path and not new:\n   self.load()\n  else :\n   self._records={}\n   self._source=[]\n   \n def __repr__(self):\n  tail=''\n  if self.autosave:\n   tail +=' autosave=True'\n  if self._path:\n   tail +=' path=%r'%self._path\n  if self.encoding !=\"utf-8\":\n   tail +=' encoding=%r'%self.encoding\n  return \"<%s 0x%0x%s>\"%(self.__class__.__name__,id(self),tail)\n  \n  \n  \n @property\n def path(self):\n  return self._path\n  \n @path.setter\n def path(self,value):\n  if value !=self._path:\n   self._mtime=0\n  self._path=value\n  \n @property\n def mtime(self):\n  ''\n  return self._mtime\n  \n  \n  \n  \n def load_if_changed(self):\n  ''\n  if not self._path:\n   raise RuntimeError(\"%r is not bound to a local file\"%self)\n  if self._mtime and self._mtime ==os.path.getmtime(self._path):\n   return False\n  self.load()\n  return True\n  \n def load(self,path=None ,force=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if path is not None :\n   with open(path,\"rb\")as fh:\n    self._mtime=0\n    self._load_lines(fh)\n  elif not force:\n   warn(\"%(name)s.load(force=False) is deprecated as of Passlib 1.6,\"\n   \"and will be removed in Passlib 1.8; \"\n   \"use %(name)s.load_if_changed() instead.\"%\n   dict(name=self.__class__.__name__),\n   DeprecationWarning,stacklevel=2)\n   return self.load_if_changed()\n  elif self._path:\n   with open(self._path,\"rb\")as fh:\n    self._mtime=os.path.getmtime(self._path)\n    self._load_lines(fh)\n  else :\n   raise RuntimeError(\"%s().path is not set, an explicit path is required\"%\n   self.__class__.__name__)\n  return True\n  \n def load_string(self,data):\n  ''\n  data=to_bytes(data,self.encoding,\"data\")\n  self._mtime=0\n  self._load_lines(BytesIO(data))\n  \n def _load_lines(self,lines):\n  ''\n  parse=self._parse_record\n  records={}\n  source=[]\n  skipped=b''\n  for idx,line in enumerate(lines):\n  \n  \n  \n   tmp=line.lstrip()\n   if not tmp or tmp.startswith(_BHASH):\n    skipped +=line\n    continue\n    \n    \n   key,value=parse(line,idx+1)\n   \n   \n   \n   if key in records:\n    log.warning(\"username occurs multiple times in source file: %r\"%key)\n    skipped +=line\n    continue\n    \n    \n   if skipped:\n    source.append((_SKIPPED,skipped))\n    skipped=b''\n    \n    \n   records[key]=value\n   source.append((_RECORD,key))\n   \n   \n  if skipped.rstrip():\n   source.append((_SKIPPED,skipped))\n   \n   \n  self._records=records\n  self._source=source\n  \n def _parse_record(self,record,lineno):\n  ''\n  raise NotImplementedError(\"should be implemented in subclass\")\n  \n def _set_record(self,key,value):\n  ''\n\n\n\n\n  \n  records=self._records\n  existing=(key in records)\n  records[key]=value\n  if not existing:\n   self._source.append((_RECORD,key))\n  return existing\n  \n  \n  \n  \n def _autosave(self):\n  ''\n  if self.autosave and self._path:\n   self.save()\n   \n def save(self,path=None ):\n  ''\n\n  \n  if path is not None :\n   with open(path,\"wb\")as fh:\n    fh.writelines(self._iter_lines())\n  elif self._path:\n   self.save(self._path)\n   self._mtime=os.path.getmtime(self._path)\n  else :\n   raise RuntimeError(\"%s().path is not set, cannot autosave\"%\n   self.__class__.__name__)\n   \n def to_string(self):\n  ''\n  return join_bytes(self._iter_lines())\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _iter_lines(self):\n  ''\n  \n  \n  records=self._records\n  if __debug__:\n   pending=set(records)\n  for action,content in self._source:\n   if action ==_SKIPPED:\n   \n    yield content\n   else :\n    assert action ==_RECORD\n    \n    if content not in records:\n    \n    \n    \n     continue\n    yield self._render_record(content,records[content])\n    if __debug__:\n     pending.remove(content)\n  if __debug__:\n  \n  \n   assert not pending,\"failed to write all records: missing=%r\"%(pending,)\n   \n def _render_record(self,key,value):\n  ''\n  raise NotImplementedError(\"should be implemented in subclass\")\n  \n  \n  \n  \n def _encode_user(self,user):\n  ''\n  return self._encode_field(user,\"user\")\n  \n def _encode_realm(self,realm):\n  ''\n  return self._encode_field(realm,\"realm\")\n  \n def _encode_field(self,value,param=\"field\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(value,unicode):\n   value=value.encode(self.encoding)\n  elif not isinstance(value,bytes):\n   raise ExpectedStringError(value,param)\n  if len(value)>255:\n   raise ValueError(\"%s must be at most 255 characters: %r\"%\n   (param,value))\n  if any(c in _INVALID_FIELD_CHARS for c in value):\n   raise ValueError(\"%s contains invalid characters: %r\"%\n   (param,value,))\n  return value\n  \n def _decode_field(self,value):\n  ''\n\n\n\n\n\n\n\n\n  \n  assert isinstance(value,bytes),\"expected value to be bytes\"\n  if self.return_unicode:\n   return value.decode(self.encoding)\n  else :\n   return value\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n_warn_no_bcrypt=set()\n\ndef _init_default_schemes():\n\n\n host_best=None\n for name in [\"bcrypt\",\"sha256_crypt\"]:\n  if registry.has_os_crypt_support(name):\n   host_best=name\n   break\n   \n   \n   \n bcrypt=\"bcrypt\"if registry.has_backend(\"bcrypt\")else None\n _warn_no_bcrypt.clear()\n if not bcrypt:\n  _warn_no_bcrypt.update([\"portable_apache_24\",\"host_apache_24\",\n  \"linux_apache_24\",\"portable\",\"host\"])\n  \n defaults=dict(\n \n portable_apache_24=bcrypt or \"apr_md5_crypt\",\n portable_apache_22=\"apr_md5_crypt\",\n \n \n host_apache_24=bcrypt or host_best or \"apr_md5_crypt\",\n host_apache_22=host_best or \"apr_md5_crypt\",\n \n \n linux_apache_24=bcrypt or \"sha256_crypt\",\n linux_apache_22=\"sha256_crypt\",\n )\n \n \n \n \n defaults.update(\n portable=defaults['portable_apache_24'],\n host=defaults['host_apache_24'],\n )\n return defaults\n \n \nhtpasswd_defaults=_init_default_schemes()\n\ndef _init_htpasswd_context():\n\n\n schemes=[\n \n \n \"bcrypt\",\n \n \n \n \"sha256_crypt\",\n \"sha512_crypt\",\n \"des_crypt\",\n \n \n \"apr_md5_crypt\",\n \n \n \"ldap_sha1\",\n \n \n \"plaintext\"\n ]\n \n \n \n \n schemes.extend(registry.get_supported_os_crypt_schemes())\n \n \n preferred=schemes[:3]+[\"apr_md5_crypt\"]+schemes\n schemes=sorted(set(schemes),key=preferred.index)\n \n \n return CryptContext(\n schemes=schemes,\n \n \n default=htpasswd_defaults['portable_apache_22'],\n \n \n bcrypt__ident=\"2y\",\n )\n \n \nhtpasswd_context=_init_htpasswd_context()\n\n\n\n\n\nclass HtpasswdFile(_CommonFile):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n def __init__(self,path=None ,default_scheme=None ,context=htpasswd_context,\n **kwds):\n  if 'default'in kwds:\n   warn(\"``default`` is deprecated as of Passlib 1.6, \"\n   \"and will be removed in Passlib 1.8, it has been renamed \"\n   \"to ``default_scheem``.\",\n   DeprecationWarning,stacklevel=2)\n   default_scheme=kwds.pop(\"default\")\n  if default_scheme:\n   if default_scheme in _warn_no_bcrypt:\n    warn(\"HtpasswdFile: no bcrypt backends available, \"\n    \"using fallback for default scheme %r\"%default_scheme,\n    exc.PasslibSecurityWarning)\n   default_scheme=htpasswd_defaults.get(default_scheme,default_scheme)\n   context=context.copy(default=default_scheme)\n  self.context=context\n  super(HtpasswdFile,self).__init__(path,**kwds)\n  \n def _parse_record(self,record,lineno):\n \n  result=record.rstrip().split(_BCOLON)\n  if len(result)!=2:\n   raise ValueError(\"malformed htpasswd file (error reading line %d)\"\n   %lineno)\n  return result\n  \n def _render_record(self,user,hash):\n  return render_bytes(\"%s:%s\\n\",user,hash)\n  \n  \n  \n  \n  \n def users(self):\n  ''\n\n  \n  return [self._decode_field(user)for user in self._records]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def set_password(self,user,password):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  hash=self.context.hash(password)\n  return self.set_hash(user,hash)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"set_password\")\n def update(self,user,password):\n  ''\n  return self.set_password(user,password)\n  \n def get_hash(self,user):\n  ''\n\n\n\n\n\n  \n  try :\n   return self._records[self._encode_user(user)]\n  except KeyError:\n   return None\n   \n def set_hash(self,user,hash):\n  ''\n\n\n\n\n\n\n\n  \n  \n  if PY3 and isinstance(hash,str):\n   hash=hash.encode(self.encoding)\n  user=self._encode_user(user)\n  existing=self._set_record(user,hash)\n  self._autosave()\n  return existing\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"get_hash\")\n def find(self,user):\n  ''\n  return self.get_hash(user)\n  \n  \n def delete(self,user):\n  ''\n\n\n\n\n  \n  try :\n   del self._records[self._encode_user(user)]\n  except KeyError:\n   return False\n  self._autosave()\n  return True\n  \n def check_password(self,user,password):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  user=self._encode_user(user)\n  hash=self._records.get(user)\n  if hash is None :\n   return None\n  if isinstance(password,unicode):\n  \n  \n   password=password.encode(self.encoding)\n  ok,new_hash=self.context.verify_and_update(password,hash)\n  if ok and new_hash is not None :\n  \n   assert user in self._records\n   self._records[user]=new_hash\n   self._autosave()\n  return ok\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"check_password\")\n def verify(self,user,password):\n  ''\n  return self.check_password(user,password)\n  \n  \n  \n  \n  \n  \n  \n  \nclass HtdigestFile(_CommonFile):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n default_realm=None\n \n \n \n \n def __init__(self,path=None ,default_realm=None ,**kwds):\n  self.default_realm=default_realm\n  super(HtdigestFile,self).__init__(path,**kwds)\n  \n def _parse_record(self,record,lineno):\n  result=record.rstrip().split(_BCOLON)\n  if len(result)!=3:\n   raise ValueError(\"malformed htdigest file (error reading line %d)\"\n   %lineno)\n  user,realm,hash=result\n  return (user,realm),hash\n  \n def _render_record(self,key,hash):\n  user,realm=key\n  return render_bytes(\"%s:%s:%s\\n\",user,realm,hash)\n  \n def _require_realm(self,realm):\n  if realm is None :\n   realm=self.default_realm\n   if realm is None :\n    raise TypeError(\"you must specify a realm explicitly, \"\n    \"or set the default_realm attribute\")\n  return realm\n  \n def _encode_realm(self,realm):\n  realm=self._require_realm(realm)\n  return self._encode_field(realm,\"realm\")\n  \n def _encode_key(self,user,realm):\n  return self._encode_user(user),self._encode_realm(realm)\n  \n  \n  \n  \n  \n def realms(self):\n  ''\n  realms=set(key[1]for key in self._records)\n  return [self._decode_field(realm)for realm in realms]\n  \n def users(self,realm=None ):\n  ''\n\n\n\n  \n  realm=self._encode_realm(realm)\n  return [self._decode_field(key[0])for key in self._records\n  if key[1]==realm]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def set_password(self,user,realm=None ,password=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if password is _UNSET:\n  \n   realm,password=None ,realm\n  realm=self._require_realm(realm)\n  hash=htdigest.hash(password,user,realm,encoding=self.encoding)\n  return self.set_hash(user,realm,hash)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"set_password\")\n def update(self,user,realm,password):\n  ''\n  return self.set_password(user,realm,password)\n  \n def get_hash(self,user,realm=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  key=self._encode_key(user,realm)\n  hash=self._records.get(key)\n  if hash is None :\n   return None\n  if PY3:\n   hash=hash.decode(self.encoding)\n  return hash\n  \n def set_hash(self,user,realm=None ,hash=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if hash is _UNSET:\n  \n   realm,hash=None ,realm\n   \n  if PY3 and isinstance(hash,str):\n   hash=hash.encode(self.encoding)\n  key=self._encode_key(user,realm)\n  existing=self._set_record(key,hash)\n  self._autosave()\n  return existing\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"get_hash\")\n def find(self,user,realm):\n  ''\n  return self.get_hash(user,realm)\n  \n  \n def delete(self,user,realm=None ):\n  ''\n\n\n\n\n\n\n  \n  key=self._encode_key(user,realm)\n  try :\n   del self._records[key]\n  except KeyError:\n   return False\n  self._autosave()\n  return True\n  \n def delete_realm(self,realm):\n  ''\n\n\n\n\n  \n  realm=self._encode_realm(realm)\n  records=self._records\n  keys=[key for key in records if key[1]==realm]\n  for key in keys:\n   del records[key]\n  self._autosave()\n  return len(keys)\n  \n def check_password(self,user,realm=None ,password=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if password is _UNSET:\n  \n   realm,password=None ,realm\n  user=self._encode_user(user)\n  realm=self._encode_realm(realm)\n  hash=self._records.get((user,realm))\n  if hash is None :\n   return None\n  return htdigest.verify(password,hash,user,realm,\n  encoding=self.encoding)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"check_password\")\n def verify(self,user,realm,password):\n  ''\n  return self.check_password(user,realm,password)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "os", "passlib", "passlib.context", "passlib.exc", "passlib.hash", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "warnings"]], "passlib.ifc": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nimport sys\n\n\nfrom passlib.utils.decor import deprecated_method\n\n__all__=[\n\"PasswordHash\",\n]\n\n\n\n\ndef recreate_with_metaclass(meta):\n ''\n def builder(cls):\n  if meta is type(cls):\n   return cls\n  return meta(cls.__name__,cls.__bases__,cls.__dict__.copy())\n return builder\n \n \n \n \nfrom abc import ABCMeta,abstractmethod,abstractproperty\n\n\n\n\n\n\n@recreate_with_metaclass(ABCMeta)\nclass PasswordHash(object):\n ''\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n is_disabled=False\n \n \n \n \n \n \n \n \n truncate_size=None\n \n \n \n \n \n \n \n \n \n \n \n \n truncate_error=True\n \n \n \n \n \n truncate_verify_reject=True\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n @abstractmethod\n def hash(cls,secret,\n **setting_and_context_kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\",replacement=\".hash()\")\n @classmethod\n def encrypt(cls,*args,**kwds):\n  ''\n\n\n\n\n\n\n  \n  return cls.hash(*args,**kwds)\n  \n  \n  \n  \n @classmethod\n @abstractmethod\n def verify(cls,secret,hash,**context_kwds):\n  ''\n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n  \n  \n  \n @classmethod\n @abstractmethod\n def using(cls,relaxed=False ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,secret=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return False\n  \n  \n  \n  \n @classmethod\n @abstractmethod\n def identify(cls,hash):\n  ''\n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls,**setting_kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  if cls.context_kwds:\n   raise NotImplementedError(\"must be implemented by subclass\")\n  return cls.using(**setting_kwds).hash(\"\")\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,**context):\n  ''\n\n\n\n\n\n\n\n  \n  \n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n deprecated=False\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nclass DisabledHash(PasswordHash):\n ''\n\n \n \n is_disabled=True\n \n @classmethod\n def disable(cls,hash=None ):\n  ''\n\n\n\n  \n  \n  return cls.hash(\"\")\n  \n @classmethod\n def enable(cls,hash):\n  ''\n\n\n\n  \n  \n  raise ValueError(\"cannot restore original hash\")\n  \n  \n  \n  \n", ["abc", "logging", "passlib.utils.decor", "sys"]], "passlib": [".py", "''\n\n__version__='1.7.4'\n", [], 1], "passlib.hosts": [".py", "''\n\n\n\n\nfrom warnings import warn\n\nfrom passlib.context import LazyCryptContext\nfrom passlib.exc import PasslibRuntimeWarning\nfrom passlib import registry\nfrom passlib.utils import has_crypt,unix_crypt_schemes\n\n__all__=[\n\"linux_context\",\"linux2_context\",\n\"openbsd_context\",\n\"netbsd_context\",\n\"freebsd_context\",\n\"host_context\",\n]\n\n\n\n\n\n\n\nlinux_context=linux2_context=LazyCryptContext(\nschemes=[\"sha512_crypt\",\"sha256_crypt\",\"md5_crypt\",\n\"des_crypt\",\"unix_disabled\"],\ndeprecated=[\"des_crypt\"],\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfreebsd_context=LazyCryptContext([\"bcrypt\",\"md5_crypt\",\"bsd_nthash\",\n\"des_crypt\",\"unix_disabled\"])\n\nopenbsd_context=LazyCryptContext([\"bcrypt\",\"md5_crypt\",\"bsdi_crypt\",\n\"des_crypt\",\"unix_disabled\"])\n\nnetbsd_context=LazyCryptContext([\"bcrypt\",\"sha1_crypt\",\"md5_crypt\",\n\"bsdi_crypt\",\"des_crypt\",\"unix_disabled\"])\n\n\n\n\n\n\n\nif registry.os_crypt_present:\n\n\n\n\n def _iter_os_crypt_schemes():\n  ''\n  out=registry.get_supported_os_crypt_schemes()\n  if out:\n  \n  \n   out +=(\"unix_disabled\",)\n  return out\n  \n host_context=LazyCryptContext(_iter_os_crypt_schemes())\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", ["passlib", "passlib.context", "passlib.exc", "passlib.utils", "warnings"]], "passlib.win32": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom warnings import warn\nwarn(\"the 'passlib.win32' module is deprecated, and will be removed in \"\n\"passlib 1.8; please use the 'passlib.hash.nthash' and \"\n\"'passlib.hash.lmhash' classes instead.\",\nDeprecationWarning)\n\n\n\n\n\nfrom binascii import hexlify\n\n\nfrom passlib.utils.compat import unicode\nfrom passlib.crypto.des import des_encrypt_block\nfrom passlib.hash import nthash\n\n__all__=[\n\"nthash\",\n\"raw_lmhash\",\n\"raw_nthash\",\n]\n\n\n\nLM_MAGIC=b\"KGS!@#$%\"\n\nraw_nthash=nthash.raw_nthash\n\ndef raw_lmhash(secret,encoding=\"ascii\",hex=False ):\n ''\n \n \n \n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(encoding)\n ns=secret.upper()[:14]+b\"\\x00\"*(14 -len(secret))\n out=des_encrypt_block(ns[:7],LM_MAGIC)+des_encrypt_block(ns[7:],LM_MAGIC)\n return hexlify(out).decode(\"ascii\")if hex else out\n \n \n \n \n", ["binascii", "passlib.crypto.des", "passlib.hash", "passlib.utils.compat", "warnings"]], "passlib.apps": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nfrom itertools import chain\n\n\nfrom passlib import hash\nfrom passlib.context import LazyCryptContext\nfrom passlib.utils import sys_bits\n\n__all__=[\n'custom_app_context',\n'django_context',\n'ldap_context','ldap_nocrypt_context',\n'mysql_context','mysql4_context','mysql3_context',\n'phpass_context',\n'phpbb3_context',\n'postgres_context',\n]\n\n\n\n\ndef _load_master_config():\n from passlib.registry import list_crypt_handlers\n \n \n schemes=list_crypt_handlers()\n \n \n excluded=[\n \n 'bigcrypt',\n 'crypt16',\n \n \n 'cisco_pix',\n 'cisco_type7',\n 'htdigest',\n 'mysql323',\n 'oracle10',\n \n \n 'lmhash',\n 'msdcc',\n 'msdcc2',\n 'nthash',\n \n \n 'plaintext',\n 'ldap_plaintext',\n \n \n 'django_disabled',\n 'unix_disabled',\n 'unix_fallback',\n ]\n for name in excluded:\n  schemes.remove(name)\n  \n  \n return dict(schemes=schemes,default=\"sha256_crypt\")\nmaster_context=LazyCryptContext(onload=_load_master_config)\n\n\n\n\ncustom_app_context=LazyCryptContext(\n\nschemes=[\"sha512_crypt\",\"sha256_crypt\"],\n\n\ndefault=\"sha256_crypt\"if sys_bits <64 else \"sha512_crypt\",\n\n\nsha512_crypt__min_rounds=535000,\nsha256_crypt__min_rounds=535000,\n\n\nadmin__sha512_crypt__min_rounds=1024000,\nadmin__sha256_crypt__min_rounds=1024000,\n)\n\n\n\n\n\n\n\n\n\n_django10_schemes=[\n\"django_salted_sha1\",\n\"django_salted_md5\",\n\"django_des_crypt\",\n\"hex_md5\",\n\"django_disabled\",\n]\n\ndjango10_context=LazyCryptContext(\nschemes=_django10_schemes,\ndefault=\"django_salted_sha1\",\ndeprecated=[\"hex_md5\"],\n)\n\n\n\n\n\n_django14_schemes=[\n\"django_pbkdf2_sha256\",\n\"django_pbkdf2_sha1\",\n\"django_bcrypt\"\n]+_django10_schemes\n\ndjango14_context=LazyCryptContext(\nschemes=_django14_schemes,\ndeprecated=_django10_schemes,\n)\n\n\n\n\n\n_django16_schemes=list(_django14_schemes)\n_django16_schemes.insert(1,\"django_bcrypt_sha256\")\ndjango16_context=LazyCryptContext(\nschemes=_django16_schemes,\ndeprecated=_django10_schemes,\n)\n\n\n\n\n\n_django_110_schemes=[\n\"django_pbkdf2_sha256\",\n\"django_pbkdf2_sha1\",\n\"django_argon2\",\n\"django_bcrypt\",\n\"django_bcrypt_sha256\",\n\"django_disabled\",\n]\ndjango110_context=LazyCryptContext(schemes=_django_110_schemes)\n\n\n\n\n\n_django21_schemes=list(_django_110_schemes)\n_django21_schemes.remove(\"django_bcrypt\")\ndjango21_context=LazyCryptContext(schemes=_django21_schemes)\n\n\n\n\n\n\ndjango_context=django21_context\n\n\n\n\n\n\nstd_ldap_schemes=[\n\"ldap_salted_sha512\",\n\"ldap_salted_sha256\",\n\"ldap_salted_sha1\",\n\"ldap_salted_md5\",\n\"ldap_sha1\",\n\"ldap_md5\",\n\"ldap_plaintext\",\n]\n\n\nldap_nocrypt_context=LazyCryptContext(std_ldap_schemes)\n\n\ndef _iter_ldap_crypt_schemes():\n from passlib.utils import unix_crypt_schemes\n return ('ldap_'+name for name in unix_crypt_schemes)\n \ndef _iter_ldap_schemes():\n ''\n return chain(std_ldap_schemes,_iter_ldap_crypt_schemes())\nldap_context=LazyCryptContext(_iter_ldap_schemes())\n\n\n\n\n\n\n\n\n\n\n\nmysql3_context=LazyCryptContext([\"mysql323\"])\nmysql4_context=LazyCryptContext([\"mysql41\",\"mysql323\"],deprecated=\"mysql323\")\nmysql_context=mysql4_context\n\n\n\n\npostgres_context=LazyCryptContext([\"postgres_md5\"])\n\n\n\n\ndef _create_phpass_policy(**kwds):\n ''\n kwds['default']='bcrypt'if hash.bcrypt.has_backend()else 'phpass'\n return kwds\n \nphpass_context=LazyCryptContext(\nschemes=[\"bcrypt\",\"phpass\",\"bsdi_crypt\"],\nonload=_create_phpass_policy,\n)\n\nphpbb3_context=LazyCryptContext([\"phpass\"],phpass__ident=\"H\")\n\n\n\n\n\n\n\n_std_roundup_schemes=[\"ldap_hex_sha1\",\"ldap_hex_md5\",\"ldap_des_crypt\",\"roundup_plaintext\"]\nroundup10_context=LazyCryptContext(_std_roundup_schemes)\n\n\nroundup_context=roundup15_context=LazyCryptContext(\nschemes=_std_roundup_schemes+[\"ldap_pbkdf2_sha1\"],\ndeprecated=_std_roundup_schemes,\ndefault=\"ldap_pbkdf2_sha1\",\nldap_pbkdf2_sha1__default_rounds=10000,\n)\n\n\n\n\n", ["itertools", "logging", "passlib", "passlib.context", "passlib.registry", "passlib.utils"]], "passlib.pwd": [".py", "''\n\n\n\nfrom __future__ import absolute_import,division,print_function,unicode_literals\n\nimport codecs\nfrom collections import defaultdict\ntry :\n from collections.abc import MutableMapping\nexcept ImportError:\n\n from collections import MutableMapping\nfrom math import ceil,log as logf\nimport logging ;log=logging.getLogger(__name__)\nimport pkg_resources\nimport os\n\n\nfrom passlib import exc\nfrom passlib.utils.compat import PY2,irange,itervalues,int_types\nfrom passlib.utils import rng,getrandstr,to_unicode\nfrom passlib.utils.decor import memoized_property\n\n__all__=[\n\"genword\",\"default_charsets\",\n\"genphrase\",\"default_wordsets\",\n]\n\n\n\n\n\n\nentropy_aliases=dict(\n\nunsafe=12,\n\n\nweak=24,\n\n\nfair=36,\n\n\nstrong=48,\n\n\nsecure=60,\n)\n\n\n\n\n\ndef _superclasses(obj,cls):\n ''\n mro=type(obj).__mro__\n return mro[mro.index(cls)+1:]\n \n \ndef _self_info_rate(source):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  size=len(source)\n except TypeError:\n \n  size=None\n counts=defaultdict(int)\n for char in source:\n  counts[char]+=1\n if size is None :\n  values=counts.values()\n  size=sum(values)\n else :\n  values=itervalues(counts)\n if not size:\n  return 0\n  \n  \n return logf(size,2)-sum(value *logf(value,2)for value in values)/size\n \n \n \n \n \n \n \n \n \n \ndef _open_asset_path(path,encoding=None ):\n ''\n\n\n\n\n\n\n\n\n \n if encoding:\n  return codecs.getreader(encoding)(_open_asset_path(path))\n if os.path.isabs(path):\n  return open(path,\"rb\")\n package,sep,subpath=path.partition(\":\")\n if not sep:\n  raise ValueError(\"asset path must be absolute file path \"\n  \"or use 'pkg.name:sub/path' format: %r\"%(path,))\n return pkg_resources.resource_stream(package,subpath)\n \n \n \n_sequence_types=(list,tuple)\n_set_types=(set,frozenset)\n\n\n_ensure_unique_cache=set()\n\n\ndef _ensure_unique(source,param=\"source\"):\n ''\n\n\n\n \n \n cache=_ensure_unique_cache\n hashable=True\n try :\n  if source in cache:\n   return True\n except TypeError:\n  hashable=False\n  \n  \n if isinstance(source,_set_types)or len(set(source))==len(source):\n  if hashable:\n   try :\n    cache.add(source)\n   except TypeError:\n   \n   \n    pass\n  return True\n  \n  \n seen=set()\n dups=set()\n for elem in source:\n  (dups if elem in seen else seen).add(elem)\n dups=sorted(dups)\n trunc=8\n if len(dups)>trunc:\n  trunc=5\n dup_repr=\", \".join(repr(str(word))for word in dups[:trunc])\n if len(dups)>trunc:\n  dup_repr +=\", ... plus %d others\"%(len(dups)-trunc)\n  \n  \n raise ValueError(\"`%s` cannot contain duplicate elements: %s\"%\n (param,dup_repr))\n \n \n \n \nclass SequenceGenerator(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n length=None\n \n \n requested_entropy=\"strong\"\n \n \n rng=rng\n \n \n symbol_count=None\n \n \n \n \n def __init__(self,entropy=None ,length=None ,rng=None ,**kwds):\n \n \n  assert self.symbol_count is not None ,\"subclass must set .symbol_count\"\n  \n  \n  if entropy is not None or length is None :\n   if entropy is None :\n    entropy=self.requested_entropy\n   entropy=entropy_aliases.get(entropy,entropy)\n   if entropy <=0:\n    raise ValueError(\"`entropy` must be positive number\")\n   min_length=int(ceil(entropy /self.entropy_per_symbol))\n   if length is None or length <min_length:\n    length=min_length\n    \n  self.requested_entropy=entropy\n  \n  if length <1:\n   raise ValueError(\"`length` must be positive integer\")\n  self.length=length\n  \n  \n  if rng is not None :\n   self.rng=rng\n   \n   \n  if kwds and _superclasses(self,SequenceGenerator)==(object,):\n   raise TypeError(\"Unexpected keyword(s): %s\"%\", \".join(kwds.keys()))\n  super(SequenceGenerator,self).__init__(**kwds)\n  \n  \n  \n  \n  \n @memoized_property\n def entropy_per_symbol(self):\n  ''\n\n  \n  return logf(self.symbol_count,2)\n  \n @memoized_property\n def entropy(self):\n  ''\n\n\n\n\n\n  \n  return self.length *self.entropy_per_symbol\n  \n  \n  \n  \n def __next__(self):\n  ''\n  raise NotImplementedError(\"implement in subclass\")\n  \n def __call__(self,returns=None ):\n  ''\n\n  \n  if returns is None :\n   return next(self)\n  elif isinstance(returns,int_types):\n   return [next(self)for _ in irange(returns)]\n  elif returns is iter:\n   return self\n  else :\n   raise exc.ExpectedTypeError(returns,\"<None>, int, or <iter>\",\"returns\")\n   \n def __iter__(self):\n  return self\n  \n if PY2:\n  def next(self):\n   return self.__next__()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \ndefault_charsets=dict(\n\nascii_72='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*?/',\n\n\nascii_62='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\n\nascii_50='234679abcdefghjkmnpqrstuvwxyzACDEFGHJKMNPQRTUVWXYZ',\n\n\nhex='0123456789abcdef',\n)\n\n\n\n\n\nclass WordGenerator(SequenceGenerator):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n charset=\"ascii_62\"\n \n \n chars=None\n \n \n \n \n def __init__(self,chars=None ,charset=None ,**kwds):\n \n \n  if chars:\n   if charset:\n    raise TypeError(\"`chars` and `charset` are mutually exclusive\")\n  else :\n   if not charset:\n    charset=self.charset\n    assert charset\n   chars=default_charsets[charset]\n  self.charset=charset\n  chars=to_unicode(chars,param=\"chars\")\n  _ensure_unique(chars,param=\"chars\")\n  self.chars=chars\n  \n  \n  super(WordGenerator,self).__init__(**kwds)\n  \n  \n  \n  \n  \n  \n @memoized_property\n def symbol_count(self):\n  return len(self.chars)\n  \n  \n  \n  \n  \n def __next__(self):\n \n \n  return getrandstr(self.rng,self.chars,self.length)\n  \n  \n  \n  \n  \n  \ndef genword(entropy=None ,length=None ,returns=None ,**kwds):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n gen=WordGenerator(length=length,entropy=entropy,**kwds)\n return gen(returns)\n \n \n \n \n \ndef _load_wordset(asset_path):\n ''\n\n\n\n\n\n\n\n\n\n \n \n with _open_asset_path(asset_path,\"utf-8\")as fh:\n  gen=(word.strip()for word in fh)\n  words=tuple(word for word in gen if word)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n log.debug(\"loaded %d-element wordset from %r\",len(words),asset_path)\n return words\n \n \nclass WordsetDict(MutableMapping):\n ''\n\n\n\n \n \n \n paths=None\n \n \n _loaded=None\n \n def __init__(self,*args,**kwds):\n  self.paths={}\n  self._loaded={}\n  super(WordsetDict,self).__init__(*args,**kwds)\n  \n def __getitem__(self,key):\n  try :\n   return self._loaded[key]\n  except KeyError:\n   pass\n  path=self.paths[key]\n  value=self._loaded[key]=_load_wordset(path)\n  return value\n  \n def set_path(self,key,path):\n  ''\n\n  \n  self.paths[key]=path\n  \n def __setitem__(self,key,value):\n  self._loaded[key]=value\n  \n def __delitem__(self,key):\n  if key in self:\n   del self._loaded[key]\n   self.paths.pop(key,None )\n  else :\n   del self.paths[key]\n   \n @property\n def _keyset(self):\n  keys=set(self._loaded)\n  keys.update(self.paths)\n  return keys\n  \n def __iter__(self):\n  return iter(self._keyset)\n  \n def __len__(self):\n  return len(self._keyset)\n  \n  \n def __contains__(self,key):\n  return key in self._loaded or key in self.paths\n  \n  \n  \n  \ndefault_wordsets=WordsetDict()\n\n\nfor name in \"eff_long eff_short eff_prefixed bip39\".split():\n default_wordsets.set_path(name,\"passlib:_data/wordsets/%s.txt\"%name)\n \n \n \n \nclass PhraseGenerator(SequenceGenerator):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n wordset=\"eff_long\"\n \n \n words=None\n \n \n sep=\" \"\n \n \n \n \n def __init__(self,wordset=None ,words=None ,sep=None ,**kwds):\n \n \n  if words is not None :\n   if wordset is not None :\n    raise TypeError(\"`words` and `wordset` are mutually exclusive\")\n  else :\n   if wordset is None :\n    wordset=self.wordset\n    assert wordset\n   words=default_wordsets[wordset]\n  self.wordset=wordset\n  \n  \n  if not isinstance(words,_sequence_types):\n   words=tuple(words)\n  _ensure_unique(words,param=\"words\")\n  self.words=words\n  \n  \n  if sep is None :\n   sep=self.sep\n  sep=to_unicode(sep,param=\"sep\")\n  self.sep=sep\n  \n  \n  super(PhraseGenerator,self).__init__(**kwds)\n  \n  \n  \n  \n  \n  \n  \n @memoized_property\n def symbol_count(self):\n  return len(self.words)\n  \n  \n  \n  \n  \n def __next__(self):\n  words=(self.rng.choice(self.words)for _ in irange(self.length))\n  return self.sep.join(words)\n  \n  \n  \n  \n  \n  \ndef genphrase(entropy=None ,length=None ,returns=None ,**kwds):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n gen=PhraseGenerator(entropy=entropy,length=length,**kwds)\n return gen(returns)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", ["__future__", "codecs", "collections", "collections.abc", "logging", "math", "os", "passlib", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "pkg_resources"]], "passlib.hash": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom passlib.registry import _proxy\nimport sys\nsys.modules[__name__]=_proxy\n\n\n\n\n\n\n\n\n\n\nif False :\n from passlib.handlers.argon2 import argon2\n from passlib.handlers.bcrypt import bcrypt,bcrypt_sha256\n from passlib.handlers.cisco import cisco_asa,cisco_pix,cisco_type7\n from passlib.handlers.des_crypt import bigcrypt,bsdi_crypt,crypt16,des_crypt\n from passlib.handlers.digests import hex_md4,hex_md5,hex_sha1,hex_sha256,hex_sha512,htdigest\n from passlib.handlers.django import django_bcrypt,django_bcrypt_sha256,django_des_crypt,django_disabled,django_pbkdf2_sha1,django_pbkdf2_sha256,django_salted_md5,django_salted_sha1\n from passlib.handlers.fshp import fshp\n from passlib.handlers.ldap_digests import ldap_bcrypt,ldap_bsdi_crypt,ldap_des_crypt,ldap_md5,ldap_md5_crypt,ldap_plaintext,ldap_salted_md5,ldap_salted_sha1,ldap_salted_sha256,ldap_salted_sha512,ldap_sha1,ldap_sha1_crypt,ldap_sha256_crypt,ldap_sha512_crypt\n from passlib.handlers.md5_crypt import apr_md5_crypt,md5_crypt\n from passlib.handlers.misc import plaintext,unix_disabled,unix_fallback\n from passlib.handlers.mssql import mssql2000,mssql2005\n from passlib.handlers.mysql import mysql323,mysql41\n from passlib.handlers.oracle import oracle10,oracle11\n from passlib.handlers.pbkdf2 import atlassian_pbkdf2_sha1,cta_pbkdf2_sha1,dlitz_pbkdf2_sha1,grub_pbkdf2_sha512,ldap_pbkdf2_sha1,ldap_pbkdf2_sha256,ldap_pbkdf2_sha512,pbkdf2_sha1,pbkdf2_sha256,pbkdf2_sha512\n from passlib.handlers.phpass import phpass\n from passlib.handlers.postgres import postgres_md5\n from passlib.handlers.roundup import ldap_hex_md5,ldap_hex_sha1,roundup_plaintext\n from passlib.handlers.scram import scram\n from passlib.handlers.scrypt import scrypt\n from passlib.handlers.sha1_crypt import sha1_crypt\n from passlib.handlers.sha2_crypt import sha256_crypt,sha512_crypt\n from passlib.handlers.sun_md5_crypt import sun_md5_crypt\n from passlib.handlers.windows import bsd_nthash,lmhash,msdcc,msdcc2,nthash\n \n \n \n \n \n \n \n", ["passlib.handlers.argon2", "passlib.handlers.bcrypt", "passlib.handlers.cisco", "passlib.handlers.des_crypt", "passlib.handlers.digests", "passlib.handlers.django", "passlib.handlers.fshp", "passlib.handlers.ldap_digests", "passlib.handlers.md5_crypt", "passlib.handlers.misc", "passlib.handlers.mssql", "passlib.handlers.mysql", "passlib.handlers.oracle", "passlib.handlers.pbkdf2", "passlib.handlers.phpass", "passlib.handlers.postgres", "passlib.handlers.roundup", "passlib.handlers.scram", "passlib.handlers.scrypt", "passlib.handlers.sha1_crypt", "passlib.handlers.sha2_crypt", "passlib.handlers.sun_md5_crypt", "passlib.handlers.windows", "passlib.registry", "sys"]], "passlib.context": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nimport threading\nimport time\nfrom warnings import warn\n\n\nfrom passlib import exc\nfrom passlib.exc import ExpectedStringError,ExpectedTypeError,PasslibConfigWarning\nfrom passlib.registry import get_crypt_handler,_validate_handler_name\nfrom passlib.utils import (handlers as uh,to_bytes,\nto_unicode,splitcomma,\nas_bool,timer,rng,getrandstr,\n)\nfrom passlib.utils.binary import BASE64_CHARS\nfrom passlib.utils.compat import (iteritems,num_types,irange,\nPY2,PY3,unicode,SafeConfigParser,\nNativeStringIO,BytesIO,\nunicode_or_bytes_types,native_string_types,\n)\nfrom passlib.utils.decor import deprecated_method,memoized_property\n\n__all__=[\n'CryptContext',\n'LazyCryptContext',\n'CryptPolicy',\n]\n\n\n\n\n\n\n_UNSET=object()\n\ndef _coerce_vary_rounds(value):\n ''\n if value.endswith(\"%\"):\n \n  return float(value.rstrip(\"%\"))*.01\n try :\n  return int(value)\n except ValueError:\n  return float(value)\n  \n  \n_forbidden_scheme_options=set([\"salt\"])\n\n\n\n\n\n_coerce_scheme_options=dict(\nmin_rounds=int,\nmax_rounds=int,\ndefault_rounds=int,\nvary_rounds=_coerce_vary_rounds,\nsalt_size=int,\n)\n\ndef _is_handler_registered(handler):\n ''\n return get_crypt_handler(handler.name,None )is handler\n \n@staticmethod\ndef _always_needs_update(hash,secret=None ):\n ''\n\n\n \n return True\n \n \n_global_settings=set([\"truncate_error\",\"vary_rounds\"])\n\n\n\n\n_preamble=(\"The CryptPolicy class has been deprecated as of \"\n\"Passlib 1.6, and will be removed in Passlib 1.8. \")\n\nclass CryptPolicy(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n @classmethod\n def from_path(cls,path,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  warn(_preamble+\n  \"Instead of ``CryptPolicy.from_path(path)``, \"\n  \"use ``CryptContext.from_path(path)`` \"\n  \" or ``context.load_path(path)`` for an existing CryptContext.\",\n  DeprecationWarning,stacklevel=2)\n  return cls(_internal_context=CryptContext.from_path(path,section,\n  encoding))\n  \n @classmethod\n def from_string(cls,source,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  warn(_preamble+\n  \"Instead of ``CryptPolicy.from_string(source)``, \"\n  \"use ``CryptContext.from_string(source)`` or \"\n  \"``context.load(source)`` for an existing CryptContext.\",\n  DeprecationWarning,stacklevel=2)\n  return cls(_internal_context=CryptContext.from_string(source,section,\n  encoding))\n  \n @classmethod\n def from_source(cls,source,_warn=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if _warn:\n   warn(_preamble+\n   \"Instead of ``CryptPolicy.from_source()``, \"\n   \"use ``CryptContext.from_string(path)`` \"\n   \" or ``CryptContext.from_path(source)``, as appropriate.\",\n   DeprecationWarning,stacklevel=2)\n  if isinstance(source,CryptPolicy):\n   return source\n  elif isinstance(source,dict):\n   return cls(_internal_context=CryptContext(**source))\n  elif not isinstance(source,(bytes,unicode)):\n   raise TypeError(\"source must be CryptPolicy, dict, config string, \"\n   \"or file path: %r\"%(type(source),))\n  elif any(c in source for c in \"\\n\\r\\t\")or not source.strip(\" \\t./;:\"):\n   return cls(_internal_context=CryptContext.from_string(source))\n  else :\n   return cls(_internal_context=CryptContext.from_path(source))\n   \n @classmethod\n def from_sources(cls,sources,_warn=True ):\n  ''\n\n\n\n\n\n\n\n\n  \n  if _warn:\n   warn(_preamble+\n   \"Instead of ``CryptPolicy.from_sources()``, \"\n   \"use the various CryptContext constructors \"\n   \" followed by ``context.update()``.\",\n   DeprecationWarning,stacklevel=2)\n  if len(sources)==0:\n   raise ValueError(\"no sources specified\")\n  if len(sources)==1:\n   return cls.from_source(sources[0],_warn=False )\n  kwds={}\n  for source in sources:\n   kwds.update(cls.from_source(source,_warn=False )._context.to_dict(resolve=True ))\n  return cls(_internal_context=CryptContext(**kwds))\n  \n def replace(self,*args,**kwds):\n  ''\n\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.replace()``, \"\n   \"use ``context.update()`` or ``context.copy()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().replace()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.update()`` or ``context.copy()``.\",\n   DeprecationWarning,stacklevel=2)\n  sources=[self]\n  if args:\n   sources.extend(args)\n  if kwds:\n   sources.append(kwds)\n  return CryptPolicy.from_sources(sources,_warn=False )\n  \n  \n  \n  \n  \n  \n  \n _context=None\n \n \n \n _stub_policy=False\n \n \n \n \n def __init__(self,*args,**kwds):\n  context=kwds.pop(\"_internal_context\",None )\n  if context:\n   assert isinstance(context,CryptContext)\n   self._context=context\n   self._stub_policy=kwds.pop(\"_stub_policy\",False )\n   assert not (args or kwds),\"unexpected args: %r %r\"%(args,kwds)\n  else :\n   if args:\n    if len(args)!=1:\n     raise TypeError(\"only one positional argument accepted\")\n    if kwds:\n     raise TypeError(\"cannot specify positional arg and kwds\")\n    kwds=args[0]\n   warn(_preamble+\n   \"Instead of constructing a CryptPolicy instance, \"\n   \"create a CryptContext directly, or use ``context.update()`` \"\n   \"and ``context.load()`` to reconfigure existing CryptContext \"\n   \"instances.\",\n   DeprecationWarning,stacklevel=2)\n   self._context=CryptContext(**kwds)\n   \n   \n   \n   \n def has_schemes(self):\n  ''\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.has_schemes()``, \"\n   \"use ``bool(context.schemes())``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().has_schemes()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``bool(context.schemes())``.\",\n   DeprecationWarning,stacklevel=2)\n  return bool(self._context.schemes())\n  \n def iter_handlers(self):\n  ''\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.iter_handlers()``, \"\n   \"use ``context.schemes(resolve=True)``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().iter_handlers()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.schemes(resolve=True)``.\",\n   DeprecationWarning,stacklevel=2)\n  return self._context.schemes(resolve=True ,unconfigured=True )\n  \n def schemes(self,resolve=False ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.schemes()``, \"\n   \"use ``context.schemes()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().schemes()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.schemes()``.\",\n   DeprecationWarning,stacklevel=2)\n  return list(self._context.schemes(resolve=resolve,unconfigured=True ))\n  \n def get_handler(self,name=None ,category=None ,required=False ):\n  ''\n\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.get_handler()``, \"\n   \"use ``context.handler()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().get_handler()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.handler()``.\",\n   DeprecationWarning,stacklevel=2)\n   \n   \n  try :\n   return self._context.handler(name,category,unconfigured=True )\n  except KeyError:\n   if required:\n    raise\n   else :\n    return None\n    \n def get_min_verify_time(self,category=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  warn(\"get_min_verify_time() and min_verify_time option is deprecated and ignored, \"\n  \"and will be removed in Passlib 1.8\",DeprecationWarning,\n  stacklevel=2)\n  return 0\n  \n def get_options(self,name,category=None ):\n  ''\n\n\n\n\n\n  \n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"``context.policy.get_options()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"``CryptPolicy().get_options()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  if hasattr(name,\"name\"):\n   name=name.name\n  return self._context._config._get_record_options_with_flag(name,category)[0]\n  \n def handler_is_deprecated(self,name,category=None ):\n  ''\n\n\n\n\n\n  \n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"``context.policy.handler_is_deprecated()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"``CryptPolicy().handler_is_deprecated()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  if hasattr(name,\"name\"):\n   name=name.name\n  return self._context.handler(name,category).deprecated\n  \n  \n  \n  \n  \n def iter_config(self,ini=False ,resolve=False ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.iter_config()``, \"\n   \"use ``context.to_dict().items()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().iter_config()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.to_dict().items()``.\",\n   DeprecationWarning,stacklevel=2)\n   \n   \n  context=self._context\n  if ini:\n   def render_key(key):\n    return context._render_config_key(key).replace(\"__\",\".\")\n   def render_value(value):\n    if isinstance(value,(list,tuple)):\n     value=\", \".join(value)\n    return value\n   resolve=False\n  else :\n   render_key=context._render_config_key\n   render_value=lambda value:value\n  return (\n  (render_key(key),render_value(value))\n  for key,value in context._config.iter_config(resolve)\n  )\n  \n def to_dict(self,resolve=False ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.to_dict()``, \"\n   \"use ``context.to_dict()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().to_dict()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.to_dict()``.\",\n   DeprecationWarning,stacklevel=2)\n  return self._context.to_dict(resolve)\n  \n def to_file(self,stream,section=\"passlib\"):\n  ''\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.to_file(stream)``, \"\n   \"use ``stream.write(context.to_string())``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().to_file(stream)``, \"\n   \"create a CryptContext instance and \"\n   \"use ``stream.write(context.to_string())``.\",\n   DeprecationWarning,stacklevel=2)\n  out=self._context.to_string(section=section)\n  if PY2:\n   out=out.encode(\"utf-8\")\n  stream.write(out)\n  \n def to_string(self,section=\"passlib\",encoding=None ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.to_string()``, \"\n   \"use ``context.to_string()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().to_string()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.to_string()``.\",\n   DeprecationWarning,stacklevel=2)\n  out=self._context.to_string(section=section)\n  if encoding:\n   out=out.encode(encoding)\n  return out\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CryptConfig(object):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n _scheme_options=None\n \n \n \n _context_options=None\n \n \n handlers=None\n \n \n schemes=None\n \n \n categories=None\n \n \n context_kwds=None\n \n \n _default_schemes=None\n \n \n _records=None\n \n \n \n _record_lists=None\n \n \n \n \n def __init__(self,source):\n  self._init_scheme_list(source.get((None ,None ,\"schemes\")))\n  self._init_options(source)\n  self._init_default_schemes()\n  self._init_records()\n  \n def _init_scheme_list(self,data):\n  ''\n  handlers=[]\n  schemes=[]\n  if isinstance(data,native_string_types):\n   data=splitcomma(data)\n  for elem in data or ():\n  \n   if hasattr(elem,\"name\"):\n    handler=elem\n    scheme=handler.name\n    _validate_handler_name(scheme)\n   elif isinstance(elem,native_string_types):\n    handler=get_crypt_handler(elem)\n    scheme=handler.name\n   else :\n    raise TypeError(\"scheme must be name or CryptHandler, \"\n    \"not %r\"%type(elem))\n    \n    \n   if scheme in schemes:\n    raise KeyError(\"multiple handlers with same name: %r\"%\n    (scheme,))\n    \n    \n   handlers.append(handler)\n   schemes.append(scheme)\n   \n  self.handlers=tuple(handlers)\n  self.schemes=tuple(schemes)\n  \n  \n  \n  \n  \n  \n  \n  \n def _init_options(self,source):\n  ''\n\n  \n  \n  norm_scheme_option=self._norm_scheme_option\n  norm_context_option=self._norm_context_option\n  self._scheme_options=scheme_options={}\n  self._context_options=context_options={}\n  categories=set()\n  \n  \n  for (cat,scheme,key),value in iteritems(source):\n   categories.add(cat)\n   explicit_scheme=scheme\n   if not cat and not scheme and key in _global_settings:\n   \n   \n   \n    scheme=\"all\"\n   if scheme:\n   \n    key,value=norm_scheme_option(key,value)\n    \n    \n    \n    if scheme ==\"all\"and key not in _global_settings:\n     warn(\"The '%s' option should be configured per-algorithm, and not set \"\n     \"globally in the context; This will be an error in Passlib 2.0\"%\n     (key,),PasslibConfigWarning)\n     \n     \n     \n    if explicit_scheme ==\"all\":\n     warn(\"The 'all' scheme is deprecated as of Passlib 1.7, \"\n     \"and will be removed in Passlib 2.0; Please configure \"\n     \"options on a per-algorithm basis.\",DeprecationWarning)\n     \n     \n     \n    try :\n     category_map=scheme_options[scheme]\n    except KeyError:\n     scheme_options[scheme]={cat:{key:value}}\n    else :\n     try :\n      option_map=category_map[cat]\n     except KeyError:\n      category_map[cat]={key:value}\n     else :\n      option_map[key]=value\n   else :\n   \n    if cat and key ==\"schemes\":\n     raise KeyError(\"'schemes' context option is not allowed \"\n     \"per category\")\n    key,value=norm_context_option(cat,key,value)\n    if key ==\"min_verify_time\":\n     continue\n     \n     \n     \n    try :\n     category_map=context_options[key]\n    except KeyError:\n     context_options[key]={cat:value}\n    else :\n     category_map[cat]=value\n     \n     \n  categories.discard(None )\n  self.categories=tuple(sorted(categories))\n  \n def _norm_scheme_option(self,key,value):\n \n  if key in _forbidden_scheme_options:\n   raise KeyError(\"%r option not allowed in CryptContext \"\n   \"configuration\"%(key,))\n   \n  if isinstance(value,native_string_types):\n   func=_coerce_scheme_options.get(key)\n   if func:\n    value=func(value)\n  return key,value\n  \n def _norm_context_option(self,cat,key,value):\n  schemes=self.schemes\n  if key ==\"default\":\n   if hasattr(value,\"name\"):\n    value=value.name\n   elif not isinstance(value,native_string_types):\n    raise ExpectedTypeError(value,\"str\",\"default\")\n   if schemes and value not in schemes:\n    raise KeyError(\"default scheme not found in policy\")\n  elif key ==\"deprecated\":\n   if isinstance(value,native_string_types):\n    value=splitcomma(value)\n   elif not isinstance(value,(list,tuple)):\n    raise ExpectedTypeError(value,\"str or seq\",\"deprecated\")\n   if 'auto'in value:\n   \n   \n    if len(value)>1:\n     raise ValueError(\"cannot list other schemes if \"\n     \"``deprecated=['auto']`` is used\")\n   elif schemes:\n   \n    for scheme in value:\n     if not isinstance(scheme,native_string_types):\n      raise ExpectedTypeError(value,\"str\",\"deprecated element\")\n     if scheme not in schemes:\n      raise KeyError(\"deprecated scheme not found \"\n      \"in policy: %r\"%(scheme,))\n  elif key ==\"min_verify_time\":\n   warn(\"'min_verify_time' was deprecated in Passlib 1.6, is \"\n   \"ignored in 1.7, and will be removed in 1.8\",\n   DeprecationWarning)\n  elif key ==\"harden_verify\":\n   warn(\"'harden_verify' is deprecated & ignored as of Passlib 1.7.1, \"\n   \" and will be removed in 1.8\",\n   DeprecationWarning)\n  elif key !=\"schemes\":\n   raise KeyError(\"unknown CryptContext keyword: %r\"%(key,))\n  return key,value\n  \n  \n  \n  \n def get_context_optionmap(self,key,_default={}):\n  ''\n\n\n  \n  return self._context_options.get(key,_default)\n  \n def get_context_option_with_flag(self,category,key):\n  ''\n\n  \n  try :\n   category_map=self._context_options[key]\n  except KeyError:\n   return None ,False\n  value=category_map.get(None )\n  if category:\n   try :\n    alt=category_map[category]\n   except KeyError:\n    pass\n   else :\n    if value is None or alt !=value:\n     return alt,True\n  return value,False\n  \n  \n  \n  \n def _get_scheme_optionmap(self,scheme,category,default={}):\n  ''\n\n\n  \n  try :\n   return self._scheme_options[scheme][category]\n  except KeyError:\n   return default\n   \n def get_base_handler(self,scheme):\n  return self.handlers[self.schemes.index(scheme)]\n  \n @staticmethod\n def expand_settings(handler):\n  setting_kwds=handler.setting_kwds\n  if 'rounds'in handler.setting_kwds:\n  \n   setting_kwds +=uh.HasRounds.using_rounds_kwds\n  return setting_kwds\n  \n  \n def get_scheme_options_with_flag(self,scheme,category):\n  ''\n\n\n\n  \n  \n  get_optionmap=self._get_scheme_optionmap\n  kwds=get_optionmap(\"all\",None ).copy()\n  has_cat_options=False\n  \n  \n  if category:\n   defkwds=kwds.copy()\n   kwds.update(get_optionmap(\"all\",category))\n   \n   \n  allowed_settings=self.expand_settings(self.get_base_handler(scheme))\n  for key in set(kwds).difference(allowed_settings):\n   kwds.pop(key)\n  if category:\n   for key in set(defkwds).difference(allowed_settings):\n    defkwds.pop(key)\n    \n    \n  other=get_optionmap(scheme,None )\n  kwds.update(other)\n  \n  \n  if category:\n   defkwds.update(other)\n   kwds.update(get_optionmap(scheme,category))\n   \n   \n   \n   if kwds !=defkwds:\n    has_cat_options=True\n    \n  return kwds,has_cat_options\n  \n  \n  \n  \n def _init_default_schemes(self):\n  ''\n\n\n\n  \n  \n  get_optionmap=self.get_context_optionmap\n  default_map=self._default_schemes=get_optionmap(\"default\").copy()\n  dep_map=get_optionmap(\"deprecated\")\n  schemes=self.schemes\n  if not schemes:\n   return\n   \n   \n  deps=dep_map.get(None )or ()\n  default=default_map.get(None )\n  if not default:\n   for scheme in schemes:\n    if scheme not in deps:\n     default_map[None ]=scheme\n     break\n   else :\n    raise ValueError(\"must have at least one non-deprecated scheme\")\n  elif default in deps:\n   raise ValueError(\"default scheme cannot be deprecated\")\n   \n   \n  for cat in self.categories:\n   cdeps=dep_map.get(cat,deps)\n   cdefault=default_map.get(cat,default)\n   if not cdefault:\n    for scheme in schemes:\n     if scheme not in cdeps:\n      default_map[cat]=scheme\n      break\n    else :\n     raise ValueError(\"must have at least one non-deprecated \"\n     \"scheme for %r category\"%cat)\n   elif cdefault in cdeps:\n    raise ValueError(\"default scheme for %r category \"\n    \"cannot be deprecated\"%cat)\n    \n def default_scheme(self,category):\n  ''\n  defaults=self._default_schemes\n  try :\n   return defaults[category]\n  except KeyError:\n   pass\n  if not self.schemes:\n   raise KeyError(\"no hash schemes configured for this \"\n   \"CryptContext instance\")\n  return defaults[None ]\n  \n def is_deprecated_with_flag(self,scheme,category):\n  ''\n  depmap=self.get_context_optionmap(\"deprecated\")\n  def test(cat):\n   source=depmap.get(cat,depmap.get(None ))\n   if source is None :\n    return None\n   elif 'auto'in source:\n    return scheme !=self.default_scheme(cat)\n   else :\n    return scheme in source\n  value=test(None )or False\n  if category:\n   alt=test(category)\n   if alt is not None and value !=alt:\n    return alt,True\n  return value,False\n  \n  \n  \n  \n def _init_records(self):\n \n \n \n \n  self._record_lists={}\n  records=self._records={}\n  all_context_kwds=self.context_kwds=set()\n  get_options=self._get_record_options_with_flag\n  categories=(None ,)+self.categories\n  for handler in self.handlers:\n   scheme=handler.name\n   all_context_kwds.update(handler.context_kwds)\n   for cat in categories:\n    kwds,has_cat_options=get_options(scheme,cat)\n    if cat is None or has_cat_options:\n     records[scheme,cat]=self._create_record(handler,cat,**kwds)\n     \n     \n     \n     \n     \n @staticmethod\n def _create_record(handler,category=None ,deprecated=False ,**settings):\n \n  try :\n  \n  \n   subcls=handler.using(relaxed=True ,**settings)\n  except TypeError as err:\n   m=re.match(r\".* unexpected keyword argument '(.*)'$\",str(err))\n   if m and m.group(1)in settings:\n   \n   \n    key=m.group(1)\n    raise KeyError(\"keyword not supported by %s handler: %r\"%\n    (handler.name,key))\n   raise\n   \n   \n  assert subcls is not handler,\"expected unique variant of handler\"\n  \n  subcls._Context__orig_handler=handler\n  subcls.deprecated=deprecated\n  return subcls\n  \n def _get_record_options_with_flag(self,scheme,category):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  kwds,has_cat_options=self.get_scheme_options_with_flag(scheme,category)\n  \n  \n  value,not_inherited=self.is_deprecated_with_flag(scheme,category)\n  if value:\n   kwds['deprecated']=True\n  if not_inherited:\n   has_cat_options=True\n   \n  return kwds,has_cat_options\n  \n def get_record(self,scheme,category):\n  ''\n  \n  \n  \n  \n  \n  try :\n   return self._records[scheme,category]\n  except KeyError:\n   pass\n   \n   \n  if category is not None and not isinstance(category,native_string_types):\n   if PY2 and isinstance(category,unicode):\n   \n    return self.get_record(scheme,category.encode(\"utf-8\"))\n   raise ExpectedTypeError(category,\"str or None\",\"category\")\n  if scheme is not None and not isinstance(scheme,native_string_types):\n   raise ExpectedTypeError(scheme,\"str or None\",\"scheme\")\n   \n   \n   \n  if not scheme:\n   default=self.default_scheme(category)\n   assert default\n   record=self._records[None ,category]=self.get_record(default,\n   category)\n   return record\n   \n   \n   \n  if category:\n   try :\n    cache=self._records\n    record=cache[scheme,category]=cache[scheme,None ]\n    return record\n   except KeyError:\n    pass\n    \n    \n  raise KeyError(\"crypt algorithm not found in policy: %r\"%(scheme,))\n  \n def _get_record_list(self,category=None ):\n  ''\n\n\n  \n  \n  \n  try :\n   return self._record_lists[category]\n  except KeyError:\n   pass\n   \n  value=self._record_lists[category]=[\n  self.get_record(scheme,category)\n  for scheme in self.schemes\n  ]\n  return value\n  \n def identify_record(self,hash,category,required=True ):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if not isinstance(hash,unicode_or_bytes_types):\n   raise ExpectedStringError(hash,\"hash\")\n   \n  for record in self._get_record_list(category):\n   if record.identify(hash):\n    return record\n  if not required:\n   return None\n  elif not self.schemes:\n   raise KeyError(\"no crypt algorithms supported\")\n  else :\n   raise exc.UnknownHashError(\"hash could not be identified\")\n   \n @memoized_property\n def disabled_record(self):\n  for record in self._get_record_list(None ):\n   if record.is_disabled:\n    return record\n  raise RuntimeError(\"no disabled hasher present \"\n  \"(perhaps add 'unix_disabled' to list of schemes?)\")\n  \n  \n  \n  \n def iter_config(self,resolve=False ):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  scheme_options=self._scheme_options\n  context_options=self._context_options\n  scheme_keys=sorted(scheme_options)\n  context_keys=sorted(context_options)\n  \n  \n  if 'schemes'in context_keys:\n   context_keys.remove(\"schemes\")\n  value=self.handlers if resolve else self.schemes\n  if value:\n   yield (None ,None ,\"schemes\"),list(value)\n   \n   \n  for cat in (None ,)+self.categories:\n  \n  \n   for key in context_keys:\n    try :\n     value=context_options[key][cat]\n    except KeyError:\n     pass\n    else :\n     if isinstance(value,list):\n      value=list(value)\n     yield (cat,None ,key),value\n     \n     \n   for scheme in scheme_keys:\n    try :\n     kwds=scheme_options[scheme][cat]\n    except KeyError:\n     pass\n    else :\n     for key in sorted(kwds):\n      yield (cat,scheme,key),kwds[key]\n      \n      \n      \n      \n      \n      \n      \n      \nclass CryptContext(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n _config=None\n \n \n _get_record=None\n _identify_record=None\n \n \n \n \n @classmethod\n def _norm_source(cls,source):\n  ''\n  if isinstance(source,dict):\n   return cls(**source)\n  elif isinstance(source,cls):\n   return source\n  else :\n   self=cls()\n   self.load(source)\n   return self\n   \n @classmethod\n def from_string(cls,source,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(source,unicode_or_bytes_types):\n   raise ExpectedTypeError(source,\"unicode or bytes\",\"source\")\n  self=cls(_autoload=False )\n  self.load(source,section=section,encoding=encoding)\n  return self\n  \n @classmethod\n def from_path(cls,path,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self=cls(_autoload=False )\n  self.load_path(path,section=section,encoding=encoding)\n  return self\n  \n def copy(self,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  other=CryptContext(_autoload=False )\n  other.load(self)\n  if kwds:\n   other.load(kwds,update=True )\n  return other\n  \n def using(self,**kwds):\n  ''\n\n  \n  return self.copy(**kwds)\n  \n def replace(self,**kwds):\n  ''\n  warn(\"CryptContext().replace() has been deprecated in Passlib 1.6, \"\n  \"and will be removed in Passlib 1.8, \"\n  \"it has been renamed to CryptContext().copy()\",\n  DeprecationWarning,stacklevel=2)\n  return self.copy(**kwds)\n  \n  \n  \n  \n def __init__(self,schemes=None ,\n \n policy=_UNSET,\n _autoload=True ,**kwds):\n \n \n \n  if schemes is not None :\n   kwds['schemes']=schemes\n  if policy is not _UNSET:\n   warn(\"The CryptContext ``policy`` keyword has been deprecated as of Passlib 1.6, \"\n   \"and will be removed in Passlib 1.8; please use \"\n   \"``CryptContext.from_string()` or \"\n   \"``CryptContext.from_path()`` instead.\",\n   DeprecationWarning)\n   if policy is None :\n    self.load(kwds)\n   elif isinstance(policy,CryptPolicy):\n    self.load(policy._context)\n    self.update(kwds)\n   else :\n    raise TypeError(\"policy must be a CryptPolicy instance\")\n  elif _autoload:\n   self.load(kwds)\n  else :\n   assert not kwds,\"_autoload=False and kwds are mutually exclusive\"\n   \n   \n   \n   \n   \n   \n   \n   \n def __repr__(self):\n  return \"<CryptContext at 0x%0x>\"%id(self)\n  \n  \n  \n  \n def _get_policy(self):\n \n \n \n \n \n \n \n \n \n \n  return CryptPolicy(_internal_context=self.copy(),_stub_policy=True )\n  \n def _set_policy(self,policy):\n  warn(\"The CryptPolicy class and the ``context.policy`` attribute have \"\n  \"been deprecated as of Passlib 1.6, and will be removed in \"\n  \"Passlib 1.8; please use the ``context.load()`` and \"\n  \"``context.update()`` methods instead.\",\n  DeprecationWarning,stacklevel=2)\n  if isinstance(policy,CryptPolicy):\n   self.load(policy._context)\n  else :\n   raise TypeError(\"expected CryptPolicy instance\")\n   \n policy=property(_get_policy,_set_policy,\n doc=\"[deprecated] returns CryptPolicy instance \"\n \"tied to this CryptContext\")\n \n \n \n \n @staticmethod\n def _parse_ini_stream(stream,section,filename):\n  ''\n  \n  \n  \n  p=SafeConfigParser()\n  if PY3:\n  \n   p.read_file(stream,filename)\n  else :\n   p.readfp(stream,filename)\n   \n   \n  return dict(p.items(section))\n  \n def load_path(self,path,update=False ,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n  \n  def helper(stream):\n   kwds=self._parse_ini_stream(stream,section,path)\n   return self.load(kwds,update=update)\n  if PY3:\n  \n   with open(path,\"rt\",encoding=encoding)as stream:\n    return helper(stream)\n  elif encoding in [\"utf-8\",\"ascii\"]:\n  \n   with open(path,\"rb\")as stream:\n    return helper(stream)\n  else :\n  \n   with open(path,\"rb\")as fh:\n    tmp=fh.read().decode(encoding).encode(\"utf-8\")\n    return helper(BytesIO(tmp))\n    \n def load(self,source,update=False ,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  parse_keys=True\n  if isinstance(source,unicode_or_bytes_types):\n   if PY3:\n    source=to_unicode(source,encoding,param=\"source\")\n   else :\n    source=to_bytes(source,\"utf-8\",source_encoding=encoding,\n    param=\"source\")\n   source=self._parse_ini_stream(NativeStringIO(source),section,\n   \"<string passed to CryptContext.load()>\")\n  elif isinstance(source,CryptContext):\n  \n   source=dict(source._config.iter_config(resolve=True ))\n   parse_keys=False\n  elif not hasattr(source,\"items\"):\n  \n   raise ExpectedTypeError(source,\"string or dict\",\"source\")\n   \n   \n   \n   \n   \n   \n   \n  if parse_keys:\n   parse=self._parse_config_key\n   source=dict((parse(key),value)\n   for key,value in iteritems(source))\n  if update and self._config is not None :\n  \n   if not source:\n    return\n    \n   tmp=source\n   source=dict(self._config.iter_config(resolve=True ))\n   source.update(tmp)\n   \n   \n   \n   \n  config=_CryptConfig(source)\n  self._config=config\n  self._reset_dummy_verify()\n  self._get_record=config.get_record\n  self._identify_record=config.identify_record\n  if config.context_kwds:\n  \n   self.__dict__.pop(\"_strip_unused_context_kwds\",None )\n  else :\n  \n   self._strip_unused_context_kwds=None\n   \n @staticmethod\n def _parse_config_key(ckey):\n  ''\n  \n  assert isinstance(ckey,native_string_types)\n  parts=ckey.replace(\".\",\"__\").split(\"__\")\n  count=len(parts)\n  if count ==1:\n   cat,scheme,key=None ,None ,parts[0]\n  elif count ==2:\n   cat=None\n   scheme,key=parts\n  elif count ==3:\n   cat,scheme,key=parts\n  else :\n   raise TypeError(\"keys must have less than 3 separators: %r\"%\n   (ckey,))\n   \n  if cat ==\"default\":\n   cat=None\n  elif not cat and cat is not None :\n   raise TypeError(\"empty category: %r\"%ckey)\n  if scheme ==\"context\":\n   scheme=None\n  elif not scheme and scheme is not None :\n   raise TypeError(\"empty scheme: %r\"%ckey)\n  if not key:\n   raise TypeError(\"empty option: %r\"%ckey)\n  return cat,scheme,key\n  \n def update(self,*args,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if args:\n   if len(args)>1:\n    raise TypeError(\"expected at most one positional argument\")\n   if kwds:\n    raise TypeError(\"positional arg and keywords mutually exclusive\")\n   self.load(args[0],update=True )\n  elif kwds:\n   self.load(kwds,update=True )\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def schemes(self,resolve=False ,category=None ,unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  schemes=self._config.schemes\n  if resolve:\n   return tuple(self.handler(scheme,category,unconfigured=unconfigured)\n   for scheme in schemes)\n  else :\n   return schemes\n   \n def default_scheme(self,category=None ,resolve=False ,unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  hasher=self.handler(None ,category,unconfigured=unconfigured)\n  return hasher if resolve else hasher.name\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def handler(self,scheme=None ,category=None ,unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   hasher=self._get_record(scheme,category)\n   if unconfigured:\n    return hasher._Context__orig_handler\n   else :\n    return hasher\n  except KeyError:\n   pass\n  if self._config.handlers:\n   raise KeyError(\"crypt algorithm not found in this \"\n   \"CryptContext instance: %r\"%(scheme,))\n  else :\n   raise KeyError(\"no crypt algorithms loaded in this \"\n   \"CryptContext instance\")\n   \n def _get_unregistered_handlers(self):\n  ''\n  return tuple(handler for handler in self._config.handlers\n  if not _is_handler_registered(handler))\n  \n @property\n def context_kwds(self):\n  ''\n\n\n\n\n  \n  return self._config.context_kwds\n  \n  \n  \n  \n @staticmethod\n def _render_config_key(key):\n  ''\n  cat,scheme,option=key\n  if cat:\n   return \"%s__%s__%s\"%(cat,scheme or \"context\",option)\n  elif scheme:\n   return \"%s__%s\"%(scheme,option)\n  else :\n   return option\n   \n @staticmethod\n def _render_ini_value(key,value):\n  ''\n  \n  \n  if isinstance(value,(list,tuple)):\n   value=\", \".join(value)\n   \n   \n  elif isinstance(value,num_types):\n   if isinstance(value,float)and key[2]==\"vary_rounds\":\n    value=(\"%.2f\"%value).rstrip(\"0\")if value else \"0\"\n   else :\n    value=str(value)\n    \n  assert isinstance(value,native_string_types),\\\n  \"expected string for key: %r %r\"%(key,value)\n  \n  \n  return value.replace(\"%\",\"%%\")\n  \n def to_dict(self,resolve=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  render_key=self._render_config_key\n  return dict((render_key(key),value)\n  for key,value in self._config.iter_config(resolve))\n  \n def _write_to_parser(self,parser,section):\n  ''\n  render_key=self._render_config_key\n  render_value=self._render_ini_value\n  parser.add_section(section)\n  for k,v in self._config.iter_config():\n   v=render_value(k,v)\n   k=render_key(k)\n   parser.set(section,k,v)\n   \n def to_string(self,section=\"passlib\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  parser=SafeConfigParser()\n  self._write_to_parser(parser,section)\n  buf=NativeStringIO()\n  parser.write(buf)\n  unregistered=self._get_unregistered_handlers()\n  if unregistered:\n   buf.write((\n   \"# NOTE: the %s handler(s) are not registered with Passlib,\\n\"\n   \"# this string may not correctly reproduce the current configuration.\\n\\n\"\n   )%\", \".join(repr(handler.name)for handler in unregistered))\n  out=buf.getvalue()\n  if not PY3:\n   out=out.decode(\"utf-8\")\n  return out\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n mvt_estimate_max_samples=20\n mvt_estimate_min_samples=10\n mvt_estimate_max_time=2\n mvt_estimate_resolution=0.01\n harden_verify=None\n min_verify_time=0\n \n def reset_min_verify_time(self):\n  self._reset_dummy_verify()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _get_or_identify_record(self,hash,scheme=None ,category=None ):\n  ''\n  if scheme:\n   if not isinstance(hash,unicode_or_bytes_types):\n    raise ExpectedStringError(hash,\"hash\")\n   return self._get_record(scheme,category)\n  else :\n  \n   return self._identify_record(hash,category)\n   \n def _strip_unused_context_kwds(self,kwds,record):\n  ''\n\n\n\n\n\n\n\n  \n  if not kwds:\n   return\n  unused_kwds=self._config.context_kwds.difference(record.context_kwds)\n  for key in unused_kwds:\n   kwds.pop(key,None )\n   \n def needs_update(self,hash,scheme=None ,category=None ,secret=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if scheme is not None :\n  \n  \n  \n   warn(\"CryptContext.needs_update(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  record=self._get_or_identify_record(hash,scheme,category)\n  return record.deprecated or record.needs_update(hash,secret=secret)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"2.0\",replacement=\"CryptContext.needs_update()\")\n def hash_needs_update(self,hash,scheme=None ,category=None ):\n  ''\n\n\n\n\n\n  \n  return self.needs_update(hash,scheme,category)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genconfig(self,scheme=None ,category=None ,**settings):\n  ''\n\n\n\n\n\n  \n  record=self._get_record(scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(settings,record)\n  return record.genconfig(**settings)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genhash(self,secret,config,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n  \n  record=self._get_or_identify_record(config,scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(kwds,record)\n  return record.genhash(secret,config,**kwds)\n  \n def identify(self,hash,category=None ,resolve=False ,required=False ,\n unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  record=self._identify_record(hash,category,required)\n  if record is None :\n   return None\n  elif resolve:\n   if unconfigured:\n    return record._Context__orig_handler\n   else :\n    return record\n  else :\n   return record.name\n   \n def hash(self,secret,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if scheme is not None :\n  \n  \n  \n   warn(\"CryptContext.hash(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  record=self._get_record(scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(kwds,record)\n  return record.hash(secret,**kwds)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\",replacement=\"CryptContext.hash()\")\n def encrypt(self,*args,**kwds):\n  ''\n\n\n\n\n\n\n  \n  return self.hash(*args,**kwds)\n  \n def verify(self,secret,hash,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  if scheme is not None :\n  \n  \n  \n   warn(\"CryptContext.verify(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  if hash is None :\n  \n  \n   self.dummy_verify()\n   return False\n  record=self._get_or_identify_record(hash,scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(kwds,record)\n  return record.verify(secret,hash,**kwds)\n  \n def verify_and_update(self,secret,hash,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if scheme is not None :\n   warn(\"CryptContext.verify(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  if hash is None :\n  \n  \n   self.dummy_verify()\n   return False ,None\n  record=self._get_or_identify_record(hash,scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused and kwds:\n   clean_kwds=kwds.copy()\n   strip_unused(clean_kwds,record)\n  else :\n   clean_kwds=kwds\n   \n   \n   \n   \n  if not record.verify(secret,hash,**clean_kwds):\n   return False ,None\n  elif record.deprecated or record.needs_update(hash,secret=secret):\n  \n   return True ,self.hash(secret,category=category,**kwds)\n  else :\n   return True ,None\n   \n   \n   \n   \n   \n   \n _dummy_secret=\"too many secrets\"\n \n @memoized_property\n def _dummy_hash(self):\n  ''\n\n  \n  return self.hash(self._dummy_secret)\n  \n def _reset_dummy_verify(self):\n  ''\n\n  \n  type(self)._dummy_hash.clear_cache(self)\n  \n def dummy_verify(self,elapsed=0):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.verify(self._dummy_secret,self._dummy_hash)\n  return False\n  \n  \n  \n  \n  \n def is_enabled(self,hash):\n  ''\n\n\n\n\n\n\n\n  \n  return not self._identify_record(hash,None ).is_disabled\n  \n def disable(self,hash=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  record=self._config.disabled_record\n  assert record.is_disabled\n  return record.disable(hash)\n  \n def enable(self,hash):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  record=self._identify_record(hash,None )\n  if record.is_disabled:\n  \n   return record.enable(hash)\n  else :\n  \n   return hash\n   \n   \n   \n   \n   \nclass LazyCryptContext(CryptContext):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n _lazy_kwds=None\n \n \n \n \n \n \n \n def __init__(self,schemes=None ,**kwds):\n  if schemes is not None :\n   kwds['schemes']=schemes\n  self._lazy_kwds=kwds\n  \n def _lazy_init(self):\n  kwds=self._lazy_kwds\n  if 'create_policy'in kwds:\n   warn(\"The CryptPolicy class, and LazyCryptContext's \"\n   \"``create_policy`` keyword have been deprecated as of \"\n   \"Passlib 1.6, and will be removed in Passlib 1.8; \"\n   \"please use the ``onload`` keyword instead.\",\n   DeprecationWarning)\n   create_policy=kwds.pop(\"create_policy\")\n   result=create_policy(**kwds)\n   policy=CryptPolicy.from_source(result,_warn=False )\n   kwds=policy._context.to_dict()\n  elif 'onload'in kwds:\n   onload=kwds.pop(\"onload\")\n   kwds=onload(**kwds)\n  del self._lazy_kwds\n  super(LazyCryptContext,self).__init__(**kwds)\n  self.__class__=CryptContext\n  \n def __getattribute__(self,attr):\n  if (not attr.startswith(\"_\")or attr.startswith(\"__\"))and\\\n  self._lazy_kwds is not None :\n   self._lazy_init()\n  return object.__getattribute__(self,attr)\n  \n  \n  \n  \n", ["__future__", "logging", "passlib", "passlib.exc", "passlib.registry", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "re", "threading", "time", "warnings"]], "passlib.exc": [".py", "''\n\n\n\nclass UnknownBackendError(ValueError):\n ''\n\n\n\n\n \n def __init__(self,hasher,backend):\n  self.hasher=hasher\n  self.backend=backend\n  message=\"%s: unknown backend: %r\"%(hasher.name,backend)\n  ValueError.__init__(self,message)\n  \n  \n  \n  \n  \nclass MissingBackendError(RuntimeError):\n ''\n\n\n\n\n\n\n\n\n \n \n \nclass InternalBackendError(RuntimeError):\n ''\n\n\n\n\n \n \n \nclass PasswordValueError(ValueError):\n ''\n\n\n\n\n\n\n\n\n \n pass\n \n \nclass PasswordSizeError(PasswordValueError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n max_size=None\n \n def __init__(self,max_size,msg=None ):\n  self.max_size=max_size\n  if msg is None :\n   msg=\"password exceeds maximum allowed size\"\n  PasswordValueError.__init__(self,msg)\n  \n  \n  \n  \nclass PasswordTruncateError(PasswordSizeError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,cls,msg=None ):\n  if msg is None :\n   msg=(\"Password too long (%s truncates to %d characters)\"%\n   (cls.name,cls.truncate_size))\n  PasswordSizeError.__init__(self,cls.truncate_size,msg)\n  \n  \nclass PasslibSecurityError(RuntimeError):\n ''\n\n\n\n\n \n \n \nclass TokenError(ValueError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n _default_message='Token not acceptable'\n \n def __init__(self,msg=None ,*args,**kwds):\n  if msg is None :\n   msg=self._default_message\n  ValueError.__init__(self,msg,*args,**kwds)\n  \n  \nclass MalformedTokenError(TokenError):\n ''\n\n\n \n _default_message=\"Unrecognized token\"\n \n \nclass InvalidTokenError(TokenError):\n ''\n\n\n \n _default_message=\"Token did not match\"\n \n \nclass UsedTokenError(TokenError):\n ''\n\n\n\n\n\n\n \n _default_message=\"Token has already been used, please wait for another.\"\n \n \n \n expire_time=None\n \n def __init__(self,*args,**kwds):\n  self.expire_time=kwds.pop(\"expire_time\",None )\n  TokenError.__init__(self,*args,**kwds)\n  \n  \nclass UnknownHashError(ValueError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,message=None ,value=None ):\n  self.value=value\n  if message is None :\n   message=\"unknown hash algorithm: %r\"%value\n  self.message=message\n  ValueError.__init__(self,message,value)\n  \n def __str__(self):\n  return self.message\n  \n  \n  \n  \n  \nclass PasslibWarning(UserWarning):\n ''\n\n\n\n \n \n \n \nclass PasslibConfigWarning(PasslibWarning):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \nclass PasslibHashWarning(PasslibWarning):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \nclass PasslibRuntimeWarning(PasslibWarning):\n ''\n\n\n\n\n\n\n \n \nclass PasslibSecurityWarning(PasslibWarning):\n ''\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \ndef _get_name(handler):\n return handler.name if handler else \"<unnamed>\"\n \n \n \n \ndef type_name(value):\n ''\n cls=value.__class__\n if cls.__module__ and cls.__module__ not in [\"__builtin__\",\"builtins\"]:\n  return \"%s.%s\"%(cls.__module__,cls.__name__)\n elif value is None :\n  return 'None'\n else :\n  return cls.__name__\n  \ndef ExpectedTypeError(value,expected,param):\n ''\n \n name=type_name(value)\n return TypeError(\"%s must be %s, not %s\"%(param,expected,name))\n \ndef ExpectedStringError(value,param):\n ''\n return ExpectedTypeError(value,\"unicode or bytes\",param)\n \n \n \n \ndef MissingDigestError(handler=None ):\n ''\n name=_get_name(handler)\n return ValueError(\"expected %s hash, got %s config string instead\"%\n (name,name))\n \ndef NullPasswordError(handler=None ):\n ''\n name=_get_name(handler)\n return PasswordValueError(\"%s does not allow NULL bytes in password\"%name)\n \n \n \n \ndef InvalidHashError(handler=None ):\n ''\n return ValueError(\"not a valid %s hash\"%_get_name(handler))\n \ndef MalformedHashError(handler=None ,reason=None ):\n ''\n text=\"malformed %s hash\"%_get_name(handler)\n if reason:\n  text=\"%s (%s)\"%(text,reason)\n return ValueError(text)\n \ndef ZeroPaddedRoundsError(handler=None ):\n ''\n return MalformedHashError(handler,\"zero-padded rounds\")\n \n \n \n \ndef ChecksumSizeError(handler,raw=False ):\n ''\n \n \n checksum_size=handler.checksum_size\n unit=\"bytes\"if raw else \"chars\"\n reason=\"checksum must be exactly %d %s\"%(checksum_size,unit)\n return MalformedHashError(handler,reason)\n \n \n \n \n \n \nENABLE_DEBUG_ONLY_REPR=False\n\n\ndef debug_only_repr(value,param=\"hash\"):\n ''\n\n\n\n\n\n\n\n\n \n if ENABLE_DEBUG_ONLY_REPR or value is None or isinstance(value,bool):\n  return repr(value)\n return \"<%s %s value omitted>\"%(param,type(value))\n \n \ndef CryptBackendError(handler,config,hash,\nsource=\"crypt.crypt()\"):\n ''\n\n\n \n name=_get_name(handler)\n msg=\"%s returned invalid %s hash: config=%s hash=%s\"%\\\n (source,name,debug_only_repr(config),debug_only_repr(hash))\n raise InternalBackendError(msg)\n \n \n \n \n", []], "passlib.crypto.digest": [".py", "''\n\n\n\n\n\n\nfrom __future__ import division\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\ntry :\n\n from hashlib import pbkdf2_hmac as _stdlib_pbkdf2_hmac\n if _stdlib_pbkdf2_hmac.__module__ ==\"hashlib\":\n \n \n  log.debug(\"ignoring pure-python hashlib.pbkdf2_hmac()\")\n  _stdlib_pbkdf2_hmac=None\nexcept ImportError:\n _stdlib_pbkdf2_hmac=None\nimport re\nimport os\nfrom struct import Struct\nfrom warnings import warn\n\ntry :\n\n from fastpbkdf2 import pbkdf2_hmac as _fast_pbkdf2_hmac\nexcept ImportError:\n _fast_pbkdf2_hmac=None\n \nfrom passlib import exc\nfrom passlib.utils import join_bytes,to_native_str,join_byte_values,to_bytes,\\\nSequenceMixin,as_bool\nfrom passlib.utils.compat import irange,int_types,unicode_or_bytes_types,PY3,error_from\nfrom passlib.utils.decor import memoized_property\n\n__all__=[\n\n\"lookup_hash\",\n\"HashInfo\",\n\"norm_hash_name\",\n\n\n\"compile_hmac\",\n\n\n\"pbkdf1\",\n\"pbkdf2_hmac\",\n]\n\n\n\n\n\n\nMAX_UINT32=(1 <<32)-1\n\n\nMAX_UINT64=(1 <<64)-1\n\n\n\n\n\n\n_known_hash_names=[\n\n\n\n\n\n\n(\"md2\",\"md2\"),\n(\"md5\",\"md5\"),\n(\"sha1\",\"sha-1\"),\n(\"sha224\",\"sha-224\",\"sha2-224\"),\n(\"sha256\",\"sha-256\",\"sha2-256\"),\n(\"sha384\",\"sha-384\",\"sha2-384\"),\n(\"sha512\",\"sha-512\",\"sha2-512\"),\n\n\n\n\n\n\n\n\n(\"blake2b\",\"blake-2b\"),\n(\"blake2s\",\"blake-2s\"),\n(\"md4\",\"md4\"),\n\n\n\n(\"ripemd160\",\"ripemd-160\",\"ripemd\"),\n]\n\n\n\n\n_fallback_info={\n\n'blake2b':(64,128),\n'blake2s':(32,64),\n'md4':(16,64),\n'md5':(16,64),\n'sha1':(20,64),\n'sha224':(28,64),\n'sha256':(32,64),\n'sha384':(48,128),\n'sha3_224':(28,144),\n'sha3_256':(32,136),\n'sha3_384':(48,104),\n'sha3_512':(64,72),\n'sha512':(64,128),\n'shake128':(16,168),\n'shake256':(32,136),\n}\n\n\ndef _gen_fallback_info():\n ''\n\n\n\n \n out={}\n for alg in sorted(hashlib.algorithms_available |set([\"md4\"])):\n  info=lookup_hash(alg)\n  out[info.name]=(info.digest_size,info.block_size)\n return out\n \n \n \n_hash_info_cache={}\n\ndef _get_hash_aliases(name):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n orig=name\n if not isinstance(name,str):\n  name=to_native_str(name,'utf-8','hash name')\n name=re.sub(\"[_ /]\",\"-\",name.strip().lower())\n if name.startswith(\"scram-\"):\n  name=name[6:]\n  if name.endswith(\"-plus\"):\n   name=name[:-5]\n   \n   \n def check_table(name):\n  for row in _known_hash_names:\n   if name in row:\n    return row\n result=check_table(name)\n if result:\n  return result\n  \n  \n m=re.match(r\"(?i)^(?P<name>[a-z]+)-?(?P<rev>\\d)?-?(?P<size>\\d{3,4})?$\",name)\n if m:\n \n \n  iana_name,rev,size=m.group(\"name\",\"rev\",\"size\")\n  if rev:\n   iana_name +=rev\n  hashlib_name=iana_name\n  if size:\n   iana_name +=\"-\"+size\n   if rev:\n    hashlib_name +=\"_\"\n   hashlib_name +=size\n  result=check_table(iana_name)\n  if result:\n   return result\n   \n   \n  log.info(\"normalizing unrecognized hash name %r => %r / %r\",\n  orig,hashlib_name,iana_name)\n  \n else :\n \n  iana_name=name\n  hashlib_name=name.replace(\"-\",\"_\")\n  log.warning(\"normalizing unrecognized hash name and format %r => %r / %r\",\n  orig,hashlib_name,iana_name)\n  \n return hashlib_name,iana_name\n \n \ndef _get_hash_const(name):\n ''\n\n\n\n\n\n\n\n\n\n \n \n if not name.startswith(\"_\")and name not in (\"new\",\"algorithms\"):\n  try :\n   return getattr(hashlib,name)\n  except AttributeError:\n   pass\n   \n   \n new_ssl_hash=hashlib.new\n try :\n \n  new_ssl_hash(name,b\"\")\n except ValueError:\n  pass\n else :\n \n \n  def const(msg=b\"\"):\n   return new_ssl_hash(name,msg)\n  const.__name__=name\n  const.__module__=\"hashlib\"\n  const.__doc__=(\"wrapper for hashlib.new(%r),\\n\"\n  \"generated by passlib.crypto.digest.lookup_hash()\")%name\n  return const\n  \n  \n if name ==\"md4\":\n  from passlib.crypto._md4 import md4\n  return md4\n  \n  \n  \n  \n return None\n \n \ndef lookup_hash(digest,\nreturn_unknown=False ,required=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n cache=_hash_info_cache\n try :\n  return cache[digest]\n except (KeyError,TypeError):\n \n  pass\n  \n  \n if return_unknown:\n  required=False\n  \n  \n cache_by_name=True\n if isinstance(digest,unicode_or_bytes_types):\n \n  name_list=_get_hash_aliases(digest)\n  name=name_list[0]\n  assert name\n  \n  \n  \n  if name !=digest:\n   info=lookup_hash(name,required=required)\n   cache[digest]=info\n   return info\n   \n   \n   \n  const=_get_hash_const(name)\n  \n  \n  \n  if const and mock_fips_mode and name not in _fips_algorithms:\n   def const(source=b\"\"):\n    raise ValueError(\"%r disabled for fips by passlib set_mock_fips_mode()\"%name)\n    \n elif isinstance(digest,HashInfo):\n \n  return digest\n  \n elif callable(digest):\n \n \n  const=digest\n  name_list=_get_hash_aliases(const().name)\n  name=name_list[0]\n  other_const=_get_hash_const(name)\n  if other_const is None :\n  \n  \n   pass\n   \n  elif other_const is const:\n  \n  \n   pass\n   \n  else :\n  \n  \n  \n   cache_by_name=False\n   \n else :\n  raise exc.ExpectedTypeError(digest,\"digest name or constructor\",\"digest\")\n  \n  \n info=HashInfo(const=const,names=name_list,required=required)\n \n \n if const is not None :\n  cache[const]=info\n if cache_by_name:\n  for name in name_list:\n   if name:\n    assert cache.get(name)in [None ,info],\"%r already in cache\"%name\n    cache[name]=info\n return info\n \n \nlookup_hash.clear_cache=_hash_info_cache.clear\n\n\ndef norm_hash_name(name,format=\"hashlib\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n info=lookup_hash(name,required=False )\n if info.unknown:\n  warn(\"norm_hash_name(): \"+info.error_text,exc.PasslibRuntimeWarning)\n if format ==\"hashlib\":\n  return info.name\n elif format ==\"iana\":\n  return info.iana_name\n else :\n  raise ValueError(\"unknown format: %r\"%(format,))\n  \n  \nclass HashInfo(SequenceMixin):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=None\n \n \n iana_name=None\n \n \n aliases=()\n \n \n const=None\n \n \n digest_size=None\n \n \n block_size=None\n \n \n \n error_text=None\n \n \n \n unknown=False\n \n \n \n \n \n def __init__(self,\n const,names,required=True ):\n  ''\n\n\n\n\n\n\n  \n  \n  name=self.name=names[0]\n  self.iana_name=names[1]\n  self.aliases=names[2:]\n  \n  def use_stub_const(msg):\n   ''\n\n   \n   def const(source=b\"\"):\n    raise exc.UnknownHashError(msg,name)\n   if required:\n   \n   \n    const()\n    assert \"shouldn't get here\"\n   self.error_text=msg\n   self.const=const\n   try :\n    self.digest_size,self.block_size=_fallback_info[name]\n   except KeyError:\n    pass\n    \n    \n  if const is None :\n   if names in _known_hash_names:\n    msg=\"unsupported hash: %r\"%name\n   else :\n    msg=\"unknown hash: %r\"%name\n    self.unknown=True\n   use_stub_const(msg)\n   \n   return\n   \n   \n  try :\n   hash=const()\n  except ValueError as err:\n  \n  \n  \n  \n   if \"disabled for fips\"in str(err).lower():\n    msg=\"%r hash disabled for fips\"%name\n   else :\n    msg=\"internal error in %r constructor\\n(%s: %s)\"%(name,type(err).__name__,err)\n   use_stub_const(msg)\n   return\n   \n   \n  self.const=const\n  self.digest_size=hash.digest_size\n  self.block_size=hash.block_size\n  \n  \n  if len(hash.digest())!=hash.digest_size:\n   raise RuntimeError(\"%r constructor failed sanity check\"%self.name)\n   \n   \n  if hash.name !=self.name:\n   warn(\"inconsistent digest name: %r resolved to %r, which reports name as %r\"%\n   (self.name,const,hash.name),exc.PasslibRuntimeWarning)\n   \n   \n   \n   \n def __repr__(self):\n  return \"<lookup_hash(%r): digest_size=%r block_size=%r)\"%\\\n  (self.name,self.digest_size,self.block_size)\n  \n def _as_tuple(self):\n  return self.const,self.digest_size,self.block_size\n  \n @memoized_property\n def supported(self):\n  ''\n\n\n  \n  return self.error_text is None\n  \n @memoized_property\n def supported_by_fastpbkdf2(self):\n  ''\n  if not _fast_pbkdf2_hmac:\n   return None\n  try :\n   _fast_pbkdf2_hmac(self.name,b\"p\",b\"s\",1)\n   return True\n  except ValueError:\n  \n   return False\n   \n @memoized_property\n def supported_by_hashlib_pbkdf2(self):\n  ''\n  if not _stdlib_pbkdf2_hmac:\n   return None\n  try :\n   _stdlib_pbkdf2_hmac(self.name,b\"p\",b\"s\",1)\n   return True\n  except ValueError:\n  \n   return False\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nmock_fips_mode=False\n\n\n\n\n_fips_algorithms=set([\n\n'sha1',\n'sha224',\n'sha256',\n'sha384',\n'sha512',\n\n\n\n\n'sha3_224',\n'sha3_256',\n'sha3_384',\n'sha3_512',\n'shake_128',\n'shake_256',\n])\n\n\ndef _set_mock_fips_mode(enable=True ):\n ''\n\n \n global mock_fips_mode\n mock_fips_mode=enable\n lookup_hash.clear_cache()\n \n \n \nif as_bool(os.environ.get(\"PASSLIB_MOCK_FIPS_MODE\")):\n _set_mock_fips_mode()\n \n \n \n \n \n \n_TRANS_5C=join_byte_values((x ^0x5C)for x in irange(256))\n_TRANS_36=join_byte_values((x ^0x36)for x in irange(256))\n\ndef compile_hmac(digest,key,multipart=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n digest_info=lookup_hash(digest)\n const,digest_size,block_size=digest_info\n assert block_size >=16,\"block size too small\"\n \n \n if not isinstance(key,bytes):\n  key=to_bytes(key,param=\"key\")\n klen=len(key)\n if klen >block_size:\n  key=const(key).digest()\n  klen=digest_size\n if klen <block_size:\n  key +=b'\\x00'*(block_size -klen)\n  \n  \n _inner_copy=const(key.translate(_TRANS_36)).copy\n _outer_copy=const(key.translate(_TRANS_5C)).copy\n \n if multipart:\n \n \n \n  def hmac():\n   ''\n   inner=_inner_copy()\n   def finalize():\n    outer=_outer_copy()\n    outer.update(inner.digest())\n    return outer.digest()\n   return inner.update,finalize\n else :\n \n \n  def hmac(msg):\n   ''\n   inner=_inner_copy()\n   inner.update(msg)\n   outer=_outer_copy()\n   outer.update(inner.digest())\n   return outer.digest()\n   \n   \n hmac.digest_info=digest_info\n return hmac\n \n \n \n \ndef pbkdf1(digest,secret,salt,rounds,keylen=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n const,digest_size,block_size=lookup_hash(digest)\n \n \n secret=to_bytes(secret,param=\"secret\")\n salt=to_bytes(salt,param=\"salt\")\n \n \n if not isinstance(rounds,int_types):\n  raise exc.ExpectedTypeError(rounds,\"int\",\"rounds\")\n if rounds <1:\n  raise ValueError(\"rounds must be at least 1\")\n  \n  \n if keylen is None :\n  keylen=digest_size\n elif not isinstance(keylen,int_types):\n  raise exc.ExpectedTypeError(keylen,\"int or None\",\"keylen\")\n elif keylen <0:\n  raise ValueError(\"keylen must be at least 0\")\n elif keylen >digest_size:\n  raise ValueError(\"keylength too large for digest: %r > %r\"%\n  (keylen,digest_size))\n  \n  \n block=secret+salt\n for _ in irange(rounds):\n  block=const(block).digest()\n return block[:keylen]\n \n \n \n \n \n_pack_uint32=Struct(\">L\").pack\n\ndef pbkdf2_hmac(digest,secret,salt,rounds,keylen=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n secret=to_bytes(secret,param=\"secret\")\n salt=to_bytes(salt,param=\"salt\")\n \n \n digest_info=lookup_hash(digest)\n digest_size=digest_info.digest_size\n \n \n if not isinstance(rounds,int_types):\n  raise exc.ExpectedTypeError(rounds,\"int\",\"rounds\")\n if rounds <1:\n  raise ValueError(\"rounds must be at least 1\")\n  \n  \n if keylen is None :\n  keylen=digest_size\n elif not isinstance(keylen,int_types):\n  raise exc.ExpectedTypeError(keylen,\"int or None\",\"keylen\")\n elif keylen <1:\n \n  raise ValueError(\"keylen must be at least 1\")\n  \n  \n  \n  \n  \n  \n  \n block_count=(keylen+digest_size -1)//digest_size\n if block_count >MAX_UINT32:\n  raise OverflowError(\"keylen too long for digest\")\n  \n  \n  \n  \n  \n  \n  \n if digest_info.supported_by_fastpbkdf2:\n  return _fast_pbkdf2_hmac(digest_info.name,secret,salt,rounds,keylen)\n  \n  \n  \n  \n if digest_info.supported_by_hashlib_pbkdf2:\n  return _stdlib_pbkdf2_hmac(digest_info.name,secret,salt,rounds,keylen)\n  \n  \n  \n  \n  \n  \n keyed_hmac=compile_hmac(digest,secret)\n \n \n calc_block=_get_pbkdf2_looper(digest_size)\n \n \n return join_bytes(\n calc_block(keyed_hmac,keyed_hmac(salt+_pack_uint32(i)),rounds)\n for i in irange(1,block_count+1)\n )[:keylen]\n \n \n \n \n \n \n_force_backend=os.environ.get(\"PASSLIB_PBKDF2_BACKEND\")or \"any\"\n\nif PY3 and _force_backend in [\"any\",\"from-bytes\"]:\n from functools import partial\n \n def _get_pbkdf2_looper(digest_size):\n  return partial(_pbkdf2_looper,digest_size)\n  \n def _pbkdf2_looper(digest_size,keyed_hmac,digest,rounds):\n  ''\n\n\n  \n  from_bytes=int.from_bytes\n  BIG=\"big\"\n  accum=from_bytes(digest,BIG)\n  for _ in irange(rounds -1):\n   digest=keyed_hmac(digest)\n   accum ^=from_bytes(digest,BIG)\n  return accum.to_bytes(digest_size,BIG)\n  \n _builtin_backend=\"from-bytes\"\n \nelif _force_backend in [\"any\",\"unpack\",\"from-bytes\"]:\n from struct import Struct\n from passlib.utils import sys_bits\n \n _have_64_bit=(sys_bits >=64)\n \n \n _looper_cache={}\n \n def _get_pbkdf2_looper(digest_size):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  try :\n   return _looper_cache[digest_size]\n  except KeyError:\n   pass\n   \n   \n   \n   \n  if _have_64_bit and not digest_size&0x7:\n  \n   count=(digest_size >>3)\n   fmt=\"=%dQ\"%count\n  elif not digest_size&0x3:\n   if _have_64_bit:\n   \n    count=(digest_size >>3)\n    fmt=\"=%dQI\"%count\n    count +=1\n   else :\n   \n    count=(digest_size >>2)\n    fmt=\"=%dI\"%count\n  else :\n  \n  \n   raise NotImplementedError(\"unsupported digest size: %d\"%digest_size)\n  struct=Struct(fmt)\n  \n  \n  \n  \n  tdict=dict(\n  digest_size=digest_size,\n  accum_vars=\", \".join(\"acc_%d\"%i for i in irange(count)),\n  digest_vars=\", \".join(\"dig_%d\"%i for i in irange(count)),\n  )\n  \n  \n  source=(\n  \"def helper(keyed_hmac, digest, rounds):\\n\"\n  \"    '''pbkdf2 loop helper for digest_size={digest_size}'''\\n\"\n  \"    unpack_digest = struct.unpack\\n\"\n  \"    {accum_vars} = unpack_digest(digest)\\n\"\n  \"    for _ in irange(1, rounds):\\n\"\n  \"        digest = keyed_hmac(digest)\\n\"\n  \"        {digest_vars} = unpack_digest(digest)\\n\"\n  ).format(**tdict)\n  \n  \n  for i in irange(count):\n   source +=\"        acc_%d ^= dig_%d\\n\"%(i,i)\n   \n   \n  source +=\"    return struct.pack({accum_vars})\\n\".format(**tdict)\n  \n  \n  \n  \n  code=compile(source,\"<generated by passlib.crypto.digest._get_pbkdf2_looper()>\",\"exec\")\n  gdict=dict(irange=irange,struct=struct)\n  ldict=dict()\n  eval(code,gdict,ldict)\n  helper=ldict['helper']\n  if __debug__:\n   helper.__source__=source\n   \n   \n   \n   \n  _looper_cache[digest_size]=helper\n  return helper\n  \n _builtin_backend=\"unpack\"\n \nelse :\n assert _force_backend in [\"any\",\"hexlify\"]\n \n \n \n \n from binascii import hexlify as _hexlify\n from passlib.utils import int_to_bytes\n \n def _get_pbkdf2_looper(digest_size):\n  return _pbkdf2_looper\n  \n def _pbkdf2_looper(keyed_hmac,digest,rounds):\n  hexlify=_hexlify\n  accum=int(hexlify(digest),16)\n  for _ in irange(rounds -1):\n   digest=keyed_hmac(digest)\n   accum ^=int(hexlify(digest),16)\n  return int_to_bytes(accum,len(digest))\n  \n _builtin_backend=\"hexlify\"\n \n \nif _force_backend ==_builtin_backend:\n _fast_pbkdf2_hmac=_stdlib_pbkdf2_hmac=None\n \n \nPBKDF2_BACKENDS=[b for b in [\n\"fastpbkdf2\"if _fast_pbkdf2_hmac else None ,\n\"hashlib-ssl\"if _stdlib_pbkdf2_hmac else None ,\n\"builtin-\"+_builtin_backend\n]if b]\n\n\nif \"fastpbkdf2\"in PBKDF2_BACKENDS:\n PBKDF2_SPEED_FACTOR=3\nelif \"hashlib-ssl\"in PBKDF2_BACKENDS:\n PBKDF2_SPEED_FACTOR=1.4\nelse :\n\n PBKDF2_SPEED_FACTOR=1\n \n \n \n \n", ["__future__", "binascii", "fastpbkdf2", "functools", "hashlib", "logging", "os", "passlib", "passlib.crypto._md4", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "re", "struct", "warnings"]], "passlib.crypto._md4": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom binascii import hexlify\nimport struct\n\nfrom passlib.utils.compat import bascii_to_str,irange,PY3\n\n__all__=[\"md4\"]\n\n\n\n\ndef F(x,y,z):\n return (x&y)|((~x)&z)\n \ndef G(x,y,z):\n return (x&y)|(x&z)|(y&z)\n \n \n \n \nMASK_32=2 **32 -1\n\n\n\n\nclass md4(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"md4\"\n digest_size=digestsize=16\n block_size=64\n \n _count=0\n _state=None\n _buf=None\n \n def __init__(self,content=None ):\n  self._count=0\n  self._state=[0x67452301,0xefcdab89,0x98badcfe,0x10325476]\n  self._buf=b''\n  if content:\n   self.update(content)\n   \n   \n _round1=[\n [0,1,2,3,0,3],\n [3,0,1,2,1,7],\n [2,3,0,1,2,11],\n [1,2,3,0,3,19],\n \n [0,1,2,3,4,3],\n [3,0,1,2,5,7],\n [2,3,0,1,6,11],\n [1,2,3,0,7,19],\n \n [0,1,2,3,8,3],\n [3,0,1,2,9,7],\n [2,3,0,1,10,11],\n [1,2,3,0,11,19],\n \n [0,1,2,3,12,3],\n [3,0,1,2,13,7],\n [2,3,0,1,14,11],\n [1,2,3,0,15,19],\n ]\n \n \n _round2=[\n [0,1,2,3,0,3],\n [3,0,1,2,4,5],\n [2,3,0,1,8,9],\n [1,2,3,0,12,13],\n \n [0,1,2,3,1,3],\n [3,0,1,2,5,5],\n [2,3,0,1,9,9],\n [1,2,3,0,13,13],\n \n [0,1,2,3,2,3],\n [3,0,1,2,6,5],\n [2,3,0,1,10,9],\n [1,2,3,0,14,13],\n \n [0,1,2,3,3,3],\n [3,0,1,2,7,5],\n [2,3,0,1,11,9],\n [1,2,3,0,15,13],\n ]\n \n \n _round3=[\n [0,1,2,3,0,3],\n [3,0,1,2,8,9],\n [2,3,0,1,4,11],\n [1,2,3,0,12,15],\n \n [0,1,2,3,2,3],\n [3,0,1,2,10,9],\n [2,3,0,1,6,11],\n [1,2,3,0,14,15],\n \n [0,1,2,3,1,3],\n [3,0,1,2,9,9],\n [2,3,0,1,5,11],\n [1,2,3,0,13,15],\n \n [0,1,2,3,3,3],\n [3,0,1,2,11,9],\n [2,3,0,1,7,11],\n [1,2,3,0,15,15],\n ]\n \n def _process(self,block):\n  ''\n  \n  X=struct.unpack(\"<16I\",block)\n  \n  \n  orig=self._state\n  state=list(orig)\n  \n  \n  for a,b,c,d,k,s in self._round1:\n   t=(state[a]+F(state[b],state[c],state[d])+X[k])&MASK_32\n   state[a]=((t <<s)&MASK_32)+(t >>(32 -s))\n   \n   \n  for a,b,c,d,k,s in self._round2:\n   t=(state[a]+G(state[b],state[c],state[d])+X[k]+0x5a827999)&MASK_32\n   state[a]=((t <<s)&MASK_32)+(t >>(32 -s))\n   \n   \n  for a,b,c,d,k,s in self._round3:\n   t=(state[a]+(state[b]^state[c]^state[d])+X[k]+0x6ed9eba1)&MASK_32\n   state[a]=((t <<s)&MASK_32)+(t >>(32 -s))\n   \n   \n  for i in irange(4):\n   orig[i]=(orig[i]+state[i])&MASK_32\n   \n def update(self,content):\n  if not isinstance(content,bytes):\n   if PY3:\n    raise TypeError(\"expected bytes\")\n   else :\n   \n    content=content.encode(\"ascii\")\n  buf=self._buf\n  if buf:\n   content=buf+content\n  idx=0\n  end=len(content)\n  while True :\n   next=idx+64\n   if next <=end:\n    self._process(content[idx:next])\n    self._count +=1\n    idx=next\n   else :\n    self._buf=content[idx:]\n    return\n    \n def copy(self):\n  other=md4()\n  other._count=self._count\n  other._state=list(self._state)\n  other._buf=self._buf\n  return other\n  \n def digest(self):\n \n \n  orig=list(self._state)\n  \n  \n  \n  \n  buf=self._buf\n  msglen=self._count *512+len(buf)*8\n  block=buf+b'\\x80'+b'\\x00'*((119 -len(buf))%64)+\\\n  struct.pack(\"<2I\",msglen&MASK_32,(msglen >>32)&MASK_32)\n  if len(block)==128:\n   self._process(block[:64])\n   self._process(block[64:])\n  else :\n   assert len(block)==64\n   self._process(block)\n   \n   \n  out=struct.pack(\"<4I\",*self._state)\n  self._state=orig\n  return out\n  \n def hexdigest(self):\n  return bascii_to_str(hexlify(self.digest()))\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "passlib.utils.compat", "struct"]], "passlib.crypto": [".py", "''\n", [], 1], "passlib.crypto.des": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport struct\n\nfrom passlib import exc\nfrom passlib.utils.compat import join_byte_values,byte_elem_value,\\\nirange,irange,int_types\n\n__all__=[\n\"expand_des_key\",\n\"des_encrypt_block\",\n]\n\n\n\n\n\n\nINT_24_MASK=0xffffff\nINT_56_MASK=0xffffffffffffff\nINT_64_MASK=0xffffffffffffffff\n\n\n_KDATA_MASK=0xfefefefefefefefe\n_KPARITY_MASK=0x0101010101010101\n\n\n_KS_MASK=0xfcfcfcfcffffffff\n\n\n\n\n\n\nPCXROT=IE3264=SPE=CF6464=None\n\ndef _load_tables():\n ''\n global PCXROT,IE3264,SPE,CF6464\n \n \n \n \n \n \n PC1ROT=(\n (0x0000000000000000,0x0000000000000000,0x0000000000002000,0x0000000000002000,\n 0x0000000000000020,0x0000000000000020,0x0000000000002020,0x0000000000002020,\n 0x0000000000000400,0x0000000000000400,0x0000000000002400,0x0000000000002400,\n 0x0000000000000420,0x0000000000000420,0x0000000000002420,0x0000000000002420,),\n (0x0000000000000000,0x2000000000000000,0x0000000400000000,0x2000000400000000,\n 0x0000800000000000,0x2000800000000000,0x0000800400000000,0x2000800400000000,\n 0x0008000000000000,0x2008000000000000,0x0008000400000000,0x2008000400000000,\n 0x0008800000000000,0x2008800000000000,0x0008800400000000,0x2008800400000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000040,0x0000000000000040,\n 0x0000000020000000,0x0000000020000000,0x0000000020000040,0x0000000020000040,\n 0x0000000000200000,0x0000000000200000,0x0000000000200040,0x0000000000200040,\n 0x0000000020200000,0x0000000020200000,0x0000000020200040,0x0000000020200040,),\n (0x0000000000000000,0x0002000000000000,0x0800000000000000,0x0802000000000000,\n 0x0100000000000000,0x0102000000000000,0x0900000000000000,0x0902000000000000,\n 0x4000000000000000,0x4002000000000000,0x4800000000000000,0x4802000000000000,\n 0x4100000000000000,0x4102000000000000,0x4900000000000000,0x4902000000000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000040000,0x0000000000040000,\n 0x0000020000000000,0x0000020000000000,0x0000020000040000,0x0000020000040000,\n 0x0000000000000004,0x0000000000000004,0x0000000000040004,0x0000000000040004,\n 0x0000020000000004,0x0000020000000004,0x0000020000040004,0x0000020000040004,),\n (0x0000000000000000,0x0000400000000000,0x0200000000000000,0x0200400000000000,\n 0x0080000000000000,0x0080400000000000,0x0280000000000000,0x0280400000000000,\n 0x0000008000000000,0x0000408000000000,0x0200008000000000,0x0200408000000000,\n 0x0080008000000000,0x0080408000000000,0x0280008000000000,0x0280408000000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000010000000,0x0000000010000000,\n 0x0000000000001000,0x0000000000001000,0x0000000010001000,0x0000000010001000,\n 0x0000000040000000,0x0000000040000000,0x0000000050000000,0x0000000050000000,\n 0x0000000040001000,0x0000000040001000,0x0000000050001000,0x0000000050001000,),\n (0x0000000000000000,0x0000001000000000,0x0000080000000000,0x0000081000000000,\n 0x1000000000000000,0x1000001000000000,0x1000080000000000,0x1000081000000000,\n 0x0004000000000000,0x0004001000000000,0x0004080000000000,0x0004081000000000,\n 0x1004000000000000,0x1004001000000000,0x1004080000000000,0x1004081000000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000080,0x0000000000000080,\n 0x0000000000080000,0x0000000000080000,0x0000000000080080,0x0000000000080080,\n 0x0000000000800000,0x0000000000800000,0x0000000000800080,0x0000000000800080,\n 0x0000000000880000,0x0000000000880000,0x0000000000880080,0x0000000000880080,),\n (0x0000000000000000,0x0000000008000000,0x0000002000000000,0x0000002008000000,\n 0x0000100000000000,0x0000100008000000,0x0000102000000000,0x0000102008000000,\n 0x0000200000000000,0x0000200008000000,0x0000202000000000,0x0000202008000000,\n 0x0000300000000000,0x0000300008000000,0x0000302000000000,0x0000302008000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000400000,0x0000000000400000,\n 0x0000000004000000,0x0000000004000000,0x0000000004400000,0x0000000004400000,\n 0x0000000000000800,0x0000000000000800,0x0000000000400800,0x0000000000400800,\n 0x0000000004000800,0x0000000004000800,0x0000000004400800,0x0000000004400800,),\n (0x0000000000000000,0x0000000000008000,0x0040000000000000,0x0040000000008000,\n 0x0000004000000000,0x0000004000008000,0x0040004000000000,0x0040004000008000,\n 0x8000000000000000,0x8000000000008000,0x8040000000000000,0x8040000000008000,\n 0x8000004000000000,0x8000004000008000,0x8040004000000000,0x8040004000008000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000004000,0x0000000000004000,\n 0x0000000000000008,0x0000000000000008,0x0000000000004008,0x0000000000004008,\n 0x0000000000000010,0x0000000000000010,0x0000000000004010,0x0000000000004010,\n 0x0000000000000018,0x0000000000000018,0x0000000000004018,0x0000000000004018,),\n (0x0000000000000000,0x0000000200000000,0x0001000000000000,0x0001000200000000,\n 0x0400000000000000,0x0400000200000000,0x0401000000000000,0x0401000200000000,\n 0x0020000000000000,0x0020000200000000,0x0021000000000000,0x0021000200000000,\n 0x0420000000000000,0x0420000200000000,0x0421000000000000,0x0421000200000000,),\n (0x0000000000000000,0x0000000000000000,0x0000010000000000,0x0000010000000000,\n 0x0000000100000000,0x0000000100000000,0x0000010100000000,0x0000010100000000,\n 0x0000000000100000,0x0000000000100000,0x0000010000100000,0x0000010000100000,\n 0x0000000100100000,0x0000000100100000,0x0000010100100000,0x0000010100100000,),\n (0x0000000000000000,0x0000000080000000,0x0000040000000000,0x0000040080000000,\n 0x0010000000000000,0x0010000080000000,0x0010040000000000,0x0010040080000000,\n 0x0000000800000000,0x0000000880000000,0x0000040800000000,0x0000040880000000,\n 0x0010000800000000,0x0010000880000000,0x0010040800000000,0x0010040880000000,),\n )\n \n \n \n \n \n PC2ROTA=(\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000200000,0x0000000000200000,0x0000000000200000,0x0000000000200000,\n 0x0000000004000000,0x0000000004000000,0x0000000004000000,0x0000000004000000,\n 0x0000000004200000,0x0000000004200000,0x0000000004200000,0x0000000004200000,),\n (0x0000000000000000,0x0000000000000800,0x0000010000000000,0x0000010000000800,\n 0x0000000000002000,0x0000000000002800,0x0000010000002000,0x0000010000002800,\n 0x0000000010000000,0x0000000010000800,0x0000010010000000,0x0000010010000800,\n 0x0000000010002000,0x0000000010002800,0x0000010010002000,0x0000010010002800,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000100000000,0x0000000100000000,0x0000000100000000,0x0000000100000000,\n 0x0000000000800000,0x0000000000800000,0x0000000000800000,0x0000000000800000,\n 0x0000000100800000,0x0000000100800000,0x0000000100800000,0x0000000100800000,),\n (0x0000000000000000,0x0000020000000000,0x0000000080000000,0x0000020080000000,\n 0x0000000000400000,0x0000020000400000,0x0000000080400000,0x0000020080400000,\n 0x0000000008000000,0x0000020008000000,0x0000000088000000,0x0000020088000000,\n 0x0000000008400000,0x0000020008400000,0x0000000088400000,0x0000020088400000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000000040,0x0000000000000040,0x0000000000000040,0x0000000000000040,\n 0x0000000000001000,0x0000000000001000,0x0000000000001000,0x0000000000001000,\n 0x0000000000001040,0x0000000000001040,0x0000000000001040,0x0000000000001040,),\n (0x0000000000000000,0x0000000000000010,0x0000000000000400,0x0000000000000410,\n 0x0000000000000080,0x0000000000000090,0x0000000000000480,0x0000000000000490,\n 0x0000000040000000,0x0000000040000010,0x0000000040000400,0x0000000040000410,\n 0x0000000040000080,0x0000000040000090,0x0000000040000480,0x0000000040000490,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000080000,0x0000000000080000,0x0000000000080000,0x0000000000080000,\n 0x0000000000100000,0x0000000000100000,0x0000000000100000,0x0000000000100000,\n 0x0000000000180000,0x0000000000180000,0x0000000000180000,0x0000000000180000,),\n (0x0000000000000000,0x0000000000040000,0x0000000000000020,0x0000000000040020,\n 0x0000000000000004,0x0000000000040004,0x0000000000000024,0x0000000000040024,\n 0x0000000200000000,0x0000000200040000,0x0000000200000020,0x0000000200040020,\n 0x0000000200000004,0x0000000200040004,0x0000000200000024,0x0000000200040024,),\n (0x0000000000000000,0x0000000000000008,0x0000000000008000,0x0000000000008008,\n 0x0010000000000000,0x0010000000000008,0x0010000000008000,0x0010000000008008,\n 0x0020000000000000,0x0020000000000008,0x0020000000008000,0x0020000000008008,\n 0x0030000000000000,0x0030000000000008,0x0030000000008000,0x0030000000008008,),\n (0x0000000000000000,0x0000400000000000,0x0000080000000000,0x0000480000000000,\n 0x0000100000000000,0x0000500000000000,0x0000180000000000,0x0000580000000000,\n 0x4000000000000000,0x4000400000000000,0x4000080000000000,0x4000480000000000,\n 0x4000100000000000,0x4000500000000000,0x4000180000000000,0x4000580000000000,),\n (0x0000000000000000,0x0000000000004000,0x0000000020000000,0x0000000020004000,\n 0x0001000000000000,0x0001000000004000,0x0001000020000000,0x0001000020004000,\n 0x0200000000000000,0x0200000000004000,0x0200000020000000,0x0200000020004000,\n 0x0201000000000000,0x0201000000004000,0x0201000020000000,0x0201000020004000,),\n (0x0000000000000000,0x1000000000000000,0x0004000000000000,0x1004000000000000,\n 0x0002000000000000,0x1002000000000000,0x0006000000000000,0x1006000000000000,\n 0x0000000800000000,0x1000000800000000,0x0004000800000000,0x1004000800000000,\n 0x0002000800000000,0x1002000800000000,0x0006000800000000,0x1006000800000000,),\n (0x0000000000000000,0x0040000000000000,0x2000000000000000,0x2040000000000000,\n 0x0000008000000000,0x0040008000000000,0x2000008000000000,0x2040008000000000,\n 0x0000001000000000,0x0040001000000000,0x2000001000000000,0x2040001000000000,\n 0x0000009000000000,0x0040009000000000,0x2000009000000000,0x2040009000000000,),\n (0x0000000000000000,0x0400000000000000,0x8000000000000000,0x8400000000000000,\n 0x0000002000000000,0x0400002000000000,0x8000002000000000,0x8400002000000000,\n 0x0100000000000000,0x0500000000000000,0x8100000000000000,0x8500000000000000,\n 0x0100002000000000,0x0500002000000000,0x8100002000000000,0x8500002000000000,),\n (0x0000000000000000,0x0000800000000000,0x0800000000000000,0x0800800000000000,\n 0x0000004000000000,0x0000804000000000,0x0800004000000000,0x0800804000000000,\n 0x0000000400000000,0x0000800400000000,0x0800000400000000,0x0800800400000000,\n 0x0000004400000000,0x0000804400000000,0x0800004400000000,0x0800804400000000,),\n (0x0000000000000000,0x0080000000000000,0x0000040000000000,0x0080040000000000,\n 0x0008000000000000,0x0088000000000000,0x0008040000000000,0x0088040000000000,\n 0x0000200000000000,0x0080200000000000,0x0000240000000000,0x0080240000000000,\n 0x0008200000000000,0x0088200000000000,0x0008240000000000,0x0088240000000000,),\n )\n \n \n PC2ROTB=(\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000000400,0x0000000000000400,0x0000000000000400,0x0000000000000400,\n 0x0000000000080000,0x0000000000080000,0x0000000000080000,0x0000000000080000,\n 0x0000000000080400,0x0000000000080400,0x0000000000080400,0x0000000000080400,),\n (0x0000000000000000,0x0000000000800000,0x0000000000004000,0x0000000000804000,\n 0x0000000080000000,0x0000000080800000,0x0000000080004000,0x0000000080804000,\n 0x0000000000040000,0x0000000000840000,0x0000000000044000,0x0000000000844000,\n 0x0000000080040000,0x0000000080840000,0x0000000080044000,0x0000000080844000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000000008,0x0000000000000008,0x0000000000000008,0x0000000000000008,\n 0x0000000040000000,0x0000000040000000,0x0000000040000000,0x0000000040000000,\n 0x0000000040000008,0x0000000040000008,0x0000000040000008,0x0000000040000008,),\n (0x0000000000000000,0x0000000020000000,0x0000000200000000,0x0000000220000000,\n 0x0000000000000080,0x0000000020000080,0x0000000200000080,0x0000000220000080,\n 0x0000000000100000,0x0000000020100000,0x0000000200100000,0x0000000220100000,\n 0x0000000000100080,0x0000000020100080,0x0000000200100080,0x0000000220100080,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000002000,0x0000000000002000,0x0000000000002000,0x0000000000002000,\n 0x0000020000000000,0x0000020000000000,0x0000020000000000,0x0000020000000000,\n 0x0000020000002000,0x0000020000002000,0x0000020000002000,0x0000020000002000,),\n (0x0000000000000000,0x0000000000000800,0x0000000100000000,0x0000000100000800,\n 0x0000000010000000,0x0000000010000800,0x0000000110000000,0x0000000110000800,\n 0x0000000000000004,0x0000000000000804,0x0000000100000004,0x0000000100000804,\n 0x0000000010000004,0x0000000010000804,0x0000000110000004,0x0000000110000804,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000001000,0x0000000000001000,0x0000000000001000,0x0000000000001000,\n 0x0000000000000010,0x0000000000000010,0x0000000000000010,0x0000000000000010,\n 0x0000000000001010,0x0000000000001010,0x0000000000001010,0x0000000000001010,),\n (0x0000000000000000,0x0000000000000040,0x0000010000000000,0x0000010000000040,\n 0x0000000000200000,0x0000000000200040,0x0000010000200000,0x0000010000200040,\n 0x0000000000008000,0x0000000000008040,0x0000010000008000,0x0000010000008040,\n 0x0000000000208000,0x0000000000208040,0x0000010000208000,0x0000010000208040,),\n (0x0000000000000000,0x0000000004000000,0x0000000008000000,0x000000000c000000,\n 0x0400000000000000,0x0400000004000000,0x0400000008000000,0x040000000c000000,\n 0x8000000000000000,0x8000000004000000,0x8000000008000000,0x800000000c000000,\n 0x8400000000000000,0x8400000004000000,0x8400000008000000,0x840000000c000000,),\n (0x0000000000000000,0x0002000000000000,0x0200000000000000,0x0202000000000000,\n 0x1000000000000000,0x1002000000000000,0x1200000000000000,0x1202000000000000,\n 0x0008000000000000,0x000a000000000000,0x0208000000000000,0x020a000000000000,\n 0x1008000000000000,0x100a000000000000,0x1208000000000000,0x120a000000000000,),\n (0x0000000000000000,0x0000000000400000,0x0000000000000020,0x0000000000400020,\n 0x0040000000000000,0x0040000000400000,0x0040000000000020,0x0040000000400020,\n 0x0800000000000000,0x0800000000400000,0x0800000000000020,0x0800000000400020,\n 0x0840000000000000,0x0840000000400000,0x0840000000000020,0x0840000000400020,),\n (0x0000000000000000,0x0080000000000000,0x0000008000000000,0x0080008000000000,\n 0x2000000000000000,0x2080000000000000,0x2000008000000000,0x2080008000000000,\n 0x0020000000000000,0x00a0000000000000,0x0020008000000000,0x00a0008000000000,\n 0x2020000000000000,0x20a0000000000000,0x2020008000000000,0x20a0008000000000,),\n (0x0000000000000000,0x0000002000000000,0x0000040000000000,0x0000042000000000,\n 0x4000000000000000,0x4000002000000000,0x4000040000000000,0x4000042000000000,\n 0x0000400000000000,0x0000402000000000,0x0000440000000000,0x0000442000000000,\n 0x4000400000000000,0x4000402000000000,0x4000440000000000,0x4000442000000000,),\n (0x0000000000000000,0x0000004000000000,0x0000200000000000,0x0000204000000000,\n 0x0000080000000000,0x0000084000000000,0x0000280000000000,0x0000284000000000,\n 0x0000800000000000,0x0000804000000000,0x0000a00000000000,0x0000a04000000000,\n 0x0000880000000000,0x0000884000000000,0x0000a80000000000,0x0000a84000000000,),\n (0x0000000000000000,0x0000000800000000,0x0000000400000000,0x0000000c00000000,\n 0x0000100000000000,0x0000100800000000,0x0000100400000000,0x0000100c00000000,\n 0x0010000000000000,0x0010000800000000,0x0010000400000000,0x0010000c00000000,\n 0x0010100000000000,0x0010100800000000,0x0010100400000000,0x0010100c00000000,),\n (0x0000000000000000,0x0100000000000000,0x0001000000000000,0x0101000000000000,\n 0x0000001000000000,0x0100001000000000,0x0001001000000000,0x0101001000000000,\n 0x0004000000000000,0x0104000000000000,0x0005000000000000,0x0105000000000000,\n 0x0004001000000000,0x0104001000000000,0x0005001000000000,0x0105001000000000,),\n )\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n PCXROT=(\n (PC1ROT,PC2ROTA),(PC2ROTB,PC2ROTB),\n (PC2ROTB,PC2ROTB),(PC2ROTB,PC2ROTB),\n (PC2ROTA,PC2ROTB),(PC2ROTB,PC2ROTB),\n (PC2ROTB,PC2ROTB),(PC2ROTB,PC2ROTA),\n )\n \n \n \n \n \n \n IE3264=(\n (0x0000000000000000,0x0000000000800800,0x0000000000008008,0x0000000000808808,\n 0x0000008008000000,0x0000008008800800,0x0000008008008008,0x0000008008808808,\n 0x0000000080080000,0x0000000080880800,0x0000000080088008,0x0000000080888808,\n 0x0000008088080000,0x0000008088880800,0x0000008088088008,0x0000008088888808,),\n (0x0000000000000000,0x0080080000000000,0x0000800800000000,0x0080880800000000,\n 0x0800000000000080,0x0880080000000080,0x0800800800000080,0x0880880800000080,\n 0x8008000000000000,0x8088080000000000,0x8008800800000000,0x8088880800000000,\n 0x8808000000000080,0x8888080000000080,0x8808800800000080,0x8888880800000080,),\n (0x0000000000000000,0x0000000000001000,0x0000000000000010,0x0000000000001010,\n 0x0000000010000000,0x0000000010001000,0x0000000010000010,0x0000000010001010,\n 0x0000000000100000,0x0000000000101000,0x0000000000100010,0x0000000000101010,\n 0x0000000010100000,0x0000000010101000,0x0000000010100010,0x0000000010101010,),\n (0x0000000000000000,0x0000100000000000,0x0000001000000000,0x0000101000000000,\n 0x1000000000000000,0x1000100000000000,0x1000001000000000,0x1000101000000000,\n 0x0010000000000000,0x0010100000000000,0x0010001000000000,0x0010101000000000,\n 0x1010000000000000,0x1010100000000000,0x1010001000000000,0x1010101000000000,),\n (0x0000000000000000,0x0000000000002000,0x0000000000000020,0x0000000000002020,\n 0x0000000020000000,0x0000000020002000,0x0000000020000020,0x0000000020002020,\n 0x0000000000200000,0x0000000000202000,0x0000000000200020,0x0000000000202020,\n 0x0000000020200000,0x0000000020202000,0x0000000020200020,0x0000000020202020,),\n (0x0000000000000000,0x0000200000000000,0x0000002000000000,0x0000202000000000,\n 0x2000000000000000,0x2000200000000000,0x2000002000000000,0x2000202000000000,\n 0x0020000000000000,0x0020200000000000,0x0020002000000000,0x0020202000000000,\n 0x2020000000000000,0x2020200000000000,0x2020002000000000,0x2020202000000000,),\n (0x0000000000000000,0x0000000000004004,0x0400000000000040,0x0400000000004044,\n 0x0000000040040000,0x0000000040044004,0x0400000040040040,0x0400000040044044,\n 0x0000000000400400,0x0000000000404404,0x0400000000400440,0x0400000000404444,\n 0x0000000040440400,0x0000000040444404,0x0400000040440440,0x0400000040444444,),\n (0x0000000000000000,0x0000400400000000,0x0000004004000000,0x0000404404000000,\n 0x4004000000000000,0x4004400400000000,0x4004004004000000,0x4004404404000000,\n 0x0040040000000000,0x0040440400000000,0x0040044004000000,0x0040444404000000,\n 0x4044040000000000,0x4044440400000000,0x4044044004000000,0x4044444404000000,),\n )\n \n \n \n \n SPE=(\n (0x0080088008200000,0x0000008008000000,0x0000000000200020,0x0080088008200020,\n 0x0000000000200000,0x0080088008000020,0x0000008008000020,0x0000000000200020,\n 0x0080088008000020,0x0080088008200000,0x0000008008200000,0x0080080000000020,\n 0x0080080000200020,0x0000000000200000,0x0000000000000000,0x0000008008000020,\n 0x0000008008000000,0x0000000000000020,0x0080080000200000,0x0080088008000000,\n 0x0080088008200020,0x0000008008200000,0x0080080000000020,0x0080080000200000,\n 0x0000000000000020,0x0080080000000000,0x0080088008000000,0x0000008008200020,\n 0x0080080000000000,0x0080080000200020,0x0000008008200020,0x0000000000000000,\n 0x0000000000000000,0x0080088008200020,0x0080080000200000,0x0000008008000020,\n 0x0080088008200000,0x0000008008000000,0x0080080000000020,0x0080080000200000,\n 0x0000008008200020,0x0080080000000000,0x0080088008000000,0x0000000000200020,\n 0x0080088008000020,0x0000000000000020,0x0000000000200020,0x0000008008200000,\n 0x0080088008200020,0x0080088008000000,0x0000008008200000,0x0080080000200020,\n 0x0000000000200000,0x0080080000000020,0x0000008008000020,0x0000000000000000,\n 0x0000008008000000,0x0000000000200000,0x0080080000200020,0x0080088008200000,\n 0x0000000000000020,0x0000008008200020,0x0080080000000000,0x0080088008000020,),\n (0x1000800810004004,0x0000000000000000,0x0000800810000000,0x0000000010004004,\n 0x1000000000004004,0x1000800800000000,0x0000800800004004,0x0000800810000000,\n 0x0000800800000000,0x1000000010004004,0x1000000000000000,0x0000800800004004,\n 0x1000000010000000,0x0000800810004004,0x0000000010004004,0x1000000000000000,\n 0x0000000010000000,0x1000800800004004,0x1000000010004004,0x0000800800000000,\n 0x1000800810000000,0x0000000000004004,0x0000000000000000,0x1000000010000000,\n 0x1000800800004004,0x1000800810000000,0x0000800810004004,0x1000000000004004,\n 0x0000000000004004,0x0000000010000000,0x1000800800000000,0x1000800810004004,\n 0x1000000010000000,0x0000800810004004,0x0000800800004004,0x1000800810000000,\n 0x1000800810004004,0x1000000010000000,0x1000000000004004,0x0000000000000000,\n 0x0000000000004004,0x1000800800000000,0x0000000010000000,0x1000000010004004,\n 0x0000800800000000,0x0000000000004004,0x1000800810000000,0x1000800800004004,\n 0x0000800810004004,0x0000800800000000,0x0000000000000000,0x1000000000004004,\n 0x1000000000000000,0x1000800810004004,0x0000800810000000,0x0000000010004004,\n 0x1000000010004004,0x0000000010000000,0x1000800800000000,0x0000800800004004,\n 0x1000800800004004,0x1000000000000000,0x0000000010004004,0x0000800810000000,),\n (0x0000000000400410,0x0010004004400400,0x0010000000000000,0x0010000000400410,\n 0x0000004004000010,0x0000000000400400,0x0010000000400410,0x0010004004000000,\n 0x0010000000400400,0x0000004004000000,0x0000004004400400,0x0000000000000010,\n 0x0010004004400410,0x0010000000000010,0x0000000000000010,0x0000004004400410,\n 0x0000000000000000,0x0000004004000010,0x0010004004400400,0x0010000000000000,\n 0x0010000000000010,0x0010004004400410,0x0000004004000000,0x0000000000400410,\n 0x0000004004400410,0x0010000000400400,0x0010004004000010,0x0000004004400400,\n 0x0010004004000000,0x0000000000000000,0x0000000000400400,0x0010004004000010,\n 0x0010004004400400,0x0010000000000000,0x0000000000000010,0x0000004004000000,\n 0x0010000000000010,0x0000004004000010,0x0000004004400400,0x0010000000400410,\n 0x0000000000000000,0x0010004004400400,0x0010004004000000,0x0000004004400410,\n 0x0000004004000010,0x0000000000400400,0x0010004004400410,0x0000000000000010,\n 0x0010004004000010,0x0000000000400410,0x0000000000400400,0x0010004004400410,\n 0x0000004004000000,0x0010000000400400,0x0010000000400410,0x0010004004000000,\n 0x0010000000400400,0x0000000000000000,0x0000004004400410,0x0010000000000010,\n 0x0000000000400410,0x0010004004000010,0x0010000000000000,0x0000004004400400,),\n (0x0800100040040080,0x0000100000001000,0x0800000000000080,0x0800100040041080,\n 0x0000000000000000,0x0000000040041000,0x0800100000001080,0x0800000040040080,\n 0x0000100040041000,0x0800000000001080,0x0000000000001000,0x0800100000000080,\n 0x0800000000001080,0x0800100040040080,0x0000000040040000,0x0000000000001000,\n 0x0800000040041080,0x0000100040040000,0x0000100000000000,0x0800000000000080,\n 0x0000100040040000,0x0800100000001080,0x0000000040041000,0x0000100000000000,\n 0x0800100000000080,0x0000000000000000,0x0800000040040080,0x0000100040041000,\n 0x0000100000001000,0x0800000040041080,0x0800100040041080,0x0000000040040000,\n 0x0800000040041080,0x0800100000000080,0x0000000040040000,0x0800000000001080,\n 0x0000100040040000,0x0000100000001000,0x0800000000000080,0x0000000040041000,\n 0x0800100000001080,0x0000000000000000,0x0000100000000000,0x0800000040040080,\n 0x0000000000000000,0x0800000040041080,0x0000100040041000,0x0000100000000000,\n 0x0000000000001000,0x0800100040041080,0x0800100040040080,0x0000000040040000,\n 0x0800100040041080,0x0800000000000080,0x0000100000001000,0x0800100040040080,\n 0x0800000040040080,0x0000100040040000,0x0000000040041000,0x0800100000001080,\n 0x0800100000000080,0x0000000000001000,0x0800000000001080,0x0000100040041000,),\n (0x0000000000800800,0x0000001000000000,0x0040040000000000,0x2040041000800800,\n 0x2000001000800800,0x0040040000800800,0x2040041000000000,0x0000001000800800,\n 0x0000001000000000,0x2000000000000000,0x2000000000800800,0x0040041000000000,\n 0x2040040000800800,0x2000001000800800,0x0040041000800800,0x0000000000000000,\n 0x0040041000000000,0x0000000000800800,0x2000001000000000,0x2040040000000000,\n 0x0040040000800800,0x2040041000000000,0x0000000000000000,0x2000000000800800,\n 0x2000000000000000,0x2040040000800800,0x2040041000800800,0x2000001000000000,\n 0x0000001000800800,0x0040040000000000,0x2040040000000000,0x0040041000800800,\n 0x0040041000800800,0x2040040000800800,0x2000001000000000,0x0000001000800800,\n 0x0000001000000000,0x2000000000000000,0x2000000000800800,0x0040040000800800,\n 0x0000000000800800,0x0040041000000000,0x2040041000800800,0x0000000000000000,\n 0x2040041000000000,0x0000000000800800,0x0040040000000000,0x2000001000000000,\n 0x2040040000800800,0x0040040000000000,0x0000000000000000,0x2040041000800800,\n 0x2000001000800800,0x0040041000800800,0x2040040000000000,0x0000001000000000,\n 0x0040041000000000,0x2000001000800800,0x0040040000800800,0x2040040000000000,\n 0x2000000000000000,0x2040041000000000,0x0000001000800800,0x2000000000800800,),\n (0x4004000000008008,0x4004000020000000,0x0000000000000000,0x0000200020008008,\n 0x4004000020000000,0x0000200000000000,0x4004200000008008,0x0000000020000000,\n 0x4004200000000000,0x4004200020008008,0x0000200020000000,0x0000000000008008,\n 0x0000200000008008,0x4004000000008008,0x0000000020008008,0x4004200020000000,\n 0x0000000020000000,0x4004200000008008,0x4004000020008008,0x0000000000000000,\n 0x0000200000000000,0x4004000000000000,0x0000200020008008,0x4004000020008008,\n 0x4004200020008008,0x0000000020008008,0x0000000000008008,0x4004200000000000,\n 0x4004000000000000,0x0000200020000000,0x4004200020000000,0x0000200000008008,\n 0x4004200000000000,0x0000000000008008,0x0000200000008008,0x4004200020000000,\n 0x0000200020008008,0x4004000020000000,0x0000000000000000,0x0000200000008008,\n 0x0000000000008008,0x0000200000000000,0x4004000020008008,0x0000000020000000,\n 0x4004000020000000,0x4004200020008008,0x0000200020000000,0x4004000000000000,\n 0x4004200020008008,0x0000200020000000,0x0000000020000000,0x4004200000008008,\n 0x4004000000008008,0x0000000020008008,0x4004200020000000,0x0000000000000000,\n 0x0000200000000000,0x4004000000008008,0x4004200000008008,0x0000200020008008,\n 0x0000000020008008,0x4004200000000000,0x4004000000000000,0x4004000020008008,),\n (0x0000400400000000,0x0020000000000000,0x0020000000100000,0x0400000000100040,\n 0x0420400400100040,0x0400400400000040,0x0020400400000000,0x0000000000000000,\n 0x0000000000100000,0x0420000000100040,0x0420000000000040,0x0000400400100000,\n 0x0400000000000040,0x0020400400100000,0x0000400400100000,0x0420000000000040,\n 0x0420000000100040,0x0000400400000000,0x0400400400000040,0x0420400400100040,\n 0x0000000000000000,0x0020000000100000,0x0400000000100040,0x0020400400000000,\n 0x0400400400100040,0x0420400400000040,0x0020400400100000,0x0400000000000040,\n 0x0420400400000040,0x0400400400100040,0x0020000000000000,0x0000000000100000,\n 0x0420400400000040,0x0000400400100000,0x0400400400100040,0x0420000000000040,\n 0x0000400400000000,0x0020000000000000,0x0000000000100000,0x0400400400100040,\n 0x0420000000100040,0x0420400400000040,0x0020400400000000,0x0000000000000000,\n 0x0020000000000000,0x0400000000100040,0x0400000000000040,0x0020000000100000,\n 0x0000000000000000,0x0420000000100040,0x0020000000100000,0x0020400400000000,\n 0x0420000000000040,0x0000400400000000,0x0420400400100040,0x0000000000100000,\n 0x0020400400100000,0x0400000000000040,0x0400400400000040,0x0420400400100040,\n 0x0400000000100040,0x0020400400100000,0x0000400400100000,0x0400400400000040,),\n (0x8008000080082000,0x0000002080082000,0x8008002000000000,0x0000000000000000,\n 0x0000002000002000,0x8008000080080000,0x0000000080082000,0x8008002080082000,\n 0x8008000000000000,0x0000000000002000,0x0000002080080000,0x8008002000000000,\n 0x8008002080080000,0x8008002000002000,0x8008000000002000,0x0000000080082000,\n 0x0000002000000000,0x8008002080080000,0x8008000080080000,0x0000002000002000,\n 0x8008002080082000,0x8008000000002000,0x0000000000000000,0x0000002080080000,\n 0x0000000000002000,0x0000000080080000,0x8008002000002000,0x8008000080082000,\n 0x0000000080080000,0x0000002000000000,0x0000002080082000,0x8008000000000000,\n 0x0000000080080000,0x0000002000000000,0x8008000000002000,0x8008002080082000,\n 0x8008002000000000,0x0000000000002000,0x0000000000000000,0x0000002080080000,\n 0x8008000080082000,0x8008002000002000,0x0000002000002000,0x8008000080080000,\n 0x0000002080082000,0x8008000000000000,0x8008000080080000,0x0000002000002000,\n 0x8008002080082000,0x0000000080080000,0x0000000080082000,0x8008000000002000,\n 0x0000002080080000,0x8008002000000000,0x8008002000002000,0x0000000080082000,\n 0x8008000000000000,0x0000002080082000,0x8008002080080000,0x0000000000000000,\n 0x0000000000002000,0x8008000080082000,0x0000002000000000,0x8008002080080000,),\n )\n \n \n \n \n \n \n CF6464=(\n (0x0000000000000000,0x0000002000000000,0x0000200000000000,0x0000202000000000,\n 0x0020000000000000,0x0020002000000000,0x0020200000000000,0x0020202000000000,\n 0x2000000000000000,0x2000002000000000,0x2000200000000000,0x2000202000000000,\n 0x2020000000000000,0x2020002000000000,0x2020200000000000,0x2020202000000000,),\n (0x0000000000000000,0x0000000200000000,0x0000020000000000,0x0000020200000000,\n 0x0002000000000000,0x0002000200000000,0x0002020000000000,0x0002020200000000,\n 0x0200000000000000,0x0200000200000000,0x0200020000000000,0x0200020200000000,\n 0x0202000000000000,0x0202000200000000,0x0202020000000000,0x0202020200000000,),\n (0x0000000000000000,0x0000000000000020,0x0000000000002000,0x0000000000002020,\n 0x0000000000200000,0x0000000000200020,0x0000000000202000,0x0000000000202020,\n 0x0000000020000000,0x0000000020000020,0x0000000020002000,0x0000000020002020,\n 0x0000000020200000,0x0000000020200020,0x0000000020202000,0x0000000020202020,),\n (0x0000000000000000,0x0000000000000002,0x0000000000000200,0x0000000000000202,\n 0x0000000000020000,0x0000000000020002,0x0000000000020200,0x0000000000020202,\n 0x0000000002000000,0x0000000002000002,0x0000000002000200,0x0000000002000202,\n 0x0000000002020000,0x0000000002020002,0x0000000002020200,0x0000000002020202,),\n (0x0000000000000000,0x0000008000000000,0x0000800000000000,0x0000808000000000,\n 0x0080000000000000,0x0080008000000000,0x0080800000000000,0x0080808000000000,\n 0x8000000000000000,0x8000008000000000,0x8000800000000000,0x8000808000000000,\n 0x8080000000000000,0x8080008000000000,0x8080800000000000,0x8080808000000000,),\n (0x0000000000000000,0x0000000800000000,0x0000080000000000,0x0000080800000000,\n 0x0008000000000000,0x0008000800000000,0x0008080000000000,0x0008080800000000,\n 0x0800000000000000,0x0800000800000000,0x0800080000000000,0x0800080800000000,\n 0x0808000000000000,0x0808000800000000,0x0808080000000000,0x0808080800000000,),\n (0x0000000000000000,0x0000000000000080,0x0000000000008000,0x0000000000008080,\n 0x0000000000800000,0x0000000000800080,0x0000000000808000,0x0000000000808080,\n 0x0000000080000000,0x0000000080000080,0x0000000080008000,0x0000000080008080,\n 0x0000000080800000,0x0000000080800080,0x0000000080808000,0x0000000080808080,),\n (0x0000000000000000,0x0000000000000008,0x0000000000000800,0x0000000000000808,\n 0x0000000000080000,0x0000000000080008,0x0000000000080800,0x0000000000080808,\n 0x0000000008000000,0x0000000008000008,0x0000000008000800,0x0000000008000808,\n 0x0000000008080000,0x0000000008080008,0x0000000008080800,0x0000000008080808,),\n (0x0000000000000000,0x0000001000000000,0x0000100000000000,0x0000101000000000,\n 0x0010000000000000,0x0010001000000000,0x0010100000000000,0x0010101000000000,\n 0x1000000000000000,0x1000001000000000,0x1000100000000000,0x1000101000000000,\n 0x1010000000000000,0x1010001000000000,0x1010100000000000,0x1010101000000000,),\n (0x0000000000000000,0x0000000100000000,0x0000010000000000,0x0000010100000000,\n 0x0001000000000000,0x0001000100000000,0x0001010000000000,0x0001010100000000,\n 0x0100000000000000,0x0100000100000000,0x0100010000000000,0x0100010100000000,\n 0x0101000000000000,0x0101000100000000,0x0101010000000000,0x0101010100000000,),\n (0x0000000000000000,0x0000000000000010,0x0000000000001000,0x0000000000001010,\n 0x0000000000100000,0x0000000000100010,0x0000000000101000,0x0000000000101010,\n 0x0000000010000000,0x0000000010000010,0x0000000010001000,0x0000000010001010,\n 0x0000000010100000,0x0000000010100010,0x0000000010101000,0x0000000010101010,),\n (0x0000000000000000,0x0000000000000001,0x0000000000000100,0x0000000000000101,\n 0x0000000000010000,0x0000000000010001,0x0000000000010100,0x0000000000010101,\n 0x0000000001000000,0x0000000001000001,0x0000000001000100,0x0000000001000101,\n 0x0000000001010000,0x0000000001010001,0x0000000001010100,0x0000000001010101,),\n (0x0000000000000000,0x0000004000000000,0x0000400000000000,0x0000404000000000,\n 0x0040000000000000,0x0040004000000000,0x0040400000000000,0x0040404000000000,\n 0x4000000000000000,0x4000004000000000,0x4000400000000000,0x4000404000000000,\n 0x4040000000000000,0x4040004000000000,0x4040400000000000,0x4040404000000000,),\n (0x0000000000000000,0x0000000400000000,0x0000040000000000,0x0000040400000000,\n 0x0004000000000000,0x0004000400000000,0x0004040000000000,0x0004040400000000,\n 0x0400000000000000,0x0400000400000000,0x0400040000000000,0x0400040400000000,\n 0x0404000000000000,0x0404000400000000,0x0404040000000000,0x0404040400000000,),\n (0x0000000000000000,0x0000000000000040,0x0000000000004000,0x0000000000004040,\n 0x0000000000400000,0x0000000000400040,0x0000000000404000,0x0000000000404040,\n 0x0000000040000000,0x0000000040000040,0x0000000040004000,0x0000000040004040,\n 0x0000000040400000,0x0000000040400040,0x0000000040404000,0x0000000040404040,),\n (0x0000000000000000,0x0000000000000004,0x0000000000000400,0x0000000000000404,\n 0x0000000000040000,0x0000000000040004,0x0000000000040400,0x0000000000040404,\n 0x0000000004000000,0x0000000004000004,0x0000000004000400,0x0000000004000404,\n 0x0000000004040000,0x0000000004040004,0x0000000004040400,0x0000000004040404,),\n )\n \n \n \n \n \n \n \n \ndef _permute(c,p):\n ''\n \n \n \n out=0\n for r in p:\n  out |=r[c&0xf]\n  c >>=4\n return out\n \n \n \n \n \n_uint64_struct=struct.Struct(\">Q\")\n\ndef _pack64(value):\n return _uint64_struct.pack(value)\n \ndef _unpack64(value):\n return _uint64_struct.unpack(value)[0]\n \ndef _pack56(value):\n return _uint64_struct.pack(value)[1:]\n \ndef _unpack56(value):\n return _uint64_struct.unpack(b'\\x00'+value)[0]\n \n \n \n \n \n \n \n \n \n \n \n \n_EXPAND_ITER=irange(49,-7,-7)\n\ndef expand_des_key(key):\n ''\n if isinstance(key,bytes):\n  if len(key)!=7:\n   raise ValueError(\"key must be 7 bytes in size\")\n elif isinstance(key,int_types):\n  if key <0 or key >INT_56_MASK:\n   raise ValueError(\"key must be 56-bit non-negative integer\")\n  return _unpack64(expand_des_key(_pack56(key)))\n else :\n  raise exc.ExpectedTypeError(key,\"bytes or int\",\"key\")\n key=_unpack56(key)\n \n \n \n \n \n \n return join_byte_values(((key >>shift)&0x7f)<<1 for shift in _EXPAND_ITER)\n \ndef shrink_des_key(key):\n ''\n if isinstance(key,bytes):\n  if len(key)!=8:\n   raise ValueError(\"key must be 8 bytes in size\")\n  return _pack56(shrink_des_key(_unpack64(key)))\n elif isinstance(key,int_types):\n  if key <0 or key >INT_64_MASK:\n   raise ValueError(\"key must be 64-bit non-negative integer\")\n else :\n  raise exc.ExpectedTypeError(key,\"bytes or int\",\"key\")\n key >>=1\n result=0\n offset=0\n while offset <56:\n  result |=(key&0x7f)<<offset\n  key >>=8\n  offset +=7\n assert not (result&~INT_64_MASK)\n return result\n \n \n \n \ndef des_encrypt_block(key,input,salt=0,rounds=1):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if isinstance(key,bytes):\n  if len(key)==7:\n   key=expand_des_key(key)\n  elif len(key)!=8:\n   raise ValueError(\"key must be 7 or 8 bytes\")\n  key=_unpack64(key)\n else :\n  raise exc.ExpectedTypeError(key,\"bytes\",\"key\")\n  \n  \n if isinstance(input,bytes):\n  if len(input)!=8:\n   raise ValueError(\"input block must be 8 bytes\")\n  input=_unpack64(input)\n else :\n  raise exc.ExpectedTypeError(input,\"bytes\",\"input\")\n  \n  \n result=des_encrypt_int_block(key,input,salt,rounds)\n \n \n return _pack64(result)\n \ndef des_encrypt_int_block(key,input,salt=0,rounds=1):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n if rounds <1:\n  raise ValueError(\"rounds must be positive integer\")\n if salt <0 or salt >INT_24_MASK:\n  raise ValueError(\"salt must be 24-bit non-negative integer\")\n  \n  \n if not isinstance(key,int_types):\n  raise exc.ExpectedTypeError(key,\"int\",\"key\")\n elif key <0 or key >INT_64_MASK:\n  raise ValueError(\"key must be 64-bit non-negative integer\")\n  \n  \n if not isinstance(input,int_types):\n  raise exc.ExpectedTypeError(input,\"int\",\"input\")\n elif input <0 or input >INT_64_MASK:\n  raise ValueError(\"input must be 64-bit non-negative integer\")\n  \n  \n  \n  \n  \n global SPE,PCXROT,IE3264,CF6464\n if PCXROT is None :\n  _load_tables()\n  \n  \n SPE0,SPE1,SPE2,SPE3,SPE4,SPE5,SPE6,SPE7=SPE\n \n \n \n \n \n \n \n def _iter_key_schedule(ks_odd):\n  ''\n  for p_even,p_odd in PCXROT:\n   ks_even=_permute(ks_odd,p_even)\n   ks_odd=_permute(ks_even,p_odd)\n   yield ks_even&_KS_MASK,ks_odd&_KS_MASK\n ks_list=list(_iter_key_schedule(key))\n \n \n salt=(\n ((salt&0x00003f)<<26)|\n ((salt&0x000fc0)<<12)|\n ((salt&0x03f000)>>2)|\n ((salt&0xfc0000)>>16)\n )\n \n \n if input ==0:\n  L=R=0\n else :\n  L=((input >>31)&0xaaaaaaaa)|(input&0x55555555)\n  L=_permute(L,IE3264)\n  \n  R=((input >>32)&0xaaaaaaaa)|((input >>1)&0x55555555)\n  R=_permute(R,IE3264)\n  \n  \n  \n  \n while rounds:\n  rounds -=1\n  \n  \n  for ks_even,ks_odd in ks_list:\n   k=((R >>32)^R)&salt\n   B=(k <<32)^k ^R ^ks_even\n   \n   L ^=(SPE0[(B >>58)&0x3f]^SPE1[(B >>50)&0x3f]^\n   SPE2[(B >>42)&0x3f]^SPE3[(B >>34)&0x3f]^\n   SPE4[(B >>26)&0x3f]^SPE5[(B >>18)&0x3f]^\n   SPE6[(B >>10)&0x3f]^SPE7[(B >>2)&0x3f])\n   \n   k=((L >>32)^L)&salt\n   B=(k <<32)^k ^L ^ks_odd\n   \n   R ^=(SPE0[(B >>58)&0x3f]^SPE1[(B >>50)&0x3f]^\n   SPE2[(B >>42)&0x3f]^SPE3[(B >>34)&0x3f]^\n   SPE4[(B >>26)&0x3f]^SPE5[(B >>18)&0x3f]^\n   SPE6[(B >>10)&0x3f]^SPE7[(B >>2)&0x3f])\n   \n   \n  L,R=R,L\n  \n  \n  \n  \n C=(\n ((L >>3)&0x0f0f0f0f00000000)\n |\n ((L <<33)&0xf0f0f0f000000000)\n |\n ((R >>35)&0x000000000f0f0f0f)\n |\n ((R <<1)&0x00000000f0f0f0f0)\n )\n return _permute(C,CF6464)\n \n \n \n \n", ["passlib", "passlib.utils.compat", "struct"]], "passlib.crypto._blowfish.unrolled": [".py", "''\n\n\n\n\n\n\n\n\n\nfrom passlib.crypto._blowfish.base import BlowfishEngine as _BlowfishEngine\n\n__all__=[\n\"BlowfishEngine\",\n]\n\n\n\nclass BlowfishEngine(_BlowfishEngine):\n\n def encipher(self,l,r):\n  ''\n  \n  (p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,\n  p10,p11,p12,p13,p14,p15,p16,p17)=self.P\n  S0,S1,S2,S3=self.S\n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  \n  return r ^p17,l\n  \n def expand(self,key_words):\n  ''\n  \n  \n  P,S=self.P,self.S\n  S0,S1,S2,S3=S\n  \n  \n  \n  \n  p0=P[0]^key_words[0]\n  p1=P[1]^key_words[1]\n  p2=P[2]^key_words[2]\n  p3=P[3]^key_words[3]\n  p4=P[4]^key_words[4]\n  p5=P[5]^key_words[5]\n  p6=P[6]^key_words[6]\n  p7=P[7]^key_words[7]\n  p8=P[8]^key_words[8]\n  p9=P[9]^key_words[9]\n  p10=P[10]^key_words[10]\n  p11=P[11]^key_words[11]\n  p12=P[12]^key_words[12]\n  p13=P[13]^key_words[13]\n  p14=P[14]^key_words[14]\n  p15=P[15]^key_words[15]\n  p16=P[16]^key_words[16]\n  p17=P[17]^key_words[17]\n  \n  \n  \n  \n  \n  \n  \n  \n  l,r=p0,0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  \n  p0,p1=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p2,p3=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p4,p5=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p6,p7=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p8,p9=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p10,p11=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p12,p13=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p14,p15=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p16,p17=l,r=r ^p17,l\n  \n  \n  \n  \n  \n  P[:]=(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,\n  p10,p11,p12,p13,p14,p15,p16,p17)\n  \n  \n  \n  \n  \n  for box in S:\n   j=0\n   while j <256:\n    l ^=p0\n    \n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p1\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p2\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p3\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p4\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p5\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p6\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p7\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p8\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p9\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p10\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p11\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p12\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p13\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p14\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p15\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p16\n    \n    box[j],box[j+1]=l,r=r ^p17,l\n    j +=2\n    \n    \n    \n    \n    \n    \n    \n", ["passlib.crypto._blowfish.base"]], "passlib.crypto._blowfish": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom itertools import chain\nimport struct\n\nfrom passlib.utils import getrandbytes,rng\nfrom passlib.utils.binary import bcrypt64\nfrom passlib.utils.compat import BytesIO,unicode,u,native_string_types\nfrom passlib.crypto._blowfish.unrolled import BlowfishEngine\n\n__all__=[\n'BlowfishEngine',\n'raw_bcrypt',\n]\n\n\n\n\n\n\nBCRYPT_CDATA=[\n0x4f727068,0x65616e42,0x65686f6c,\n0x64657253,0x63727944,0x6f756274\n]\n\n\ndigest_struct=struct.Struct(\">6I\")\n\n\n\n\n\n\n\nBNULL=b'\\x00'\n\ndef raw_bcrypt(password,ident,salt,log_rounds):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n assert isinstance(ident,native_string_types)\n add_null_padding=True\n if ident ==u('2a')or ident ==u('2y')or ident ==u('2b'):\n  pass\n elif ident ==u('2'):\n  add_null_padding=False\n elif ident ==u('2x'):\n  raise ValueError(\"crypt_blowfish's buggy '2x' hashes are not \"\n  \"currently supported\")\n else :\n  raise ValueError(\"unknown ident: %r\"%(ident,))\n  \n  \n assert isinstance(salt,bytes)\n salt=bcrypt64.decode_bytes(salt)\n if len(salt)<16:\n  raise ValueError(\"Missing salt bytes\")\n elif len(salt)>16:\n  salt=salt[:16]\n  \n  \n assert isinstance(password,bytes)\n if add_null_padding:\n  password +=BNULL\n  \n  \n if log_rounds <4 or log_rounds >31:\n  raise ValueError(\"Bad number of rounds\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n engine=BlowfishEngine()\n \n \n pass_words=engine.key_to_words(password)\n salt_words=engine.key_to_words(salt)\n \n \n \n salt_words16=salt_words[:4]\n \n \n engine.eks_salted_expand(pass_words,salt_words16)\n \n \n rounds=1 <<log_rounds\n engine.eks_repeated_expand(pass_words,salt_words,rounds)\n \n \n data=list(BCRYPT_CDATA)\n i=0\n while i <6:\n  data[i],data[i+1]=engine.repeat_encipher(data[i],data[i+1],64)\n  i +=2\n raw=digest_struct.pack(*data)[:-1]\n return bcrypt64.encode_bytes(raw)\n \n \n \n \n", ["itertools", "passlib.crypto._blowfish.unrolled", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "struct"], 1], "passlib.crypto._blowfish._gen_files": [".py", "''\n\n\n\n\nimport os\nimport textwrap\n\nfrom passlib.utils.compat import irange\n\n\n\n\n\ndef varlist(name,count):\n return \", \".join(name+str(x)for x in irange(count))\n \n \ndef indent_block(block,padding):\n ''\n lines=block.split(\"\\n\")\n return \"\\n\".join(\n padding+line if line else \"\"\n for line in lines\n )\n \nBFSTR=\"\"\"\\\n                ((((S0[l >> 24] + S1[(l >> 16) & 0xff]) ^ S2[(l >> 8) & 0xff]) +\n                  S3[l & 0xff]) & 0xffffffff)\n\"\"\".strip()\n\ndef render_encipher(write,indent=0):\n for i in irange(0,15,2):\n  write(indent,\"\"\"\\\n            # Feistel substitution on left word (round %(i)d)\n            r ^= %(left)s ^ p%(i1)d\n\n            # Feistel substitution on right word (round %(i1)d)\n            l ^= %(right)s ^ p%(i2)d\n        \"\"\",i=i,i1=i+1,i2=i+2,\n  left=BFSTR,right=BFSTR.replace(\"l\",\"r\"),\n  )\n  \ndef write_encipher_function(write,indent=0):\n write(indent,\"\"\"\\\n        def encipher(self, l, r):\n            \\\"\"\"blowfish encipher a single 64-bit block encoded as two 32-bit ints\\\"\"\"\n\n            (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,\n              p10, p11, p12, p13, p14, p15, p16, p17) = self.P\n            S0, S1, S2, S3 = self.S\n\n            l ^= p0\n\n            \"\"\")\n render_encipher(write,indent+1)\n \n write(indent+1,\"\"\"\\\n\n        return r ^ p17, l\n\n        \"\"\")\n \ndef write_expand_function(write,indent=0):\n write(indent,\"\"\"\\\n        def expand(self, key_words):\n            \\\"\"\"unrolled version of blowfish key expansion\\\"\"\"\n            ##assert len(key_words) >= 18, \"size of key_words must be >= 18\"\n\n            P, S = self.P, self.S\n            S0, S1, S2, S3 = S\n\n            #=============================================================\n            # integrate key\n            #=============================================================\n        \"\"\")\n for i in irange(18):\n  write(indent+1,\"\"\"\\\n            p%(i)d = P[%(i)d] ^ key_words[%(i)d]\n        \"\"\",i=i)\n write(indent+1,\"\"\"\\\n\n        #=============================================================\n        # update P\n        #=============================================================\n\n        #------------------------------------------------\n        # update P[0] and P[1]\n        #------------------------------------------------\n        l, r = p0, 0\n\n        \"\"\")\n \n render_encipher(write,indent+1)\n \n write(indent+1,\"\"\"\\\n\n        p0, p1 = l, r = r ^ p17, l\n\n        \"\"\")\n \n for i in irange(2,18,2):\n  write(indent+1,\"\"\"\\\n            #------------------------------------------------\n            # update P[%(i)d] and P[%(i1)d]\n            #------------------------------------------------\n            l ^= p0\n\n            \"\"\",i=i,i1=i+1)\n  \n  render_encipher(write,indent+1)\n  \n  write(indent+1,\"\"\"\\\n            p%(i)d, p%(i1)d = l, r = r ^ p17, l\n\n            \"\"\",i=i,i1=i+1)\n  \n write(indent+1,\"\"\"\\\n\n        #------------------------------------------------\n        # save changes to original P array\n        #------------------------------------------------\n        P[:] = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,\n          p10, p11, p12, p13, p14, p15, p16, p17)\n\n        #=============================================================\n        # update S\n        #=============================================================\n\n        for box in S:\n            j = 0\n            while j < 256:\n                l ^= p0\n\n        \"\"\")\n \n render_encipher(write,indent+3)\n \n write(indent+3,\"\"\"\\\n\n                box[j], box[j+1] = l, r = r ^ p17, l\n                j += 2\n        \"\"\")\n \n \n \n \n \ndef main():\n target=os.path.join(os.path.dirname(__file__),\"unrolled.py\")\n fh=file(target,\"w\")\n \n def write(indent,msg,**kwds):\n  literal=kwds.pop(\"literal\",False )\n  if kwds:\n   msg %=kwds\n  if not literal:\n   msg=textwrap.dedent(msg.rstrip(\" \"))\n  if indent:\n   msg=indent_block(msg,\" \"*(indent *4))\n  fh.write(msg)\n  \n write(0,\"\"\"\\\n        \\\"\"\"passlib.crypto._blowfish.unrolled - unrolled loop implementation of bcrypt,\n        autogenerated by _gen_files.py\n\n        currently this override the encipher() and expand() methods\n        with optimized versions, and leaves the other base.py methods alone.\n        \\\"\"\"\n        #=================================================================\n        # imports\n        #=================================================================\n        # pkg\n        from passlib.crypto._blowfish.base import BlowfishEngine as _BlowfishEngine\n        # local\n        __all__ = [\n            \"BlowfishEngine\",\n        ]\n        #=================================================================\n        #\n        #=================================================================\n        class BlowfishEngine(_BlowfishEngine):\n\n        \"\"\")\n \n write_encipher_function(write,indent=1)\n write_expand_function(write,indent=1)\n \n write(0,\"\"\"\\\n            #=================================================================\n            # eoc\n            #=================================================================\n\n        #=================================================================\n        # eof\n        #=================================================================\n        \"\"\")\n \nif __name__ ==\"__main__\":\n main()\n \n \n \n \n", ["os", "passlib.utils.compat", "textwrap"]], "passlib.crypto._blowfish.base": [".py", "''\n\n\n\n\nimport struct\n\nfrom passlib.utils import repeat_string\n\n__all__=[\n\"BlowfishEngine\",\n]\n\n\n\n\nBLOWFISH_P=BLOWFISH_S=None\n\ndef _init_constants():\n global BLOWFISH_P,BLOWFISH_S\n \n \n \n \n \n BLOWFISH_P=[\n 0x243f6a88,0x85a308d3,0x13198a2e,0x03707344,\n 0xa4093822,0x299f31d0,0x082efa98,0xec4e6c89,\n 0x452821e6,0x38d01377,0xbe5466cf,0x34e90c6c,\n 0xc0ac29b7,0xc97c50dd,0x3f84d5b5,0xb5470917,\n 0x9216d5d9,0x8979fb1b,\n ]\n \n \n BLOWFISH_S=[\n \n [\n 0xd1310ba6,0x98dfb5ac,0x2ffd72db,0xd01adfb7,\n 0xb8e1afed,0x6a267e96,0xba7c9045,0xf12c7f99,\n 0x24a19947,0xb3916cf7,0x0801f2e2,0x858efc16,\n 0x636920d8,0x71574e69,0xa458fea3,0xf4933d7e,\n 0x0d95748f,0x728eb658,0x718bcd58,0x82154aee,\n 0x7b54a41d,0xc25a59b5,0x9c30d539,0x2af26013,\n 0xc5d1b023,0x286085f0,0xca417918,0xb8db38ef,\n 0x8e79dcb0,0x603a180e,0x6c9e0e8b,0xb01e8a3e,\n 0xd71577c1,0xbd314b27,0x78af2fda,0x55605c60,\n 0xe65525f3,0xaa55ab94,0x57489862,0x63e81440,\n 0x55ca396a,0x2aab10b6,0xb4cc5c34,0x1141e8ce,\n 0xa15486af,0x7c72e993,0xb3ee1411,0x636fbc2a,\n 0x2ba9c55d,0x741831f6,0xce5c3e16,0x9b87931e,\n 0xafd6ba33,0x6c24cf5c,0x7a325381,0x28958677,\n 0x3b8f4898,0x6b4bb9af,0xc4bfe81b,0x66282193,\n 0x61d809cc,0xfb21a991,0x487cac60,0x5dec8032,\n 0xef845d5d,0xe98575b1,0xdc262302,0xeb651b88,\n 0x23893e81,0xd396acc5,0x0f6d6ff3,0x83f44239,\n 0x2e0b4482,0xa4842004,0x69c8f04a,0x9e1f9b5e,\n 0x21c66842,0xf6e96c9a,0x670c9c61,0xabd388f0,\n 0x6a51a0d2,0xd8542f68,0x960fa728,0xab5133a3,\n 0x6eef0b6c,0x137a3be4,0xba3bf050,0x7efb2a98,\n 0xa1f1651d,0x39af0176,0x66ca593e,0x82430e88,\n 0x8cee8619,0x456f9fb4,0x7d84a5c3,0x3b8b5ebe,\n 0xe06f75d8,0x85c12073,0x401a449f,0x56c16aa6,\n 0x4ed3aa62,0x363f7706,0x1bfedf72,0x429b023d,\n 0x37d0d724,0xd00a1248,0xdb0fead3,0x49f1c09b,\n 0x075372c9,0x80991b7b,0x25d479d8,0xf6e8def7,\n 0xe3fe501a,0xb6794c3b,0x976ce0bd,0x04c006ba,\n 0xc1a94fb6,0x409f60c4,0x5e5c9ec2,0x196a2463,\n 0x68fb6faf,0x3e6c53b5,0x1339b2eb,0x3b52ec6f,\n 0x6dfc511f,0x9b30952c,0xcc814544,0xaf5ebd09,\n 0xbee3d004,0xde334afd,0x660f2807,0x192e4bb3,\n 0xc0cba857,0x45c8740f,0xd20b5f39,0xb9d3fbdb,\n 0x5579c0bd,0x1a60320a,0xd6a100c6,0x402c7279,\n 0x679f25fe,0xfb1fa3cc,0x8ea5e9f8,0xdb3222f8,\n 0x3c7516df,0xfd616b15,0x2f501ec8,0xad0552ab,\n 0x323db5fa,0xfd238760,0x53317b48,0x3e00df82,\n 0x9e5c57bb,0xca6f8ca0,0x1a87562e,0xdf1769db,\n 0xd542a8f6,0x287effc3,0xac6732c6,0x8c4f5573,\n 0x695b27b0,0xbbca58c8,0xe1ffa35d,0xb8f011a0,\n 0x10fa3d98,0xfd2183b8,0x4afcb56c,0x2dd1d35b,\n 0x9a53e479,0xb6f84565,0xd28e49bc,0x4bfb9790,\n 0xe1ddf2da,0xa4cb7e33,0x62fb1341,0xcee4c6e8,\n 0xef20cada,0x36774c01,0xd07e9efe,0x2bf11fb4,\n 0x95dbda4d,0xae909198,0xeaad8e71,0x6b93d5a0,\n 0xd08ed1d0,0xafc725e0,0x8e3c5b2f,0x8e7594b7,\n 0x8ff6e2fb,0xf2122b64,0x8888b812,0x900df01c,\n 0x4fad5ea0,0x688fc31c,0xd1cff191,0xb3a8c1ad,\n 0x2f2f2218,0xbe0e1777,0xea752dfe,0x8b021fa1,\n 0xe5a0cc0f,0xb56f74e8,0x18acf3d6,0xce89e299,\n 0xb4a84fe0,0xfd13e0b7,0x7cc43b81,0xd2ada8d9,\n 0x165fa266,0x80957705,0x93cc7314,0x211a1477,\n 0xe6ad2065,0x77b5fa86,0xc75442f5,0xfb9d35cf,\n 0xebcdaf0c,0x7b3e89a0,0xd6411bd3,0xae1e7e49,\n 0x00250e2d,0x2071b35e,0x226800bb,0x57b8e0af,\n 0x2464369b,0xf009b91e,0x5563911d,0x59dfa6aa,\n 0x78c14389,0xd95a537f,0x207d5ba2,0x02e5b9c5,\n 0x83260376,0x6295cfa9,0x11c81968,0x4e734a41,\n 0xb3472dca,0x7b14a94a,0x1b510052,0x9a532915,\n 0xd60f573f,0xbc9bc6e4,0x2b60a476,0x81e67400,\n 0x08ba6fb5,0x571be91f,0xf296ec6b,0x2a0dd915,\n 0xb6636521,0xe7b9f9b6,0xff34052e,0xc5855664,\n 0x53b02d5d,0xa99f8fa1,0x08ba4799,0x6e85076a,\n ],\n \n [\n 0x4b7a70e9,0xb5b32944,0xdb75092e,0xc4192623,\n 0xad6ea6b0,0x49a7df7d,0x9cee60b8,0x8fedb266,\n 0xecaa8c71,0x699a17ff,0x5664526c,0xc2b19ee1,\n 0x193602a5,0x75094c29,0xa0591340,0xe4183a3e,\n 0x3f54989a,0x5b429d65,0x6b8fe4d6,0x99f73fd6,\n 0xa1d29c07,0xefe830f5,0x4d2d38e6,0xf0255dc1,\n 0x4cdd2086,0x8470eb26,0x6382e9c6,0x021ecc5e,\n 0x09686b3f,0x3ebaefc9,0x3c971814,0x6b6a70a1,\n 0x687f3584,0x52a0e286,0xb79c5305,0xaa500737,\n 0x3e07841c,0x7fdeae5c,0x8e7d44ec,0x5716f2b8,\n 0xb03ada37,0xf0500c0d,0xf01c1f04,0x0200b3ff,\n 0xae0cf51a,0x3cb574b2,0x25837a58,0xdc0921bd,\n 0xd19113f9,0x7ca92ff6,0x94324773,0x22f54701,\n 0x3ae5e581,0x37c2dadc,0xc8b57634,0x9af3dda7,\n 0xa9446146,0x0fd0030e,0xecc8c73e,0xa4751e41,\n 0xe238cd99,0x3bea0e2f,0x3280bba1,0x183eb331,\n 0x4e548b38,0x4f6db908,0x6f420d03,0xf60a04bf,\n 0x2cb81290,0x24977c79,0x5679b072,0xbcaf89af,\n 0xde9a771f,0xd9930810,0xb38bae12,0xdccf3f2e,\n 0x5512721f,0x2e6b7124,0x501adde6,0x9f84cd87,\n 0x7a584718,0x7408da17,0xbc9f9abc,0xe94b7d8c,\n 0xec7aec3a,0xdb851dfa,0x63094366,0xc464c3d2,\n 0xef1c1847,0x3215d908,0xdd433b37,0x24c2ba16,\n 0x12a14d43,0x2a65c451,0x50940002,0x133ae4dd,\n 0x71dff89e,0x10314e55,0x81ac77d6,0x5f11199b,\n 0x043556f1,0xd7a3c76b,0x3c11183b,0x5924a509,\n 0xf28fe6ed,0x97f1fbfa,0x9ebabf2c,0x1e153c6e,\n 0x86e34570,0xeae96fb1,0x860e5e0a,0x5a3e2ab3,\n 0x771fe71c,0x4e3d06fa,0x2965dcb9,0x99e71d0f,\n 0x803e89d6,0x5266c825,0x2e4cc978,0x9c10b36a,\n 0xc6150eba,0x94e2ea78,0xa5fc3c53,0x1e0a2df4,\n 0xf2f74ea7,0x361d2b3d,0x1939260f,0x19c27960,\n 0x5223a708,0xf71312b6,0xebadfe6e,0xeac31f66,\n 0xe3bc4595,0xa67bc883,0xb17f37d1,0x018cff28,\n 0xc332ddef,0xbe6c5aa5,0x65582185,0x68ab9802,\n 0xeecea50f,0xdb2f953b,0x2aef7dad,0x5b6e2f84,\n 0x1521b628,0x29076170,0xecdd4775,0x619f1510,\n 0x13cca830,0xeb61bd96,0x0334fe1e,0xaa0363cf,\n 0xb5735c90,0x4c70a239,0xd59e9e0b,0xcbaade14,\n 0xeecc86bc,0x60622ca7,0x9cab5cab,0xb2f3846e,\n 0x648b1eaf,0x19bdf0ca,0xa02369b9,0x655abb50,\n 0x40685a32,0x3c2ab4b3,0x319ee9d5,0xc021b8f7,\n 0x9b540b19,0x875fa099,0x95f7997e,0x623d7da8,\n 0xf837889a,0x97e32d77,0x11ed935f,0x16681281,\n 0x0e358829,0xc7e61fd6,0x96dedfa1,0x7858ba99,\n 0x57f584a5,0x1b227263,0x9b83c3ff,0x1ac24696,\n 0xcdb30aeb,0x532e3054,0x8fd948e4,0x6dbc3128,\n 0x58ebf2ef,0x34c6ffea,0xfe28ed61,0xee7c3c73,\n 0x5d4a14d9,0xe864b7e3,0x42105d14,0x203e13e0,\n 0x45eee2b6,0xa3aaabea,0xdb6c4f15,0xfacb4fd0,\n 0xc742f442,0xef6abbb5,0x654f3b1d,0x41cd2105,\n 0xd81e799e,0x86854dc7,0xe44b476a,0x3d816250,\n 0xcf62a1f2,0x5b8d2646,0xfc8883a0,0xc1c7b6a3,\n 0x7f1524c3,0x69cb7492,0x47848a0b,0x5692b285,\n 0x095bbf00,0xad19489d,0x1462b174,0x23820e00,\n 0x58428d2a,0x0c55f5ea,0x1dadf43e,0x233f7061,\n 0x3372f092,0x8d937e41,0xd65fecf1,0x6c223bdb,\n 0x7cde3759,0xcbee7460,0x4085f2a7,0xce77326e,\n 0xa6078084,0x19f8509e,0xe8efd855,0x61d99735,\n 0xa969a7aa,0xc50c06c2,0x5a04abfc,0x800bcadc,\n 0x9e447a2e,0xc3453484,0xfdd56705,0x0e1e9ec9,\n 0xdb73dbd3,0x105588cd,0x675fda79,0xe3674340,\n 0xc5c43465,0x713e38d8,0x3d28f89e,0xf16dff20,\n 0x153e21e7,0x8fb03d4a,0xe6e39f2b,0xdb83adf7,\n ],\n \n [\n 0xe93d5a68,0x948140f7,0xf64c261c,0x94692934,\n 0x411520f7,0x7602d4f7,0xbcf46b2e,0xd4a20068,\n 0xd4082471,0x3320f46a,0x43b7d4b7,0x500061af,\n 0x1e39f62e,0x97244546,0x14214f74,0xbf8b8840,\n 0x4d95fc1d,0x96b591af,0x70f4ddd3,0x66a02f45,\n 0xbfbc09ec,0x03bd9785,0x7fac6dd0,0x31cb8504,\n 0x96eb27b3,0x55fd3941,0xda2547e6,0xabca0a9a,\n 0x28507825,0x530429f4,0x0a2c86da,0xe9b66dfb,\n 0x68dc1462,0xd7486900,0x680ec0a4,0x27a18dee,\n 0x4f3ffea2,0xe887ad8c,0xb58ce006,0x7af4d6b6,\n 0xaace1e7c,0xd3375fec,0xce78a399,0x406b2a42,\n 0x20fe9e35,0xd9f385b9,0xee39d7ab,0x3b124e8b,\n 0x1dc9faf7,0x4b6d1856,0x26a36631,0xeae397b2,\n 0x3a6efa74,0xdd5b4332,0x6841e7f7,0xca7820fb,\n 0xfb0af54e,0xd8feb397,0x454056ac,0xba489527,\n 0x55533a3a,0x20838d87,0xfe6ba9b7,0xd096954b,\n 0x55a867bc,0xa1159a58,0xcca92963,0x99e1db33,\n 0xa62a4a56,0x3f3125f9,0x5ef47e1c,0x9029317c,\n 0xfdf8e802,0x04272f70,0x80bb155c,0x05282ce3,\n 0x95c11548,0xe4c66d22,0x48c1133f,0xc70f86dc,\n 0x07f9c9ee,0x41041f0f,0x404779a4,0x5d886e17,\n 0x325f51eb,0xd59bc0d1,0xf2bcc18f,0x41113564,\n 0x257b7834,0x602a9c60,0xdff8e8a3,0x1f636c1b,\n 0x0e12b4c2,0x02e1329e,0xaf664fd1,0xcad18115,\n 0x6b2395e0,0x333e92e1,0x3b240b62,0xeebeb922,\n 0x85b2a20e,0xe6ba0d99,0xde720c8c,0x2da2f728,\n 0xd0127845,0x95b794fd,0x647d0862,0xe7ccf5f0,\n 0x5449a36f,0x877d48fa,0xc39dfd27,0xf33e8d1e,\n 0x0a476341,0x992eff74,0x3a6f6eab,0xf4f8fd37,\n 0xa812dc60,0xa1ebddf8,0x991be14c,0xdb6e6b0d,\n 0xc67b5510,0x6d672c37,0x2765d43b,0xdcd0e804,\n 0xf1290dc7,0xcc00ffa3,0xb5390f92,0x690fed0b,\n 0x667b9ffb,0xcedb7d9c,0xa091cf0b,0xd9155ea3,\n 0xbb132f88,0x515bad24,0x7b9479bf,0x763bd6eb,\n 0x37392eb3,0xcc115979,0x8026e297,0xf42e312d,\n 0x6842ada7,0xc66a2b3b,0x12754ccc,0x782ef11c,\n 0x6a124237,0xb79251e7,0x06a1bbe6,0x4bfb6350,\n 0x1a6b1018,0x11caedfa,0x3d25bdd8,0xe2e1c3c9,\n 0x44421659,0x0a121386,0xd90cec6e,0xd5abea2a,\n 0x64af674e,0xda86a85f,0xbebfe988,0x64e4c3fe,\n 0x9dbc8057,0xf0f7c086,0x60787bf8,0x6003604d,\n 0xd1fd8346,0xf6381fb0,0x7745ae04,0xd736fccc,\n 0x83426b33,0xf01eab71,0xb0804187,0x3c005e5f,\n 0x77a057be,0xbde8ae24,0x55464299,0xbf582e61,\n 0x4e58f48f,0xf2ddfda2,0xf474ef38,0x8789bdc2,\n 0x5366f9c3,0xc8b38e74,0xb475f255,0x46fcd9b9,\n 0x7aeb2661,0x8b1ddf84,0x846a0e79,0x915f95e2,\n 0x466e598e,0x20b45770,0x8cd55591,0xc902de4c,\n 0xb90bace1,0xbb8205d0,0x11a86248,0x7574a99e,\n 0xb77f19b6,0xe0a9dc09,0x662d09a1,0xc4324633,\n 0xe85a1f02,0x09f0be8c,0x4a99a025,0x1d6efe10,\n 0x1ab93d1d,0x0ba5a4df,0xa186f20f,0x2868f169,\n 0xdcb7da83,0x573906fe,0xa1e2ce9b,0x4fcd7f52,\n 0x50115e01,0xa70683fa,0xa002b5c4,0x0de6d027,\n 0x9af88c27,0x773f8641,0xc3604c06,0x61a806b5,\n 0xf0177a28,0xc0f586e0,0x006058aa,0x30dc7d62,\n 0x11e69ed7,0x2338ea63,0x53c2dd94,0xc2c21634,\n 0xbbcbee56,0x90bcb6de,0xebfc7da1,0xce591d76,\n 0x6f05e409,0x4b7c0188,0x39720a3d,0x7c927c24,\n 0x86e3725f,0x724d9db9,0x1ac15bb4,0xd39eb8fc,\n 0xed545578,0x08fca5b5,0xd83d7cd3,0x4dad0fc4,\n 0x1e50ef5e,0xb161e6f8,0xa28514d9,0x6c51133c,\n 0x6fd5c7e7,0x56e14ec4,0x362abfce,0xddc6c837,\n 0xd79a3234,0x92638212,0x670efa8e,0x406000e0,\n ],\n \n [\n 0x3a39ce37,0xd3faf5cf,0xabc27737,0x5ac52d1b,\n 0x5cb0679e,0x4fa33742,0xd3822740,0x99bc9bbe,\n 0xd5118e9d,0xbf0f7315,0xd62d1c7e,0xc700c47b,\n 0xb78c1b6b,0x21a19045,0xb26eb1be,0x6a366eb4,\n 0x5748ab2f,0xbc946e79,0xc6a376d2,0x6549c2c8,\n 0x530ff8ee,0x468dde7d,0xd5730a1d,0x4cd04dc6,\n 0x2939bbdb,0xa9ba4650,0xac9526e8,0xbe5ee304,\n 0xa1fad5f0,0x6a2d519a,0x63ef8ce2,0x9a86ee22,\n 0xc089c2b8,0x43242ef6,0xa51e03aa,0x9cf2d0a4,\n 0x83c061ba,0x9be96a4d,0x8fe51550,0xba645bd6,\n 0x2826a2f9,0xa73a3ae1,0x4ba99586,0xef5562e9,\n 0xc72fefd3,0xf752f7da,0x3f046f69,0x77fa0a59,\n 0x80e4a915,0x87b08601,0x9b09e6ad,0x3b3ee593,\n 0xe990fd5a,0x9e34d797,0x2cf0b7d9,0x022b8b51,\n 0x96d5ac3a,0x017da67d,0xd1cf3ed6,0x7c7d2d28,\n 0x1f9f25cf,0xadf2b89b,0x5ad6b472,0x5a88f54c,\n 0xe029ac71,0xe019a5e6,0x47b0acfd,0xed93fa9b,\n 0xe8d3c48d,0x283b57cc,0xf8d56629,0x79132e28,\n 0x785f0191,0xed756055,0xf7960e44,0xe3d35e8c,\n 0x15056dd4,0x88f46dba,0x03a16125,0x0564f0bd,\n 0xc3eb9e15,0x3c9057a2,0x97271aec,0xa93a072a,\n 0x1b3f6d9b,0x1e6321f5,0xf59c66fb,0x26dcf319,\n 0x7533d928,0xb155fdf5,0x03563482,0x8aba3cbb,\n 0x28517711,0xc20ad9f8,0xabcc5167,0xccad925f,\n 0x4de81751,0x3830dc8e,0x379d5862,0x9320f991,\n 0xea7a90c2,0xfb3e7bce,0x5121ce64,0x774fbe32,\n 0xa8b6e37e,0xc3293d46,0x48de5369,0x6413e680,\n 0xa2ae0810,0xdd6db224,0x69852dfd,0x09072166,\n 0xb39a460a,0x6445c0dd,0x586cdecf,0x1c20c8ae,\n 0x5bbef7dd,0x1b588d40,0xccd2017f,0x6bb4e3bb,\n 0xdda26a7e,0x3a59ff45,0x3e350a44,0xbcb4cdd5,\n 0x72eacea8,0xfa6484bb,0x8d6612ae,0xbf3c6f47,\n 0xd29be463,0x542f5d9e,0xaec2771b,0xf64e6370,\n 0x740e0d8d,0xe75b1357,0xf8721671,0xaf537d5d,\n 0x4040cb08,0x4eb4e2cc,0x34d2466a,0x0115af84,\n 0xe1b00428,0x95983a1d,0x06b89fb4,0xce6ea048,\n 0x6f3f3b82,0x3520ab82,0x011a1d4b,0x277227f8,\n 0x611560b1,0xe7933fdc,0xbb3a792b,0x344525bd,\n 0xa08839e1,0x51ce794b,0x2f32c9b7,0xa01fbac9,\n 0xe01cc87e,0xbcc7d1f6,0xcf0111c3,0xa1e8aac7,\n 0x1a908749,0xd44fbd9a,0xd0dadecb,0xd50ada38,\n 0x0339c32a,0xc6913667,0x8df9317c,0xe0b12b4f,\n 0xf79e59b7,0x43f5bb3a,0xf2d519ff,0x27d9459c,\n 0xbf97222c,0x15e6fc2a,0x0f91fc71,0x9b941525,\n 0xfae59361,0xceb69ceb,0xc2a86459,0x12baa8d1,\n 0xb6c1075e,0xe3056a0c,0x10d25065,0xcb03a442,\n 0xe0ec6e0e,0x1698db3b,0x4c98a0be,0x3278e964,\n 0x9f1f9532,0xe0d392df,0xd3a0342b,0x8971f21e,\n 0x1b0a7441,0x4ba3348c,0xc5be7120,0xc37632d8,\n 0xdf359f8d,0x9b992f2e,0xe60b6f47,0x0fe3f11d,\n 0xe54cda54,0x1edad891,0xce6279cf,0xcd3e7e6f,\n 0x1618b166,0xfd2c1d05,0x848fd2c5,0xf6fb2299,\n 0xf523f357,0xa6327623,0x93a83531,0x56cccd02,\n 0xacf08162,0x5a75ebb5,0x6e163697,0x88d273cc,\n 0xde966292,0x81b949d0,0x4c50901b,0x71c65614,\n 0xe6c6c7bd,0x327a140a,0x45e1d006,0xc3f27b9a,\n 0xc9aa53fd,0x62a80f00,0xbb25bfe2,0x35bdd2f6,\n 0x71126905,0xb2040222,0xb6cbcf7c,0xcd769c2b,\n 0x53113ec0,0x1640e3d3,0x38abbd60,0x2547adf0,\n 0xba38209c,0xf746ce76,0x77afa1c5,0x20756060,\n 0x85cbfe4e,0x8ae88dd8,0x7aaaf9b0,0x4cf9aa7e,\n 0x1948c25c,0x02fb8a8c,0x01c36ae4,0xd6ebe1f9,\n 0x90d4f869,0xa65cdea0,0x3f09252d,0xc208e69f,\n 0xb74e6132,0xce77e25b,0x578fdfe3,0x3ac372e6,\n ]\n ]\n \n \n \n \nclass BlowfishEngine(object):\n\n def __init__(self):\n  if BLOWFISH_P is None :\n   _init_constants()\n  self.P=list(BLOWFISH_P)\n  self.S=[list(box)for box in BLOWFISH_S]\n  \n  \n  \n  \n @staticmethod\n def key_to_words(data,size=18):\n  ''\n  \n  assert isinstance(data,bytes)\n  dlen=len(data)\n  if not dlen:\n  \n  \n   return [0]*size\n   \n   \n  data=repeat_string(data,size <<2)\n  \n  \n  return struct.unpack(\">%dI\"%(size,),data)\n  \n  \n  \n  \n def encipher(self,l,r):\n  ''\n  P,S=self.P,self.S\n  l ^=P[0]\n  i=1\n  while i <17:\n  \n   r=((((S[0][l >>24]+S[1][(l >>16)&0xff])^S[2][(l >>8)&0xff])+\n   S[3][l&0xff])&0xffffffff)^P[i]^r\n   \n   l,r=r,l\n   i +=1\n  return r ^P[17],l\n  \n  \n  \n def expand(self,key_words):\n  ''\n  assert len(key_words)>=18,\"key_words must be at least as large as P\"\n  P,S,encipher=self.P,self.S,self.encipher\n  \n  i=0\n  while i <18:\n   P[i]^=key_words[i]\n   i +=1\n   \n  i=l=r=0\n  while i <18:\n   P[i],P[i+1]=l,r=encipher(l,r)\n   i +=2\n   \n  for box in S:\n   i=0\n   while i <256:\n    box[i],box[i+1]=l,r=encipher(l,r)\n    i +=2\n    \n    \n    \n    \n def eks_salted_expand(self,key_words,salt_words):\n  ''\n  \n  \n  \n  assert len(key_words)>=18,\"key_words must be at least as large as P\"\n  salt_size=len(salt_words)\n  assert salt_size,\"salt_words must not be empty\"\n  assert not salt_size&1,\"salt_words must have even length\"\n  P,S,encipher=self.P,self.S,self.encipher\n  \n  i=0\n  while i <18:\n   P[i]^=key_words[i]\n   i +=1\n   \n  s=i=l=r=0\n  while i <18:\n   l ^=salt_words[s]\n   r ^=salt_words[s+1]\n   s +=2\n   if s ==salt_size:\n    s=0\n   P[i],P[i+1]=l,r=encipher(l,r)\n   i +=2\n   \n  for box in S:\n   i=0\n   while i <256:\n    l ^=salt_words[s]\n    r ^=salt_words[s+1]\n    s +=2\n    if s ==salt_size:\n     s=0\n    box[i],box[i+1]=l,r=encipher(l,r)\n    i +=2\n    \n def eks_repeated_expand(self,key_words,salt_words,rounds):\n  ''\n  expand=self.expand\n  n=0\n  while n <rounds:\n   expand(key_words)\n   expand(salt_words)\n   n +=1\n   \n def repeat_encipher(self,l,r,count):\n  ''\n  encipher=self.encipher\n  n=0\n  while n <count:\n   l,r=encipher(l,r)\n   n +=1\n  return l,r\n  \n  \n  \n  \n  \n  \n  \n  \n", ["passlib.utils", "struct"]], "passlib.crypto.scrypt": [".py", "''\n\n\n\n\n\n\n\nfrom __future__ import absolute_import\n\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\nfrom passlib import exc\nfrom passlib.utils import to_bytes\nfrom passlib.utils.compat import PYPY\n\n__all__=[\n\"validate\",\n\"scrypt\",\n]\n\n\n\n\n\n\n\n\n\n\nSCRYPT_MAXMEM=-1\n\n\nMAX_KEYLEN=((1 <<32)-1)*32\n\n\nMAX_RP=(1 <<30)-1\n\n\ndef validate(n,r,p):\n ''\n\n\n\n\n\n\n\n \n if r <1:\n  raise ValueError(\"r must be > 0: r=%r\"%r)\n  \n if p <1:\n  raise ValueError(\"p must be > 0: p=%r\"%p)\n  \n if r *p >MAX_RP:\n \n \n \n  raise ValueError(\"r * p must be < 2**30: r=%r, p=%r\"%(r,p))\n  \n if n <2 or n&(n -1):\n  raise ValueError(\"n must be > 1, and a power of 2: n=%r\"%n)\n  \n return True\n \n \nUINT32_SIZE=4\n\n\ndef estimate_maxmem(n,r,p,fudge=1.05):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n maxmem=r *(128 *p+32 *(n+2)*UINT32_SIZE)\n \n maxmem=int(maxmem *fudge)\n return maxmem\n \n \n \n \n \n \n \n \n \n_scrypt=None\n\n\nbackend=None\n\ndef scrypt(secret,salt,n,r,p=1,keylen=32):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n validate(n,r,p)\n secret=to_bytes(secret,param=\"secret\")\n salt=to_bytes(salt,param=\"salt\")\n if keylen <1:\n  raise ValueError(\"keylen must be at least 1\")\n if keylen >MAX_KEYLEN:\n  raise ValueError(\"keylen too large, must be <= %d\"%MAX_KEYLEN)\n return _scrypt(secret,salt,n,r,p,keylen)\n \n \ndef _load_builtin_backend():\n ''\n\n \n slowdown=10 if PYPY else 100\n warn(\"Using builtin scrypt backend, which is %dx slower than is required \"\n \"for adequate security. Installing scrypt support (via 'pip install scrypt') \"\n \"is strongly recommended\"%slowdown,exc.PasslibSecurityWarning)\n from ._builtin import ScryptEngine\n return ScryptEngine.execute\n \n \ndef _load_cffi_backend():\n ''\n\n\n \n try :\n  from scrypt import hash\n  return hash\n except ImportError:\n  pass\n  \n try :\n  import scrypt\n except ImportError as err:\n  if \"scrypt\"not in str(err):\n  \n  \n   warn(\"'scrypt' package failed to import correctly (possible installation issue?)\",\n   exc.PasslibWarning)\n   \n else :\n  warn(\"'scrypt' package is too old (lacks ``hash()`` method)\",exc.PasslibWarning)\n return None\n \n \ndef _load_stdlib_backend():\n ''\n\n\n \n try :\n \n  from hashlib import scrypt as stdlib_scrypt\n except ImportError:\n  return None\n  \n def stdlib_scrypt_wrapper(secret,salt,n,r,p,keylen):\n \n \n \n \n \n \n \n \n \n \n \n  maxmem=SCRYPT_MAXMEM\n  if maxmem <0:\n   maxmem=estimate_maxmem(n,r,p)\n  return stdlib_scrypt(password=secret,salt=salt,n=n,r=r,p=p,dklen=keylen,\n  maxmem=maxmem)\n  \n return stdlib_scrypt_wrapper\n \n \n \nbackend_values=(\"stdlib\",\"scrypt\",\"builtin\")\n\n\n_backend_loaders=dict(\nstdlib=_load_stdlib_backend,\nscrypt=_load_cffi_backend,\nbuiltin=_load_builtin_backend,\n)\n\n\ndef _set_backend(name,dryrun=False ):\n ''\n\n\n\n\n\n \n if name ==\"any\":\n  return\n elif name ==\"default\":\n  for name in backend_values:\n   try :\n    return _set_backend(name,dryrun=dryrun)\n   except exc.MissingBackendError:\n    continue\n  raise exc.MissingBackendError(\"no scrypt backends available\")\n else :\n  loader=_backend_loaders.get(name)\n  if not loader:\n   raise ValueError(\"unknown scrypt backend: %r\"%(name,))\n  hash=loader()\n  if not hash:\n   raise exc.MissingBackendError(\"scrypt backend %r not available\"%name)\n  if dryrun:\n   return\n  global _scrypt,backend\n  backend=name\n  _scrypt=hash\n  \n  \n_set_backend(\"default\")\n\n\ndef _has_backend(name):\n try :\n  _set_backend(name,dryrun=True )\n  return True\n except exc.MissingBackendError:\n  return False\n  \n  \n  \n  \n", ["__future__", "hashlib", "logging", "passlib", "passlib.crypto.scrypt._builtin", "passlib.utils", "passlib.utils.compat", "scrypt", "warnings"], 1], "passlib.crypto.scrypt._salsa": [".py", "''\n\n\n\n\ndef salsa20(input):\n ''\n\n\n\n \n \n b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15=input\n v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15=\\\n b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15\n \n i=0\n while i <4:\n \n  t=(v0+v12)&0xffffffff\n  v4 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v4+v0)&0xffffffff\n  v8 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v8+v4)&0xffffffff\n  v12 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v12+v8)&0xffffffff\n  v0 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v5+v1)&0xffffffff\n  v9 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v9+v5)&0xffffffff\n  v13 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v13+v9)&0xffffffff\n  v1 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v1+v13)&0xffffffff\n  v5 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v10+v6)&0xffffffff\n  v14 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v14+v10)&0xffffffff\n  v2 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v2+v14)&0xffffffff\n  v6 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v6+v2)&0xffffffff\n  v10 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v15+v11)&0xffffffff\n  v3 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v3+v15)&0xffffffff\n  v7 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v7+v3)&0xffffffff\n  v11 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v11+v7)&0xffffffff\n  v15 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v0+v3)&0xffffffff\n  v1 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v1+v0)&0xffffffff\n  v2 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v2+v1)&0xffffffff\n  v3 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v3+v2)&0xffffffff\n  v0 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v5+v4)&0xffffffff\n  v6 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v6+v5)&0xffffffff\n  v7 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v7+v6)&0xffffffff\n  v4 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v4+v7)&0xffffffff\n  v5 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v10+v9)&0xffffffff\n  v11 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v11+v10)&0xffffffff\n  v8 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v8+v11)&0xffffffff\n  v9 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v9+v8)&0xffffffff\n  v10 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v15+v14)&0xffffffff\n  v12 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v12+v15)&0xffffffff\n  v13 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v13+v12)&0xffffffff\n  v14 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v14+v13)&0xffffffff\n  v15 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  i +=1\n  \n b0=(b0+v0)&0xffffffff\n b1=(b1+v1)&0xffffffff\n b2=(b2+v2)&0xffffffff\n b3=(b3+v3)&0xffffffff\n b4=(b4+v4)&0xffffffff\n b5=(b5+v5)&0xffffffff\n b6=(b6+v6)&0xffffffff\n b7=(b7+v7)&0xffffffff\n b8=(b8+v8)&0xffffffff\n b9=(b9+v9)&0xffffffff\n b10=(b10+v10)&0xffffffff\n b11=(b11+v11)&0xffffffff\n b12=(b12+v12)&0xffffffff\n b13=(b13+v13)&0xffffffff\n b14=(b14+v14)&0xffffffff\n b15=(b15+v15)&0xffffffff\n \n return b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15\n \n \n \n \n", []], "passlib.crypto.scrypt._gen_files": [".py", "''\n\n\n\n\nimport os\n\n\n\n\n\n\n_SALSA_OPS=[\n\n\n\n\n\n\n\n\n(4,0,12,7),\n(8,4,0,9),\n(12,8,4,13),\n(0,12,8,18),\n\n\n\n(9,5,1,7),\n(13,9,5,9),\n(1,13,9,13),\n(5,1,13,18),\n\n\n\n(14,10,6,7),\n(2,14,10,9),\n(6,2,14,13),\n(10,6,2,18),\n\n\n\n(3,15,11,7),\n(7,3,15,9),\n(11,7,3,13),\n(15,11,7,18),\n\n\n\n\n(1,0,3,7),\n(2,1,0,9),\n(3,2,1,13),\n(0,3,2,18),\n\n\n\n(6,5,4,7),\n(7,6,5,9),\n(4,7,6,13),\n(5,4,7,18),\n\n\n\n(11,10,9,7),\n(8,11,10,9),\n(9,8,11,13),\n(10,9,8,18),\n\n\n\n(12,15,14,7),\n(13,12,15,9),\n(14,13,12,13),\n(15,14,13,18),\n]\n\ndef main():\n target=os.path.join(os.path.dirname(__file__),\"_salsa.py\")\n fh=file(target,\"w\")\n write=fh.write\n \n VNAMES=[\"v%d\"%i for i in range(16)]\n \n PAD=\" \"*4\n PAD2=\" \"*8\n PAD3=\" \"*12\n TLIST=\", \".join(\"b%d\"%i for i in range(16))\n VLIST=\", \".join(VNAMES)\n kwds=dict(\n VLIST=VLIST,\n TLIST=TLIST,\n )\n \n write('''\\\n\"\"\"passlib.utils.scrypt._salsa - salsa 20/8 core, autogenerated by _gen_salsa.py\"\"\"\n#=================================================================\n# salsa function\n#=================================================================\n\ndef salsa20(input):\n    \\\"\"\"apply the salsa20/8 core to the provided input\n\n    :args input: input list containing 16 32-bit integers\n    :returns: result list containing 16 32-bit integers\n    \\\"\"\"\n\n    %(TLIST)s = input\n    %(VLIST)s = \\\\\n        %(TLIST)s\n\n    i = 0\n    while i < 4:\n'''%kwds)\n \n for idx,(target,source1,source2,rotate)in enumerate(_SALSA_OPS):\n  write('''\\\n        # salsa op %(idx)d: [%(it)d] ^= ([%(is1)d]+[%(is2)d])<<<%(rot1)d\n        t = (%(src1)s + %(src2)s) & 0xffffffff\n        %(dst)s ^= ((t & 0x%(rmask)08x) << %(rot1)d) | (t >> %(rot2)d)\n\n'''%dict(\n  idx=idx,is1=source1,is2=source2,it=target,\n  src1=VNAMES[source1],\n  src2=VNAMES[source2],\n  dst=VNAMES[target],\n  rmask=(1 <<(32 -rotate))-1,\n  rot1=rotate,\n  rot2=32 -rotate,\n  ))\n  \n write('''\\\n        i += 1\n\n''')\n \n for idx in range(16):\n  write(PAD+\"b%d = (b%d + v%d) & 0xffffffff\\n\"%(idx,idx,idx))\n  \n write('''\\\n\n    return %(TLIST)s\n\n#=================================================================\n# eof\n#=================================================================\n'''%kwds)\n \nif __name__ ==\"__main__\":\n main()\n \n \n \n \n", ["os"]], "passlib.crypto.scrypt._builtin": [".py", "''\n\n\n\n\nimport operator\nimport struct\n\nfrom passlib.utils.compat import izip\nfrom passlib.crypto.digest import pbkdf2_hmac\nfrom passlib.crypto.scrypt._salsa import salsa20\n\n__all__=[\n\"ScryptEngine\",\n]\n\n\n\n\nclass ScryptEngine(object):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n n=0\n r=0\n p=0\n \n \n smix_bytes=0\n iv_bytes=0\n bmix_len=0\n bmix_half_len=0\n bmix_struct=None\n integerify=None\n \n \n \n \n @classmethod\n def execute(cls,secret,salt,n,r,p,keylen):\n  ''\n  return cls(n,r,p).run(secret,salt,keylen)\n  \n  \n  \n  \n def __init__(self,n,r,p):\n \n  self.n=n\n  self.r=r\n  self.p=p\n  self.smix_bytes=r <<7\n  self.iv_bytes=self.smix_bytes *p\n  self.bmix_len=bmix_len=r <<5\n  self.bmix_half_len=r <<4\n  assert struct.calcsize(\"I\")==4\n  self.bmix_struct=struct.Struct(\"<\"+str(bmix_len)+\"I\")\n  \n  \n  if r ==1:\n   self.bmix=self._bmix_1\n   \n   \n   \n   \n   \n   \n  if n <=0xFFFFffff:\n   integerify=operator.itemgetter(-16)\n  else :\n   assert n <=0xFFFFffffFFFFffff\n   ig1=operator.itemgetter(-16)\n   ig2=operator.itemgetter(-17)\n   def integerify(X):\n    return ig1(X)|(ig2(X)<<32)\n  self.integerify=integerify\n  \n  \n  \n  \n def run(self,secret,salt,keylen):\n  ''\n\n\n\n\n\n\n  \n  \n  iv_bytes=self.iv_bytes\n  input=pbkdf2_hmac(\"sha256\",secret,salt,rounds=1,keylen=iv_bytes)\n  \n  \n  \n  smix=self.smix\n  if self.p ==1:\n   output=smix(input)\n  else :\n  \n  \n   smix_bytes=self.smix_bytes\n   output=b''.join(\n   smix(input[offset:offset+smix_bytes])\n   for offset in range(0,iv_bytes,smix_bytes)\n   )\n   \n   \n  return pbkdf2_hmac(\"sha256\",secret,output,rounds=1,keylen=keylen)\n  \n  \n  \n  \n def smix(self,input):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  bmix=self.bmix\n  bmix_struct=self.bmix_struct\n  integerify=self.integerify\n  n=self.n\n  \n  \n  \n  buffer=list(bmix_struct.unpack(input))\n  \n  \n  \n  \n  \n  \n  \n  \n  def vgen():\n   i=0\n   while i <n:\n    last=tuple(buffer)\n    yield last\n    bmix(last,buffer)\n    i +=1\n  V=list(vgen())\n  \n  \n  \n  \n  \n  get_v_elem=V.__getitem__\n  n_mask=n -1\n  i=0\n  while i <n:\n   j=integerify(buffer)&n_mask\n   result=tuple(a ^b for a,b in izip(buffer,get_v_elem(j)))\n   bmix(result,buffer)\n   i +=1\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  return bmix_struct.pack(*buffer)\n  \n  \n  \n  \n def bmix(self,source,target):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  half=self.bmix_half_len\n  tmp=source[-16:]\n  siter=iter(source)\n  j=0\n  while j <half:\n   jn=j+16\n   target[j:jn]=tmp=salsa20(a ^b for a,b in izip(tmp,siter))\n   target[half+j:half+jn]=tmp=salsa20(a ^b for a,b in izip(tmp,siter))\n   j=jn\n   \n def _bmix_1(self,source,target):\n  ''\n  B=source[16:]\n  target[:16]=tmp=salsa20(a ^b for a,b in izip(B,iter(source)))\n  target[16:]=salsa20(a ^b for a,b in izip(tmp,B))\n  \n  \n  \n  \n  \n  \n  \n  \n", ["operator", "passlib.crypto.digest", "passlib.crypto.scrypt._salsa", "passlib.utils.compat", "struct"]], "passlib.ext": [".py", "", [], 1], "passlib.ext.django.models": [".py", "''\n\n\n\n\n\n\nfrom passlib.context import CryptContext\nfrom passlib.ext.django.utils import DjangoContextAdapter\n\n__all__=[\"password_context\"]\n\n\n\n\n\n\nadapter=DjangoContextAdapter()\n\n\n\npassword_context=adapter.context\n\n\ncontext_changed=adapter.reset_hashers\n\n\n\n\n\n\nadapter.load_model()\n\n\n\n\n", ["passlib.context", "passlib.ext.django.utils"]], "passlib.ext.django": [".py", "''\n\n\n\n\n\n", [], 1], "passlib.ext.django.utils": [".py", "''\n\n\n\n\nfrom functools import update_wrapper,wraps\nimport logging ;log=logging.getLogger(__name__)\nimport sys\nimport weakref\nfrom warnings import warn\n\ntry :\n from django import VERSION as DJANGO_VERSION\n log.debug(\"found django %r installation\",DJANGO_VERSION)\nexcept ImportError:\n log.debug(\"django installation not found\")\n DJANGO_VERSION=()\n \nfrom passlib import exc,registry\nfrom passlib.context import CryptContext\nfrom passlib.exc import PasslibRuntimeWarning\nfrom passlib.utils.compat import get_method_function,iteritems,OrderedDict,unicode\nfrom passlib.utils.decor import memoized_property\n\n__all__=[\n\"DJANGO_VERSION\",\n\"MIN_DJANGO_VERSION\",\n\"get_preset_config\",\n\"quirks\",\n]\n\n\nMIN_DJANGO_VERSION=(1,8)\n\n\n\n\n\nclass quirks:\n\n\n\n none_causes_check_password_error=DJANGO_VERSION >=(2,1)\n \n \n empty_is_usable_password=DJANGO_VERSION >=(2,1)\n \n \n invalid_is_usable_password=DJANGO_VERSION >=(2,1)\n \n \n \n \n \n \n_preset_map={\n\"django-1.0\":\"django10_context\",\n\"django-1.4\":\"django14_context\",\n\"django-1.6\":\"django16_context\",\n\"django-latest\":\"django_context\",\n}\n\ndef get_preset_config(name):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n if name ==\"django-default\":\n  if not DJANGO_VERSION:\n   raise ValueError(\"can't resolve django-default preset, \"\n   \"django not installed\")\n  name=\"django-1.6\"\n if name ==\"passlib-default\":\n  return PASSLIB_DEFAULT\n try :\n  attr=_preset_map[name]\n except KeyError:\n  raise ValueError(\"unknown preset config name: %r\"%name)\n import passlib.apps\n return getattr(passlib.apps,attr).to_string()\n \n \nPASSLIB_DEFAULT=\"\"\"\n[passlib]\n\n; list of schemes supported by configuration\n; currently all django 1.6, 1.4, and 1.0 hashes,\n; and three common modular crypt format hashes.\nschemes =\n    django_pbkdf2_sha256, django_pbkdf2_sha1, django_bcrypt, django_bcrypt_sha256,\n    django_salted_sha1, django_salted_md5, django_des_crypt, hex_md5,\n    sha512_crypt, bcrypt, phpass\n\n; default scheme to use for new hashes\ndefault = django_pbkdf2_sha256\n\n; hashes using these schemes will automatically be re-hashed\n; when the user logs in (currently all django 1.0 hashes)\ndeprecated =\n    django_pbkdf2_sha1, django_salted_sha1, django_salted_md5,\n    django_des_crypt, hex_md5\n\n; sets some common options, including minimum rounds for two primary hashes.\n; if a hash has less than this number of rounds, it will be re-hashed.\nsha512_crypt__min_rounds = 80000\ndjango_pbkdf2_sha256__min_rounds = 10000\n\n; set somewhat stronger iteration counts for ``User.is_staff``\nstaff__sha512_crypt__default_rounds = 100000\nstaff__django_pbkdf2_sha256__default_rounds = 12500\n\n; and even stronger ones for ``User.is_superuser``\nsuperuser__sha512_crypt__default_rounds = 120000\nsuperuser__django_pbkdf2_sha256__default_rounds = 15000\n\"\"\"\n\n\n\n\n\n\nPASSLIB_WRAPPER_PREFIX=\"passlib_\"\n\n\n\nDJANGO_COMPAT_PREFIX=\"django_\"\n\n\n_other_django_hashes=set([\"hex_md5\"])\n\ndef _wrap_method(method):\n ''\n @wraps(method)\n def wrapper(*args,**kwds):\n  return method(*args,**kwds)\n return wrapper\n \n \n \n \nclass DjangoTranslator(object):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n context=None\n \n \n \n _django_hasher_cache=None\n \n \n _django_unsalted_sha1=None\n \n \n \n _passlib_hasher_cache=None\n \n \n \n \n \n def __init__(self,context=None ,**kwds):\n  super(DjangoTranslator,self).__init__(**kwds)\n  if context is not None :\n   self.context=context\n   \n  self._django_hasher_cache=weakref.WeakKeyDictionary()\n  self._passlib_hasher_cache=weakref.WeakValueDictionary()\n  \n def reset_hashers(self):\n  self._django_hasher_cache.clear()\n  self._passlib_hasher_cache.clear()\n  self._django_unsalted_sha1=None\n  \n def _get_passlib_hasher(self,passlib_name):\n  ''\n\n  \n  context=self.context\n  if context is None :\n   return registry.get_crypt_handler(passlib_name)\n  else :\n   return context.handler(passlib_name)\n   \n   \n   \n   \n   \n def passlib_to_django_name(self,passlib_name):\n  ''\n\n  \n  return self.passlib_to_django(passlib_name).algorithm\n  \n  \n  \n  \n def passlib_to_django(self,passlib_hasher,cached=True ):\n  ''\n\n\n\n\n\n\n\n  \n  \n  if not hasattr(passlib_hasher,\"name\"):\n   passlib_hasher=self._get_passlib_hasher(passlib_hasher)\n   \n   \n  if cached:\n   cache=self._django_hasher_cache\n   try :\n    return cache[passlib_hasher]\n   except KeyError:\n    pass\n   result=cache[passlib_hasher]=\\\n   self.passlib_to_django(passlib_hasher,cached=False )\n   return result\n   \n   \n  django_name=getattr(passlib_hasher,\"django_name\",None )\n  if django_name:\n   return self._create_django_hasher(django_name)\n  else :\n   return _PasslibHasherWrapper(passlib_hasher)\n   \n _builtin_django_hashers=dict(\n md5=\"MD5PasswordHasher\",\n )\n \n if DJANGO_VERSION >(2,1):\n \n \n  _builtin_django_hashers.update(\n  bcrypt=\"BCryptPasswordHasher\",\n  )\n  \n def _create_django_hasher(self,django_name):\n  ''\n\n\n  \n  \n  module=sys.modules.get(\"passlib.ext.django.models\")\n  if module is None or not module.adapter.patched:\n   from django.contrib.auth.hashers import get_hasher\n   try :\n    return get_hasher(django_name)\n   except ValueError as err:\n    if not str(err).startswith(\"Unknown password hashing algorithm\"):\n     raise\n  else :\n  \n  \n  \n   get_hashers=module.adapter._manager.getorig(\"django.contrib.auth.hashers:get_hashers\").__wrapped__\n   for hasher in get_hashers():\n    if hasher.algorithm ==django_name:\n     return hasher\n     \n     \n     \n  path=self._builtin_django_hashers.get(django_name)\n  if path:\n   if \".\"not in path:\n    path=\"django.contrib.auth.hashers.\"+path\n   from django.utils.module_loading import import_string\n   return import_string(path)()\n   \n  raise ValueError(\"unknown hasher: %r\"%django_name)\n  \n  \n  \n  \n  \n def django_to_passlib_name(self,django_name):\n  ''\n\n  \n  return self.django_to_passlib(django_name).name\n  \n def django_to_passlib(self,django_name,cached=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if hasattr(django_name,\"algorithm\"):\n  \n  \n   if isinstance(django_name,_PasslibHasherWrapper):\n    return django_name.passlib_handler\n    \n    \n   django_name=django_name.algorithm\n   \n   \n  if cached:\n   cache=self._passlib_hasher_cache\n   try :\n    return cache[django_name]\n   except KeyError:\n    pass\n   result=cache[django_name]=\\\n   self.django_to_passlib(django_name,cached=False )\n   return result\n   \n   \n  if django_name.startswith(PASSLIB_WRAPPER_PREFIX):\n   passlib_name=django_name[len(PASSLIB_WRAPPER_PREFIX):]\n   return self._get_passlib_hasher(passlib_name)\n   \n   \n  if django_name ==\"default\":\n   context=self.context\n   if context is None :\n    raise TypeError(\"can't determine default scheme w/ context\")\n   return context.handler()\n   \n   \n   \n   \n  if django_name ==\"unsalted_sha1\":\n   django_name=\"sha1\"\n   \n   \n   \n   \n  context=self.context\n  if context is None :\n  \n  \n   candidates=(\n   registry.get_crypt_handler(passlib_name)\n   for passlib_name in registry.list_crypt_handlers()\n   if passlib_name.startswith(DJANGO_COMPAT_PREFIX)or\n   passlib_name in _other_django_hashes\n   )\n  else :\n  \n   candidates=context.schemes(resolve=True )\n  for handler in candidates:\n   if getattr(handler,\"django_name\",None )==django_name:\n    return handler\n    \n    \n    \n    \n    \n  raise ValueError(\"can't translate django name to passlib name: %r\"%\n  (django_name,))\n  \n  \n  \n  \n  \n def resolve_django_hasher(self,django_name,cached=True ):\n  ''\n\n  \n  \n  if hasattr(django_name,\"algorithm\"):\n   return django_name\n   \n   \n  passlib_hasher=self.django_to_passlib(django_name,cached=cached)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if django_name ==\"unsalted_sha1\"and passlib_hasher.name ==\"django_salted_sha1\":\n   if not cached:\n    return self._create_django_hasher(django_name)\n   result=self._django_unsalted_sha1\n   if result is None :\n    result=self._django_unsalted_sha1=self._create_django_hasher(django_name)\n   return result\n   \n   \n  return self.passlib_to_django(passlib_hasher,cached=cached)\n  \n  \n  \n  \n  \n  \n  \n  \nclass DjangoContextAdapter(DjangoTranslator):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n context=None\n \n \n \n _orig_make_password=None\n \n \n is_password_usable=None\n \n \n _manager=None\n \n \n enabled=True\n \n \n patched=False\n \n \n \n \n def __init__(self,context=None ,get_user_category=None ,**kwds):\n \n \n  self.log=logging.getLogger(__name__+\".DjangoContextAdapter\")\n  \n  \n  if context is None :\n   context=CryptContext()\n  super(DjangoContextAdapter,self).__init__(context=context,**kwds)\n  \n  \n  if get_user_category:\n   assert callable(get_user_category)\n   self.get_user_category=get_user_category\n   \n   \n  try :\n   from functools import lru_cache\n  except ImportError:\n   from django.utils.lru_cache import lru_cache\n  self.get_hashers=lru_cache()(self.get_hashers)\n  \n  \n  from django.contrib.auth.hashers import make_password\n  if make_password.__module__.startswith(\"passlib.\"):\n   make_password=_PatchManager.peek_unpatched_func(make_password)\n  self._orig_make_password=make_password\n  \n  \n  from django.contrib.auth.hashers import is_password_usable\n  self.is_password_usable=is_password_usable\n  \n  \n  mlog=logging.getLogger(__name__+\".DjangoContextAdapter._manager\")\n  self._manager=_PatchManager(log=mlog)\n  \n def reset_hashers(self):\n  ''\n\n  \n  \n  from django.contrib.auth.hashers import reset_hashers\n  reset_hashers(setting=\"PASSWORD_HASHERS\")\n  \n  \n  super(DjangoContextAdapter,self).reset_hashers()\n  \n  \n  \n  \n  \n  \n def get_hashers(self):\n  ''\n\n\n  \n  passlib_to_django=self.passlib_to_django\n  return [passlib_to_django(hasher)\n  for hasher in self.context.schemes(resolve=True )]\n  \n def get_hasher(self,algorithm=\"default\"):\n  ''\n\n\n  \n  return self.resolve_django_hasher(algorithm)\n  \n def identify_hasher(self,encoded):\n  ''\n\n\n  \n  handler=self.context.identify(encoded,resolve=True ,required=True )\n  if handler.name ==\"django_salted_sha1\"and encoded.startswith(\"sha1$$\"):\n  \n  \n  \n   return self.get_hasher(\"unsalted_sha1\")\n  return self.passlib_to_django(handler)\n  \n  \n  \n  \n  \n def make_password(self,password,salt=None ,hasher=\"default\"):\n  ''\n\n  \n  if password is None :\n   return self._orig_make_password(None )\n   \n   \n  passlib_hasher=self.django_to_passlib(hasher)\n  if \"salt\"not in passlib_hasher.setting_kwds:\n  \n   pass\n  elif hasher.startswith(\"unsalted_\"):\n  \n  \n  \n   passlib_hasher=passlib_hasher.using(salt=\"\")\n  elif salt:\n  \n  \n   passlib_hasher=passlib_hasher.using(salt=salt)\n  return passlib_hasher.hash(password)\n  \n def check_password(self,password,encoded,setter=None ,preferred=\"default\"):\n  ''\n\n  \n  \n  \n  \n  \n  if password is None or not self.is_password_usable(encoded):\n   return False\n   \n   \n  context=self.context\n  try :\n   correct=context.verify(password,encoded)\n  except exc.UnknownHashError:\n  \n  \n   return False\n   \n  if not (correct and setter):\n   return correct\n   \n   \n  if preferred ==\"default\":\n   if not context.needs_update(encoded,secret=password):\n    return correct\n  else :\n  \n  \n  \n  \n  \n  \n   hasher=self.django_to_passlib(preferred)\n   if (hasher.identify(encoded)and\n   not hasher.needs_update(encoded,secret=password)):\n   \n   \n    return correct\n    \n    \n    \n  setter(password)\n  return correct\n  \n  \n  \n  \n  \n def user_check_password(self,user,password):\n  ''\n\n  \n  if password is None :\n   return False\n  hash=user.password\n  if not self.is_password_usable(hash):\n   return False\n  cat=self.get_user_category(user)\n  try :\n   ok,new_hash=self.context.verify_and_update(password,hash,category=cat)\n  except exc.UnknownHashError:\n  \n  \n   return False\n  if ok and new_hash is not None :\n  \n   user.password=new_hash\n   user.save()\n  return ok\n  \n def user_set_password(self,user,password):\n  ''\n\n  \n  if password is None :\n   user.set_unusable_password()\n  else :\n   cat=self.get_user_category(user)\n   user.password=self.context.hash(password,category=cat)\n   \n def get_user_category(self,user):\n  ''\n\n\n\n\n  \n  if user.is_superuser:\n   return \"superuser\"\n  elif user.is_staff:\n   return \"staff\"\n  else :\n   return None\n   \n   \n   \n   \n   \n HASHERS_PATH=\"django.contrib.auth.hashers\"\n MODELS_PATH=\"django.contrib.auth.models\"\n USER_CLASS_PATH=MODELS_PATH+\":User\"\n FORMS_PATH=\"django.contrib.auth.forms\"\n \n \n patch_locations=[\n \n \n \n \n \n (USER_CLASS_PATH+\".check_password\",\"user_check_password\",dict(method=True )),\n (USER_CLASS_PATH+\".set_password\",\"user_set_password\",dict(method=True )),\n \n \n \n \n (HASHERS_PATH+\":\",\"check_password\"),\n (HASHERS_PATH+\":\",\"make_password\"),\n (HASHERS_PATH+\":\",\"get_hashers\"),\n (HASHERS_PATH+\":\",\"get_hasher\"),\n (HASHERS_PATH+\":\",\"identify_hasher\"),\n \n \n \n \n (MODELS_PATH+\":\",\"check_password\"),\n (MODELS_PATH+\":\",\"make_password\"),\n (FORMS_PATH+\":\",\"get_hasher\"),\n (FORMS_PATH+\":\",\"identify_hasher\"),\n \n ]\n \n def install_patch(self):\n  ''\n\n  \n  \n  log=self.log\n  if self.patched:\n   log.warning(\"monkeypatching already applied, refusing to reapply\")\n   return False\n   \n   \n  if DJANGO_VERSION <MIN_DJANGO_VERSION:\n   raise RuntimeError(\"passlib.ext.django requires django >= %s\"%\n   (MIN_DJANGO_VERSION,))\n   \n   \n  log.debug(\"preparing to monkeypatch django ...\")\n  \n  \n  manager=self._manager\n  for record in self.patch_locations:\n   if len(record)==2:\n    record +=({},)\n   target,source,opts=record\n   if target.endswith((\":\",\",\")):\n    target +=source\n   value=getattr(self,source)\n   if opts.get(\"method\"):\n   \n   \n   \n    value=_wrap_method(value)\n   manager.patch(target,value)\n   \n   \n  self.reset_hashers()\n  \n  \n  self.patched=True\n  log.debug(\"... finished monkeypatching django\")\n  return True\n  \n def remove_patch(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  log=self.log\n  manager=self._manager\n  \n  if self.patched:\n   log.debug(\"removing django monkeypatching...\")\n   manager.unpatch_all(unpatch_conflicts=True )\n   self.context.load({})\n   self.patched=False\n   self.reset_hashers()\n   log.debug(\"...finished removing django monkeypatching\")\n   return True\n   \n  if manager.isactive():\n   log.warning(\"reverting partial monkeypatching of django...\")\n   manager.unpatch_all()\n   self.context.load({})\n   self.reset_hashers()\n   log.debug(\"...finished removing django monkeypatching\")\n   return True\n   \n  log.debug(\"django not monkeypatched\")\n  return False\n  \n  \n  \n  \n  \n def load_model(self):\n  ''\n\n  \n  self._load_settings()\n  if self.enabled:\n   try :\n    self.install_patch()\n   except :\n   \n    self.remove_patch()\n    raise\n  else :\n   if self.patched:\n    log.error(\"didn't expect monkeypatching would be applied!\")\n   self.remove_patch()\n  log.debug(\"passlib.ext.django loaded\")\n  \n def _load_settings(self):\n  ''\n\n  \n  from django.conf import settings\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  _UNSET=object()\n  config=getattr(settings,\"PASSLIB_CONFIG\",_UNSET)\n  if config is _UNSET:\n  \n   config=getattr(settings,\"PASSLIB_CONTEXT\",_UNSET)\n  if config is _UNSET:\n   config=\"passlib-default\"\n  if config is None :\n   warn(\"setting PASSLIB_CONFIG=None is deprecated, \"\n   \"and support will be removed in Passlib 1.8, \"\n   \"use PASSLIB_CONFIG='disabled' instead.\",\n   DeprecationWarning)\n   config=\"disabled\"\n  elif not isinstance(config,(unicode,bytes,dict)):\n   raise exc.ExpectedTypeError(config,\"str or dict\",\"PASSLIB_CONFIG\")\n   \n   \n  get_category=getattr(settings,\"PASSLIB_GET_CATEGORY\",None )\n  if get_category and not callable(get_category):\n   raise exc.ExpectedTypeError(get_category,\"callable\",\"PASSLIB_GET_CATEGORY\")\n   \n   \n  if config ==\"disabled\":\n   self.enabled=False\n   return\n  else :\n   self.__dict__.pop(\"enabled\",None )\n   \n   \n  if isinstance(config,str)and '\\n'not in config:\n   config=get_preset_config(config)\n   \n   \n  if get_category:\n   self.get_user_category=get_category\n  else :\n   self.__dict__.pop(\"get_category\",None )\n   \n   \n  self.context.load(config)\n  self.reset_hashers()\n  \n  \n  \n  \n  \n  \n  \n  \n_GEN_SALT_SIGNAL=\"--!!!generate-new-salt!!!--\"\n\nclass ProxyProperty(object):\n ''\n \n def __init__(self,attr):\n  self.attr=attr\n  \n def __get__(self,obj,cls):\n  if obj is None :\n   cls=obj\n  return getattr(obj,self.attr)\n  \n def __set__(self,obj,value):\n  setattr(obj,self.attr,value)\n  \n def __delete__(self,obj):\n  delattr(obj,self.attr)\n  \n  \nclass _PasslibHasherWrapper(object):\n ''\n\n\n\n\n\n \n \n \n \n \n \n passlib_handler=None\n \n \n \n \n \n \n \n \n \n def __init__(self,passlib_handler):\n \n  if getattr(passlib_handler,\"django_name\",None ):\n   raise ValueError(\"handlers that reflect an official django \"\n   \"hasher shouldn't be wrapped: %r\"%\n   (passlib_handler.name,))\n  if passlib_handler.is_disabled:\n  \n   raise ValueError(\"can't wrap disabled-hash handlers: %r\"%\n   (passlib_handler.name))\n  self.passlib_handler=passlib_handler\n  \n  \n  if self._has_rounds:\n   self.rounds=passlib_handler.default_rounds\n   self.iterations=ProxyProperty(\"rounds\")\n   \n   \n   \n   \n def __repr__(self):\n  return \"<PasslibHasherWrapper handler=%r>\"%self.passlib_handler\n  \n  \n  \n  \n  \n @memoized_property\n def __name__(self):\n  return \"Passlib_%s_PasswordHasher\"%self.passlib_handler.name.title()\n  \n @memoized_property\n def _has_rounds(self):\n  return \"rounds\"in self.passlib_handler.setting_kwds\n  \n @memoized_property\n def _translate_kwds(self):\n  ''\n\n\n  \n  out=dict(checksum=\"hash\")\n  if self._has_rounds and \"pbkdf2\"in self.passlib_handler.name:\n   out['rounds']='iterations'\n  return out\n  \n  \n  \n  \n  \n @memoized_property\n def algorithm(self):\n  return PASSLIB_WRAPPER_PREFIX+self.passlib_handler.name\n  \n  \n  \n  \n def salt(self):\n \n \n \n  return _GEN_SALT_SIGNAL\n  \n def verify(self,password,encoded):\n  return self.passlib_handler.verify(password,encoded)\n  \n def encode(self,password,salt=None ,rounds=None ,iterations=None ):\n  kwds={}\n  if salt is not None and salt !=_GEN_SALT_SIGNAL:\n   kwds['salt']=salt\n  if self._has_rounds:\n   if rounds is not None :\n    kwds['rounds']=rounds\n   elif iterations is not None :\n    kwds['rounds']=iterations\n   else :\n    kwds['rounds']=self.rounds\n  elif rounds is not None or iterations is not None :\n   warn(\"%s.hash(): 'rounds' and 'iterations' are ignored\"%self.__name__)\n  handler=self.passlib_handler\n  if kwds:\n   handler=handler.using(**kwds)\n  return handler.hash(password)\n  \n def safe_summary(self,encoded):\n  from django.contrib.auth.hashers import mask_hash\n  from django.utils.translation import ugettext_noop as _\n  handler=self.passlib_handler\n  items=[\n  \n  \n  (_('algorithm'),handler.name),\n  ]\n  if hasattr(handler,\"parsehash\"):\n   kwds=handler.parsehash(encoded,sanitize=mask_hash)\n   for key,value in iteritems(kwds):\n    key=self._translate_kwds.get(key,key)\n    items.append((_(key),value))\n  return OrderedDict(items)\n  \n def must_update(self,encoded):\n \n \n \n  if self._has_rounds:\n  \n  \n   subcls=self.passlib_handler.using(min_rounds=self.rounds,max_rounds=self.rounds)\n   if subcls.needs_update(encoded):\n    return True\n  return False\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_UNSET=object()\n\nclass _PatchManager(object):\n ''\n \n \n \n \n \n \n \n \n def __init__(self,log=None ):\n \n \n  self.log=log or logging.getLogger(__name__+\"._PatchManager\")\n  self._state={}\n  \n def isactive(self):\n  return bool(self._state)\n  \n  \n  \n __bool__=__nonzero__=isactive\n \n def _import_path(self,path):\n  ''\n  name,attr=path.split(\":\")\n  obj=__import__(name,fromlist=[attr],level=0)\n  while '.'in attr:\n   head,attr=attr.split(\".\",1)\n   obj=getattr(obj,head)\n  return obj,attr\n  \n @staticmethod\n def _is_same_value(left,right):\n  ''\n  return get_method_function(left)==get_method_function(right)\n  \n  \n  \n  \n def _get_path(self,key,default=_UNSET):\n  obj,attr=self._import_path(key)\n  return getattr(obj,attr,default)\n  \n def get(self,path,default=None ):\n  ''\n  return self._get_path(path,default)\n  \n def getorig(self,path,default=None ):\n  ''\n  try :\n   value,_=self._state[path]\n  except KeyError:\n   value=self._get_path(path)\n  return default if value is _UNSET else value\n  \n def check_all(self,strict=False ):\n  ''\n  same=self._is_same_value\n  for path,(orig,expected)in iteritems(self._state):\n   if same(self._get_path(path),expected):\n    continue\n   msg=\"another library has patched resource: %r\"%path\n   if strict:\n    raise RuntimeError(msg)\n   else :\n    warn(msg,PasslibRuntimeWarning)\n    \n    \n    \n    \n def _set_path(self,path,value):\n  obj,attr=self._import_path(path)\n  if value is _UNSET:\n   if hasattr(obj,attr):\n    delattr(obj,attr)\n  else :\n   setattr(obj,attr,value)\n   \n def patch(self,path,value,wrap=False ):\n  ''\n  assert value !=_UNSET\n  current=self._get_path(path)\n  try :\n   orig,expected=self._state[path]\n  except KeyError:\n   self.log.debug(\"patching resource: %r\",path)\n   orig=current\n  else :\n   self.log.debug(\"modifying resource: %r\",path)\n   if not self._is_same_value(current,expected):\n    warn(\"overridding resource another library has patched: %r\"\n    %path,PasslibRuntimeWarning)\n  if wrap:\n   assert callable(value)\n   wrapped=orig\n   wrapped_by=value\n   def wrapper(*args,**kwds):\n    return wrapped_by(wrapped,*args,**kwds)\n   update_wrapper(wrapper,value)\n   value=wrapper\n  if callable(value):\n  \n   get_method_function(value)._patched_original_value=orig\n  self._set_path(path,value)\n  self._state[path]=(orig,value)\n  \n @classmethod\n def peek_unpatched_func(cls,value):\n  return value._patched_original_value\n  \n  \n  \n  \n  \n  \n def monkeypatch(self,parent,name=None ,enable=True ,wrap=False ):\n  ''\n  def builder(func):\n   if enable:\n    sep=\".\"if \":\"in parent else \":\"\n    path=parent+sep+(name or func.__name__)\n    self.patch(path,func,wrap=wrap)\n   return func\n  if callable(name):\n  \n   func=name\n   name=None\n   builder(func)\n   return None\n  return builder\n  \n  \n  \n  \n def unpatch(self,path,unpatch_conflicts=True ):\n  try :\n   orig,expected=self._state[path]\n  except KeyError:\n   return\n  current=self._get_path(path)\n  self.log.debug(\"unpatching resource: %r\",path)\n  if not self._is_same_value(current,expected):\n   if unpatch_conflicts:\n    warn(\"reverting resource another library has patched: %r\"\n    %path,PasslibRuntimeWarning)\n   else :\n    warn(\"not reverting resource another library has patched: %r\"\n    %path,PasslibRuntimeWarning)\n    del self._state[path]\n    return\n  self._set_path(path,orig)\n  del self._state[path]\n  \n def unpatch_all(self,**kwds):\n  for key in list(self._state):\n   self.unpatch(key,**kwds)\n   \n   \n   \n   \n   \n   \n   \n   \n", ["django", "django.conf", "django.contrib.auth.hashers", "django.utils.lru_cache", "django.utils.module_loading", "django.utils.translation", "functools", "logging", "passlib", "passlib.apps", "passlib.context", "passlib.exc", "passlib.utils.compat", "passlib.utils.decor", "sys", "warnings", "weakref"]], "passlib.tests.test_ext_django": [".py", "''\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\nimport logging ;log=logging.getLogger(__name__)\nimport sys\nimport re\n\n\nfrom passlib import apps as _apps,exc,registry\nfrom passlib.apps import django10_context,django14_context,django16_context\nfrom passlib.context import CryptContext\nfrom passlib.ext.django.utils import (\nDJANGO_VERSION,MIN_DJANGO_VERSION,DjangoTranslator,quirks,\n)\nfrom passlib.utils.compat import iteritems,get_method_function,u\nfrom passlib.utils.decor import memoized_property\n\nfrom passlib.tests.utils import TestCase,TEST_MODE,handler_derived_from\nfrom passlib.tests.test_handlers import get_handler_case\n\n__all__=[\n\"DjangoBehaviorTest\",\n\"ExtensionBehaviorTest\",\n\"DjangoExtensionTest\",\n\n\"_ExtensionSupport\",\n\"_ExtensionTest\",\n]\n\n\n\n\n\nhas_min_django=DJANGO_VERSION >=MIN_DJANGO_VERSION\n\n\n\n\n\n\nif has_min_django:\n\n\n\n from django.conf import settings,LazySettings\n \n if not isinstance(settings,LazySettings):\n \n \n  raise RuntimeError(\"expected django.conf.settings to be LazySettings: %r\"%(settings,))\n  \n  \n if not settings.configured:\n  settings.configure()\n  \n  \n  \n  \n  \n from django.apps import apps\n apps.populate([\"django.contrib.contenttypes\",\"django.contrib.auth\"])\n \n \n \nif DJANGO_VERSION >=(3,2):\n log.info(\"this release hasn't been tested against Django %r\",DJANGO_VERSION)\n \n \n \n \n \n \nUNSET=object()\n\ndef update_settings(**kwds):\n ''\n for k,v in iteritems(kwds):\n  if v is UNSET:\n   if hasattr(settings,k):\n    delattr(settings,k)\n  else :\n   setattr(settings,k,v)\n   \nif has_min_django:\n from django.contrib.auth.models import User\n \n class FakeUser(User):\n  ''\n  \n  \n  \n  class Meta:\n   app_label=__name__\n   \n  @memoized_property\n  def saved_passwords(self):\n   return []\n   \n  def pop_saved_passwords(self):\n   try :\n    return self.saved_passwords[:]\n   finally :\n    del self.saved_passwords[:]\n    \n  def save(self,update_fields=None ):\n  \n   self.saved_passwords.append(self.password)\n   \ndef create_mock_setter():\n state=[]\n def setter(password):\n  state.append(password)\n def popstate():\n  try :\n   return state[:]\n  finally :\n   del state[:]\n setter.popstate=popstate\n return setter\n \n \ndef check_django_hasher_has_backend(name):\n ''\n\n\n \n assert name\n from django.contrib.auth.hashers import make_password\n try :\n  make_password(\"\",hasher=name)\n  return True\n except ValueError as err:\n  if re.match(\"Couldn't load '.*?' algorithm .* No module named .*\",str(err)):\n   return False\n  raise\n  \n  \n  \n  \n  \ndef _modify_django_config(kwds,sha_rounds=None ):\n ''\n\n\n\n\n \n \n if hasattr(kwds,\"to_dict\"):\n \n  kwds=kwds.to_dict()\n  \n  \n kwds.update(\n \n deprecated=\"auto\",\n )\n \n \n \n if sha_rounds is None and has_min_django:\n  from django.contrib.auth.hashers import PBKDF2PasswordHasher\n  sha_rounds=PBKDF2PasswordHasher.iterations\n  \n  \n if sha_rounds:\n  kwds.update(\n  django_pbkdf2_sha1__default_rounds=sha_rounds,\n  django_pbkdf2_sha256__default_rounds=sha_rounds,\n  )\n  \n return kwds\n \n \n \n \n \n \n \n \n \nif DJANGO_VERSION >=(2,1):\n stock_config=_modify_django_config(_apps.django21_context)\nelif DJANGO_VERSION >=(1,10):\n stock_config=_modify_django_config(_apps.django110_context)\nelse :\n\n stock_config=_modify_django_config(_apps.django16_context)\n \n \n \n \nfrom passlib.hash import django_pbkdf2_sha256\nsample_hashes=dict(\ndjango_pbkdf2_sha256=(\"not a password\",django_pbkdf2_sha256\n.using(rounds=stock_config.get(\"django_pbkdf2_sha256__default_rounds\"))\n.hash(\"not a password\"))\n)\n\n\n\n\n\nclass _ExtensionSupport(object):\n ''\n\n\n \n \n \n \n \n @classmethod\n def _iter_patch_candidates(cls):\n  ''\n\n\n\n\n\n\n  \n  \n  \n  from django.contrib.auth import models,hashers\n  user_attrs=[\"check_password\",\"set_password\"]\n  model_attrs=[\"check_password\",\"make_password\"]\n  hasher_attrs=[\"check_password\",\"make_password\",\"get_hasher\",\"identify_hasher\",\n  \"get_hashers\"]\n  objs=[(models,model_attrs),\n  (models.User,user_attrs),\n  (hashers,hasher_attrs),\n  ]\n  for obj,patched in objs:\n   for attr in dir(obj):\n    if attr.startswith(\"_\"):\n     continue\n    value=obj.__dict__.get(attr,UNSET)\n    if value is UNSET and attr not in patched:\n     continue\n    value=get_method_function(value)\n    source=getattr(value,\"__module__\",None )\n    if source:\n     yield obj,attr,source,(attr in patched)\n     \n     \n     \n     \n     \n def assert_unpatched(self):\n  ''\n\n  \n  \n  mod=sys.modules.get(\"passlib.ext.django.models\")\n  self.assertFalse(mod and mod.adapter.patched,\"patch should not be enabled\")\n  \n  \n  for obj,attr,source,patched in self._iter_patch_candidates():\n   if patched:\n    self.assertTrue(source.startswith(\"django.contrib.auth.\"),\n    \"obj=%r attr=%r was not reverted: %r\"%\n    (obj,attr,source))\n   else :\n    self.assertFalse(source.startswith(\"passlib.\"),\n    \"obj=%r attr=%r should not have been patched: %r\"%\n    (obj,attr,source))\n    \n def assert_patched(self,context=None ):\n  ''\n\n  \n  \n  mod=sys.modules.get(\"passlib.ext.django.models\")\n  self.assertTrue(mod and mod.adapter.patched,\"patch should have been enabled\")\n  \n  \n  for obj,attr,source,patched in self._iter_patch_candidates():\n   if patched:\n    self.assertTrue(source ==\"passlib.ext.django.utils\",\n    \"obj=%r attr=%r should have been patched: %r\"%\n    (obj,attr,source))\n   else :\n    self.assertFalse(source.startswith(\"passlib.\"),\n    \"obj=%r attr=%r should not have been patched: %r\"%\n    (obj,attr,source))\n    \n    \n  if context is not None :\n   context=CryptContext._norm_source(context)\n   self.assertEqual(mod.password_context.to_dict(resolve=True ),\n   context.to_dict(resolve=True ))\n   \n   \n   \n   \n   \n _config_keys=[\"PASSLIB_CONFIG\",\"PASSLIB_CONTEXT\",\"PASSLIB_GET_CATEGORY\"]\n \n def load_extension(self,check=True ,**kwds):\n  ''\n\n  \n  self.unload_extension()\n  if check:\n   config=kwds.get(\"PASSLIB_CONFIG\")or kwds.get(\"PASSLIB_CONTEXT\")\n  for key in self._config_keys:\n   kwds.setdefault(key,UNSET)\n  update_settings(**kwds)\n  import passlib.ext.django.models\n  if check:\n   self.assert_patched(context=config)\n   \n def unload_extension(self):\n  ''\n\n  \n  \n  mod=sys.modules.get(\"passlib.ext.django.models\")\n  if mod:\n   mod.adapter.remove_patch()\n   del sys.modules[\"passlib.ext.django.models\"]\n   \n  update_settings(**dict((key,UNSET)for key in self._config_keys))\n  \n  self.assert_unpatched()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass _ExtensionTest(TestCase,_ExtensionSupport):\n ''\n\n\n \n \n \n \n \n def setUp(self):\n  super(_ExtensionTest,self).setUp()\n  \n  self.require_TEST_MODE(\"default\")\n  \n  if not DJANGO_VERSION:\n   raise self.skipTest(\"Django not installed\")\n  elif not has_min_django:\n   raise self.skipTest(\"Django version too old\")\n   \n   \n  self.unload_extension()\n  \n  \n  self.addCleanup(self.unload_extension)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nPASS1=\"toomanysecrets\"\nWRONG1=\"letmein\"\n\n\nclass DjangoBehaviorTest(_ExtensionTest):\n ''\n\n\n\n\n\n\n \n \n \n \n \n descriptionPrefix=\"verify django behavior\"\n \n \n \n patched=False\n \n \n \n config=stock_config\n \n \n \n \n \n \n \n \n \n \n @memoized_property\n def context(self):\n  ''\n\n  \n  return CryptContext._norm_source(self.config)\n  \n def assert_unusable_password(self,user):\n  ''\n\n  \n  self.assertTrue(user.password.startswith(\"!\"))\n  self.assertFalse(user.has_usable_password())\n  self.assertEqual(user.pop_saved_passwords(),[])\n  \n def assert_valid_password(self,user,hash=UNSET,saved=None ):\n  ''\n\n\n\n  \n  if hash is UNSET:\n   self.assertNotEqual(user.password,\"!\")\n   self.assertNotEqual(user.password,None )\n  else :\n   self.assertEqual(user.password,hash)\n  self.assertTrue(user.has_usable_password(),\n  \"hash should be usable: %r\"%(user.password,))\n  self.assertEqual(user.pop_saved_passwords(),\n  []if saved is None else [saved])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_extension_config(self):\n  ''\n\n  \n  if not self.patched:\n   raise self.skipTest(\"extension not loaded\")\n   \n  ctx=self.context\n  \n  \n  from django.contrib.auth.hashers import check_password\n  from passlib.ext.django.models import password_context\n  self.assertEqual(password_context.to_dict(resolve=True ),ctx.to_dict(resolve=True ))\n  \n  \n  from django.contrib.auth.models import check_password as check_password2\n  self.assertEqual(check_password2,check_password)\n  \n def test_default_algorithm(self):\n  ''\n\n  \n  ctx=self.context\n  \n  \n  from django.contrib.auth.hashers import make_password\n  \n  \n  user=FakeUser()\n  user.set_password(PASS1)\n  self.assertTrue(ctx.handler().verify(PASS1,user.password))\n  self.assert_valid_password(user)\n  \n  \n  \n  \n  hash=make_password(PASS1)\n  self.assertTrue(ctx.handler().verify(PASS1,hash))\n  \n  \n  \n def test_empty_password(self):\n  ''\n\n  \n  ctx=self.context\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  user=FakeUser()\n  user.set_password('')\n  hash=user.password\n  self.assertTrue(ctx.handler().verify('',hash))\n  self.assert_valid_password(user,hash)\n  \n  \n  self.assertTrue(user.check_password(\"\"))\n  self.assert_valid_password(user,hash)\n  \n  \n  \n  \n  \n  \n  \n  \n  self.assertTrue(check_password(\"\",hash))\n  \n def test_unusable_flag(self):\n  ''\n\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  user=FakeUser()\n  user.set_unusable_password()\n  self.assert_unusable_password(user)\n  \n  \n  user=FakeUser()\n  user.set_password(None )\n  self.assert_unusable_password(user)\n  \n  \n  self.assertFalse(user.check_password(None ))\n  self.assertFalse(user.check_password('None'))\n  self.assertFalse(user.check_password(''))\n  self.assertFalse(user.check_password(PASS1))\n  self.assertFalse(user.check_password(WRONG1))\n  self.assert_unusable_password(user)\n  \n  \n  self.assertTrue(make_password(None ).startswith(\"!\"))\n  \n  \n  self.assertFalse(check_password(PASS1,'!'))\n  \n  \n  self.assertFalse(is_password_usable(user.password))\n  self.assertRaises(ValueError,identify_hasher,user.password)\n  \n def test_none_hash_value(self):\n  ''\n\n  \n  patched=self.patched\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  user=FakeUser()\n  user.password=None\n  if quirks.none_causes_check_password_error and not patched:\n  \n   self.assertRaises(TypeError,user.check_password,PASS1)\n  else :\n   self.assertFalse(user.check_password(PASS1))\n   \n  self.assertEqual(user.has_usable_password(),\n  quirks.empty_is_usable_password)\n  \n  \n  \n  \n  \n  \n  if quirks.none_causes_check_password_error and not patched:\n   self.assertRaises(TypeError,check_password,PASS1,None )\n  else :\n   self.assertFalse(check_password(PASS1,None ))\n   \n   \n  self.assertRaises(TypeError,identify_hasher,None )\n  \n def test_empty_hash_value(self):\n  ''\n\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  \n  user=FakeUser()\n  user.password=\"\"\n  self.assertFalse(user.check_password(PASS1))\n  \n  \n  self.assertEqual(user.password,\"\")\n  self.assertEqual(user.pop_saved_passwords(),[])\n  \n  \n  self.assertEqual(user.has_usable_password(),quirks.empty_is_usable_password)\n  \n  \n  \n  \n  \n  \n  self.assertFalse(check_password(PASS1,\"\"))\n  \n  \n  self.assertRaises(ValueError,identify_hasher,\"\")\n  \n def test_invalid_hash_values(self):\n  ''\n\n  \n  for hash in [\n  \"$789$foo\",\n  ]:\n   with self.subTest(hash=hash):\n    self._do_test_invalid_hash_value(hash)\n    \n def _do_test_invalid_hash_value(self,hash):\n \n \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  \n  user=FakeUser()\n  user.password=hash\n  self.assertFalse(user.check_password(PASS1))\n  \n  \n  self.assertEqual(user.password,hash)\n  self.assertEqual(user.pop_saved_passwords(),[])\n  \n  \n  self.assertEqual(user.has_usable_password(),quirks.invalid_is_usable_password)\n  \n  \n  \n  \n  \n  \n  self.assertFalse(check_password(PASS1,hash))\n  \n  \n  self.assertRaises(ValueError,identify_hasher,hash)\n  \n def test_available_schemes(self):\n  ''\n\n\n  \n  for scheme in self.context.schemes():\n   with self.subTest(scheme=scheme):\n    self._do_test_available_scheme(scheme)\n    \n def _do_test_available_scheme(self,scheme):\n  ''\n\n\n  \n  log=self.getLogger()\n  ctx=self.context\n  patched=self.patched\n  setter=create_mock_setter()\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  handler=ctx.handler(scheme)\n  log.debug(\"testing scheme: %r => %r\",scheme,handler)\n  deprecated=ctx.handler(scheme).deprecated\n  assert not deprecated or scheme !=ctx.default_scheme()\n  try :\n   testcase=get_handler_case(scheme)\n  except exc.MissingBackendError:\n   raise self.skipTest(\"backend not available\")\n  assert handler_derived_from(handler,testcase.handler)\n  if handler.is_disabled:\n   raise self.skipTest(\"skip disabled hasher\")\n   \n   \n   \n   \n  if not patched and not check_django_hasher_has_backend(handler.django_name):\n   assert scheme in [\"django_bcrypt\",\"django_bcrypt_sha256\",\"django_argon2\"],\\\n   \"%r scheme should always have active backend\"%scheme\n   log.warning(\"skipping scheme %r due to missing django dependency\",scheme)\n   raise self.skipTest(\"skip due to missing dependency\")\n   \n   \n  try :\n   secret,hash=sample_hashes[scheme]\n  except KeyError:\n   get_sample_hash=testcase(\"setUp\").get_sample_hash\n   while True :\n    secret,hash=get_sample_hash()\n    if secret:\n     break\n  other='dontletmein'\n  \n  \n  \n  \n  \n  \n  \n  \n  user=FakeUser()\n  user.password=hash\n  \n  \n  self.assertFalse(user.check_password(None ))\n  \n  self.assertFalse(user.check_password(other))\n  self.assert_valid_password(user,hash)\n  \n  \n  self.assertTrue(user.check_password(secret))\n  \n  \n  \n  needs_update=deprecated\n  if needs_update:\n   self.assertNotEqual(user.password,hash)\n   self.assertFalse(handler.identify(user.password))\n   self.assertTrue(ctx.handler().verify(secret,user.password))\n   self.assert_valid_password(user,saved=user.password)\n  else :\n   self.assert_valid_password(user,hash)\n   \n   \n  if TEST_MODE(max=\"default\"):\n   return\n   \n   \n   \n   \n  alg=DjangoTranslator().passlib_to_django_name(scheme)\n  hash2=make_password(secret,hasher=alg)\n  self.assertTrue(handler.verify(secret,hash2))\n  \n  \n  \n  \n  \n  self.assertTrue(check_password(secret,hash,setter=setter))\n  self.assertEqual(setter.popstate(),[secret]if needs_update else [])\n  \n  \n  self.assertFalse(check_password(other,hash,setter=setter))\n  self.assertEqual(setter.popstate(),[])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self.assertTrue(is_password_usable(hash))\n  name=DjangoTranslator().django_to_passlib_name(identify_hasher(hash).algorithm)\n  self.assertEqual(name,scheme)\n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass ExtensionBehaviorTest(DjangoBehaviorTest):\n ''\n\n \n descriptionPrefix=\"verify extension behavior\"\n \n config=dict(\n schemes=\"sha256_crypt,md5_crypt,des_crypt\",\n deprecated=\"des_crypt\",\n )\n \n def setUp(self):\n  super(ExtensionBehaviorTest,self).setUp()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=self.config)\n  self.patched=True\n  \n  \n  \n  \n  \nclass DjangoExtensionTest(_ExtensionTest):\n ''\n\n \n \n \n \n \n descriptionPrefix=\"passlib.ext.django plugin\"\n \n \n \n \n \n def test_00_patch_control(self):\n  ''\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"disabled\",check=False )\n  self.assert_unpatched()\n  \n  \n  with self.assertWarningList(\"PASSLIB_CONFIG=None is deprecated\"):\n   self.load_extension(PASSLIB_CONFIG=None ,check=False )\n  self.assert_unpatched()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.0\",check=False )\n  self.assert_patched(context=django10_context)\n  \n  \n  self.unload_extension()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.4\",check=False )\n  self.assert_patched(context=django14_context)\n  \n  \n  self.unload_extension()\n  \n def test_01_overwrite_detection(self):\n  ''\n  \n  \n  \n  \n  \n  config=\"[passlib]\\nschemes=des_crypt\\n\"\n  self.load_extension(PASSLIB_CONFIG=config)\n  \n  \n  import django.contrib.auth.models as models\n  from passlib.ext.django.models import adapter\n  def dummy():\n   pass\n   \n   \n  orig=models.User.set_password\n  models.User.set_password=dummy\n  with self.assertWarningList(\"another library has patched.*User\\.set_password\"):\n   adapter._manager.check_all()\n  models.User.set_password=orig\n  \n  \n  orig=models.check_password\n  models.check_password=dummy\n  with self.assertWarningList(\"another library has patched.*models:check_password\"):\n   adapter._manager.check_all()\n  models.check_password=orig\n  \n def test_02_handler_wrapper(self):\n  ''\n  from django.contrib.auth import hashers\n  \n  passlib_to_django=DjangoTranslator().passlib_to_django\n  \n  \n  if DJANGO_VERSION >(1,10):\n   self.assertRaises(ValueError,passlib_to_django,\"hex_md5\")\n  else :\n   hasher=passlib_to_django(\"hex_md5\")\n   self.assertIsInstance(hasher,hashers.UnsaltedMD5PasswordHasher)\n   \n   \n   \n   \n  hasher=passlib_to_django(\"django_bcrypt\")\n  self.assertIsInstance(hasher,hashers.BCryptPasswordHasher)\n  \n  \n  from passlib.hash import sha256_crypt\n  hasher=passlib_to_django(\"sha256_crypt\")\n  self.assertEqual(hasher.algorithm,\"passlib_sha256_crypt\")\n  \n  \n  encoded=hasher.encode(\"stub\")\n  self.assertTrue(sha256_crypt.verify(\"stub\",encoded))\n  self.assertTrue(hasher.verify(\"stub\",encoded))\n  self.assertFalse(hasher.verify(\"xxxx\",encoded))\n  \n  \n  encoded=hasher.encode(\"stub\",\"abcd\"*4,rounds=1234)\n  self.assertEqual(encoded,\"$5$rounds=1234$abcdabcdabcdabcd$\"\n  \"v2RWkZQzctPdejyRqmmTDQpZN6wTh7.RUy9zF2LftT6\")\n  self.assertEqual(hasher.safe_summary(encoded),\n  {'algorithm':'sha256_crypt',\n  'salt':u('abcdab**********'),\n  'rounds':1234,\n  'hash':u('v2RWkZ*************************************'),\n  })\n  \n  \n  \n  self.assertRaises(KeyError,passlib_to_django,\"does_not_exist\")\n  \n  \n  \n  \n def test_11_config_disabled(self):\n  ''\n  \n  with self.assertWarningList(\"PASSLIB_CONFIG=None is deprecated\"):\n   self.load_extension(PASSLIB_CONFIG=None ,check=False )\n  self.assert_unpatched()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"disabled\",check=False )\n  self.assert_unpatched()\n  \n def test_12_config_presets(self):\n  ''\n  \n  self.load_extension(PASSLIB_CONTEXT=\"django-default\",check=False )\n  ctx=django16_context\n  self.assert_patched(ctx)\n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.0\",check=False )\n  self.assert_patched(django10_context)\n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.4\",check=False )\n  self.assert_patched(django14_context)\n  \n def test_13_config_defaults(self):\n  ''\n  \n  from passlib.ext.django.utils import PASSLIB_DEFAULT\n  default=CryptContext.from_string(PASSLIB_DEFAULT)\n  self.load_extension()\n  self.assert_patched(PASSLIB_DEFAULT)\n  \n  \n  self.load_extension(PASSLIB_CONTEXT=\"passlib-default\",check=False )\n  self.assert_patched(PASSLIB_DEFAULT)\n  \n  \n  self.load_extension(PASSLIB_CONTEXT=PASSLIB_DEFAULT,check=False )\n  self.assert_patched(PASSLIB_DEFAULT)\n  \n def test_14_config_invalid(self):\n  ''\n  update_settings(PASSLIB_CONTEXT=123,PASSLIB_CONFIG=UNSET)\n  self.assertRaises(TypeError,__import__,'passlib.ext.django.models')\n  \n  self.unload_extension()\n  update_settings(PASSLIB_CONFIG=\"missing-preset\",PASSLIB_CONTEXT=UNSET)\n  self.assertRaises(ValueError,__import__,'passlib.ext.django.models')\n  \n  \n  \n  \n def test_21_category_setting(self):\n  ''\n  \n  config=dict(\n  schemes=[\"sha256_crypt\"],\n  sha256_crypt__default_rounds=1000,\n  staff__sha256_crypt__default_rounds=2000,\n  superuser__sha256_crypt__default_rounds=3000,\n  )\n  from passlib.hash import sha256_crypt\n  \n  def run(**kwds):\n   ''\n   user=FakeUser(**kwds)\n   user.set_password(\"stub\")\n   return sha256_crypt.from_string(user.password).rounds\n   \n   \n  self.load_extension(PASSLIB_CONFIG=config)\n  self.assertEqual(run(),1000)\n  self.assertEqual(run(is_staff=True ),2000)\n  self.assertEqual(run(is_superuser=True ),3000)\n  \n  \n  def get_category(user):\n   return user.first_name or None\n  self.load_extension(PASSLIB_CONTEXT=config,\n  PASSLIB_GET_CATEGORY=get_category)\n  self.assertEqual(run(),1000)\n  self.assertEqual(run(first_name='other'),1000)\n  self.assertEqual(run(first_name='staff'),2000)\n  self.assertEqual(run(first_name='superuser'),3000)\n  \n  \n  def get_category(user):\n   return None\n  self.load_extension(PASSLIB_CONTEXT=config,\n  PASSLIB_GET_CATEGORY=get_category)\n  self.assertEqual(run(),1000)\n  self.assertEqual(run(first_name='other'),1000)\n  self.assertEqual(run(first_name='staff',is_staff=True ),1000)\n  self.assertEqual(run(first_name='superuser',is_superuser=True ),1000)\n  \n  \n  self.assertRaises(TypeError,self.load_extension,PASSLIB_CONTEXT=config,\n  PASSLIB_GET_CATEGORY='x')\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "django.apps", "django.conf", "django.contrib.auth", "django.contrib.auth.hashers", "django.contrib.auth.models", "logging", "passlib", "passlib.apps", "passlib.context", "passlib.ext.django.models", "passlib.ext.django.utils", "passlib.hash", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.compat", "passlib.utils.decor", "re", "sys"]], "passlib.tests.test_registry": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom logging import getLogger\nimport warnings\nimport sys\n\n\nfrom passlib import hash,registry,exc\nfrom passlib.registry import register_crypt_handler,register_crypt_handler_path,\\\nget_crypt_handler,list_crypt_handlers,_unload_handler_name as unload_handler_name\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import TestCase\n\nlog=getLogger(__name__)\n\n\n\n\n\n\n\n\nclass dummy_0(uh.StaticHandler):\n name=\"dummy_0\"\n \nclass alt_dummy_0(uh.StaticHandler):\n name=\"dummy_0\"\n \ndummy_x=1\n\n\n\n\nclass RegistryTest(TestCase):\n\n descriptionPrefix=\"passlib.registry\"\n \n def setUp(self):\n  super(RegistryTest,self).setUp()\n  \n  \n  locations=dict(registry._locations)\n  handlers=dict(registry._handlers)\n  def restore():\n   registry._locations.clear()\n   registry._locations.update(locations)\n   registry._handlers.clear()\n   registry._handlers.update(handlers)\n  self.addCleanup(restore)\n  \n def test_hash_proxy(self):\n  ''\n  \n  dir(hash)\n  \n  \n  repr(hash)\n  \n  \n  self.assertRaises(AttributeError,getattr,hash,'fooey')\n  \n  \n  \n  old=getattr(hash,\"__loader__\",None )\n  test=object()\n  hash.__loader__=test\n  self.assertIs(hash.__loader__,test)\n  if old is None :\n   del hash.__loader__\n   self.assertFalse(hasattr(hash,\"__loader__\"))\n  else :\n   hash.__loader__=old\n   self.assertIs(hash.__loader__,old)\n   \n   \n  class dummy_1(uh.StaticHandler):\n   name=\"dummy_1\"\n  hash.dummy_1=dummy_1\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  \n  self.assertRaises(ValueError,setattr,hash,\"dummy_1x\",dummy_1)\n  \n def test_register_crypt_handler_path(self):\n  ''\n  \n  paths=registry._locations\n  \n  \n  self.assertTrue('dummy_0'not in paths)\n  self.assertFalse(hasattr(hash,'dummy_0'))\n  \n  \n  self.assertRaises(ValueError,register_crypt_handler_path,\n  \"dummy_0\",\".test_registry\")\n  self.assertRaises(ValueError,register_crypt_handler_path,\n  \"dummy_0\",__name__+\":dummy_0:xxx\")\n  self.assertRaises(ValueError,register_crypt_handler_path,\n  \"dummy_0\",__name__+\":dummy_0.xxx\")\n  \n  \n  register_crypt_handler_path('dummy_0',__name__)\n  self.assertTrue('dummy_0'in list_crypt_handlers())\n  self.assertTrue('dummy_0'not in list_crypt_handlers(loaded_only=True ))\n  self.assertIs(hash.dummy_0,dummy_0)\n  self.assertTrue('dummy_0'in list_crypt_handlers(loaded_only=True ))\n  unload_handler_name('dummy_0')\n  \n  \n  register_crypt_handler_path('dummy_0',__name__+':alt_dummy_0')\n  self.assertIs(hash.dummy_0,alt_dummy_0)\n  unload_handler_name('dummy_0')\n  \n  \n  register_crypt_handler_path('dummy_x',__name__)\n  self.assertRaises(TypeError,get_crypt_handler,'dummy_x')\n  \n  \n  register_crypt_handler_path('alt_dummy_0',__name__)\n  self.assertRaises(ValueError,get_crypt_handler,\"alt_dummy_0\")\n  unload_handler_name(\"alt_dummy_0\")\n  \n  \n  sys.modules.pop(\"passlib.tests._test_bad_register\",None )\n  register_crypt_handler_path(\"dummy_bad\",\"passlib.tests._test_bad_register\")\n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\",\"xxxxxxxxxx\",DeprecationWarning)\n   h=get_crypt_handler(\"dummy_bad\")\n  from passlib.tests import _test_bad_register as tbr\n  self.assertIs(h,tbr.alt_dummy_bad)\n  \n def test_register_crypt_handler(self):\n  ''\n  \n  self.assertRaises(TypeError,register_crypt_handler,{})\n  \n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=None )))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"AB_CD\")))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"ab-cd\")))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"ab__cd\")))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"default\")))\n  \n  class dummy_1(uh.StaticHandler):\n   name=\"dummy_1\"\n   \n  class dummy_1b(uh.StaticHandler):\n   name=\"dummy_1\"\n   \n  self.assertTrue('dummy_1'not in list_crypt_handlers())\n  \n  register_crypt_handler(dummy_1)\n  register_crypt_handler(dummy_1)\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  self.assertRaises(KeyError,register_crypt_handler,dummy_1b)\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  register_crypt_handler(dummy_1b,force=True )\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1b)\n  \n  self.assertTrue('dummy_1'in list_crypt_handlers())\n  \n def test_get_crypt_handler(self):\n  ''\n  \n  class dummy_1(uh.StaticHandler):\n   name=\"dummy_1\"\n   \n   \n  self.assertRaises(KeyError,get_crypt_handler,\"dummy_1\")\n  self.assertIs(get_crypt_handler(\"dummy_1\",None ),None )\n  \n  \n  register_crypt_handler(dummy_1)\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\",\"handler names should be lower-case, and use underscores instead of hyphens:.*\",UserWarning)\n   \n   \n   self.assertIs(get_crypt_handler(\"DUMMY-1\"),dummy_1)\n   \n   \n   register_crypt_handler_path('dummy_0',__name__)\n   self.assertIs(get_crypt_handler(\"DUMMY-0\"),dummy_0)\n   \n   \n  from passlib import hash\n  hash.__dict__[\"_fake\"]=\"dummy\"\n  for name in [\"_fake\",\"__package__\"]:\n   self.assertRaises(KeyError,get_crypt_handler,name)\n   self.assertIs(get_crypt_handler(name,None ),None )\n   \n def test_list_crypt_handlers(self):\n  ''\n  from passlib.registry import list_crypt_handlers\n  \n  \n  hash.__dict__[\"_fake\"]=\"dummy\"\n  for name in list_crypt_handlers():\n   self.assertFalse(name.startswith(\"_\"),\"%r: \"%name)\n  unload_handler_name(\"_fake\")\n  \n def test_handlers(self):\n  ''\n  from passlib.registry import list_crypt_handlers\n  from passlib.tests.test_handlers import get_handler_case,conditionally_available_hashes\n  for name in list_crypt_handlers():\n  \n   if name.startswith(\"ldap_\")and name[5:]in list_crypt_handlers():\n    continue\n   if name in [\"roundup_plaintext\"]:\n    continue\n    \n   try :\n    self.assertTrue(get_handler_case(name))\n   except exc.MissingBackendError:\n    if name in conditionally_available_hashes:\n     continue\n    raise\n    \n    \n    \n    \n", ["__future__", "logging", "passlib", "passlib.registry", "passlib.tests", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.handlers", "sys", "warnings"]], "passlib.tests.test_utils": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom functools import partial\nimport warnings\n\n\n\nfrom passlib.utils import is_ascii_safe,to_bytes\nfrom passlib.utils.compat import irange,PY2,PY3,u,unicode,join_bytes,PYPY\nfrom passlib.tests.utils import TestCase,hb,run_with_fixed_seeds\n\n\n\n\nclass MiscTest(TestCase):\n ''\n \n \n \n def test_compat(self):\n  ''\n  from passlib.utils import compat\n  \n  self.assertRegex(repr(compat),\n  r\"^<module 'passlib.utils.compat' from '.*?'>$\")\n  \n  \n  dir(compat)\n  self.assertTrue('UnicodeIO'in dir(compat))\n  self.assertTrue('irange'in dir(compat))\n  \n def test_classproperty(self):\n  from passlib.utils.decor import classproperty\n  \n  class test(object):\n   xvar=1\n   @classproperty\n   def xprop(cls):\n    return cls.xvar\n    \n  self.assertEqual(test.xprop,1)\n  prop=test.__dict__['xprop']\n  self.assertIs(prop.im_func,prop.__func__)\n  \n def test_deprecated_function(self):\n  from passlib.utils.decor import deprecated_function\n  \n  \n  @deprecated_function(deprecated=\"1.6\",removed=\"1.8\")\n  def test_func(*args):\n   ''\n   return args\n   \n  self.assertTrue(\".. deprecated::\"in test_func.__doc__)\n  \n  with self.assertWarningList(dict(category=DeprecationWarning,\n  message=\"the function passlib.tests.test_utils.test_func() \"\n  \"is deprecated as of Passlib 1.6, and will be \"\n  \"removed in Passlib 1.8.\"\n  )):\n   self.assertEqual(test_func(1,2),(1,2))\n   \n def test_memoized_property(self):\n  from passlib.utils.decor import memoized_property\n  \n  class dummy(object):\n   counter=0\n   \n   @memoized_property\n   def value(self):\n    value=self.counter\n    self.counter=value+1\n    return value\n    \n  d=dummy()\n  self.assertEqual(d.value,0)\n  self.assertEqual(d.value,0)\n  self.assertEqual(d.counter,1)\n  \n  prop=dummy.value\n  if not PY3:\n   self.assertIs(prop.im_func,prop.__func__)\n   \n def test_getrandbytes(self):\n  ''\n  from passlib.utils import getrandbytes\n  wrapper=partial(getrandbytes,self.getRandom())\n  self.assertEqual(len(wrapper(0)),0)\n  a=wrapper(10)\n  b=wrapper(10)\n  self.assertIsInstance(a,bytes)\n  self.assertEqual(len(a),10)\n  self.assertEqual(len(b),10)\n  self.assertNotEqual(a,b)\n  \n @run_with_fixed_seeds(count=1024)\n def test_getrandstr(self,seed):\n  ''\n  from passlib.utils import getrandstr\n  \n  wrapper=partial(getrandstr,self.getRandom(seed=seed))\n  \n  \n  self.assertEqual(wrapper('abc',0),'')\n  \n  \n  self.assertRaises(ValueError,wrapper,'abc',-1)\n  \n  \n  self.assertRaises(ValueError,wrapper,'',0)\n  \n  \n  self.assertEqual(wrapper('a',5),'aaaaa')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  x=wrapper(u('abc'),32)\n  y=wrapper(u('abc'),32)\n  self.assertIsInstance(x,unicode)\n  self.assertNotEqual(x,y)\n  self.assertEqual(sorted(set(x)),[u('a'),u('b'),u('c')])\n  \n  \n  x=wrapper(b'abc',32)\n  y=wrapper(b'abc',32)\n  self.assertIsInstance(x,bytes)\n  self.assertNotEqual(x,y)\n  \n  self.assertEqual(sorted(set(x.decode(\"ascii\"))),[u('a'),u('b'),u('c')])\n  \n def test_generate_password(self):\n  ''\n  from passlib.utils import generate_password\n  warnings.filterwarnings(\"ignore\",\"The function.*generate_password\\(\\) is deprecated\")\n  self.assertEqual(len(generate_password(15)),15)\n  \n def test_is_crypt_context(self):\n  ''\n  from passlib.utils import is_crypt_context\n  from passlib.context import CryptContext\n  cc=CryptContext([\"des_crypt\"])\n  self.assertTrue(is_crypt_context(cc))\n  self.assertFalse(not is_crypt_context(cc))\n  \n def test_genseed(self):\n  ''\n  import random\n  from passlib.utils import genseed\n  rng=random.Random(genseed())\n  a=rng.randint(0,10 **10)\n  \n  rng=random.Random(genseed())\n  b=rng.randint(0,10 **10)\n  \n  self.assertNotEqual(a,b)\n  \n  rng.seed(genseed(rng))\n  \n def test_crypt(self):\n  ''\n  from passlib.utils import has_crypt,safe_crypt,test_crypt\n  from passlib.registry import get_supported_os_crypt_schemes,get_crypt_handler\n  \n  \n  supported=get_supported_os_crypt_schemes()\n  if not has_crypt:\n   self.assertEqual(supported,())\n   self.assertEqual(safe_crypt(\"test\",\"aa\"),None )\n   self.assertFalse(test_crypt(\"test\",\"aaqPiZY5xR5l.\"))\n   raise self.skipTest(\"crypt.crypt() not available\")\n   \n   \n  if not supported:\n  \n  \n  \n  \n   raise self.fail(\"crypt() present, but no supported schemes found!\")\n   \n   \n   \n  for scheme in (\"md5_crypt\",\"sha256_crypt\"):\n   if scheme in supported:\n    break\n  else :\n   scheme=supported[-1]\n  hasher=get_crypt_handler(scheme)\n  if getattr(hasher,\"min_rounds\",None ):\n   hasher=hasher.using(rounds=hasher.min_rounds)\n   \n   \n  def get_hash(secret):\n   assert isinstance(secret,unicode)\n   hash=hasher.hash(secret)\n   if isinstance(hash,bytes):\n    hash=hash.decode(\"utf-8\")\n   assert isinstance(hash,unicode)\n   return hash\n   \n   \n  s1=u(\"test\")\n  h1=get_hash(s1)\n  result=safe_crypt(s1,h1)\n  self.assertIsInstance(result,unicode)\n  self.assertEqual(result,h1)\n  self.assertEqual(safe_crypt(to_bytes(s1),to_bytes(h1)),h1)\n  \n  \n  h1x=h1[:-2]+'xx'\n  self.assertEqual(safe_crypt(s1,h1x),h1)\n  \n  \n  s2=u('test\\u1234')\n  h2=get_hash(s2)\n  self.assertEqual(safe_crypt(s2,h2),h2)\n  self.assertEqual(safe_crypt(to_bytes(s2),to_bytes(h2)),h2)\n  \n  \n  self.assertRaises(ValueError,safe_crypt,'\\x00',h1)\n  \n  \n  self.assertTrue(test_crypt(\"test\",h1))\n  self.assertFalse(test_crypt(\"test\",h1x))\n  \n  \n  \n  \n  import passlib.utils as mod\n  orig=mod._crypt\n  try :\n   retval=None\n   mod._crypt=lambda secret,hash:retval\n   \n   for retval in [None ,\"\",\":\",\":0\",\"*0\"]:\n    self.assertEqual(safe_crypt(\"test\",h1),None )\n    self.assertFalse(test_crypt(\"test\",h1))\n    \n   retval='xxx'\n   self.assertEqual(safe_crypt(\"test\",h1),\"xxx\")\n   self.assertFalse(test_crypt(\"test\",h1))\n   \n  finally :\n   mod._crypt=orig\n   \n def test_consteq(self):\n  ''\n  \n  \n  from passlib.utils import consteq,str_consteq\n  \n  \n  self.assertRaises(TypeError,consteq,u(''),b'')\n  self.assertRaises(TypeError,consteq,u(''),1)\n  self.assertRaises(TypeError,consteq,u(''),None )\n  \n  self.assertRaises(TypeError,consteq,b'',u(''))\n  self.assertRaises(TypeError,consteq,b'',1)\n  self.assertRaises(TypeError,consteq,b'',None )\n  \n  self.assertRaises(TypeError,consteq,None ,u(''))\n  self.assertRaises(TypeError,consteq,None ,b'')\n  self.assertRaises(TypeError,consteq,1,u(''))\n  self.assertRaises(TypeError,consteq,1,b'')\n  \n  def consteq_supports_string(value):\n  \n  \n  \n   return (consteq is str_consteq or PY2 or is_ascii_safe(value))\n   \n   \n  for value in [\n  u(\"a\"),\n  u(\"abc\"),\n  u(\"\\xff\\xa2\\x12\\x00\")*10,\n  ]:\n   if consteq_supports_string(value):\n    self.assertTrue(consteq(value,value),\"value %r:\"%(value,))\n   else :\n    self.assertRaises(TypeError,consteq,value,value)\n   self.assertTrue(str_consteq(value,value),\"value %r:\"%(value,))\n   \n   value=value.encode(\"latin-1\")\n   self.assertTrue(consteq(value,value),\"value %r:\"%(value,))\n   \n   \n  for l,r in [\n  \n  (u(\"a\"),u(\"c\")),\n  (u(\"abcabc\"),u(\"zbaabc\")),\n  (u(\"abcabc\"),u(\"abzabc\")),\n  (u(\"abcabc\"),u(\"abcabz\")),\n  ((u(\"\\xff\\xa2\\x12\\x00\")*10)[:-1]+u(\"\\x01\"),\n  u(\"\\xff\\xa2\\x12\\x00\")*10),\n  \n  \n  (u(\"\"),u(\"a\")),\n  (u(\"abc\"),u(\"abcdef\")),\n  (u(\"abc\"),u(\"defabc\")),\n  (u(\"qwertyuiopasdfghjklzxcvbnm\"),u(\"abc\")),\n  ]:\n   if consteq_supports_string(l)and consteq_supports_string(r):\n    self.assertFalse(consteq(l,r),\"values %r %r:\"%(l,r))\n    self.assertFalse(consteq(r,l),\"values %r %r:\"%(r,l))\n   else :\n    self.assertRaises(TypeError,consteq,l,r)\n    self.assertRaises(TypeError,consteq,r,l)\n   self.assertFalse(str_consteq(l,r),\"values %r %r:\"%(l,r))\n   self.assertFalse(str_consteq(r,l),\"values %r %r:\"%(r,l))\n   \n   l=l.encode(\"latin-1\")\n   r=r.encode(\"latin-1\")\n   self.assertFalse(consteq(l,r),\"values %r %r:\"%(l,r))\n   self.assertFalse(consteq(r,l),\"values %r %r:\"%(r,l))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_saslprep(self):\n  ''\n  self.require_stringprep()\n  from passlib.utils import saslprep as sp\n  \n  \n  self.assertRaises(TypeError,sp,None )\n  self.assertRaises(TypeError,sp,1)\n  self.assertRaises(TypeError,sp,b'')\n  \n  \n  self.assertEqual(sp(u('')),u(''))\n  self.assertEqual(sp(u('\\u00AD')),u(''))\n  \n  \n  self.assertEqual(sp(u(\"$\\u00AD$\\u200D$\")),u(\"$$$\"))\n  \n  \n  self.assertEqual(sp(u(\"$ $\\u00A0$\\u3000$\")),u(\"$ $ $ $\"))\n  \n  \n  self.assertEqual(sp(u(\"a\\u0300\")),u(\"\\u00E0\"))\n  self.assertEqual(sp(u(\"\\u00E0\")),u(\"\\u00E0\"))\n  \n  \n  \n  self.assertRaises(ValueError,sp,u(\"\\u0000\"))\n  self.assertRaises(ValueError,sp,u(\"\\u007F\"))\n  self.assertRaises(ValueError,sp,u(\"\\u180E\"))\n  self.assertRaises(ValueError,sp,u(\"\\uFFF9\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uE000\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uFDD0\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uD800\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uFFFD\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u2FF0\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u200E\"))\n  self.assertRaises(ValueError,sp,u(\"\\u206F\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u0900\"))\n  self.assertRaises(ValueError,sp,u(\"\\uFFF8\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\U000e0001\"))\n  \n  \n  \n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0031\"))\n  self.assertEqual(sp(u(\"\\u0627\")),u(\"\\u0627\"))\n  self.assertEqual(sp(u(\"\\u0627\\u0628\")),u(\"\\u0627\\u0628\"))\n  self.assertEqual(sp(u(\"\\u0627\\u0031\\u0628\")),u(\"\\u0627\\u0031\\u0628\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0041\\u0628\"))\n  \n  self.assertRaises(ValueError,sp,u(\"x\\u0627z\"))\n  self.assertEqual(sp(u(\"x\\u0041z\")),u(\"x\\u0041z\"))\n  \n  \n  \n  \n  \n  \n  self.assertEqual(sp(u(\"I\\u00ADX\")),u(\"IX\"))\n  self.assertEqual(sp(u(\"user\")),u(\"user\"))\n  self.assertEqual(sp(u(\"USER\")),u(\"USER\"))\n  self.assertEqual(sp(u(\"\\u00AA\")),u(\"a\"))\n  self.assertEqual(sp(u(\"\\u2168\")),u(\"IX\"))\n  self.assertRaises(ValueError,sp,u(\"\\u0007\"))\n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0031\"))\n  \n  \n  \n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0031\"))\n  self.assertEqual(sp(u(\"\\u0627\\u0031\\u0628\")),u(\"\\u0627\\u0031\\u0628\"))\n  \n def test_splitcomma(self):\n  from passlib.utils import splitcomma\n  self.assertEqual(splitcomma(\"\"),[])\n  self.assertEqual(splitcomma(\",\"),[])\n  self.assertEqual(splitcomma(\"a\"),['a'])\n  self.assertEqual(splitcomma(\" a , \"),['a'])\n  self.assertEqual(splitcomma(\" a , b\"),['a','b'])\n  self.assertEqual(splitcomma(\" a, b, \"),['a','b'])\n  \n def test_utf8_truncate(self):\n  ''\n\n  \n  from passlib.utils import utf8_truncate\n  \n  \n  \n  \n  \n  for source in [\n  \n  b\"\",\n  \n  b\"1\",\n  b\"123\",\n  b'\\x1a',\n  b'\\x1a'*10,\n  b'\\x7f',\n  b'\\x7f'*10,\n  \n  b'a\\xc2\\xa0\\xc3\\xbe\\xc3\\xbe',\n  b'abcdefghjusdfaoiu\\xc2\\xa0\\xc3\\xbe\\xc3\\xbedsfioauweoiruer',\n  ]:\n   source.decode(\"utf-8\")\n   \n   end=len(source)\n   for idx in range(end+16):\n    prefix=\"source=%r index=%r: \"%(source,idx)\n    \n    result=utf8_truncate(source,idx)\n    \n    \n    result.decode(\"utf-8\")\n    \n    \n    self.assertLessEqual(len(result),end,msg=prefix)\n    \n    \n    self.assertGreaterEqual(len(result),min(idx,end),msg=prefix)\n    self.assertLess(len(result),min(idx+4,end+1),msg=prefix)\n    \n    \n    self.assertEqual(result,source[:len(result)],msg=prefix)\n    \n    \n    \n    \n    \n  for source in [\n  b'\\xca',\n  b'\\xca'*10,\n  \n  b'\\x00',\n  b'\\x00'*10,\n  ]:\n   end=len(source)\n   for idx in range(end+16):\n    prefix=\"source=%r index=%r: \"%(source,idx)\n    result=utf8_truncate(source,idx)\n    self.assertEqual(result,source[:idx],msg=prefix)\n    \n    \n    \n    \n    \n  for source in [\n  b'\\xaa',\n  b'\\xaa'*10,\n  ]:\n   end=len(source)\n   for idx in range(end+16):\n    prefix=\"source=%r index=%r: \"%(source,idx)\n    result=utf8_truncate(source,idx)\n    self.assertEqual(result,source[:idx+3],msg=prefix)\n    \n    \n    \n    \n    \n    \n    \n    \n  source=b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab'\n  \n  self.assertEqual(utf8_truncate(source,0),b'')\n  \n  self.assertEqual(utf8_truncate(source,1),b'M')\n  \n  self.assertEqual(utf8_truncate(source,2),b'MN')\n  \n  self.assertEqual(utf8_truncate(source,3),\n  b'MN\\xff\\xa0\\xa1\\xa2')\n  \n  self.assertEqual(utf8_truncate(source,4),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,5),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,6),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,7),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,8),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaO')\n  \n  self.assertEqual(utf8_truncate(source,9),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab')\n  \n  self.assertEqual(utf8_truncate(source,10),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab')\n  \n  self.assertEqual(utf8_truncate(source,11),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab')\n  \n  \n  \n  \n  \nclass CodecTest(TestCase):\n ''\n \n def test_bytes(self):\n  ''\n  if PY3:\n   import builtins\n   self.assertIs(bytes,builtins.bytes)\n  else :\n   import __builtin__ as builtins\n   self.assertIs(bytes,builtins.str)\n   \n  self.assertIsInstance(b'',bytes)\n  self.assertIsInstance(b'\\x00\\xff',bytes)\n  if PY3:\n   self.assertEqual(b'\\x00\\xff'.decode(\"latin-1\"),\"\\x00\\xff\")\n  else :\n   self.assertEqual(b'\\x00\\xff',\"\\x00\\xff\")\n   \n def test_to_bytes(self):\n  ''\n  from passlib.utils import to_bytes\n  \n  \n  self.assertEqual(to_bytes(u('abc')),b'abc')\n  self.assertEqual(to_bytes(u('\\x00\\xff')),b'\\x00\\xc3\\xbf')\n  \n  \n  self.assertEqual(to_bytes(u('\\x00\\xff'),'latin-1'),b'\\x00\\xff')\n  self.assertRaises(ValueError,to_bytes,u('\\x00\\xff'),'ascii')\n  \n  \n  self.assertEqual(to_bytes(b'abc'),b'abc')\n  self.assertEqual(to_bytes(b'\\x00\\xff'),b'\\x00\\xff')\n  self.assertEqual(to_bytes(b'\\x00\\xc3\\xbf'),b'\\x00\\xc3\\xbf')\n  \n  \n  self.assertEqual(to_bytes(b'\\x00\\xc3\\xbf',\"latin-1\"),\n  b'\\x00\\xc3\\xbf')\n  \n  \n  self.assertEqual(to_bytes(b'\\x00\\xc3\\xbf',\"latin-1\",\"\",\"utf-8\"),\n  b'\\x00\\xff')\n  \n  \n  self.assertRaises(AssertionError,to_bytes,'abc',None )\n  self.assertRaises(TypeError,to_bytes,None )\n  \n def test_to_unicode(self):\n  ''\n  from passlib.utils import to_unicode\n  \n  \n  self.assertEqual(to_unicode(u('abc')),u('abc'))\n  self.assertEqual(to_unicode(u('\\x00\\xff')),u('\\x00\\xff'))\n  \n  \n  self.assertEqual(to_unicode(u('\\x00\\xff'),\"ascii\"),u('\\x00\\xff'))\n  \n  \n  self.assertEqual(to_unicode(b'abc'),u('abc'))\n  self.assertEqual(to_unicode(b'\\x00\\xc3\\xbf'),u('\\x00\\xff'))\n  self.assertEqual(to_unicode(b'\\x00\\xff','latin-1'),\n  u('\\x00\\xff'))\n  self.assertRaises(ValueError,to_unicode,b'\\x00\\xff')\n  \n  \n  self.assertRaises(AssertionError,to_unicode,'abc',None )\n  self.assertRaises(TypeError,to_unicode,None )\n  \n def test_to_native_str(self):\n  ''\n  from passlib.utils import to_native_str\n  \n  \n  self.assertEqual(to_native_str(u('abc'),'ascii'),'abc')\n  self.assertEqual(to_native_str(b'abc','ascii'),'abc')\n  \n  \n  if PY3:\n   self.assertEqual(to_native_str(u('\\xE0'),'ascii'),'\\xE0')\n   self.assertRaises(UnicodeDecodeError,to_native_str,b'\\xC3\\xA0',\n   'ascii')\n  else :\n   self.assertRaises(UnicodeEncodeError,to_native_str,u('\\xE0'),\n   'ascii')\n   self.assertEqual(to_native_str(b'\\xC3\\xA0','ascii'),'\\xC3\\xA0')\n   \n   \n  self.assertEqual(to_native_str(u('\\xE0'),'latin-1'),'\\xE0')\n  self.assertEqual(to_native_str(b'\\xE0','latin-1'),'\\xE0')\n  \n  \n  self.assertEqual(to_native_str(u('\\xE0'),'utf-8'),\n  '\\xE0'if PY3 else '\\xC3\\xA0')\n  self.assertEqual(to_native_str(b'\\xC3\\xA0','utf-8'),\n  '\\xE0'if PY3 else '\\xC3\\xA0')\n  \n  \n  self.assertRaises(TypeError,to_native_str,None ,'ascii')\n  \n def test_is_ascii_safe(self):\n  ''\n  from passlib.utils import is_ascii_safe\n  self.assertTrue(is_ascii_safe(b\"\\x00abc\\x7f\"))\n  self.assertTrue(is_ascii_safe(u(\"\\x00abc\\x7f\")))\n  self.assertFalse(is_ascii_safe(b\"\\x00abc\\x80\"))\n  self.assertFalse(is_ascii_safe(u(\"\\x00abc\\x80\")))\n  \n def test_is_same_codec(self):\n  ''\n  from passlib.utils import is_same_codec\n  \n  self.assertTrue(is_same_codec(None ,None ))\n  self.assertFalse(is_same_codec(None ,'ascii'))\n  \n  self.assertTrue(is_same_codec(\"ascii\",\"ascii\"))\n  self.assertTrue(is_same_codec(\"ascii\",\"ASCII\"))\n  \n  self.assertTrue(is_same_codec(\"utf-8\",\"utf-8\"))\n  self.assertTrue(is_same_codec(\"utf-8\",\"utf8\"))\n  self.assertTrue(is_same_codec(\"utf-8\",\"UTF_8\"))\n  \n  self.assertFalse(is_same_codec(\"ascii\",\"utf-8\"))\n  \n  \n  \n  \nclass Base64EngineTest(TestCase):\n ''\n \n \n def test_constructor(self):\n  from passlib.utils.binary import Base64Engine,AB64_CHARS\n  \n  \n  self.assertRaises(TypeError,Base64Engine,1)\n  \n  \n  self.assertRaises(ValueError,Base64Engine,AB64_CHARS[:-1])\n  \n  \n  self.assertRaises(ValueError,Base64Engine,AB64_CHARS[:-1]+\"A\")\n  \n def test_ab64_decode(self):\n  ''\n  from passlib.utils.binary import ab64_decode\n  \n  \n  self.assertEqual(ab64_decode(b\"abc\"),hb(\"69b7\"))\n  self.assertEqual(ab64_decode(u(\"abc\")),hb(\"69b7\"))\n  \n  \n  self.assertRaises(ValueError,ab64_decode,u(\"ab\\xff\"))\n  \n  \n  self.assertRaises(TypeError,ab64_decode,b\"ab\\xff\")\n  self.assertRaises(TypeError,ab64_decode,b\"ab!\")\n  self.assertRaises(TypeError,ab64_decode,u(\"ab!\"))\n  \n  \n  self.assertEqual(ab64_decode(b\"abcd\"),hb(\"69b71d\"))\n  self.assertRaises(ValueError,ab64_decode,b\"abcde\")\n  self.assertEqual(ab64_decode(b\"abcdef\"),hb(\"69b71d79\"))\n  self.assertEqual(ab64_decode(b\"abcdeQ\"),hb(\"69b71d79\"))\n  self.assertEqual(ab64_decode(b\"abcdefg\"),hb(\"69b71d79f8\"))\n  \n  \n  \n  self.assertEqual(ab64_decode(b\"ab+/\"),hb(\"69bfbf\"))\n  self.assertEqual(ab64_decode(b\"ab./\"),hb(\"69bfbf\"))\n  \n def test_ab64_encode(self):\n  ''\n  from passlib.utils.binary import ab64_encode\n  \n  \n  self.assertEqual(ab64_encode(hb(\"69b7\")),b\"abc\")\n  \n  \n  self.assertRaises(TypeError if PY3 else UnicodeEncodeError,\n  ab64_encode,hb(\"69b7\").decode(\"latin-1\"))\n  \n  \n  self.assertEqual(ab64_encode(hb(\"69b71d\")),b\"abcd\")\n  self.assertEqual(ab64_encode(hb(\"69b71d79\")),b\"abcdeQ\")\n  self.assertEqual(ab64_encode(hb(\"69b71d79f8\")),b\"abcdefg\")\n  \n  \n  self.assertEqual(ab64_encode(hb(\"69bfbf\")),b\"ab./\")\n  \n def test_b64s_decode(self):\n  ''\n  from passlib.utils.binary import b64s_decode\n  \n  \n  self.assertEqual(b64s_decode(b\"abc\"),hb(\"69b7\"))\n  self.assertEqual(b64s_decode(u(\"abc\")),hb(\"69b7\"))\n  \n  \n  self.assertRaises(ValueError,b64s_decode,u(\"ab\\xff\"))\n  \n  \n  self.assertRaises(TypeError,b64s_decode,b\"ab\\xff\")\n  self.assertRaises(TypeError,b64s_decode,b\"ab!\")\n  self.assertRaises(TypeError,b64s_decode,u(\"ab!\"))\n  \n  \n  self.assertEqual(b64s_decode(b\"abcd\"),hb(\"69b71d\"))\n  self.assertRaises(ValueError,b64s_decode,b\"abcde\")\n  self.assertEqual(b64s_decode(b\"abcdef\"),hb(\"69b71d79\"))\n  self.assertEqual(b64s_decode(b\"abcdeQ\"),hb(\"69b71d79\"))\n  self.assertEqual(b64s_decode(b\"abcdefg\"),hb(\"69b71d79f8\"))\n  \n def test_b64s_encode(self):\n  ''\n  from passlib.utils.binary import b64s_encode\n  \n  \n  self.assertEqual(b64s_encode(hb(\"69b7\")),b\"abc\")\n  \n  \n  self.assertRaises(TypeError if PY3 else UnicodeEncodeError,\n  b64s_encode,hb(\"69b7\").decode(\"latin-1\"))\n  \n  \n  self.assertEqual(b64s_encode(hb(\"69b71d\")),b\"abcd\")\n  self.assertEqual(b64s_encode(hb(\"69b71d79\")),b\"abcdeQ\")\n  self.assertEqual(b64s_encode(hb(\"69b71d79f8\")),b\"abcdefg\")\n  \n  \n  self.assertEqual(b64s_encode(hb(\"69bfbf\")),b\"ab+/\")\n  \nclass _Base64Test(TestCase):\n ''\n \n \n \n \n \n engine=None\n \n \n encoded_data=None\n \n \n encoded_ints=None\n \n \n bad_byte=b\"?\"\n \n \n def m(self,*offsets):\n  ''\n  return join_bytes(self.engine.bytemap[o:o+1]for o in offsets)\n  \n  \n  \n  \n def test_encode_bytes(self):\n  ''\n  engine=self.engine\n  encode=engine.encode_bytes\n  for raw,encoded in self.encoded_data:\n   result=encode(raw)\n   self.assertEqual(result,encoded,\"encode %r:\"%(raw,))\n   \n def test_encode_bytes_bad(self):\n  ''\n  engine=self.engine\n  encode=engine.encode_bytes\n  self.assertRaises(TypeError,encode,u('\\x00'))\n  self.assertRaises(TypeError,encode,None )\n  \n  \n  \n  \n def test_decode_bytes(self):\n  ''\n  engine=self.engine\n  decode=engine.decode_bytes\n  for raw,encoded in self.encoded_data:\n   result=decode(encoded)\n   self.assertEqual(result,raw,\"decode %r:\"%(encoded,))\n   \n def test_decode_bytes_padding(self):\n  ''\n  bchr=(lambda v:bytes([v]))if PY3 else chr\n  engine=self.engine\n  m=self.m\n  decode=engine.decode_bytes\n  BNULL=b\"\\x00\"\n  \n  \n  self.assertEqual(decode(m(0,0)),BNULL)\n  for i in range(0,6):\n   if engine.big:\n    correct=BNULL if i <4 else bchr(1 <<(i -4))\n   else :\n    correct=bchr(1 <<(i+6))if i <2 else BNULL\n   self.assertEqual(decode(m(0,1 <<i)),correct,\"%d/4 bits:\"%i)\n   \n   \n  self.assertEqual(decode(m(0,0,0)),BNULL *2)\n  for i in range(0,6):\n   if engine.big:\n    correct=BNULL if i <2 else bchr(1 <<(i -2))\n   else :\n    correct=bchr(1 <<(i+4))if i <4 else BNULL\n   self.assertEqual(decode(m(0,0,1 <<i)),BNULL+correct,\n   \"%d/2 bits:\"%i)\n   \n def test_decode_bytes_bad(self):\n  ''\n  engine=self.engine\n  decode=engine.decode_bytes\n  \n  \n  self.assertRaises(ValueError,decode,engine.bytemap[:5])\n  \n  \n  self.assertTrue(self.bad_byte not in engine.bytemap)\n  self.assertRaises(ValueError,decode,self.bad_byte *4)\n  \n  \n  self.assertRaises(TypeError,decode,engine.charmap[:4])\n  self.assertRaises(TypeError,decode,None )\n  \n  \n  \n  \n def test_codec(self):\n  ''\n  engine=self.engine\n  from passlib.utils import getrandbytes,getrandstr\n  rng=self.getRandom()\n  saw_zero=False\n  for i in irange(500):\n  \n  \n  \n  \n  \n   size=rng.randint(1 if saw_zero else 0,12)\n   if not size:\n    saw_zero=True\n   enc_size=(4 *size+2)//3\n   raw=getrandbytes(rng,size)\n   \n   \n   encoded=engine.encode_bytes(raw)\n   self.assertEqual(len(encoded),enc_size)\n   \n   \n   result=engine.decode_bytes(encoded)\n   self.assertEqual(result,raw)\n   \n   \n   \n   \n   \n   \n   if size %4 ==1:\n    size +=rng.choice([-1,1,2])\n   raw_size=3 *size //4\n   encoded=getrandstr(rng,engine.bytemap,size)\n   \n   \n   raw=engine.decode_bytes(encoded)\n   self.assertEqual(len(raw),raw_size,\"encoded %d:\"%size)\n   \n   \n   result=engine.encode_bytes(raw)\n   if size %4:\n    self.assertEqual(result[:-1],encoded[:-1])\n   else :\n    self.assertEqual(result,encoded)\n    \n def test_repair_unused(self):\n  ''\n  \n  \n  from passlib.utils import getrandstr\n  rng=self.getRandom()\n  engine=self.engine\n  check_repair_unused=self.engine.check_repair_unused\n  i=0\n  while i <300:\n   size=rng.randint(0,23)\n   cdata=getrandstr(rng,engine.charmap,size).encode(\"ascii\")\n   if size&3 ==1:\n   \n    self.assertRaises(ValueError,check_repair_unused,cdata)\n    continue\n   rdata=engine.encode_bytes(engine.decode_bytes(cdata))\n   if rng.random()<.5:\n    cdata=cdata.decode(\"ascii\")\n    rdata=rdata.decode(\"ascii\")\n   if cdata ==rdata:\n   \n    ok,result=check_repair_unused(cdata)\n    self.assertFalse(ok)\n    self.assertEqual(result,rdata)\n   else :\n   \n    self.assertNotEqual(size %4,0)\n    ok,result=check_repair_unused(cdata)\n    self.assertTrue(ok)\n    self.assertEqual(result,rdata)\n   i +=1\n   \n   \n   \n   \n   \n   \n transposed=[\n \n (b\"\\x33\\x22\\x11\",b\"\\x11\\x22\\x33\",[2,1,0]),\n (b\"\\x22\\x33\\x11\",b\"\\x11\\x22\\x33\",[1,2,0]),\n ]\n \n transposed_dups=[\n \n (b\"\\x11\\x11\\x22\",b\"\\x11\\x22\\x33\",[0,0,1]),\n ]\n \n def test_encode_transposed_bytes(self):\n  ''\n  engine=self.engine\n  for result,input,offsets in self.transposed+self.transposed_dups:\n   tmp=engine.encode_transposed_bytes(input,offsets)\n   out=engine.decode_bytes(tmp)\n   self.assertEqual(out,result)\n   \n  self.assertRaises(TypeError,engine.encode_transposed_bytes,u(\"a\"),[])\n  \n def test_decode_transposed_bytes(self):\n  ''\n  engine=self.engine\n  for input,result,offsets in self.transposed:\n   tmp=engine.encode_bytes(input)\n   out=engine.decode_transposed_bytes(tmp,offsets)\n   self.assertEqual(out,result)\n   \n def test_decode_transposed_bytes_bad(self):\n  ''\n  engine=self.engine\n  for input,_,offsets in self.transposed_dups:\n   tmp=engine.encode_bytes(input)\n   self.assertRaises(TypeError,engine.decode_transposed_bytes,tmp,\n   offsets)\n   \n   \n   \n   \n def check_int_pair(self,bits,encoded_pairs):\n  ''\n  rng=self.getRandom()\n  engine=self.engine\n  encode=getattr(engine,\"encode_int%s\"%bits)\n  decode=getattr(engine,\"decode_int%s\"%bits)\n  pad=-bits %6\n  chars=(bits+pad)//6\n  upper=1 <<bits\n  \n  \n  for value,encoded in encoded_pairs:\n   result=encode(value)\n   self.assertIsInstance(result,bytes)\n   self.assertEqual(result,encoded)\n  self.assertRaises(ValueError,encode,-1)\n  self.assertRaises(ValueError,encode,upper)\n  \n  \n  for value,encoded in encoded_pairs:\n   self.assertEqual(decode(encoded),value,\"encoded %r:\"%(encoded,))\n  m=self.m\n  self.assertRaises(ValueError,decode,m(0)*(chars+1))\n  self.assertRaises(ValueError,decode,m(0)*(chars -1))\n  self.assertRaises(ValueError,decode,self.bad_byte *chars)\n  self.assertRaises(TypeError,decode,engine.charmap[0])\n  self.assertRaises(TypeError,decode,None )\n  \n  \n  from passlib.utils import getrandstr\n  for i in irange(100):\n  \n   value=rng.randint(0,upper -1)\n   encoded=encode(value)\n   self.assertEqual(len(encoded),chars)\n   self.assertEqual(decode(encoded),value)\n   \n   \n   encoded=getrandstr(rng,engine.bytemap,chars)\n   value=decode(encoded)\n   self.assertGreaterEqual(value,0,\"decode %r out of bounds:\"%encoded)\n   self.assertLess(value,upper,\"decode %r out of bounds:\"%encoded)\n   result=encode(value)\n   if pad:\n    self.assertEqual(result[:-2],encoded[:-2])\n   else :\n    self.assertEqual(result,encoded)\n    \n def test_int6(self):\n  engine=self.engine\n  m=self.m\n  self.check_int_pair(6,[(0,m(0)),(63,m(63))])\n  \n def test_int12(self):\n  engine=self.engine\n  m=self.m\n  self.check_int_pair(12,[(0,m(0,0)),\n  (63,m(0,63)if engine.big else m(63,0)),(0xFFF,m(63,63))])\n  \n def test_int24(self):\n  engine=self.engine\n  m=self.m\n  self.check_int_pair(24,[(0,m(0,0,0,0)),\n  (63,m(0,0,0,63)if engine.big else m(63,0,0,0)),\n  (0xFFFFFF,m(63,63,63,63))])\n  \n def test_int64(self):\n \n \n  engine=self.engine\n  m=self.m\n  self.check_int_pair(64,[(0,m(0,0,0,0,0,0,0,0,0,0,0)),\n  (63,m(0,0,0,0,0,0,0,0,0,3,60)if engine.big else\n  m(63,0,0,0,0,0,0,0,0,0,0)),\n  ((1 <<64)-1,m(63,63,63,63,63,63,63,63,63,63,60)if engine.big\n  else m(63,63,63,63,63,63,63,63,63,63,15))])\n  \n def test_encoded_ints(self):\n  ''\n  if not self.encoded_ints:\n   raise self.skipTests(\"none defined for class\")\n  engine=self.engine\n  for data,value,bits in self.encoded_ints:\n   encode=getattr(engine,\"encode_int%d\"%bits)\n   decode=getattr(engine,\"decode_int%d\"%bits)\n   self.assertEqual(encode(value),data)\n   self.assertEqual(decode(data),value)\n   \n   \n   \n   \n   \n   \n   \nfrom passlib.utils.binary import h64,h64big\n\nclass H64_Test(_Base64Test):\n ''\n engine=h64\n descriptionPrefix=\"h64 codec\"\n \n encoded_data=[\n \n (b\"\",b\"\"),\n (b\"\\x55\",b\"J/\"),\n (b\"\\x55\\xaa\",b\"Jd8\"),\n (b\"\\x55\\xaa\\x55\",b\"JdOJ\"),\n (b\"\\x55\\xaa\\x55\\xaa\",b\"JdOJe0\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\",b\"JdOJeK3\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\\xaa\",b\"JdOJeKZe\"),\n \n \n (b\"\\x55\\xaa\\x55\\xaf\",b\"JdOJj0\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x5f\",b\"JdOJey3\"),\n ]\n \n encoded_ints=[\n (b\"z.\",63,12),\n (b\".z\",4032,12),\n ]\n \nclass H64Big_Test(_Base64Test):\n ''\n engine=h64big\n descriptionPrefix=\"h64big codec\"\n \n encoded_data=[\n \n (b\"\",b\"\"),\n (b\"\\x55\",b\"JE\"),\n (b\"\\x55\\xaa\",b\"JOc\"),\n (b\"\\x55\\xaa\\x55\",b\"JOdJ\"),\n (b\"\\x55\\xaa\\x55\\xaa\",b\"JOdJeU\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\",b\"JOdJeZI\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\\xaa\",b\"JOdJeZKe\"),\n \n \n (b\"\\x55\\xaa\\x55\\xaf\",b\"JOdJfk\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x5f\",b\"JOdJeZw\"),\n ]\n \n encoded_ints=[\n (b\".z\",63,12),\n (b\"z.\",4032,12),\n ]\n \n \n \n \n", ["__builtin__", "__future__", "builtins", "functools", "passlib.context", "passlib.registry", "passlib.tests.utils", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "random", "warnings"]], "passlib.tests.tox_support": [".py", "''\n\n\n\nimport os,sys\nroot_dir=os.path.join(os.path.dirname(__file__),os.pardir,os.pardir)\nsys.path.insert(0,root_dir)\n\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.compat import print_\n\n__all__=[\n]\n\n\n\n\nTH_PATH=\"passlib.tests.test_handlers\"\n\ndef do_hash_tests(*args):\n ''\n if not args:\n  print(TH_PATH)\n  return\n suffix=''\n args=list(args)\n while True :\n  if args[0]==\"--method\":\n   suffix='.'+args[1]\n   del args[:2]\n  else :\n   break\n from passlib.tests import test_handlers\n names=[TH_PATH+\":\"+name+suffix for name in dir(test_handlers)\n if not name.startswith(\"_\")and any(re.match(arg,name)for arg in args)]\n print_(\"\\n\".join(names))\n return not names\n \ndef do_preset_tests(name):\n ''\n if name ==\"django\"or name ==\"django-hashes\":\n  do_hash_tests(\"django_.*_test\",\"hex_md5_test\")\n  if name ==\"django\":\n   print_(\"passlib.tests.test_ext_django\")\n else :\n  raise ValueError(\"unknown name: %r\"%name)\n  \ndef do_setup_gae(path,runtime):\n ''\n from passlib.tests.utils import set_file\n set_file(os.path.join(path,\"app.yaml\"),\"\"\"\\\napplication: fake-app\nversion: 2\nruntime: %s\napi_version: 1\nthreadsafe: no\n\nhandlers:\n- url: /.*\n  script: dummy.py\n\nlibraries:\n- name: django\n  version: \"latest\"\n\"\"\"%runtime)\n \ndef main(cmd,*args):\n return globals()[\"do_\"+cmd](*args)\n \nif __name__ ==\"__main__\":\n import sys\n sys.exit(main(*sys.argv[1:])or 0)\n \n \n \n \n", ["logging", "os", "passlib.tests", "passlib.tests.utils", "passlib.utils.compat", "re", "sys"]], "passlib.tests._test_bad_register": [".py", "''\nfrom passlib.registry import register_crypt_handler\nimport passlib.utils.handlers as uh\n\nclass dummy_bad(uh.StaticHandler):\n name=\"dummy_bad\"\n \nclass alt_dummy_bad(uh.StaticHandler):\n name=\"dummy_bad\"\n \n \n \n \nif __name__.startswith(\"passlib.tests\"):\n register_crypt_handler(alt_dummy_bad)\n", ["passlib.registry", "passlib.utils.handlers"]], "passlib.tests.test_handlers": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport os\nimport sys\nimport warnings\n\n\nfrom passlib import exc,hash\nfrom passlib.utils import repeat_string\nfrom passlib.utils.compat import irange,PY3,u,get_method_function\nfrom passlib.tests.utils import TestCase,HandlerCase,skipUnless,\\\nTEST_MODE,UserHandlerMixin,EncodingHandlerMixin\n\n\n\n\n\n\n\nUPASS_WAV=u('\\u0399\\u03c9\\u03b1\\u03bd\\u03bd\\u03b7\\u03c2')\nUPASS_USD=u(\"\\u20AC\\u00A5$\")\nUPASS_TABLE=u(\"t\\u00e1\\u0411\\u2113\\u0259\")\n\nPASS_TABLE_UTF8=b't\\xc3\\xa1\\xd0\\x91\\xe2\\x84\\x93\\xc9\\x99'\n\n\n_omitted_backend_tests=[\"django_bcrypt\",\"django_bcrypt_sha256\",\"django_argon2\"]\n\n\n_handler_test_modules=[\n\"test_handlers\",\n\"test_handlers_argon2\",\n\"test_handlers_bcrypt\",\n\"test_handlers_cisco\",\n\"test_handlers_django\",\n\"test_handlers_pbkdf2\",\n\"test_handlers_scrypt\",\n]\n\ndef get_handler_case(scheme):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n from passlib.registry import get_crypt_handler\n handler=get_crypt_handler(scheme)\n if hasattr(handler,\"backends\")and scheme not in _omitted_backend_tests:\n \n \n  try :\n   backend=handler.get_backend()\n  except exc.MissingBackendError:\n   assert scheme in conditionally_available_hashes\n   raise\n  name=\"%s_%s_test\"%(scheme,backend)\n else :\n  name=\"%s_test\"%scheme\n for module in _handler_test_modules:\n  modname=\"passlib.tests.\"+module\n  __import__(modname)\n  mod=sys.modules[modname]\n  try :\n   return getattr(mod,name)\n  except AttributeError:\n   pass\n   \n   \n raise RuntimeError(\"can't find test case named %r for %r\"%(name,scheme))\n \n \n \nconditionally_available_hashes=[\"argon2\",\"bcrypt\",\"bcrypt_sha256\"]\n\n\n\n\nclass apr_md5_crypt_test(HandlerCase):\n handler=hash.apr_md5_crypt\n \n known_correct_hashes=[\n \n \n \n ('myPassword','$apr1$r31.....$HqJZimcKQFAMYayBlzkrA/'),\n \n \n \n \n \n \n (UPASS_TABLE,'$apr1$bzYrOHUx$a1FcpXuQDJV3vPY20CS6N1'),\n ]\n \n known_malformed_hashes=[\n \n '$apr1$r31.....$HqJZimcKQFAMYayBlzkrA!'\n ]\n \n \n \n \nclass bigcrypt_test(HandlerCase):\n handler=hash.bigcrypt\n \n \n known_correct_hashes=[\n \n \n \n \n (\"passphrase\",\"qiyh4XPJGsOZ2MEAyLkfWqeQ\"),\n (\"This is very long passwd\",\"f8.SVpL2fvwjkAnxn8/rgTkwvrif6bjYB5c\"),\n \n \n \n \n \n \n (UPASS_TABLE,'SEChBAyMbMNhgGLyP7kD1HZU'),\n ]\n \n known_unidentified_hashes=[\n \n \"qiyh4XPJGsOZ2MEAyLkfWqe\"\n \n \n \"f8.SVpL2fvwjkAnxn8/rgTkwvrif6bjYB5cd\"\n ]\n \n \n known_other_hashes=[row for row in HandlerCase.known_other_hashes\n if row[0]!=\"des_crypt\"]\n \n def test_90_internal(self):\n \n \n  self.assertRaises(ValueError,hash.bigcrypt,use_defaults=True ,\n  checksum=u('yh4XPJGsOZ'))\n  \n  \n  \n  \nclass _bsdi_crypt_test(HandlerCase):\n ''\n handler=hash.bsdi_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','_J9..CCCCXBrJUJV154M'),\n ('U*U***U','_J9..CCCCXUhOBTXzaiE'),\n ('U*U***U*','_J9..CCCC4gQ.mB/PffM'),\n ('*U*U*U*U','_J9..XXXXvlzQGqpPPdk'),\n ('*U*U*U*U*','_J9..XXXXsqM/YSSP..Y'),\n ('*U*U*U*U*U*U*U*U','_J9..XXXXVL7qJCnku0I'),\n ('*U*U*U*U*U*U*U*U*','_J9..XXXXAj8cFbP5scI'),\n ('ab1234567','_J9..SDizh.vll5VED9g'),\n ('cr1234567','_J9..SDizRjWQ/zePPHc'),\n ('zxyDPWgydbQjgq','_J9..SDizxmRI1GjnQuE'),\n ('726 even','_K9..SaltNrQgIYUAeoY'),\n ('','_J9..SDSD5YGyRCr4W4c'),\n \n \n \n \n (\" \",\"_K1..crsmZxOLzfJH8iw\"),\n (\"my\",'_KR/.crsmykRplHbAvwA'),\n (\"my socra\",\"_K1..crsmf/9NzZr1fLM\"),\n (\"my socrates\",'_K1..crsmOv1rbde9A9o'),\n (\"my socrates note\",\"_K1..crsm/2qeAhdISMA\"),\n \n \n (UPASS_TABLE,'_7C/.ABw0WIKy0ILVqo2'),\n ]\n known_unidentified_hashes=[\n \n \n \"_K1.!crsmZxOLzfJH8iw\"\n ]\n \n platform_crypt_support=[\n \n (\"openbsd[6789]\",False ),\n (\"openbsd5\",None ),\n (\"openbsd\",True ),\n \n (\"freebsd|netbsd|darwin\",True ),\n (\"solaris\",False ),\n (\"linux\",None ),\n ]\n \n def test_77_fuzz_input(self,**kwds):\n \n  warnings.filterwarnings(\"ignore\",\"bsdi_crypt rounds should be odd.*\")\n  super(_bsdi_crypt_test,self).test_77_fuzz_input(**kwds)\n  \n def test_needs_update_w_even_rounds(self):\n  ''\n  handler=self.handler\n  even_hash='_Y/../cG0zkJa6LY6k4c'\n  odd_hash='_Z/..TgFg0/ptQtpAgws'\n  secret='test'\n  \n  \n  self.assertTrue(handler.verify(secret,even_hash))\n  self.assertTrue(handler.verify(secret,odd_hash))\n  \n  \n  self.assertTrue(handler.needs_update(even_hash))\n  self.assertFalse(handler.needs_update(odd_hash))\n  \n  \n  new_hash=handler.hash(\"stub\")\n  self.assertFalse(handler.needs_update(new_hash))\n  \n  \nbsdi_crypt_os_crypt_test=_bsdi_crypt_test.create_backend_case(\"os_crypt\")\nbsdi_crypt_builtin_test=_bsdi_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass crypt16_test(HandlerCase):\n handler=hash.crypt16\n \n \n known_correct_hashes=[\n \n \n \n \n (\"passphrase\",\"qi8H8R7OM4xMUNMPuRAZxlY.\"),\n (\"printf\",\"aaCjFz4Sh8Eg2QSqAReePlq6\"),\n (\"printf\",\"AA/xje2RyeiSU0iBY3PDwjYo\"),\n (\"LOLOAQICI82QB4IP\",\"/.FcK3mad6JwYt8LVmDqz9Lc\"),\n (\"LOLOAQICI\",\"/.FcK3mad6JwYSaRHJoTPzY2\"),\n (\"LOLOAQIC\",\"/.FcK3mad6JwYelhbtlysKy6\"),\n (\"L\",\"/.CIu/PzYCkl6elhbtlysKy6\"),\n \n \n \n \n \n \n (UPASS_TABLE,'YeDc9tKkkmDvwP7buzpwhoqQ'),\n ]\n \n \n \n \nclass _des_crypt_test(HandlerCase):\n ''\n handler=hash.des_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','CCNf8Sbh3HDfQ'),\n ('U*U***U','CCX.K.MFy4Ois'),\n ('U*U***U*','CC4rMpbg9AMZ.'),\n ('*U*U*U*U','XXxzOu6maQKqQ'),\n ('','SDbsugeBiC58A'),\n \n \n \n \n ('','OgAwTx2l6NADI'),\n (' ','/Hk.VPuwQTXbc'),\n ('test','N1tQbOFcM5fpg'),\n ('Compl3X AlphaNu3meric','um.Wguz3eVCx2'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','sNYqfOyauIyic'),\n ('AlOtBsOl','cEpWz5IUCShqM'),\n \n \n (u('hell\\u00D6'),'saykDgk3BPZ9E'),\n ]\n known_unidentified_hashes=[\n \n \n '!gAwTx2l6NADI',\n \n \n 'OgAwTx2l6NAD',\n 'OgAwTx2l6NADIj',\n ]\n \n platform_crypt_support=[\n \n (\"openbsd[6789]\",False ),\n (\"openbsd5\",None ),\n (\"openbsd\",True ),\n \n (\"freebsd|netbsd|linux|solaris|darwin\",True ),\n ]\n \n \ndes_crypt_os_crypt_test=_des_crypt_test.create_backend_case(\"os_crypt\")\ndes_crypt_builtin_test=_des_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass fshp_test(HandlerCase):\n ''\n handler=hash.fshp\n \n known_correct_hashes=[\n \n \n \n \n ('test','{FSHP0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M='),\n \n ('test',\n '{FSHP1|8|4096}MTIzNDU2NzjTdHcmoXwNc0f'\n 'f9+ArUHoN0CvlbPZpxFi1C6RDM/MHSA=='\n ),\n \n ('OrpheanBeholderScryDoubt',\n '{FSHP1|8|4096}GVSUFDAjdh0vBosn1GUhz'\n 'GLHP7BmkbCZVH/3TQqGIjADXpc+6NCg3g=='\n ),\n ('ExecuteOrder66',\n '{FSHP3|16|8192}0aY7rZQ+/PR+Rd5/I9ss'\n 'RM7cjguyT8ibypNaSp/U1uziNO3BVlg5qPU'\n 'ng+zHUDQC3ao/JbzOnIBUtAeWHEy7a2vZeZ'\n '7jAwyJJa2EqOsq4Io='\n ),\n \n \n \n \n \n \n (UPASS_TABLE,'{FSHP1|16|16384}9v6/l3Lu/d9by5nznpOS'\n 'cqQo8eKu/b/CKli3RCkgYg4nRTgZu5y659YV8cCZ68UL'),\n ]\n \n known_unidentified_hashes=[\n \n '{FSHX0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n 'FSHP0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n ]\n \n known_malformed_hashes=[\n \n '{FSHP0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M',\n \n \n '{FSHP0|1|1}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n \n \n '{FSHP0|0|A}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n ]\n \n def test_90_variant(self):\n  ''\n  handler=self.handler\n  kwds=dict(salt=b'a',rounds=1)\n  \n  \n  handler(variant=1,**kwds)\n  \n  \n  handler(variant=u('1'),**kwds)\n  handler(variant=b'1',**kwds)\n  \n  \n  handler(variant=u('sha256'),**kwds)\n  handler(variant=b'sha256',**kwds)\n  \n  \n  self.assertRaises(TypeError,handler,variant=None ,**kwds)\n  \n  \n  self.assertRaises(TypeError,handler,variant=complex(1,1),**kwds)\n  \n  \n  self.assertRaises(ValueError,handler,variant='9',**kwds)\n  self.assertRaises(ValueError,handler,variant=9,**kwds)\n  \n  \n  \n  \nclass hex_md4_test(HandlerCase):\n handler=hash.hex_md4\n known_correct_hashes=[\n (\"password\",'8a9d093f14f8701df17732b2bb182c74'),\n (UPASS_TABLE,'876078368c47817ce5f9115f3a42cf74'),\n ]\n \nclass hex_md5_test(HandlerCase):\n handler=hash.hex_md5\n known_correct_hashes=[\n (\"password\",'5f4dcc3b5aa765d61d8327deb882cf99'),\n (UPASS_TABLE,'05473f8a19f66815e737b33264a0d0b0'),\n ]\n \n \n def test_mock_fips_mode(self):\n  ''\n\n\n  \n  from passlib.exc import UnknownHashError\n  from passlib.crypto.digest import lookup_hash,_set_mock_fips_mode\n  \n  \n  supported=lookup_hash(\"md5\",required=False ).supported\n  self.assertEqual(self.handler.supported,supported)\n  if supported:\n   _set_mock_fips_mode()\n   self.addCleanup(_set_mock_fips_mode,False )\n   \n   \n   \n  from passlib.handlers.digests import create_hex_hash\n  hasher=create_hex_hash(\"md5\",required=False )\n  self.assertFalse(hasher.supported)\n  \n  \n  ref1='5f4dcc3b5aa765d61d8327deb882cf99'\n  ref2='xxx'\n  self.assertTrue(hasher.identify(ref1))\n  self.assertFalse(hasher.identify(ref2))\n  \n  \n  pat=\"'md5' hash disabled for fips\"\n  self.assertRaisesRegex(UnknownHashError,pat,hasher.hash,\"password\")\n  self.assertRaisesRegex(UnknownHashError,pat,hasher.verify,\"password\",ref1)\n  \n  \nclass hex_sha1_test(HandlerCase):\n handler=hash.hex_sha1\n known_correct_hashes=[\n (\"password\",'5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8'),\n (UPASS_TABLE,'e059b2628e3a3e2de095679de9822c1d1466e0f0'),\n ]\n \nclass hex_sha256_test(HandlerCase):\n handler=hash.hex_sha256\n known_correct_hashes=[\n (\"password\",'5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'),\n (UPASS_TABLE,'6ed729e19bf24d3d20f564375820819932029df05547116cfc2cc868a27b4493'),\n ]\n \nclass hex_sha512_test(HandlerCase):\n handler=hash.hex_sha512\n known_correct_hashes=[\n (\"password\",'b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c'\n '706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cac'\n 'bc86'),\n (UPASS_TABLE,'d91bb0a23d66dca07a1781fd63ae6a05f6919ee5fc368049f350c9f'\n '293b078a18165d66097cf0d89fdfbeed1ad6e7dba2344e57348cd6d51308c843a06f'\n '29caf'),\n ]\n \n \n \n \nclass htdigest_test(UserHandlerMixin,HandlerCase):\n handler=hash.htdigest\n \n known_correct_hashes=[\n \n \n \n ((\"Circle Of Life\",\"Mufasa\",\"testrealm@host.com\"),\n '939e7578ed9e3c518a452acee763bce9'),\n \n \n ((UPASS_TABLE,UPASS_USD,UPASS_WAV),\n '4dabed2727d583178777fab468dd1f17'),\n ]\n \n known_unidentified_hashes=[\n \n '939e7578edAe3c518a452acee763bce9',\n \n \n '939e7578edxe3c518a452acee763bce9',\n ]\n \n def test_80_user(self):\n  raise self.skipTest(\"test case doesn't support 'realm' keyword\")\n  \n def populate_context(self,secret,kwds):\n  ''\n  if isinstance(secret,tuple):\n   secret,user,realm=secret\n  else :\n   user,realm=\"user\",\"realm\"\n  kwds.setdefault(\"user\",user)\n  kwds.setdefault(\"realm\",realm)\n  return secret\n  \n  \n  \n  \nclass ldap_md5_test(HandlerCase):\n handler=hash.ldap_md5\n known_correct_hashes=[\n (\"helloworld\",'{MD5}/F4DjTilcDIIVEHn/nAQsA=='),\n (UPASS_TABLE,'{MD5}BUc/ihn2aBXnN7MyZKDQsA=='),\n ]\n \nclass ldap_sha1_test(HandlerCase):\n handler=hash.ldap_sha1\n known_correct_hashes=[\n (\"helloworld\",'{SHA}at+xg6SiyUovktq1redipHiJpaE='),\n (UPASS_TABLE,'{SHA}4FmyYo46Pi3glWed6YIsHRRm4PA='),\n ]\n \nclass ldap_salted_md5_test(HandlerCase):\n handler=hash.ldap_salted_md5\n known_correct_hashes=[\n (\"testing1234\",'{SMD5}UjFY34os/pnZQ3oQOzjqGu4yeXE='),\n (UPASS_TABLE,'{SMD5}Z0ioJ58LlzUeRxm3K6JPGAvBGIM='),\n \n \n ('test','{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4cw'),\n ('test','{SMD5}XRlncfRzvGi0FDzgR98tUgBg7B3jXOs9p9S615qTkg=='),\n ('test','{SMD5}FbAkzOMOxRbMp6Nn4hnZuel9j9Gas7a2lvI+x5hT6j0='),\n ]\n \n known_malformed_hashes=[\n \n '{SMD5}IGVhwK+anvspmfDt2t0vgGjt/Q==',\n \n \n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4c',\n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4cw'\n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4cw=',\n '{SMD5}LnuZPJhiaY95/4lmV=pg548xBsD4P4cw',\n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P===',\n ]\n \nclass ldap_salted_sha1_test(HandlerCase):\n handler=hash.ldap_salted_sha1\n known_correct_hashes=[\n (\"testing123\",'{SSHA}0c0blFTXXNuAMHECS4uxrj3ZieMoWImr'),\n (\"secret\",\"{SSHA}0H+zTv8o4MR4H43n03eCsvw1luG8LdB7\"),\n (UPASS_TABLE,'{SSHA}3yCSD1nLZXznra4N8XzZgAL+s1sQYsx5'),\n \n \n ('test','{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOckw=='),\n ('test','{SSHA}/ZMF5KymNM+uEOjW+9STKlfCFj51bg3BmBNCiPHeW2ttbU0='),\n ('test','{SSHA}Pfx6Vf48AT9x3FVv8znbo8WQkEVSipHSWovxXmvNWUvp/d/7'),\n ]\n \n known_malformed_hashes=[\n \n '{SSHA}ZQK3Yvtvl6wtIRoISgMGPkcWU7Nfq5U=',\n \n \n '{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOck',\n '{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOckw=',\n '{SSHA}P90+qijSp8MJ1tN25j5o1Pf=UvlqjXHOGeOckw==',\n '{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOck===',\n ]\n \n \nclass ldap_salted_sha256_test(HandlerCase):\n handler=hash.ldap_salted_sha256\n known_correct_hashes=[\n \n \n (\"password\",'{SSHA256}x1tymSTVjozxQ2PtT46ysrzhZxbcskK0o2f8hEFx7fAQQmhtDSEkJA=='),\n (\"test\",'{SSHA256}xfqc9aOR6z15YaEk3/Ufd7UL9+JozB/1EPmCDTizL0GkdA7BuNda6w=='),\n (\"toomanysecrets\",'{SSHA256}RrTKrg6HFXcjJ+eDAq4UtbODxOr9RLeG+I69FoJvutcbY0zpfU+p1Q=='),\n (u('letm\\xe8\\xefn'),'{SSHA256}km7UjUTBZN8a+gf1ND2/qn15N7LsO/jmGYJXvyTfJKAbI0RoLWWslQ=='),\n \n \n \n ('test','{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDIm'),\n ('test','{SSHA256}J6MFQdkfjdmXz9UyUPb773kekJdm4dgSL4y8WQEQW11VipHSundOKaV0LsV4L6U='),\n ('test','{SSHA256}uBLazLaiBaPb6Cpnvq2XTYDkvXbYIuqRW1anMKk85d1/j1GqFQIgpHSOMUYIIcS4'),\n ]\n \n known_malformed_hashes=[\n \n '{SSHA256}Lpdyr1+lR+rtxgp3SpQnUuNw33ENivTl28nzF2ZI4Gm41/o=',\n \n \n '{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDI@',\n '{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDI',\n '{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDIm===',\n ]\n \n \n \nclass ldap_salted_sha512_test(HandlerCase):\n handler=hash.ldap_salted_sha512\n known_correct_hashes=[\n \n \n (\"toomanysecrets\",'{SSHA512}wExp4xjiCHS0zidJDC4UJq9EEeIebAQPJ1PWSwfhxWjfutI9XiiKuHm2AE41cEFfK+8HyI8bh+ztbczUGsvVFIgICWWPt7qu'),\n (u('letm\\xe8\\xefn'),'{SSHA512}mpNUSmZc3TNx+RnPwkIAVMf7ocEKLPrIoQNsg4Eu8dHvyCeb2xzHp5A6n4tF7ntknSvfvRZaJII4ImvNJlYsgiwAm0FMqR+3'),\n \n \n \n (\"password\",'{SSHA512}f/lFQskkl7PdMsTGJxHZq8LDt/l+UqRMm6/pj4pV7/xZkcOaKCgvQqp+KCeXc/Vd4RY6vEHWn4y0DnFcQ6wgyv9fyxk='),\n (\"test\",'{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+Uc'),\n \n \n \n ('test','{SSHA512}Yg9DQ2wURCFGwobu7R2O6cq7nVbnGMPrFCX0aPQ9kj/y1hd6k9PEzkgWCB5aXdPwPzNrVb0PkiHiBnG1CxFiT+B8L8U='),\n ('test','{SSHA512}5ecDGWs5RY4xLszUO6hAcl90W3wAozGQoI4Gqj8xSZdcfU1lVEM4aY8s+4xVeLitcn7BO8i7xkzMFWLoxas7SeHc23sP4dx77937PyeE0A=='),\n ('test','{SSHA512}6FQv5W47HGg2MFBFZofoiIbO8KRW75Pm51NKoInpthYQQ5ujazHGhVGzrj3JXgA7j0k+UNmkHdbJjdY5xcUHPzynFEII4fwfIySEcG5NKSU='),\n ]\n \n known_malformed_hashes=[\n \n '{SSHA512}zFnn4/8x8GveUaMqgrYWyIWqFQ0Irt6gADPtRk4Uv3nUC6uR5cD8+YdQni/0ZNij9etm6p17kSFuww3M6l+d6AbAeA==',\n \n \n '{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+U',\n '{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+U@',\n '{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+U===',\n ]\n \n \nclass ldap_plaintext_test(HandlerCase):\n\n handler=hash.ldap_plaintext\n known_correct_hashes=[\n (\"password\",'password'),\n (UPASS_TABLE,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n (PASS_TABLE_UTF8,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n ]\n known_unidentified_hashes=[\n \"{FOO}bar\",\n \n \n \"\",\n ]\n \n known_other_hashes=[\n (\"ldap_md5\",\"{MD5}/F4DjTilcDIIVEHn/nAQsA==\")\n ]\n \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_password(self):\n  \n   while True :\n    pwd=super(ldap_plaintext_test.FuzzHashGenerator,self).random_password()\n    if pwd:\n     return pwd\n     \nclass _ldap_md5_crypt_test(HandlerCase):\n\n\n handler=hash.ldap_md5_crypt\n \n known_correct_hashes=[\n \n \n \n ('','{CRYPT}$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.'),\n (' ','{CRYPT}$1$m/5ee7ol$bZn0kIBFipq39e.KDXX8I0'),\n ('test','{CRYPT}$1$ec6XvcoW$ghEtNK2U1MC5l.Dwgi3020'),\n ('Compl3X AlphaNu3meric','{CRYPT}$1$nX1e7EeI$ljQn72ZUgt6Wxd9hfvHdV0'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','{CRYPT}$1$jQS7o98J$V6iTcr71CGgwW2laf17pi1'),\n ('test','{CRYPT}$1$SuMrG47N$ymvzYjr7QcEQjaK5m1PGx1'),\n \n \n (UPASS_TABLE,'{CRYPT}$1$d6/Ky1lU$/xpf8m7ftmWLF.TjHCqel0'),\n ]\n \n known_malformed_hashes=[\n \n '{CRYPT}$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o!',\n ]\n \n \nldap_md5_crypt_os_crypt_test=_ldap_md5_crypt_test.create_backend_case(\"os_crypt\")\nldap_md5_crypt_builtin_test=_ldap_md5_crypt_test.create_backend_case(\"builtin\")\n\nclass _ldap_sha1_crypt_test(HandlerCase):\n\n\n handler=hash.ldap_sha1_crypt\n \n known_correct_hashes=[\n ('password','{CRYPT}$sha1$10$c.mcTzCw$gF8UeYst9yXX7WNZKc5Fjkq0.au7'),\n (UPASS_TABLE,'{CRYPT}$sha1$10$rnqXlOsF$aGJf.cdRPewJAXo1Rn1BkbaYh0fP'),\n ]\n \n def populate_settings(self,kwds):\n  kwds.setdefault(\"rounds\",10)\n  super(_ldap_sha1_crypt_test,self).populate_settings(kwds)\n  \n def test_77_fuzz_input(self,**ignored):\n  raise self.skipTest(\"unneeded\")\n  \n  \nldap_sha1_crypt_os_crypt_test=_ldap_sha1_crypt_test.create_backend_case(\"os_crypt\")\n\n\n\n\nclass lmhash_test(EncodingHandlerMixin,HandlerCase):\n handler=hash.lmhash\n secret_case_insensitive=True\n \n known_correct_hashes=[\n \n \n \n (\"OLDPASSWORD\",\"c9b81d939d6fd80cd408e6b105741864\"),\n (\"NEWPASSWORD\",'09eeab5aa415d6e4d408e6b105741864'),\n (\"welcome\",\"c23413a8a1e7665faad3b435b51404ee\"),\n \n \n \n \n ('','aad3b435b51404eeaad3b435b51404ee'),\n ('zzZZZzz','a5e6066de61c3e35aad3b435b51404ee'),\n ('passphrase','855c3697d9979e78ac404c4ba2c66533'),\n ('Yokohama','5ecd9236d21095ce7584248b8d2c9f9e'),\n \n \n (u('ENCYCLOP\\xC6DIA'),'fed6416bffc9750d48462b9d7aaac065'),\n (u('encyclop\\xE6dia'),'fed6416bffc9750d48462b9d7aaac065'),\n \n \n ((u(\"\\xC6\"),None ),'25d8ab4a0659c97aaad3b435b51404ee'),\n ((u(\"\\xC6\"),\"cp437\"),'25d8ab4a0659c97aaad3b435b51404ee'),\n ((u(\"\\xC6\"),\"latin-1\"),'184eecbbe9991b44aad3b435b51404ee'),\n ((u(\"\\xC6\"),\"utf-8\"),'00dd240fcfab20b8aad3b435b51404ee'),\n ]\n \n known_unidentified_hashes=[\n \n '855c3697d9979e78ac404c4ba2c6653X',\n ]\n \n def test_90_raw(self):\n  ''\n  from binascii import unhexlify\n  from passlib.utils.compat import str_to_bascii\n  lmhash=self.handler\n  for secret,hash in self.known_correct_hashes:\n   kwds={}\n   secret=self.populate_context(secret,kwds)\n   data=unhexlify(str_to_bascii(hash))\n   self.assertEqual(lmhash.raw(secret,**kwds),data)\n  self.assertRaises(TypeError,lmhash.raw,1)\n  \n  \n  \n  \nclass _md5_crypt_test(HandlerCase):\n handler=hash.md5_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','$1$dXc3I7Rw$ctlgjDdWJLMT.qwHsWhXR1'),\n ('U*U***U','$1$dXc3I7Rw$94JPyQc/eAgQ3MFMCoMF.0'),\n ('U*U***U*','$1$dXc3I7Rw$is1mVIAEtAhIzSdfn5JOO0'),\n ('*U*U*U*U','$1$eQT9Hwbt$XtuElNJD.eW5MN5UCWyTQ0'),\n ('','$1$Eu.GHtia$CFkL/nE1BYTlEPiVx1VWX0'),\n \n \n \n \n \n \n \n \n ('','$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.'),\n (' ','$1$m/5ee7ol$bZn0kIBFipq39e.KDXX8I0'),\n ('test','$1$ec6XvcoW$ghEtNK2U1MC5l.Dwgi3020'),\n ('Compl3X AlphaNu3meric','$1$nX1e7EeI$ljQn72ZUgt6Wxd9hfvHdV0'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','$1$jQS7o98J$V6iTcr71CGgwW2laf17pi1'),\n ('test','$1$SuMrG47N$ymvzYjr7QcEQjaK5m1PGx1'),\n (b'test','$1$SuMrG47N$ymvzYjr7QcEQjaK5m1PGx1'),\n (u('s'),'$1$ssssssss$YgmLTApYTv12qgTwBoj8i/'),\n \n \n (UPASS_TABLE,'$1$d6/Ky1lU$/xpf8m7ftmWLF.TjHCqel0'),\n ]\n \n known_malformed_hashes=[\n \n '$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o!',\n \n \n '$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.$',\n ]\n \n platform_crypt_support=[\n \n (\"openbsd[6789]\",False ),\n (\"openbsd5\",None ),\n (\"openbsd\",True ),\n \n (\"freebsd|netbsd|linux|solaris\",True ),\n (\"darwin\",False ),\n ]\n \n \nmd5_crypt_os_crypt_test=_md5_crypt_test.create_backend_case(\"os_crypt\")\nmd5_crypt_builtin_test=_md5_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass msdcc_test(UserHandlerMixin,HandlerCase):\n handler=hash.msdcc\n user_case_insensitive=True\n \n known_correct_hashes=[\n \n \n \n \n ((\"Asdf999\",\"sevans\"),\"b1176c2587478785ec1037e5abc916d0\"),\n \n \n \n \n ((\"ASDqwe123\",\"jdoe\"),\"592cdfbc3f1ef77ae95c75f851e37166\"),\n \n \n \n \n ((\"test1\",\"test1\"),\"64cd29e36a8431a2b111378564a10631\"),\n ((\"test2\",\"test2\"),\"ab60bdb4493822b175486810ac2abe63\"),\n ((\"test3\",\"test3\"),\"14dd041848e12fc48c0aa7a416a4a00c\"),\n ((\"test4\",\"test4\"),\"b945d24866af4b01a6d89b9d932a153c\"),\n \n \n \n \n ((\"1234qwer!@#$\",\"Administrator\"),\"7b69d06ef494621e3f47b9802fe7776d\"),\n \n \n \n \n ((\"password\",\"user\"),\"2d9f0b052932ad18b87f315641921cda\"),\n \n \n \n \n ((\"\",\"root\"),\"176a4c2bd45ac73687676c2f09045353\"),\n ((\"test1\",\"TEST1\"),\"64cd29e36a8431a2b111378564a10631\"),\n ((\"okolada\",\"nineteen_characters\"),\"290efa10307e36a79b3eebf2a6b29455\"),\n ((u(\"\\u00FC\"),u(\"\\u00FC\")),\"48f84e6f73d6d5305f6558a33fa2c9bb\"),\n ((u(\"\\u00FC\\u00FC\"),u(\"\\u00FC\\u00FC\")),\"593246a8335cf0261799bda2a2a9c623\"),\n ((u(\"\\u20AC\\u20AC\"),\"user\"),\"9121790702dda0fa5d353014c334c2ce\"),\n \n \n \n \n \n \n ((UPASS_TABLE,'bob'),'fcb82eb4212865c7ac3503156ca3f349'),\n ]\n \n known_alternate_hashes=[\n \n (\"B1176C2587478785EC1037E5ABC916D0\",(\"Asdf999\",\"sevans\"),\n \"b1176c2587478785ec1037e5abc916d0\"),\n ]\n \nclass msdcc2_test(UserHandlerMixin,HandlerCase):\n handler=hash.msdcc2\n user_case_insensitive=True\n \n known_correct_hashes=[\n \n \n \n ((\"test1\",\"test1\"),\"607bbe89611e37446e736f7856515bf8\"),\n ((\"qerwt\",\"Joe\"),\"e09b38f84ab0be586b730baf61781e30\"),\n ((\"12345\",\"Joe\"),\"6432f517a900b3fc34ffe57f0f346e16\"),\n ((\"\",\"bin\"),\"c0cbe0313a861062e29f92ede58f9b36\"),\n ((\"w00t\",\"nineteen_characters\"),\"87136ae0a18b2dafe4a41d555425b2ed\"),\n ((\"w00t\",\"eighteencharacters\"),\"fc5df74eca97afd7cd5abb0032496223\"),\n ((\"longpassword\",\"twentyXXX_characters\"),\"cfc6a1e33eb36c3d4f84e4c2606623d2\"),\n ((\"longpassword\",\"twentyoneX_characters\"),\"99ff74cea552799da8769d30b2684bee\"),\n ((\"longpassword\",\"twentytwoXX_characters\"),\"0a721bdc92f27d7fb23b87a445ec562f\"),\n ((\"test2\",\"TEST2\"),\"c6758e5be7fc943d00b97972a8a97620\"),\n ((\"test3\",\"test3\"),\"360e51304a2d383ea33467ab0b639cc4\"),\n ((\"test4\",\"test4\"),\"6f79ee93518306f071c47185998566ae\"),\n ((u(\"\\u00FC\"),\"joe\"),\"bdb80f2c4656a8b8591bd27d39064a54\"),\n ((u(\"\\u20AC\\u20AC\"),\"joe\"),\"1e1e20f482ff748038e47d801d0d1bda\"),\n ((u(\"\\u00FC\\u00FC\"),\"admin\"),\"0839e4a07c00f18a8c65cf5b985b9e73\"),\n \n \n \n \n \n \n ((UPASS_TABLE,'bob'),'cad511dc9edefcf69201da72efb6bb55'),\n ]\n \n \n \n \nclass mssql2000_test(HandlerCase):\n handler=hash.mssql2000\n secret_case_insensitive=\"verify-only\"\n \n \n known_correct_hashes=[\n \n \n \n ('Test','0x010034767D5C0CFA5FDCA28C4A56085E65E882E71CB0ED2503412FD54D6119FFF04129A1D72E7C3194F7284A7F3A'),\n ('TEST','0x010034767D5C2FD54D6119FFF04129A1D72E7C3194F7284A7F3A2FD54D6119FFF04129A1D72E7C3194F7284A7F3A'),\n \n \n \n \n ('x','0x010086489146C46DD7318D2514D1AC706457CBF6CD3DF8407F071DB4BBC213939D484BF7A766E974F03C96524794'),\n \n \n \n \n ('AAAA','0x0100CF465B7B12625EF019E157120D58DD46569AC7BF4118455D12625EF019E157120D58DD46569AC7BF4118455D'),\n \n \n \n \n ('123','0x01002D60BA07FE612C8DE537DF3BFCFA49CD9968324481C1A8A8FE612C8DE537DF3BFCFA49CD9968324481C1A8A8'),\n \n \n \n \n ('12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n \n \n \n \n \n \n \n \n \n \n ('foo','0x0100A607BA7C54A24D17B565C59F1743776A10250F581D482DA8B6D6261460D3F53B279CC6913CE747006A2E3254'),\n ('bar','0x01000508513EADDF6DB7DDD270CCA288BF097F2FF69CC2DB74FBB9644D6901764F999BAB9ECB80DE578D92E3F80D'),\n ('canard','0x01008408C523CF06DCB237835D701C165E68F9460580132E28ED8BC558D22CEDF8801F4503468A80F9C52A12C0A3'),\n ('lapin','0x0100BF088517935FC9183FE39FDEC77539FD5CB52BA5F5761881E5B9638641A79DBF0F1501647EC941F3355440A2'),\n \n \n \n \n \n \n (UPASS_USD,'0x0100624C0961B28E39FEE13FD0C35F57B4523F0DA1861C11D5A5B28E39FEE13FD0C35F57B4523F0DA1861C11D5A5'),\n (UPASS_TABLE,'0x010083104228FAD559BE52477F2131E538BE9734E5C4B0ADEFD7F6D784B03C98585DC634FE2B8CA3A6DFFEC729B4'),\n \n ]\n \n known_alternate_hashes=[\n \n ('0x01005b20054332752e1bc2e7c5df0f9ebfe486e9bee063e8d3b332752e1bc2e7c5df0f9ebfe486e9bee063e8d3b3',\n '12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n ]\n \n known_unidentified_hashes=[\n \n '0X01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n \n \n '0x02005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n \n \n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3',\n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3AF',\n \n \n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n ]\n \n known_malformed_hashes=[\n \n b'0x01005B200543327G2E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n u('0x01005B200543327G2E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n ]\n \nclass mssql2005_test(HandlerCase):\n handler=hash.mssql2005\n \n known_correct_hashes=[\n \n \n \n ('TEST','0x010034767D5C2FD54D6119FFF04129A1D72E7C3194F7284A7F3A'),\n \n \n \n \n ('toto','0x01004086CEB6BF932BC4151A1AF1F13CD17301D70816A8886908'),\n \n \n \n \n ('123','0x01004A335DCEDB366D99F564D460B1965B146D6184E4E1025195'),\n ('123','0x0100E11D573F359629B344990DCD3D53DE82CF8AD6BBA7B638B6'),\n \n \n \n \n \n \n \n \n \n \n ('AAAA','0x010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F30'),\n \n \n \n \n (\"toto\",\"0x01004086CEB6BF932BC4151A1AF1F13CD17301D70816A8886908\"),\n (\"titi\",\"0x01004086CEB60ED526885801C23B366965586A43D3DEAC6DD3FD\"),\n (\"foo\",\"0x0100A607BA7C54A24D17B565C59F1743776A10250F581D482DA8\"),\n (\"bar\",\"0x01000508513EADDF6DB7DDD270CCA288BF097F2FF69CC2DB74FB\"),\n (\"canard\",\"0x01008408C523CF06DCB237835D701C165E68F9460580132E28ED\"),\n (\"lapin\",\"0x0100BF088517935FC9183FE39FDEC77539FD5CB52BA5F5761881\"),\n \n \n \n \n ('Test','0x010034767D5C0CFA5FDCA28C4A56085E65E882E71CB0ED250341'),\n ('Test','0x0100993BF2315F36CC441485B35C4D84687DC02C78B0E680411F'),\n ('x','0x010086489146C46DD7318D2514D1AC706457CBF6CD3DF8407F07'),\n ('AAAA','0x0100CF465B7B12625EF019E157120D58DD46569AC7BF4118455D'),\n ('123','0x01002D60BA07FE612C8DE537DF3BFCFA49CD9968324481C1A8A8'),\n ('12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n \n \n \n \n \n \n (UPASS_USD,'0x0100624C0961B28E39FEE13FD0C35F57B4523F0DA1861C11D5A5'),\n (UPASS_TABLE,'0x010083104228FAD559BE52477F2131E538BE9734E5C4B0ADEFD7'),\n ]\n \n known_alternate_hashes=[\n \n ('0x01005b20054332752e1bc2e7c5df0f9ebfe486e9bee063e8d3b3',\n '12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n ]\n \n known_unidentified_hashes=[\n \n '0X010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F30',\n \n \n '0x020036D726AE86834E97F20B198ACD219D60B446AC5E48C54F30',\n \n \n '0x010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F',\n '0x010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F3012',\n \n \n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n ]\n \n known_malformed_hashes=[\n \n '0x010036D726AE86G34E97F20B198ACD219D60B446AC5E48C54F30',\n ]\n \n \n \n \nclass mysql323_test(HandlerCase):\n handler=hash.mysql323\n \n known_correct_hashes=[\n \n \n \n ('drew','697a7de87c5390b2'),\n ('password',\"5d2e19393cc5ef67\"),\n \n \n \n \n ('mypass','6f8c114b58f2ce9e'),\n \n \n (UPASS_TABLE,'4ef327ca5491c8d7'),\n ]\n \n known_unidentified_hashes=[\n \n '6z8c114b58f2ce9e',\n ]\n \n def test_90_whitespace(self):\n  ''\n  h=self.do_encrypt(\"mypass\")\n  h2=self.do_encrypt(\"my pass\")\n  self.assertEqual(h,h2)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def accept_password_pair(self,secret,other):\n  \n   return secret.replace(\" \",\"\")!=other.replace(\" \",\"\")\n   \nclass mysql41_test(HandlerCase):\n handler=hash.mysql41\n known_correct_hashes=[\n \n \n \n ('verysecretpassword','*2C905879F74F28F8570989947D06A8429FB943E6'),\n ('12345678123456781234567812345678','*F9F1470004E888963FB466A5452C9CBD9DF6239C'),\n (\"' OR 1 /*'\",'*97CF7A3ACBE0CA58D5391AC8377B5D9AC11D46D9'),\n \n \n \n \n ('mypass','*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4'),\n \n \n (UPASS_TABLE,'*E7AFE21A9CFA2FC9D15D942AE8FB5C240FE5837B'),\n ]\n known_unidentified_hashes=[\n \n '*6Z8989366EAF75BB670AD8EA7A7FC1176A95CEF4',\n ]\n \n \n \n \nclass nthash_test(HandlerCase):\n handler=hash.nthash\n \n known_correct_hashes=[\n \n \n \n (\"OLDPASSWORD\",u(\"6677b2c394311355b54f25eec5bfacf5\")),\n (\"NEWPASSWORD\",u(\"256781a62031289d3c2c98c14f1efc8c\")),\n \n \n \n \n \n \n ('','31d6cfe0d16ae931b73c59d7e0c089c0'),\n ('tigger','b7e0ea9fbffcf6dd83086e905089effd'),\n \n \n (b'\\xC3\\xBC','8bd6e4fb88e01009818749c5443ea712'),\n (b'\\xC3\\xBC\\xC3\\xBC','cc1260adb6985ca749f150c7e0b22063'),\n (b'\\xE2\\x82\\xAC','030926b781938db4365d46adc7cfbcb8'),\n (b'\\xE2\\x82\\xAC\\xE2\\x82\\xAC','682467b963bb4e61943e170a04f7db46'),\n \n \n \n \n ('passphrase','7f8fe03093cc84b267b109625f6bbf4b'),\n ]\n \n known_unidentified_hashes=[\n \n '7f8fe03093cc84b267b109625f6bbfxb',\n ]\n \nclass bsd_nthash_test(HandlerCase):\n handler=hash.bsd_nthash\n \n known_correct_hashes=[\n ('passphrase','$3$$7f8fe03093cc84b267b109625f6bbf4b'),\n (b'\\xC3\\xBC','$3$$8bd6e4fb88e01009818749c5443ea712'),\n ]\n \n known_unidentified_hashes=[\n \n '$3$$7f8fe03093cc84b267b109625f6bbfxb',\n ]\n \n \n \n \nclass oracle10_test(UserHandlerMixin,HandlerCase):\n handler=hash.oracle10\n secret_case_insensitive=True\n user_case_insensitive=True\n \n \n known_correct_hashes=[\n \n \n \n \n \n (('tiger','scott'),'F894844C34402B67'),\n ((u('ttTiGGeR'),u('ScO')),'7AA1A84E31ED7771'),\n ((\"d_syspw\",\"SYSTEM\"),'1B9F1F9A5CB9EB31'),\n ((\"strat_passwd\",\"strat_user\"),'AEBEDBB4EFB5225B'),\n \n \n \n \n (('#95LWEIGHTS','USER'),'000EA4D72A142E29'),\n (('CIAO2010','ALFREDO'),'EB026A76F0650F7B'),\n \n \n \n \n (('GLOUGlou','Bob'),'CDC6B483874B875B'),\n (('GLOUGLOUTER','bOB'),'EF1F9139DB2D5279'),\n (('LONG_MOT_DE_PASSE_OUI','BOB'),'EC8147ABB3373D53'),\n \n \n \n \n ((UPASS_TABLE,'System'),'B915A853F297B281'),\n ]\n \n known_unidentified_hashes=[\n \n 'F894844C34402B6Z',\n ]\n \nclass oracle11_test(HandlerCase):\n handler=hash.oracle11\n \n known_correct_hashes=[\n \n \n \n (\"abc123\",\"S:5FDAB69F543563582BA57894FE1C1361FB8ED57B903603F2C52ED1B4D642\"),\n (\"SyStEm123!@#\",\"S:450F957ECBE075D2FA009BA822A9E28709FBC3DA82B44D284DDABEC14C42\"),\n (\"oracle\",\"S:3437FF72BD69E3FB4D10C750B92B8FB90B155E26227B9AB62D94F54E5951\"),\n (\"11g\",\"S:61CE616647A4F7980AFD7C7245261AF25E0AFE9C9763FCF0D54DA667D4E6\"),\n (\"11g\",\"S:B9E7556F53500C8C78A58F50F24439D79962DE68117654B6700CE7CC71CF\"),\n \n \n \n \n (\"SHAlala\",\"S:2BFCFDF5895014EE9BB2B9BA067B01E0389BB5711B7B5F82B7235E9E182C\"),\n \n \n \n \n (UPASS_TABLE,'S:51586343E429A6DF024B8F242F2E9F8507B1096FACD422E29142AA4974B0'),\n ]\n \n \n \n \nclass phpass_test(HandlerCase):\n handler=hash.phpass\n \n known_correct_hashes=[\n \n \n \n \n ('test12345','$P$9IQRaTwmfeRo7ud9Fh4E2PdI0S3r.L0'),\n \n \n \n \n ('test1','$H$9aaaaaSXBjgypwqm.JsMssPLiS8YQ00'),\n ('123456','$H$9PE8jEklgZhgLmZl5.HYJAzfGCQtzi1'),\n ('123456','$H$9pdx7dbOW3Nnt32sikrjAxYFjX8XoK1'),\n ('thisisalongertestPW','$P$912345678LIjjb6PhecupozNBmDndU0'),\n ('JohnRipper','$P$612345678si5M0DDyPpmRCmcltU/YW/'),\n ('JohnRipper','$H$712345678WhEyvy1YWzT4647jzeOmo0'),\n ('JohnRipper','$P$B12345678L6Lpt4BxNotVIMILOa9u81'),\n \n \n \n \n ('','$P$7JaFQsPzJSuenezefD/3jHgt5hVfNH0'),\n ('compL3X!','$P$FiS0N5L672xzQx1rt1vgdJQRYKnQM9/'),\n \n \n (UPASS_TABLE,'$P$7SMy8VxnfsIy2Sxm7fJxDSdil.h7TW.'),\n ]\n \n known_malformed_hashes=[\n \n \n '$P$9IQRaTwmfeRo7ud9Fh4E2PdI0S3r!L0',\n ]\n \n \n \n \nclass plaintext_test(HandlerCase):\n\n handler=hash.plaintext\n accepts_all_hashes=True\n \n known_correct_hashes=[\n ('',''),\n ('password','password'),\n \n \n (UPASS_TABLE,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n (PASS_TABLE_UTF8,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n ]\n \n \n \n \nclass postgres_md5_test(UserHandlerMixin,HandlerCase):\n handler=hash.postgres_md5\n known_correct_hashes=[\n \n \n \n \n \n (('mypass','postgres'),'md55fba2ea04fd36069d2574ea71c8efe9d'),\n (('mypass','root'),'md540c31989b20437833f697e485811254b'),\n ((\"testpassword\",'testuser'),'md5d4fc5129cc2c25465a5370113ae9835f'),\n \n \n \n \n \n \n ((UPASS_TABLE,'postgres'),'md5cb9f11283265811ce076db86d18a22d2'),\n ]\n known_unidentified_hashes=[\n \n 'md54zc31989b20437833f697e485811254b',\n ]\n \n \n \n \nclass _sha1_crypt_test(HandlerCase):\n handler=hash.sha1_crypt\n \n known_correct_hashes=[\n \n \n \n (\"password\",\"$sha1$19703$iVdJqfSE$v4qYKl1zqYThwpjJAoKX6UvlHq/a\"),\n (\"password\",\"$sha1$21773$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH\"),\n (UPASS_TABLE,'$sha1$40000$uJ3Sp7LE$.VEmLO5xntyRFYihC7ggd3297T/D'),\n ]\n \n known_malformed_hashes=[\n \n '$sha1$21773$u!7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH',\n \n \n '$sha1$01773$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH',\n \n \n '$sha1$21773$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH$',\n \n \n '$sha1$$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH$',\n ]\n \n platform_crypt_support=[\n (\"netbsd\",True ),\n (\"freebsd|openbsd|solaris|darwin\",False ),\n (\"linux\",None ),\n ]\n \n \nsha1_crypt_os_crypt_test=_sha1_crypt_test.create_backend_case(\"os_crypt\")\nsha1_crypt_builtin_test=_sha1_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\n\n\n\n\n\nclass RoundupTest(TestCase):\n\n def _test_pair(self,h,secret,hash):\n  self.assertTrue(h.verify(secret,hash))\n  self.assertFalse(h.verify('x'+secret,hash))\n  \n def test_pairs(self):\n  self._test_pair(\n  hash.ldap_hex_sha1,\n  \"sekrit\",\n  '{SHA}8d42e738c7adee551324955458b5e2c0b49ee655')\n  \n  self._test_pair(\n  hash.ldap_hex_md5,\n  \"sekrit\",\n  '{MD5}ccbc53f4464604e714f69dd11138d8b5')\n  \n  self._test_pair(\n  hash.ldap_des_crypt,\n  \"sekrit\",\n  '{CRYPT}nFia0rj2TT59A')\n  \n  self._test_pair(\n  hash.roundup_plaintext,\n  \"sekrit\",\n  '{plaintext}sekrit')\n  \n  self._test_pair(\n  hash.ldap_pbkdf2_sha1,\n  \"sekrit\",\n  '{PBKDF2}5000$7BvbBq.EZzz/O0HuwX3iP.nAG3s$g3oPnFFaga2BJaX5PoPRljl4XIE')\n  \n  \n  \n  \nclass _sha256_crypt_test(HandlerCase):\n handler=hash.sha256_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','$5$LKO/Ute40T3FNF95$U0prpBQd4PloSGU0pnpM4z9wKn4vZ1.jsrzQfPqxph9'),\n ('U*U***U','$5$LKO/Ute40T3FNF95$fdgfoJEBoMajNxCv3Ru9LyQ0xZgv0OBMQoq80LQ/Qd.'),\n ('U*U***U*','$5$LKO/Ute40T3FNF95$8Ry82xGnnPI/6HtFYnvPBTYgOL23sdMXn8C29aO.x/A'),\n ('*U*U*U*U','$5$9mx1HkCz7G1xho50$O7V7YgleJKLUhcfk9pgzdh3RapEaWqMtEp9UUBAKIPA'),\n ('','$5$kc7lRD1fpYg0g.IP$d7CMTcEqJyTXyeq8hTdu/jB/I6DGkoo62NXbHIR7S43'),\n \n \n \n \n ('','$5$rounds=10428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3'),\n (' ','$5$rounds=10376$I5lNtXtRmf.OoMd8$Ko3AI1VvTANdyKhBPavaRjJzNpSatKU6QVN9uwS9MH.'),\n ('test','$5$rounds=11858$WH1ABM5sKhxbkgCK$aTQsjPkz0rBsH3lQlJxw9HDTDXPKBxC0LlVeV69P.t1'),\n ('Compl3X AlphaNu3meric','$5$rounds=10350$o.pwkySLCzwTdmQX$nCMVsnF3TXWcBPOympBUUSQi6LGGloZoOsVJMGJ09UB'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','$5$rounds=11944$9dhlu07dQMRWvTId$LyUI5VWkGFwASlzntk1RLurxX54LUhgAcJZIt0pYGT7'),\n (u('with unic\\u00D6de'),'$5$rounds=1000$IbG0EuGQXw5EkMdP$LQ5AfPf13KufFsKtmazqnzSGZ4pxtUNw3woQ.ELRDF4'),\n ]\n \n if TEST_MODE(\"full\"):\n \n \n \n \n  known_correct_hashes.extend([\n  (\"secret\",'$5$rounds=1004$nacl$oiWPbm.kQ7.jTCZoOtdv7/tO5mWv/vxw5yTqlBagVR7'),\n  (\"secret\",'$5$rounds=1005$nacl$6Mo/TmGDrXxg.bMK9isRzyWH3a..6HnSVVsJMEX7ud/'),\n  (\"secret\",'$5$rounds=1006$nacl$I46VwuAiUBwmVkfPFakCtjVxYYaOJscsuIeuZLbfKID'),\n  (\"secret\",'$5$rounds=1007$nacl$9fY4j1AV3N/dV/YMUn1enRHKH.7nEL4xf1wWB6wfDD4'),\n  (\"secret\",'$5$rounds=1008$nacl$CiFWCfn8ODmWs0I1xAdXFo09tM8jr075CyP64bu3by9'),\n  (\"secret\",'$5$rounds=1009$nacl$QtpFX.CJHgVQ9oAjVYStxAeiU38OmFILWm684c6FyED'),\n  (\"secret\",'$5$rounds=1010$nacl$ktAwXuT5WbjBW/0ZU1eNMpqIWY1Sm4twfRE1zbZyo.B'),\n  (\"secret\",'$5$rounds=1011$nacl$QJWLBEhO9qQHyMx4IJojSN9sS41P1Yuz9REddxdO721'),\n  (\"secret\",'$5$rounds=1012$nacl$mmf/k2PkbBF4VCtERgky3bEVavmLZKFwAcvxD1p3kV2'),\n  ])\n  \n known_malformed_hashes=[\n \n '$5$rounds=10428$uy/:jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMeZGsGx2aBvxTvDFI613c3',\n \n \n '$5$rounds=010428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3',\n \n \n '$5$rounds=10428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3$',\n ]\n \n known_correct_configs=[\n \n \n \n \n \n (\"$5$saltstring\",\"Hello world!\",\n \"$5$saltstring$5B8vYYiY.CVt1RlTTf8KbXBH3hsxY/GNooZaBBGWEc5\"),\n (\"$5$rounds=10000$saltstringsaltstring\",\"Hello world!\",\n \"$5$rounds=10000$saltstringsaltst$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.\"\n \"opqey6IcA\"),\n (\"$5$rounds=5000$toolongsaltstring\",\"This is just a test\",\n \"$5$rounds=5000$toolongsaltstrin$Un/5jzAHMgOGZ5.mWJpuVolil07guHPvOW8\"\n \"mGRcvxa5\"),\n (\"$5$rounds=1400$anotherlongsaltstring\",\n \"a very much longer text to encrypt.  This one even stretches over more\"\n \"than one line.\",\n \"$5$rounds=1400$anotherlongsalts$Rx.j8H.h8HjEDGomFU8bDkXm3XIUnzyxf12\"\n \"oP84Bnq1\"),\n (\"$5$rounds=77777$short\",\n \"we have a short salt string but not a short password\",\n \"$5$rounds=77777$short$JiO1O3ZpDAxGJeaDIuqCoEFysAe1mZNJRs3pw0KQRd/\"),\n (\"$5$rounds=123456$asaltof16chars..\",\"a short string\",\n \"$5$rounds=123456$asaltof16chars..$gP3VQ/6X7UUEW3HkBn2w1/Ptq2jxPyzV/\"\n \"cZKmF/wJvD\"),\n (\"$5$rounds=10$roundstoolow\",\"the minimum number is still observed\",\n \"$5$rounds=1000$roundstoolow$yfvwcWrQ8l/K0DAWyuPMDNHpIVlTQebY9l/gL97\"\n \"2bIC\"),\n ]\n \n filter_config_warnings=True\n \n platform_crypt_support=[\n (\"freebsd(9|1\\d)|linux\",True ),\n (\"freebsd8\",None ),\n (\"freebsd|openbsd|netbsd|darwin\",False ),\n (\"solaris\",None ),\n ]\n \n \nsha256_crypt_os_crypt_test=_sha256_crypt_test.create_backend_case(\"os_crypt\")\nsha256_crypt_builtin_test=_sha256_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass _sha512_crypt_test(HandlerCase):\n handler=hash.sha512_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*',\"$6$LKO/Ute40T3FNF95$6S/6T2YuOIHY0N3XpLKABJ3soYcXD9mB7uVbtEZDj/LNscVhZoZ9DEH.sBciDrMsHOWOoASbNLTypH/5X26gN0\"),\n ('U*U***U',\"$6$LKO/Ute40T3FNF95$wK80cNqkiAUzFuVGxW6eFe8J.fSVI65MD5yEm8EjYMaJuDrhwe5XXpHDJpwF/kY.afsUs1LlgQAaOapVNbggZ1\"),\n ('U*U***U*',\"$6$LKO/Ute40T3FNF95$YS81pp1uhOHTgKLhSMtQCr2cDiUiN03Ud3gyD4ameviK1Zqz.w3oXsMgO6LrqmIEcG3hiqaUqHi/WEE2zrZqa/\"),\n ('*U*U*U*U',\"$6$OmBOuxFYBZCYAadG$WCckkSZok9xhp4U1shIZEV7CCVwQUwMVea7L3A77th6SaE9jOPupEMJB.z0vIWCDiN9WLh2m9Oszrj5G.gt330\"),\n ('',\"$6$ojWH1AiTee9x1peC$QVEnTvRVlPRhcLQCk/HnHaZmlGAAjCfrAN0FtOsOnUk5K5Bn/9eLHHiRzrTzaIKjW9NTLNIBUCtNVOowWS2mN.\"),\n \n \n \n \n ('','$6$rounds=11021$KsvQipYPWpr93wWP$v7xjI4X6vyVptJjB1Y02vZC5SaSijBkGmq1uJhPr3cvqvvkd42Xvo48yLVPFt8dvhCsnlUgpX.//Cxn91H4qy1'),\n (' ','$6$rounds=11104$ED9SA4qGmd57Fq2m$q/.PqACDM/JpAHKmr86nkPzzuR5.YpYa8ZJJvI8Zd89ZPUYTJExsFEIuTYbM7gAGcQtTkCEhBKmp1S1QZwaXx0'),\n ('test','$6$rounds=11531$G/gkPn17kHYo0gTF$Kq.uZBHlSBXyzsOJXtxJruOOH4yc0Is13uY7yK0PvAvXxbvc1w8DO1RzREMhKsc82K/Jh8OquV8FZUlreYPJk1'),\n ('Compl3X AlphaNu3meric','$6$rounds=10787$wakX8nGKEzgJ4Scy$X78uqaX1wYXcSCtS4BVYw2trWkvpa8p7lkAtS9O/6045fK4UB2/Jia0Uy/KzCpODlfVxVNZzCCoV9s2hoLfDs/'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','$6$rounds=11065$5KXQoE1bztkY5IZr$Jf6krQSUKKOlKca4hSW07MSerFFzVIZt/N3rOTsUgKqp7cUdHrwV8MoIVNCk9q9WL3ZRMsdbwNXpVk0gVxKtz1'),\n \n \n (UPASS_TABLE,'$6$rounds=40000$PEZTJDiyzV28M3.m$GTlnzfzGB44DGd1XqlmC4erAJKCP.rhvLvrYxiT38htrNzVGBnplFOHjejUGVrCfusGWxLQCc3pFO0A/1jYYr0'),\n ]\n \n known_malformed_hashes=[\n \n '$6$rounds=011021$KsvQipYPWpr93wWP$v7xjI4X6vyVptJjB1Y02vZC5SaSijBkGmq1uJhPr3cvqvvkd42Xvo48yLVPFt8dvhCsnlUgpX.//Cxn91H4qy1',\n \n '$6$rounds=11021$KsvQipYPWpr9:wWP$v7xjI4X6vyVptJjB1Y02vZC5SaSijBkGmq1uJhPr3cvqvvkd42Xvo48yLVPFt8dvhCsnlUgpX.//Cxn91H4qy1',\n ]\n \n known_correct_configs=[\n \n \n \n \n \n (\"$6$saltstring\",\"Hello world!\",\n \"$6$saltstring$svn8UoSVapNtMuq1ukKS4tPQd8iKwSMHWjl/O817G3uBnIFNjnQJu\"\n \"esI68u4OTLiBFdcbYEdFCoEOfaS35inz1\"),\n \n (\"$6$rounds=10000$saltstringsaltstring\",\"Hello world!\",\n \"$6$rounds=10000$saltstringsaltst$OW1/O6BYHV6BcXZu8QVeXbDWra3Oeqh0sb\"\n \"HbbMCVNSnCM/UrjmM0Dp8vOuZeHBy/YTBmSK6H9qs/y3RnOaw5v.\"),\n \n (\"$6$rounds=5000$toolongsaltstring\",\"This is just a test\",\n \"$6$rounds=5000$toolongsaltstrin$lQ8jolhgVRVhY4b5pZKaysCLi0QBxGoNeKQ\"\n \"zQ3glMhwllF7oGDZxUhx1yxdYcz/e1JSbq3y6JMxxl8audkUEm0\"),\n \n (\"$6$rounds=1400$anotherlongsaltstring\",\n \"a very much longer text to encrypt.  This one even stretches over more\"\n \"than one line.\",\n \"$6$rounds=1400$anotherlongsalts$POfYwTEok97VWcjxIiSOjiykti.o/pQs.wP\"\n \"vMxQ6Fm7I6IoYN3CmLs66x9t0oSwbtEW7o7UmJEiDwGqd8p4ur1\"),\n \n (\"$6$rounds=77777$short\",\n \"we have a short salt string but not a short password\",\n \"$6$rounds=77777$short$WuQyW2YR.hBNpjjRhpYD/ifIw05xdfeEyQoMxIXbkvr0g\"\n \"ge1a1x3yRULJ5CCaUeOxFmtlcGZelFl5CxtgfiAc0\"),\n \n (\"$6$rounds=123456$asaltof16chars..\",\"a short string\",\n \"$6$rounds=123456$asaltof16chars..$BtCwjqMJGx5hrJhZywWvt0RLE8uZ4oPwc\"\n \"elCjmw2kSYu.Ec6ycULevoBK25fs2xXgMNrCzIMVcgEJAstJeonj1\"),\n \n (\"$6$rounds=10$roundstoolow\",\"the minimum number is still observed\",\n \"$6$rounds=1000$roundstoolow$kUMsbe306n21p9R.FRkW3IGn.S9NPN0x50YhH1x\"\n \"hLsPuWGsUSklZt58jaTfF4ZEQpyUNGc0dqbpBYYBaHHrsX.\"),\n ]\n \n filter_config_warnings=True\n \n platform_crypt_support=_sha256_crypt_test.platform_crypt_support\n \n \nsha512_crypt_os_crypt_test=_sha512_crypt_test.create_backend_case(\"os_crypt\")\nsha512_crypt_builtin_test=_sha512_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass sun_md5_crypt_test(HandlerCase):\n handler=hash.sun_md5_crypt\n \n \n \n known_correct_hashes=[\n \n \n \n (\"Gpcs3_adm\",\"$md5$zrdhpMlZ$$wBvMOEqbSjU.hu5T2VEP01\"),\n \n \n \n \n (\"aa12345678\",\"$md5$vyy8.OVF$$FY4TWzuauRl4.VQNobqMY.\"),\n \n \n \n \n (\"this\",\"$md5$3UqYqndY$$6P.aaWOoucxxq.l00SS9k0\"),\n \n \n \n \n (\"passwd\",\"$md5$RPgLF6IJ$WTvAlUJ7MqH5xak2FMEwS/\"),\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n (UPASS_TABLE,'$md5,rounds=5000$10VYDzAA$$1arAVtMA3trgE1qJ2V0Ez1'),\n ]\n \n known_correct_configs=[\n \n \n \n \n \n \n \n \n \n \n \n \n (\"$md5$3UqYqndY$\",\n \"this\",\"$md5$3UqYqndY$$6P.aaWOoucxxq.l00SS9k0\"),\n (\"$md5$3UqYqndY$$.................DUMMY\",\n \"this\",\"$md5$3UqYqndY$$6P.aaWOoucxxq.l00SS9k0\"),\n \n \n \n \n \n \n (\"$md5$3UqYqndY\",\n \"this\",\"$md5$3UqYqndY$HIZVnfJNGCPbDZ9nIRSgP1\"),\n (\"$md5$3UqYqndY$.................DUMMY\",\n \"this\",\"$md5$3UqYqndY$HIZVnfJNGCPbDZ9nIRSgP1\"),\n ]\n \n known_malformed_hashes=[\n \n \"$md5,rounds=5000\",\n \n \n \"$md5,rounds=500A$xxxx\",\n \"$md5,rounds=0500$xxxx\",\n \"$md5,rounds=0$xxxx\",\n \n \n \"$md5$RPgL!6IJ$WTvAlUJ7MqH5xak2FMEwS/\",\n \n \n \"$md5$RPgLa6IJ$WTvAlUJ7MqH5xak2FMEwS\",\n \n \n \"$md5$RPgLa6IJ$WTvAlUJ7MqH5xak2FMEwS/.\",\n \n \n \n \"$md5$3UqYqndY$$\",\n \n \n \n \"$md5$RPgLa6IJ$$$WTvAlUJ7MqH5xak2FMEwS/\",\n \n ]\n \n platform_crypt_support=[\n (\"solaris\",True ),\n (\"freebsd|openbsd|netbsd|linux|darwin\",False ),\n ]\n def do_verify(self,secret,hash):\n \n \n  if isinstance(hash,str)and hash.endswith(\"$.................DUMMY\"):\n   raise ValueError(\"pretending '$...' stub hash is config string\")\n  return self.handler.verify(secret,hash)\n  \n  \n  \n  \nclass unix_disabled_test(HandlerCase):\n handler=hash.unix_disabled\n \n \n known_correct_hashes=[\n \n \n (\"password\",\"!\"),\n (UPASS_TABLE,\"*\"),\n ]\n \n known_unidentified_hashes=[\n \n \"$1$xxx\",\n \"abc\",\n \"./az\",\n \"{SHA}xxx\",\n ]\n \n def test_76_hash_border(self):\n \n  self.accepts_all_hashes=True\n  super(unix_disabled_test,self).test_76_hash_border()\n  \n def test_90_special(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\"passing settings to .*.hash\\(\\) is deprecated\")\n  handler=self.handler\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"!asd\"),\"!asd\")\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"\"),handler.default_marker)\n  self.assertEqual(handler.hash(\"stub\"),handler.default_marker)\n  self.assertEqual(handler.using().default_marker,handler.default_marker)\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"\",marker=\"*xxx\"),\"*xxx\")\n  self.assertEqual(handler.hash(\"stub\",marker=\"*xxx\"),\"*xxx\")\n  self.assertEqual(handler.using(marker=\"*xxx\").hash(\"stub\"),\"*xxx\")\n  \n  \n  self.assertRaises(ValueError,handler.genhash,'stub',\"\",marker='abc')\n  self.assertRaises(ValueError,handler.hash,'stub',marker='abc')\n  self.assertRaises(ValueError,handler.using,marker='abc')\n  \nclass unix_fallback_test(HandlerCase):\n handler=hash.unix_fallback\n accepts_all_hashes=True\n \n known_correct_hashes=[\n \n (\"password\",\"!\"),\n (UPASS_TABLE,\"!\"),\n ]\n \n \n def setUp(self):\n  super(unix_fallback_test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\"'unix_fallback' is deprecated\")\n  \n def test_90_wildcard(self):\n  ''\n  h=self.handler\n  self.assertTrue(h.verify('password','',enable_wildcard=True ))\n  self.assertFalse(h.verify('password',''))\n  for c in \"!*x\":\n   self.assertFalse(h.verify('password',c,enable_wildcard=True ))\n   self.assertFalse(h.verify('password',c))\n   \n def test_91_preserves_existing(self):\n  ''\n  handler=self.handler\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"\"),\"!\")\n  self.assertEqual(handler.hash(\"stub\"),\"!\")\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"!asd\"),\"!asd\")\n  \n  \n  \n  \n", ["__future__", "binascii", "logging", "os", "passlib", "passlib.crypto.digest", "passlib.exc", "passlib.handlers.digests", "passlib.registry", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "sys", "warnings"]], "passlib.tests.test_handlers_django": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport re\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.utils import repeat_string\nfrom passlib.utils.compat import u\nfrom passlib.tests.utils import TestCase,HandlerCase,skipUnless,SkipTest\nfrom passlib.tests.test_handlers import UPASS_USD,UPASS_TABLE\nfrom passlib.tests.test_ext_django import DJANGO_VERSION,MIN_DJANGO_VERSION,\\\ncheck_django_hasher_has_backend\n\n\n\n\n\n\n\nUPASS_LETMEIN=u('l\\xe8tmein')\n\ndef vstr(version):\n return \".\".join(str(e)for e in version)\n \nclass _DjangoHelper(TestCase):\n ''\n\n\n \n __unittest_skip=True\n \n \n min_django_version=MIN_DJANGO_VERSION\n \n \n \n \n \n \n max_django_version=None\n \n def _require_django_support(self):\n \n  if DJANGO_VERSION <self.min_django_version:\n   raise self.skipTest(\"Django >= %s not installed\"%vstr(self.min_django_version))\n  if self.max_django_version and DJANGO_VERSION >self.max_django_version:\n   raise self.skipTest(\"Django <= %s not installed\"%vstr(self.max_django_version))\n   \n   \n  name=self.handler.django_name\n  if not check_django_hasher_has_backend(name):\n   raise self.skipTest('django hasher %r not available'%name)\n   \n  return True\n  \n extra_fuzz_verifiers=HandlerCase.fuzz_verifiers+(\n \"fuzz_verifier_django\",\n )\n \n def fuzz_verifier_django(self):\n  try :\n   self._require_django_support()\n  except SkipTest:\n   return None\n  from django.contrib.auth.hashers import check_password\n  \n  def verify_django(secret,hash):\n   ''\n   if self.handler.name ==\"django_bcrypt\"and hash.startswith(\"bcrypt$$2y$\"):\n    hash=hash.replace(\"$$2y$\",\"$$2a$\")\n   if isinstance(secret,bytes):\n    secret=secret.decode(\"utf-8\")\n   return check_password(secret,hash)\n  return verify_django\n  \n def test_90_django_reference(self):\n  ''\n  self._require_django_support()\n  \n  \n  from django.contrib.auth.hashers import check_password\n  assert self.known_correct_hashes\n  for secret,hash in self.iter_known_hashes():\n   self.assertTrue(check_password(secret,hash),\n   \"secret=%r hash=%r failed to verify\"%\n   (secret,hash))\n   self.assertFalse(check_password('x'+secret,hash),\n   \"mangled secret=%r hash=%r incorrect verified\"%\n   (secret,hash))\n   \n def test_91_django_generation(self):\n  ''\n  self._require_django_support()\n  \n  \n  from passlib.utils import tick\n  from django.contrib.auth.hashers import make_password\n  name=self.handler.django_name\n  end=tick()+self.max_fuzz_time /2\n  generator=self.FuzzHashGenerator(self,self.getRandom())\n  while tick()<end:\n   secret,other=generator.random_password_pair()\n   if not secret:\n    continue\n   if isinstance(secret,bytes):\n    secret=secret.decode(\"utf-8\")\n   hash=make_password(secret,hasher=name)\n   self.assertTrue(self.do_identify(hash))\n   self.assertTrue(self.do_verify(secret,hash))\n   self.assertFalse(self.do_verify(other,hash))\n   \nclass django_disabled_test(HandlerCase):\n ''\n handler=hash.django_disabled\n disabled_contains_salt=True\n \n known_correct_hashes=[\n \n (\"password\",\"!\"),\n (\"\",\"!\"),\n (UPASS_TABLE,\"!\"),\n ]\n \n known_alternate_hashes=[\n \n (\"!9wa845vn7098ythaehasldkfj\",\"password\",\"!\"),\n ]\n \nclass django_des_crypt_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_des_crypt\n max_django_version=(1,9)\n \n known_correct_hashes=[\n \n (\"password\",'crypt$c2$c2M87q...WWcU'),\n (\"password\",'crypt$c2e86$c2M87q...WWcU'),\n (\"passwordignoreme\",'crypt$c2.AZ$c2M87q...WWcU'),\n \n \n (UPASS_USD,'crypt$c2e86$c2hN1Bxd6ZiWs'),\n (UPASS_TABLE,'crypt$0.aQs$0.wB.TT0Czvlo'),\n (u(\"hell\\u00D6\"),\"crypt$sa$saykDgk3BPZ9E\"),\n \n \n (\"foo\",'crypt$MNVY.9ajgdvDQ$MNVY.9ajgdvDQ'),\n ]\n \n known_alternate_hashes=[\n \n \n ('crypt$$c2M87q...WWcU',\"password\",'crypt$c2$c2M87q...WWcU'),\n ]\n \n known_unidentified_hashes=[\n 'sha1$aa$bb',\n ]\n \n known_malformed_hashes=[\n \n 'crypt$c2$c2M87q',\n \n \n 'crypt$f$c2M87q...WWcU',\n \n \n 'crypt$ffe86$c2M87q...WWcU',\n ]\n \nclass django_salted_md5_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_salted_md5\n max_django_version=(1,9)\n \n known_correct_hashes=[\n \n (\"password\",'md5$123abcdef$c8272612932975ee80e8a35995708e80'),\n \n \n (\"test\",'md5$3OpqnFAHW5CT$54b29300675271049a1ebae07b395e20'),\n \n \n (UPASS_USD,'md5$c2e86$92105508419a81a6babfaecf876a2fa0'),\n (UPASS_TABLE,'md5$d9eb8$01495b32852bffb27cf5d4394fe7a54c'),\n ]\n \n known_unidentified_hashes=[\n 'sha1$aa$bb',\n ]\n \n known_malformed_hashes=[\n \n 'md5$aa$bb',\n ]\n \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_salt_size(self):\n  \n  \n  \n  \n   handler=self.handler\n   default=handler.default_salt_size\n   assert handler.min_salt_size ==0\n   lower=1\n   upper=handler.max_salt_size or default *4\n   return self.randintgauss(lower,upper,default,default *.5)\n   \nclass django_salted_sha1_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_salted_sha1\n max_django_version=(1,9)\n \n known_correct_hashes=[\n \n (\"password\",'sha1$123abcdef$e4a1877b0e35c47329e7ed7e58014276168a37ba'),\n \n \n (\"test\",'sha1$bcwHF9Hy8lxS$6b4cfa0651b43161c6f1471ce9523acf1f751ba3'),\n \n \n (UPASS_USD,'sha1$c2e86$0f75c5d7fbd100d587c127ef0b693cde611b4ada'),\n (UPASS_TABLE,'sha1$6d853$ef13a4d8fb57aed0cb573fe9c82e28dc7fd372d4'),\n \n \n (\"MyPassword\",'sha1$54123$893cf12e134c3c215f3a76bd50d13f92404a54d3'),\n ]\n \n known_unidentified_hashes=[\n 'md5$aa$bb',\n ]\n \n known_malformed_hashes=[\n \n 'sha1$c2e86$0f75',\n ]\n \n \n FuzzHashGenerator=django_salted_md5_test.FuzzHashGenerator\n \nclass django_pbkdf2_sha256_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_pbkdf2_sha256\n \n known_correct_hashes=[\n \n \n \n ('not a password',\n 'pbkdf2_sha256$10000$kjVJaVz6qsnJ$5yPHw3rwJGECpUf70daLGhOrQ5+AMxIJdz1c3bqK1Rs='),\n (UPASS_TABLE,\n 'pbkdf2_sha256$10000$bEwAfNrH1TlQ$OgYUblFNUX1B8GfMqaCYUK/iHyO0pa7STTDdaEJBuY0='),\n ]\n \nclass django_pbkdf2_sha1_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_pbkdf2_sha1\n \n known_correct_hashes=[\n \n \n \n ('not a password',\n 'pbkdf2_sha1$10000$wz5B6WkasRoF$atJmJ1o+XfJxKq1+Nu1f1i57Z5I='),\n (UPASS_TABLE,\n 'pbkdf2_sha1$10000$KZKWwvqb8BfL$rw5pWsxJEU4JrZAQhHTCO+u0f5Y='),\n ]\n \n@skipUnless(hash.bcrypt.has_backend(),\"no bcrypt backends available\")\nclass django_bcrypt_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_bcrypt\n \n max_django_version=(2,0)\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n \n ('','bcrypt$$2a$06$DCq7YPn5Rq63x1Lad4cll.TV4S6ytwfsfvkgY8jIucDrjc8deX1s.'),\n ('abcdefghijklmnopqrstuvwxyz',\n 'bcrypt$$2a$10$fVH8e28OQRj9tqiDXs1e1uxpsjN0c7II7YPKXua2NAKYvM6iQk7dq'),\n (UPASS_TABLE,\n 'bcrypt$$2a$05$Z17AXnnlpzddNUvnC6cZNOSwMA/8oNiKnHTHTwLlBijfucQQlHjaG'),\n ]\n \n \n \n def populate_settings(self,kwds):\n \n  kwds.setdefault(\"rounds\",4)\n  super(django_bcrypt_test,self).populate_settings(kwds)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n  def random_ident(self):\n  \n  \n   return None\n   \n@skipUnless(hash.bcrypt.has_backend(),\"no bcrypt backends available\")\nclass django_bcrypt_sha256_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_bcrypt_sha256\n forbidden_characters=None\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n ('',\n 'bcrypt_sha256$$2a$06$/3OeRpbOf8/l6nPPRdZPp.nRiyYqPobEZGdNRBWihQhiFDh1ws1tu'),\n (UPASS_LETMEIN,\n 'bcrypt_sha256$$2a$08$NDjSAIcas.EcoxCRiArvT.MkNiPYVhrsrnJsRkLueZOoV1bsQqlmC'),\n (UPASS_TABLE,\n 'bcrypt_sha256$$2a$06$kCXUnRFQptGg491siDKNTu8RxjBGSjALHRuvhPYNFsa4Ea5d9M48u'),\n \n \n (repeat_string(\"abc123\",72),\n 'bcrypt_sha256$$2a$06$Tg/oYyZTyAf.Nb3qSgN61OySmyXA8FoY4PjGizjE1QSDfuL5MXNni'),\n (repeat_string(\"abc123\",72)+\"qwr\",\n 'bcrypt_sha256$$2a$06$Tg/oYyZTyAf.Nb3qSgN61Ocy0BEz1RK6xslSNi8PlaLX2pe7x/KQG'),\n (repeat_string(\"abc123\",72)+\"xyz\",\n 'bcrypt_sha256$$2a$06$Tg/oYyZTyAf.Nb3qSgN61OvY2zoRVUa2Pugv2ExVOUT2YmhvxUFUa'),\n ]\n \n known_malformed_hashers=[\n \n 'bcrypt_sha256$xyz$2a$06$/3OeRpbOf8/l6nPPRdZPp.nRiyYqPobEZGdNRBWihQhiFDh1ws1tu',\n ]\n \n \n \n def populate_settings(self,kwds):\n \n  kwds.setdefault(\"rounds\",4)\n  super(django_bcrypt_sha256_test,self).populate_settings(kwds)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n  def random_ident(self):\n  \n  \n   return None\n   \nfrom passlib.tests.test_handlers_argon2 import _base_argon2_test\n\n@skipUnless(hash.argon2.has_backend(),\"no argon2 backends available\")\nclass django_argon2_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_argon2\n \n \n \n known_correct_hashes=[\n \n (\"password\",'argon2$argon2i$v=19$m=256,t=1,p=1$c29tZXNhbHQ$AJFIsNZTMKTAewB4+ETN1A'),\n \n \n (\"password\",'argon2$argon2i$v=19$m=380,t=2,p=2$c29tZXNhbHQ$SrssP8n7m/12VWPM8dvNrw'),\n \n \n (UPASS_LETMEIN,'argon2$argon2i$v=19$m=512,t=2,p=2$V25jN1l4UUJZWkR1$MxpA1BD2Gh7+D79gaAw6sQ'),\n ]\n \n def setUpWarnings(self):\n  super(django_argon2_test,self).setUpWarnings()\n  warnings.filterwarnings(\"ignore\",\".*Using argon2pure backend.*\")\n  \n def do_stub_encrypt(self,handler=None ,**settings):\n \n \n  handler=(handler or self.handler).using(**settings)\n  self=handler.wrapped(use_defaults=True )\n  self.checksum=self._stub_checksum\n  assert self.checksum\n  return handler._wrap_hash(self.to_string())\n  \n def test_03_legacy_hash_workflow(self):\n \n  raise self.skipTest(\"legacy 1.6 workflow not supported\")\n  \n class FuzzHashGenerator(_base_argon2_test.FuzzHashGenerator):\n \n  def random_type(self):\n  \n   return \"I\"\n   \n  def random_rounds(self):\n  \n   return self.randintgauss(1,3,2,1)\n   \n   \n   \n   \n", ["__future__", "django.contrib.auth.hashers", "logging", "passlib", "passlib.tests.test_ext_django", "passlib.tests.test_handlers", "passlib.tests.test_handlers_argon2", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "re", "warnings"]], "passlib.tests.test_totp": [".py", "''\n\n\n\n\nimport datetime\nfrom functools import partial\nimport logging ;log=logging.getLogger(__name__)\nimport sys\nimport time as _time\n\n\nfrom passlib import exc\nfrom passlib.utils.compat import unicode,u\nfrom passlib.tests.utils import TestCase,time_call\n\nfrom passlib import totp as totp_module\nfrom passlib.totp import TOTP,AppWallet,AES_SUPPORT\n\n__all__=[\n\"EngineTest\",\n]\n\n\n\n\n\n\n\n\n\nBase32DecodeError=Base16DecodeError=TypeError\nif sys.version_info >=(3,0):\n from binascii import Error as Base16DecodeError\nif sys.version_info >=(3,3):\n from binascii import Error as Base32DecodeError\n \nPASS1=\"abcdef\"\nPASS2=b\"\\x00\\xFF\"\nKEY1='4AOGGDBBQSYHNTUZ'\nKEY1_RAW=b'\\xe0\\x1cc\\x0c!\\x84\\xb0v\\xce\\x99'\nKEY2_RAW=b'\\xee]\\xcb9\\x870\\x06 D\\xc8y/\\xa54&\\xe4\\x9c\\x13\\xc2\\x18'\nKEY3='S3JDVB7QD2R7JPXX'\nKEY4='JBSWY3DPEHPK3PXP'\nKEY4_RAW=b'Hello!\\xde\\xad\\xbe\\xef'\n\n\n\n\n\n\n\nassert sys.float_info.radix ==2,\"unexpected float_info.radix\"\nassert sys.float_info.mant_dig >=44,\"double precision unexpectedly small\"\n\ndef _get_max_time_t():\n ''\n\n \n value=1 <<30\n year=0\n while True :\n  next_value=value <<1\n  try :\n   next_year=datetime.datetime.utcfromtimestamp(next_value -1).year\n  except (ValueError,OSError,OverflowError):\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   break\n   \n   \n   \n   \n   \n   \n   \n  if next_year <year:\n   break\n   \n  value=next_value\n  \n  \n value -=1\n \n \n \n \n max_datetime_timestamp=253402318800\n return min(value,max_datetime_timestamp)\n \n \n \nmax_time_t=_get_max_time_t()\n\ndef to_b32_size(raw_size):\n return (raw_size *8+4)//5\n \n \n \n \nclass AppWalletTest(TestCase):\n descriptionPrefix=\"passlib.totp.AppWallet\"\n \n \n \n \n \n def test_secrets_types(self):\n  ''\n  \n  \n  wallet=AppWallet()\n  self.assertEqual(wallet._secrets,{})\n  self.assertFalse(wallet.has_secrets)\n  \n  \n  ref={\"1\":b\"aaa\",\"2\":b\"bbb\"}\n  wallet=AppWallet(ref)\n  self.assertEqual(wallet._secrets,ref)\n  self.assertTrue(wallet.has_secrets)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  wallet=AppWallet(\"\\n 1: aaa\\n# comment\\n \\n2: bbb   \")\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  wallet=AppWallet(\"1: aaa: bbb \\n# comment\\n \\n2: bbb   \")\n  self.assertEqual(wallet._secrets,{\"1\":b\"aaa: bbb\",\"2\":b\"bbb\"})\n  \n  \n  wallet=AppWallet('{\"1\":\"aaa\",\"2\":\"bbb\"}')\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  \n  \n  \n  \n  self.assertRaises(TypeError,AppWallet,123)\n  \n  \n  self.assertRaises(TypeError,AppWallet,\"[123]\")\n  \n  \n  \n  \n  \n  self.assertRaises(ValueError,AppWallet,{\"1\":\"aaa\",\"2\":\"\"})\n  \n def test_secrets_tags(self):\n  ''\n  \n  \n  ref={\"1\":b\"aaa\",\"02\":b\"bbb\",\"C\":b\"ccc\"}\n  wallet=AppWallet(ref)\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  wallet=AppWallet({u(\"1\"):b\"aaa\",u(\"02\"):b\"bbb\",u(\"C\"):b\"ccc\"})\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  wallet=AppWallet({1:b\"aaa\",\"02\":b\"bbb\",\"C\":b\"ccc\"})\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  self.assertRaises(TypeError,AppWallet,{(1,):\"aaa\"})\n  \n  \n  wallet=AppWallet({\"1-2_3.4\":b\"aaa\"})\n  \n  \n  self.assertRaises(ValueError,AppWallet,{\"-abc\":\"aaa\"})\n  self.assertRaises(ValueError,AppWallet,{\"ab*$\":\"aaa\"})\n  \n  \n  wallet=AppWallet({\"1\":u(\"aaa\"),\"02\":\"bbb\",\"C\":b\"ccc\"})\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  self.assertRaises(TypeError,AppWallet,{\"1\":123})\n  self.assertRaises(TypeError,AppWallet,{\"1\":None })\n  self.assertRaises(TypeError,AppWallet,{\"1\":[]})\n  \n  \n  \n def test_default_tag(self):\n  ''\n  \n  \n  wallet=AppWallet({\"1\":\"one\",\"02\":\"two\"})\n  self.assertEqual(wallet.default_tag,\"02\")\n  self.assertEqual(wallet.get_secret(wallet.default_tag),b\"two\")\n  \n  \n  wallet=AppWallet({\"1\":\"one\",\"02\":\"two\",\"A\":\"aaa\"})\n  self.assertEqual(wallet.default_tag,\"A\")\n  self.assertEqual(wallet.get_secret(wallet.default_tag),b\"aaa\")\n  \n  \n  wallet=AppWallet({\"1\":\"one\",\"02\":\"two\",\"A\":\"aaa\"},default_tag=\"1\")\n  self.assertEqual(wallet.default_tag,\"1\")\n  self.assertEqual(wallet.get_secret(wallet.default_tag),b\"one\")\n  \n  \n  self.assertRaises(KeyError,AppWallet,{\"1\":\"one\",\"02\":\"two\",\"A\":\"aaa\"},\n  default_tag=\"B\")\n  \n  \n  wallet=AppWallet()\n  self.assertEqual(wallet.default_tag,None )\n  self.assertRaises(KeyError,wallet.get_secret,None )\n  \n  \n  \n  \n  \n  \n def require_aes_support(self,canary=None ):\n  if AES_SUPPORT:\n   canary and canary()\n  else :\n   canary and self.assertRaises(RuntimeError,canary)\n   raise self.skipTest(\"'cryptography' package not installed\")\n   \n def test_decrypt_key(self):\n  ''\n  \n  wallet=AppWallet({\"1\":PASS1,\"2\":PASS2})\n  \n  \n  CIPHER1=dict(v=1,c=13,s='6D7N7W53O7HHS37NLUFQ',\n  k='MHCTEGSNPFN5CGBJ',t='1')\n  self.require_aes_support(canary=partial(wallet.decrypt_key,CIPHER1))\n  \n  \n  self.assertEqual(wallet.decrypt_key(CIPHER1)[0],KEY1_RAW)\n  \n  \n  CIPHER2=dict(v=1,c=13,s='SPZJ54Y6IPUD2BYA4C6A',\n  k='ZGDXXTVQOWYLC2AU',t='1')\n  self.assertEqual(wallet.decrypt_key(CIPHER2)[0],KEY1_RAW)\n  \n  \n  CIPHER3=dict(v=1,c=8,s='FCCTARTIJWE7CPQHUDKA',\n  k='D2DRS32YESGHHINWFFCELKN7Z6NAHM4M',t='2')\n  self.assertEqual(wallet.decrypt_key(CIPHER3)[0],KEY2_RAW)\n  \n  \n  temp=CIPHER1.copy()\n  temp.update(t='2')\n  self.assertEqual(wallet.decrypt_key(temp)[0],b'\\xafD6.F7\\xeb\\x19\\x05Q')\n  \n  \n  temp=CIPHER1.copy()\n  temp.update(t='3')\n  self.assertRaises(KeyError,wallet.decrypt_key,temp)\n  \n  \n  temp=CIPHER1.copy()\n  temp.update(v=999)\n  self.assertRaises(ValueError,wallet.decrypt_key,temp)\n  \n def test_decrypt_key_needs_recrypt(self):\n  ''\n  self.require_aes_support()\n  \n  wallet=AppWallet({\"1\":PASS1,\"2\":PASS2},encrypt_cost=13)\n  \n  \n  ref=dict(v=1,c=13,s='AAAA',k='AAAA',t='2')\n  self.assertFalse(wallet.decrypt_key(ref)[1])\n  \n  \n  temp=ref.copy()\n  temp.update(c=8)\n  self.assertTrue(wallet.decrypt_key(temp)[1])\n  \n  \n  temp=ref.copy()\n  temp.update(t=\"1\")\n  self.assertTrue(wallet.decrypt_key(temp)[1])\n  \n  \n  \n def assertSaneResult(self,result,wallet,key,tag=\"1\",\n needs_recrypt=False ):\n  ''\n  \n  self.assertEqual(set(result),set([\"v\",\"t\",\"c\",\"s\",\"k\"]))\n  \n  self.assertEqual(result['v'],1)\n  self.assertEqual(result['t'],tag)\n  self.assertEqual(result['c'],wallet.encrypt_cost)\n  \n  self.assertEqual(len(result['s']),to_b32_size(wallet.salt_size))\n  self.assertEqual(len(result['k']),to_b32_size(len(key)))\n  \n  result_key,result_needs_recrypt=wallet.decrypt_key(result)\n  self.assertEqual(result_key,key)\n  self.assertEqual(result_needs_recrypt,needs_recrypt)\n  \n def test_encrypt_key(self):\n  ''\n  \n  \n  wallet=AppWallet({\"1\":PASS1},encrypt_cost=5)\n  self.require_aes_support(canary=partial(wallet.encrypt_key,KEY1_RAW))\n  \n  \n  result=wallet.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet,KEY1_RAW)\n  \n  \n  other=wallet.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet,KEY1_RAW)\n  self.assertNotEqual(other['s'],result['s'])\n  self.assertNotEqual(other['k'],result['k'])\n  \n  \n  wallet2=AppWallet({\"1\":PASS1},encrypt_cost=6)\n  result=wallet2.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet2,KEY1_RAW)\n  \n  \n  wallet2=AppWallet({\"1\":PASS1,\"2\":PASS2})\n  result=wallet2.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet2,KEY1_RAW,tag=\"2\")\n  \n  \n  wallet2=AppWallet({\"1\":PASS1})\n  wallet2.salt_size=64\n  result=wallet2.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet2,KEY1_RAW)\n  \n  \n  result=wallet.encrypt_key(KEY2_RAW)\n  self.assertSaneResult(result,wallet,KEY2_RAW)\n  \n  \n  \n  self.assertRaises(ValueError,wallet.encrypt_key,b\"\")\n  \n def test_encrypt_cost_timing(self):\n  ''\n  self.require_aes_support()\n  \n  \n  wallet=AppWallet({\"1\":\"aaa\"})\n  wallet.encrypt_cost -=2\n  delta,_=time_call(partial(wallet.encrypt_key,KEY1_RAW),maxtime=0)\n  \n  \n  wallet.encrypt_cost +=3\n  delta2,_=time_call(partial(wallet.encrypt_key,KEY1_RAW),maxtime=0)\n  \n  \n  \n  self.assertAlmostEqual(delta2,delta *8,delta=(delta *8)*0.5)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nRFC_KEY_BYTES_20=\"12345678901234567890\".encode(\"ascii\")\nRFC_KEY_BYTES_32=(RFC_KEY_BYTES_20 *2)[:32]\nRFC_KEY_BYTES_64=(RFC_KEY_BYTES_20 *4)[:64]\n\n\n\n\nclass TotpTest(TestCase):\n ''\n\n \n \n \n \n \n descriptionPrefix=\"passlib.totp.TOTP\"\n \n \n \n \n def setUp(self):\n  super(TotpTest,self).setUp()\n  \n  \n  from passlib.crypto.digest import lookup_hash\n  lookup_hash.clear_cache()\n  \n  \n  self.patchAttr(totp_module,\"rng\",self.getRandom())\n  \n  \n  \n  \n def randtime(self):\n  ''\n\n\n  \n  return self.getRandom().random()*max_time_t\n  \n def randotp(self,cls=None ,**kwds):\n  ''\n\n  \n  rng=self.getRandom()\n  if \"key\"not in kwds:\n   kwds['new']=True\n  kwds.setdefault(\"digits\",rng.randint(6,10))\n  kwds.setdefault(\"alg\",rng.choice([\"sha1\",\"sha256\",\"sha512\"]))\n  kwds.setdefault(\"period\",rng.randint(10,120))\n  return (cls or TOTP)(**kwds)\n  \n def test_randotp(self):\n  ''\n\n  \n  otp1=self.randotp()\n  otp2=self.randotp()\n  \n  self.assertNotEqual(otp1.key,otp2.key,\"key not randomized:\")\n  \n  \n  for _ in range(10):\n   if otp1.digits !=otp2.digits:\n    break\n   otp2=self.randotp()\n  else :\n   self.fail(\"digits not randomized\")\n   \n   \n  for _ in range(10):\n   if otp1.alg !=otp2.alg:\n    break\n   otp2=self.randotp()\n  else :\n   self.fail(\"alg not randomized\")\n   \n   \n   \n   \n   \n   \n vector_defaults=dict(format=\"base32\",alg=\"sha1\",period=30,digits=8)\n \n \n \n vectors=[\n \n \n \n \n \n \n [dict(key=\"ACDEFGHJKL234567\",digits=6),\n \n (1412873399,'221105'),\n (1412873400,'178491'),\n (1412873401,'178491'),\n (1412873429,'178491'),\n (1412873430,'915114'),\n ],\n \n \n [dict(key=\"ACDEFGHJKL234567\",digits=8),\n \n (1412873399,'20221105'),\n (1412873400,'86178491'),\n (1412873401,'86178491'),\n (1412873429,'86178491'),\n (1412873430,'03915114'),\n ],\n \n \n [dict(key=\"S3JD-VB7Q-D2R7-JPXX\",digits=6),\n (1419622709,'000492'),\n (1419622739,'897212'),\n ],\n \n \n \n \n \n \n \n \n \n [dict(key=RFC_KEY_BYTES_20,format=\"raw\",alg=\"sha1\"),\n (59,'94287082'),\n (1111111109,'07081804'),\n (1111111111,'14050471'),\n (1234567890,'89005924'),\n (2000000000,'69279037'),\n (20000000000,'65353130'),\n ],\n \n \n [dict(key=RFC_KEY_BYTES_32,format=\"raw\",alg=\"sha256\"),\n (59,'46119246'),\n (1111111109,'68084774'),\n (1111111111,'67062674'),\n (1234567890,'91819424'),\n (2000000000,'90698825'),\n (20000000000,'77737706'),\n ],\n \n \n [dict(key=RFC_KEY_BYTES_64,format=\"raw\",alg=\"sha512\"),\n (59,'90693936'),\n (1111111109,'25091201'),\n (1111111111,'99943326'),\n (1234567890,'93441116'),\n (2000000000,'38618901'),\n (20000000000,'47863826'),\n ],\n \n \n \n \n \n \n [dict(key=\"JBSWY3DPEHPK3PXP\",digits=6),(1409192430,'727248'),(1419890990,'122419')],\n [dict(key=\"JBSWY3DPEHPK3PXP\",digits=9,period=41),(1419891152,'662331049')],\n \n \n [dict(key=RFC_KEY_BYTES_20,format=\"raw\",period=60),(1111111111,'19360094')],\n [dict(key=RFC_KEY_BYTES_32,format=\"raw\",alg=\"sha256\",period=60),(1111111111,'40857319')],\n [dict(key=RFC_KEY_BYTES_64,format=\"raw\",alg=\"sha512\",period=60),(1111111111,'37023009')],\n \n ]\n \n def iter_test_vectors(self):\n  ''\n\n\n  \n  from passlib.totp import TOTP\n  for row in self.vectors:\n   kwds=self.vector_defaults.copy()\n   kwds.update(row[0])\n   for entry in row[1:]:\n    if len(entry)==3:\n     time,token,expires=entry\n    else :\n     time,token=entry\n     expires=None\n     \n     \n    log.debug(\"test vector: %r time=%r token=%r expires=%r\",kwds,time,token,expires)\n    otp=TOTP(**kwds)\n    prefix=\"alg=%r time=%r token=%r: \"%(otp.alg,time,token)\n    yield otp,time,token,expires,prefix\n    \n    \n    \n    \n def test_ctor_w_new(self):\n  ''\n  \n  \n  self.assertRaises(TypeError,TOTP)\n  self.assertRaises(TypeError,TOTP,key='4aoggdbbqsyhntuz',new=True )\n  \n  \n  otp=TOTP(new=True )\n  otp2=TOTP(new=True )\n  self.assertNotEqual(otp.key,otp2.key)\n  \n def test_ctor_w_size(self):\n  ''\n  \n  \n  self.assertEqual(len(TOTP(new=True ,alg=\"sha1\").key),20)\n  self.assertEqual(len(TOTP(new=True ,alg=\"sha256\").key),32)\n  self.assertEqual(len(TOTP(new=True ,alg=\"sha512\").key),64)\n  \n  \n  self.assertEqual(len(TOTP(new=True ,size=10).key),10)\n  self.assertEqual(len(TOTP(new=True ,size=16).key),16)\n  \n  \n  self.assertRaises(ValueError,TOTP,new=True ,size=21,alg=\"sha1\")\n  \n  \n  self.assertRaises(ValueError,TOTP,new=True ,size=9)\n  \n  \n  with self.assertWarningList([\n  dict(category=exc.PasslibSecurityWarning,message_re=\".*for security purposes, secret key must be.*\")\n  ]):\n   _=TOTP('0A'*9,'hex')\n   \n def test_ctor_w_key_and_format(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1).key,KEY1_RAW)\n  \n  \n  self.assertEqual(TOTP(KEY1.lower()).key,KEY1_RAW)\n  \n  \n  self.assertEqual(TOTP(' 4aog gdbb qsyh ntuz ').key,KEY1_RAW)\n  \n  \n  self.assertRaises(Base32DecodeError,TOTP,'ao!ggdbbqsyhntuz')\n  \n  \n  self.assertEqual(TOTP('e01c630c2184b076ce99','hex').key,KEY1_RAW)\n  \n  \n  self.assertRaises(Base16DecodeError,TOTP,'X01c630c2184b076ce99','hex')\n  \n  \n  self.assertEqual(TOTP(KEY1_RAW,\"raw\").key,KEY1_RAW)\n  \n def test_ctor_w_alg(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1,alg=\"SHA-256\").alg,\"sha256\")\n  self.assertEqual(TOTP(KEY1,alg=\"SHA256\").alg,\"sha256\")\n  \n  \n  self.assertRaises(ValueError,TOTP,KEY1,alg=\"SHA-333\")\n  \n def test_ctor_w_digits(self):\n  ''\n  self.assertRaises(ValueError,TOTP,KEY1,digits=5)\n  self.assertEqual(TOTP(KEY1,digits=6).digits,6)\n  self.assertEqual(TOTP(KEY1,digits=10).digits,10)\n  self.assertRaises(ValueError,TOTP,KEY1,digits=11)\n  \n def test_ctor_w_period(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1).period,30)\n  \n  \n  self.assertEqual(TOTP(KEY1,period=63).period,63)\n  \n  \n  self.assertRaises(TypeError,TOTP,KEY1,period=1.5)\n  self.assertRaises(TypeError,TOTP,KEY1,period='abc')\n  \n  \n  self.assertRaises(ValueError,TOTP,KEY1,period=0)\n  self.assertRaises(ValueError,TOTP,KEY1,period=-1)\n  \n def test_ctor_w_label(self):\n  ''\n  self.assertEqual(TOTP(KEY1).label,None )\n  self.assertEqual(TOTP(KEY1,label=\"foo@bar\").label,\"foo@bar\")\n  self.assertRaises(ValueError,TOTP,KEY1,label=\"foo:bar\")\n  \n def test_ctor_w_issuer(self):\n  ''\n  self.assertEqual(TOTP(KEY1).issuer,None )\n  self.assertEqual(TOTP(KEY1,issuer=\"foo.com\").issuer,\"foo.com\")\n  self.assertRaises(ValueError,TOTP,KEY1,issuer=\"foo.com:bar\")\n  \n  \n  \n  \n  \n  \n  \n def test_using_w_period(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1).period,30)\n  \n  \n  self.assertEqual(TOTP.using(period=63)(KEY1).period,63)\n  \n  \n  self.assertRaises(TypeError,TOTP.using,period=1.5)\n  self.assertRaises(TypeError,TOTP.using,period='abc')\n  \n  \n  self.assertRaises(ValueError,TOTP.using,period=0)\n  self.assertRaises(ValueError,TOTP.using,period=-1)\n  \n def test_using_w_now(self):\n  ''\n  \n  \n  \n  \n  otp=self.randotp()\n  self.assertIs(otp.now,_time.time)\n  self.assertAlmostEqual(otp.normalize_time(None ),int(_time.time()))\n  \n  \n  counter=[123.12]\n  def now():\n   counter[0]+=1\n   return counter[0]\n  otp=self.randotp(cls=TOTP.using(now=now))\n  \n  self.assertEqual(otp.normalize_time(None ),126)\n  self.assertEqual(otp.normalize_time(None ),127)\n  \n  \n  self.assertRaises(TypeError,TOTP.using,now=123)\n  \n  \n  msg_re=r\"now\\(\\) function must return non-negative\"\n  self.assertRaisesRegex(AssertionError,msg_re,TOTP.using,now=lambda :'abc')\n  \n  \n  self.assertRaisesRegex(AssertionError,msg_re,TOTP.using,now=lambda :-1)\n  \n  \n  \n  \n  \n def test_normalize_token_instance(self,otp=None ):\n  ''\n  if otp is None :\n   otp=self.randotp(digits=7)\n   \n   \n  self.assertEqual(otp.normalize_token(u('1234567')),'1234567')\n  self.assertEqual(otp.normalize_token(b'1234567'),'1234567')\n  \n  \n  self.assertEqual(otp.normalize_token(1234567),'1234567')\n  \n  \n  self.assertEqual(otp.normalize_token(234567),'0234567')\n  \n  \n  self.assertRaises(TypeError,otp.normalize_token,1234567.0)\n  self.assertRaises(TypeError,otp.normalize_token,None )\n  \n  \n  self.assertRaises(exc.MalformedTokenError,otp.normalize_token,'123456')\n  \n  \n  self.assertRaises(exc.MalformedTokenError,otp.normalize_token,'01234567')\n  self.assertRaises(exc.MalformedTokenError,otp.normalize_token,12345678)\n  \n def test_normalize_token_class(self):\n  ''\n  self.test_normalize_token_instance(otp=TOTP.using(digits=7))\n  \n def test_normalize_time(self):\n  ''\n  TotpFactory=TOTP.using()\n  otp=self.randotp(TotpFactory)\n  \n  for _ in range(10):\n   time=self.randtime()\n   tint=int(time)\n   \n   self.assertEqual(otp.normalize_time(time),tint)\n   self.assertEqual(otp.normalize_time(tint+0.5),tint)\n   \n   self.assertEqual(otp.normalize_time(tint),tint)\n   \n   dt=datetime.datetime.utcfromtimestamp(time)\n   self.assertEqual(otp.normalize_time(dt),tint)\n   \n   orig=TotpFactory.now\n   try :\n    TotpFactory.now=staticmethod(lambda :time)\n    self.assertEqual(otp.normalize_time(None ),tint)\n   finally :\n    TotpFactory.now=orig\n    \n  self.assertRaises(TypeError,otp.normalize_time,'1234')\n  \n  \n  \n  \n  \n def test_key_attrs(self):\n  ''\n  rng=self.getRandom()\n  \n  \n  otp=TOTP(KEY1_RAW,\"raw\")\n  self.assertEqual(otp.key,KEY1_RAW)\n  self.assertEqual(otp.hex_key,'e01c630c2184b076ce99')\n  self.assertEqual(otp.base32_key,KEY1)\n  \n  \n  self.assertEqual(otp.pretty_key(),'4AOG-GDBB-QSYH-NTUZ')\n  self.assertEqual(otp.pretty_key(sep=\" \"),'4AOG GDBB QSYH NTUZ')\n  self.assertEqual(otp.pretty_key(sep=False ),KEY1)\n  self.assertEqual(otp.pretty_key(format=\"hex\"),'e01c-630c-2184-b076-ce99')\n  \n  \n  otp=TOTP(new=True ,size=rng.randint(10,20))\n  _=otp.hex_key\n  _=otp.base32_key\n  _=otp.pretty_key()\n  \n  \n  \n  \n def test_totp_token(self):\n  ''\n  from passlib.totp import TOTP,TotpToken\n  \n  \n  otp=TOTP('s3jdvb7qd2r7jpxx')\n  result=otp.generate(1419622739)\n  self.assertIsInstance(result,TotpToken)\n  self.assertEqual(result.token,'897212')\n  self.assertEqual(result.counter,47320757)\n  \n  self.assertEqual(result.expire_time,1419622740)\n  self.assertEqual(result,('897212',1419622740))\n  self.assertEqual(len(result),2)\n  self.assertEqual(result[0],'897212')\n  self.assertEqual(result[1],1419622740)\n  self.assertRaises(IndexError,result.__getitem__,-3)\n  self.assertRaises(IndexError,result.__getitem__,2)\n  self.assertTrue(result)\n  \n  \n  otp.now=lambda :1419622739.5\n  self.assertEqual(result.remaining,0.5)\n  self.assertTrue(result.valid)\n  \n  otp.now=lambda :1419622741\n  self.assertEqual(result.remaining,0)\n  self.assertFalse(result.valid)\n  \n  \n  result2=otp.generate(1419622739)\n  self.assertIsNot(result2,result)\n  self.assertEqual(result2,result)\n  \n  \n  result3=otp.generate(1419622711)\n  self.assertIsNot(result3,result)\n  self.assertEqual(result3,result)\n  \n  \n  result4=otp.generate(1419622999)\n  self.assertNotEqual(result4,result)\n  \n def test_generate(self):\n  ''\n  from passlib.totp import TOTP\n  \n  \n  otp=TOTP(new=True )\n  time=self.randtime()\n  result=otp.generate(time)\n  token=result.token\n  self.assertIsInstance(token,unicode)\n  start_time=result.counter *30\n  \n  \n  self.assertEqual(otp.generate(start_time+29).token,token)\n  \n  \n  self.assertNotEqual(otp.generate(start_time+30).token,token)\n  \n  \n  dt=datetime.datetime.utcfromtimestamp(time)\n  self.assertEqual(int(otp.normalize_time(dt)),int(time))\n  \n  \n  self.assertEqual(otp.generate(dt).token,token)\n  \n  \n  otp2=TOTP.using(now=lambda :time)(key=otp.base32_key)\n  self.assertEqual(otp2.generate().token,token)\n  \n  \n  self.assertRaises(ValueError,otp.generate,-1)\n  \n def test_generate_w_reference_vectors(self):\n  ''\n  for otp,time,token,expires,prefix in self.iter_test_vectors():\n  \n   result=otp.generate(time)\n   self.assertEqual(result.token,token,msg=prefix)\n   self.assertEqual(result.counter,time //otp.period,msg=prefix)\n   if expires:\n    self.assertEqual(result.expire_time,expires)\n    \n    \n    \n    \n    \n def assertTotpMatch(self,match,time,skipped=0,period=30,window=30,msg=''):\n  from passlib.totp import TotpMatch\n  \n  \n  self.assertIsInstance(match,TotpMatch)\n  \n  \n  self.assertIsInstance(match.totp,TOTP)\n  self.assertEqual(match.totp.period,period)\n  \n  \n  self.assertEqual(match.time,time,msg=msg+\" matched time:\")\n  expected=time //period\n  counter=expected+skipped\n  self.assertEqual(match.counter,counter,msg=msg+\" matched counter:\")\n  self.assertEqual(match.expected_counter,expected,msg=msg+\" expected counter:\")\n  self.assertEqual(match.skipped,skipped,msg=msg+\" skipped:\")\n  self.assertEqual(match.cache_seconds,period+window)\n  expire_time=(counter+1)*period\n  self.assertEqual(match.expire_time,expire_time)\n  self.assertEqual(match.cache_time,expire_time+window)\n  \n  \n  self.assertEqual(len(match),2)\n  self.assertEqual(match,(counter,time))\n  self.assertRaises(IndexError,match.__getitem__,-3)\n  self.assertEqual(match[0],counter)\n  self.assertEqual(match[1],time)\n  self.assertRaises(IndexError,match.__getitem__,2)\n  \n  \n  self.assertTrue(match)\n  \n def test_totp_match_w_valid_token(self):\n  ''\n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  result=otp.match(token,time)\n  self.assertTotpMatch(result,time=time,skipped=0)\n  \n def test_totp_match_w_older_token(self):\n  ''\n  from passlib.totp import TotpMatch\n  \n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  result=otp.match(token,time -30)\n  self.assertTotpMatch(result,time=time -30,skipped=1)\n  \n def test_totp_match_w_new_token(self):\n  ''\n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  result=otp.match(token,time+30)\n  self.assertTotpMatch(result,time=time+30,skipped=-1)\n  \n def test_totp_match_w_invalid_token(self):\n  ''\n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  self.assertRaises(exc.InvalidTokenError,otp.match,token,time+60)\n  \n  \n  \n  \n  \n def assertVerifyMatches(self,expect_skipped,token,time,\n otp,gen_time=None ,**kwds):\n  ''\n  \n  msg=\"key=%r alg=%r period=%r token=%r gen_time=%r time=%r:\"%\\\n  (otp.base32_key,otp.alg,otp.period,token,gen_time,time)\n  result=otp.match(token,time,**kwds)\n  self.assertTotpMatch(result,\n  time=otp.normalize_time(time),\n  period=otp.period,\n  window=kwds.get(\"window\",30),\n  skipped=expect_skipped,\n  msg=msg)\n  \n def assertVerifyRaises(self,exc_class,token,time,\n otp,gen_time=None ,\n **kwds):\n  ''\n  \n  msg=\"key=%r alg=%r period=%r token=%r gen_time=%r time=%r:\"%\\\n  (otp.base32_key,otp.alg,otp.period,token,gen_time,time)\n  return self.assertRaises(exc_class,otp.match,token,time,\n  __msg__=msg,**kwds)\n  \n def test_match_w_window(self):\n  ''\n  \n  \n  otp=self.randotp()\n  period=otp.period\n  time=self.randtime()\n  token=otp.generate(time).token\n  common=dict(otp=otp,gen_time=time)\n  assertMatches=partial(self.assertVerifyMatches,**common)\n  assertRaises=partial(self.assertVerifyRaises,**common)\n  \n  \n  \n  \n  \n  \n  assertRaises(exc.InvalidTokenError,token,time -period,window=0)\n  assertMatches(+1,token,time -period,window=period)\n  assertMatches(+1,token,time -period,window=2 *period)\n  \n  \n  assertMatches(0,token,time,window=0)\n  \n  \n  assertRaises(exc.InvalidTokenError,token,time+period,window=0)\n  assertMatches(-1,token,time+period,window=period)\n  assertMatches(-1,token,time+period,window=2 *period)\n  \n  \n  assertRaises(exc.InvalidTokenError,token,time+2 *period,window=0)\n  assertRaises(exc.InvalidTokenError,token,time+2 *period,window=period)\n  assertMatches(-2,token,time+2 *period,window=2 *period)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  dt=datetime.datetime.utcfromtimestamp(time)\n  assertMatches(0,token,dt,window=0)\n  \n  \n  assertRaises(ValueError,token,-1)\n  \n def test_match_w_skew(self):\n  ''\n  \n  otp=self.randotp()\n  period=otp.period\n  time=self.randtime()\n  common=dict(otp=otp,gen_time=time)\n  assertMatches=partial(self.assertVerifyMatches,**common)\n  assertRaises=partial(self.assertVerifyRaises,**common)\n  \n  \n  skew=3 *period\n  behind_token=otp.generate(time -skew).token\n  assertRaises(exc.InvalidTokenError,behind_token,time,window=0)\n  assertMatches(-3,behind_token,time,window=0,skew=-skew)\n  \n  \n  ahead_token=otp.generate(time+skew).token\n  assertRaises(exc.InvalidTokenError,ahead_token,time,window=0)\n  assertMatches(+3,ahead_token,time,window=0,skew=skew)\n  \n  \n  \n def test_match_w_reuse(self):\n  ''\n  \n  \n  otp=self.randotp()\n  period=otp.period\n  time=self.randtime()\n  tdata=otp.generate(time)\n  token=tdata.token\n  counter=tdata.counter\n  expire_time=tdata.expire_time\n  common=dict(otp=otp,gen_time=time)\n  assertMatches=partial(self.assertVerifyMatches,**common)\n  assertRaises=partial(self.assertVerifyRaises,**common)\n  \n  \n  \n  assertMatches(-1,token,time+period,window=period)\n  \n  \n  \n  assertMatches(-1,token,time+period,last_counter=counter -1,\n  window=period)\n  \n  \n  \n  assertRaises(exc.InvalidTokenError,token,time+2 *period,\n  last_counter=counter,window=period)\n  \n  \n  \n  err=assertRaises(exc.UsedTokenError,token,time+period,\n  last_counter=counter,window=period)\n  self.assertEqual(err.expire_time,expire_time)\n  \n  \n  \n  err=assertRaises(exc.UsedTokenError,token,time,\n  last_counter=counter,window=0)\n  self.assertEqual(err.expire_time,expire_time)\n  \n def test_match_w_token_normalization(self):\n  ''\n  \n  otp=TOTP('otxl2f5cctbprpzx')\n  match=otp.match\n  time=1412889861\n  \n  \n  self.assertTrue(match('    3 32-136  ',time))\n  \n  \n  self.assertTrue(match(b'332136',time))\n  \n  \n  self.assertRaises(exc.MalformedTokenError,match,'12345',time)\n  \n  \n  self.assertRaises(exc.MalformedTokenError,match,'12345X',time)\n  \n  \n  self.assertRaises(exc.MalformedTokenError,match,'0123456',time)\n  \n def test_match_w_reference_vectors(self):\n  ''\n  for otp,time,token,expires,msg in self.iter_test_vectors():\n  \n   match=otp.match\n   \n   \n   result=match(token,time)\n   self.assertTrue(result)\n   self.assertEqual(result.counter,time //otp.period,msg=msg)\n   \n   \n   self.assertRaises(exc.InvalidTokenError,match,token,time+100,window=0)\n   \n   \n   \n   \n def test_verify(self):\n  ''\n  \n  \n  \n  from passlib.totp import TOTP\n  \n  time=1412889861\n  TotpFactory=TOTP.using(now=lambda :time)\n  \n  \n  source1=dict(v=1,type=\"totp\",key='otxl2f5cctbprpzx')\n  match=TotpFactory.verify('332136',source1)\n  self.assertTotpMatch(match,time=time)\n  \n  \n  source1=dict(v=1,type=\"totp\",key='otxl2f5cctbprpzx')\n  self.assertRaises(exc.InvalidTokenError,TotpFactory.verify,'332155',source1)\n  \n  \n  source1=dict(v=1,type=\"totp\")\n  self.assertRaises(ValueError,TotpFactory.verify,'332155',source1)\n  \n  \n  source1json='{\"v\": 1, \"type\": \"totp\", \"key\": \"otxl2f5cctbprpzx\"}'\n  match=TotpFactory.verify('332136',source1json)\n  self.assertTotpMatch(match,time=time)\n  \n  \n  source1uri='otpauth://totp/Label?secret=otxl2f5cctbprpzx'\n  match=TotpFactory.verify('332136',source1uri)\n  self.assertTotpMatch(match,time=time)\n  \n  \n  \n  \n def test_from_source(self):\n  ''\n  from passlib.totp import TOTP\n  from_source=TOTP.from_source\n  \n  \n  otp=from_source(u(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Example\"))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(b\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  b\"issuer=Example\")\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(dict(v=1,type=\"totp\",key=KEY4))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(u('{\"v\": 1, \"type\": \"totp\", \"key\": \"JBSWY3DPEHPK3PXP\"}'))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(b'{\"v\": 1, \"type\": \"totp\", \"key\": \"JBSWY3DPEHPK3PXP\"}')\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  self.assertIs(from_source(otp),otp)\n  \n  \n  wallet1=AppWallet()\n  otp1=TOTP.using(wallet=wallet1).from_source(otp)\n  self.assertIsNot(otp1,otp)\n  self.assertEqual(otp1.to_dict(),otp.to_dict())\n  \n  \n  otp2=TOTP.using(wallet=wallet1).from_source(otp1)\n  self.assertIs(otp2,otp1)\n  \n  \n  self.assertRaises(ValueError,from_source,u(\"foo\"))\n  self.assertRaises(ValueError,from_source,b\"foo\")\n  \n  \n  \n  \n def test_from_uri(self):\n  ''\n  from passlib.totp import TOTP\n  from_uri=TOTP.from_uri\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Example\")\n  self.assertIsInstance(otp,TOTP)\n  self.assertEqual(otp.key,KEY4_RAW)\n  self.assertEqual(otp.label,\"alice@google.com\")\n  self.assertEqual(otp.issuer,\"Example\")\n  self.assertEqual(otp.alg,\"sha1\")\n  self.assertEqual(otp.period,30)\n  self.assertEqual(otp.digits,6)\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=jbswy3dpehpk3pxp&\"\n  \"issuer=Example\")\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?digits=6\")\n  \n  \n  self.assertRaises(Base32DecodeError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHP@3PXP\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Provider1:Alice%20Smith?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Provider1\")\n  self.assertEqual(otp.label,\"Alice Smith\")\n  self.assertEqual(otp.issuer,\"Provider1\")\n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Big%20Corporation%3A%20alice@bigco.com?\"\n  \"secret=JBSWY3DPEHPK3PXP\")\n  self.assertEqual(otp.label,\"alice@bigco.com\")\n  self.assertEqual(otp.issuer,\"Big Corporation\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/alice@bigco.com?secret=JBSWY3DPEHPK3PXP&issuer=Big%20Corporation\")\n  self.assertEqual(otp.label,\"alice@bigco.com\")\n  self.assertEqual(otp.issuer,\"Big Corporation\")\n  \n  \n  self.assertRaises(ValueError,TOTP.from_uri,\n  \"otpauth://totp/Provider1:alice?secret=JBSWY3DPEHPK3PXP&issuer=Provider2\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&algorithm=SHA256\")\n  self.assertEqual(otp.alg,\"sha256\")\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHPK3PXP&algorithm=SHA333\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=8\")\n  self.assertEqual(otp.digits,8)\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=A\")\n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=%20\")\n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=15\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&period=63\")\n  self.assertEqual(otp.period,63)\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHPK3PXP&period=0\")\n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHPK3PXP&period=-1\")\n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([\n  dict(category=exc.PasslibRuntimeWarning,message_re=\"unexpected parameters encountered\")\n  ]):\n   otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n   \"foo=bar&period=63\")\n  self.assertEqual(otp.base32_key,KEY4)\n  self.assertEqual(otp.period,63)\n  \n def test_to_uri(self):\n  ''\n  \n  \n  \n  \n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30)\n  self.assertEqual(otp.to_uri(\"alice@google.com\",\"Example Org\"),\n  \"otpauth://totp/Example%20Org:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Example%20Org\")\n  \n  \n  self.assertRaises(ValueError,otp.to_uri,None ,\"Example Org\")\n  \n  \n  self.assertEqual(otp.to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP\")\n  \n  \n  otp.label=\"alice@google.com\"\n  self.assertEqual(otp.to_uri(),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP\")\n  \n  \n  otp.issuer=\"Example Org\"\n  self.assertEqual(otp.to_uri(),\n  \"otpauth://totp/Example%20Org:alice@google.com?secret=JBSWY3DPEHPK3PXP\"\n  \"&issuer=Example%20Org\")\n  \n  \n  self.assertRaises(ValueError,otp.to_uri,\"label:with:semicolons\")\n  \n  \n  self.assertRaises(ValueError,otp.to_uri,\"alice@google.com\",\"issuer:with:semicolons\")\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,alg=\"sha256\").to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"algorithm=SHA256\")\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,digits=8).to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"digits=8\")\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,period=63).to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"period=63\")\n  \n  \n  \n  \n def test_from_dict(self):\n  ''\n  from passlib.totp import TOTP\n  from_dict=TOTP.from_dict\n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,label=\"alice@google.com\",issuer=\"Example\"))\n  self.assertIsInstance(otp,TOTP)\n  self.assertEqual(otp.key,KEY4_RAW)\n  self.assertEqual(otp.label,\"alice@google.com\")\n  self.assertEqual(otp.issuer,\"Example\")\n  self.assertEqual(otp.alg,\"sha1\")\n  self.assertEqual(otp.period,30)\n  self.assertEqual(otp.digits,6)\n  \n  \n  \n  \n  \n  \n  self.assertRaises(ValueError,from_dict,dict(type=\"totp\",key=KEY4))\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=0,type=\"totp\",key=KEY4))\n  self.assertRaises(ValueError,from_dict,dict(v=999,type=\"totp\",key=KEY4))\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,key=KEY4))\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4.lower(),label=\"alice@google.com\",issuer=\"Example\"))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\"))\n  \n  \n  self.assertRaises(Base32DecodeError,from_dict,\n  dict(v=1,type=\"totp\",key=\"JBSWY3DPEHP@3PXP\"))\n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,label=\"Alice Smith\",issuer=\"Provider1\"))\n  self.assertEqual(otp.label,\"Alice Smith\")\n  self.assertEqual(otp.issuer,\"Provider1\")\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,alg=\"sha256\"))\n  self.assertEqual(otp.alg,\"sha256\")\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,alg=\"sha333\"))\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,digits=8))\n  self.assertEqual(otp.digits,8)\n  \n  \n  self.assertRaises(TypeError,from_dict,dict(v=1,type=\"totp\",key=KEY4,digits=\"A\"))\n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,digits=15))\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,period=63))\n  self.assertEqual(otp.period,63)\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,period=0))\n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,period=-1))\n  \n  \n  \n  \n  self.assertRaises(TypeError,from_dict,dict(v=1,type=\"totp\",key=KEY4,INVALID=123))\n  \n def test_to_dict(self):\n  ''\n  \n  \n  \n  \n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30)\n  self.assertEqual(otp.to_dict(),dict(v=1,type=\"totp\",key=KEY4))\n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30,\n  label=\"alice@google.com\",issuer=\"Example Org\")\n  self.assertEqual(otp.to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,\n  label=\"alice@google.com\",issuer=\"Example Org\"))\n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30,\n  label=\"alice@google.com\")\n  self.assertEqual(otp.to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,\n  label=\"alice@google.com\"))\n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30,\n  issuer=\"Example Org\")\n  self.assertEqual(otp.to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,\n  issuer=\"Example Org\"))\n  \n  \n  TotpFactory=TOTP.using(issuer=\"Example Org\")\n  otp=TotpFactory(KEY4)\n  self.assertEqual(otp.to_dict(),dict(v=1,type=\"totp\",key=KEY4))\n  \n  \n  otp=TotpFactory(KEY4,issuer=\"Example Org\")\n  self.assertEqual(otp.to_dict(),dict(v=1,type=\"totp\",key=KEY4))\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,alg=\"sha256\").to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,alg=\"sha256\"))\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,digits=8).to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,digits=8))\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,period=63).to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,period=63))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "datetime", "functools", "logging", "passlib", "passlib.crypto.digest", "passlib.tests.utils", "passlib.totp", "passlib.utils.compat", "sys", "time"]], "passlib.tests.test_ext_django_source": [".py", "''\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.compat import suppress_cause\nfrom passlib.ext.django.utils import DJANGO_VERSION,DjangoTranslator,_PasslibHasherWrapper\n\nfrom passlib.tests.utils import TestCase,TEST_MODE\nfrom .test_ext_django import (\nhas_min_django,stock_config,_ExtensionSupport,\n)\nif has_min_django:\n from .test_ext_django import settings\n \n__all__=[\n\"HashersTest\",\n]\n\n\n\n\n\n\n\n\n\ntest_hashers_mod=None\n\n\nhashers_skip_msg=None\n\n\n\n\n\nif TEST_MODE(max=\"quick\"):\n hashers_skip_msg=\"requires >= 'default' test mode\"\n \nelif has_min_django:\n import os\n import sys\n source_path=os.environ.get(\"PASSLIB_TESTS_DJANGO_SOURCE_PATH\")\n \n if source_path:\n  if not os.path.exists(source_path):\n   raise EnvironmentError(\"django source path not found: %r\"%source_path)\n  if not all(os.path.exists(os.path.join(source_path,name))\n  for name in [\"django\",\"tests\"]):\n   raise EnvironmentError(\"invalid django source path: %r\"%source_path)\n  log.info(\"using django tests from source path: %r\",source_path)\n  tests_path=os.path.join(source_path,\"tests\")\n  sys.path.insert(0,tests_path)\n  try :\n   from auth_tests import test_hashers as test_hashers_mod\n  except ImportError as err:\n   raise suppress_cause(\n   EnvironmentError(\"error trying to import django tests \"\n   \"from source path (%r): %r\"%\n   (source_path,err)))\n  finally :\n   sys.path.remove(tests_path)\n   \n else :\n  hashers_skip_msg=\"requires PASSLIB_TESTS_DJANGO_SOURCE_PATH to be set\"\n  \n  if TEST_MODE(\"full\"):\n  \n   sys.stderr.write(\"\\nWARNING: $PASSLIB_TESTS_DJANGO_SOURCE_PATH is not set; \"\n   \"can't run Django's own unittests against passlib.ext.django\\n\")\n   \nelif DJANGO_VERSION:\n hashers_skip_msg=\"django version too old\"\n \nelse :\n hashers_skip_msg=\"django not installed\"\n \n \n \n \n \nif test_hashers_mod:\n from django.core.signals import setting_changed\n from django.dispatch import receiver\n from django.utils.module_loading import import_string\n from passlib.utils.compat import get_unbound_method_function\n \n class HashersTest(test_hashers_mod.TestUtilsHashPass,_ExtensionSupport):\n  ''\n\n\n  \n  \n  \n  \n  \n  \n  \n  patchAttr=get_unbound_method_function(TestCase.patchAttr)\n  \n  \n  \n  \n  def setUp(self):\n  \n  \n  \n   self.load_extension(PASSLIB_CONTEXT=stock_config,check=False )\n   from passlib.ext.django.models import adapter\n   context=adapter.context\n   \n   \n   \n   \n   \n   from django.contrib.auth import hashers\n   for attr in [\"make_password\",\n   \"check_password\",\n   \"identify_hasher\",\n   \"is_password_usable\",\n   \"get_hasher\"]:\n    self.patchAttr(test_hashers_mod,attr,getattr(hashers,attr))\n    \n    \n    \n    \n   from passlib.hash import django_des_crypt\n   self.patchAttr(django_des_crypt,\"use_duplicate_salt\",False )\n   \n   \n   \n   \n   django_to_passlib_name=DjangoTranslator().django_to_passlib_name\n   \n   @receiver(setting_changed,weak=False )\n   def update_schemes(**kwds):\n    if kwds and kwds['setting']!='PASSWORD_HASHERS':\n     return\n    assert context is adapter.context\n    schemes=[\n    django_to_passlib_name(import_string(hash_path)())\n    for hash_path in settings.PASSWORD_HASHERS\n    ]\n    \n    \n    if \"hex_md5\"in schemes and \"django_salted_md5\"not in schemes:\n     schemes.append(\"django_salted_md5\")\n    schemes.append(\"django_disabled\")\n    context.update(schemes=schemes,deprecated=\"auto\")\n    adapter.reset_hashers()\n    \n   self.addCleanup(setting_changed.disconnect,update_schemes)\n   \n   update_schemes()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   def update_rounds():\n    ''\n\n    \n    for handler in context.schemes(resolve=True ):\n     if 'rounds'not in handler.setting_kwds:\n      continue\n     hasher=adapter.passlib_to_django(handler)\n     if isinstance(hasher,_PasslibHasherWrapper):\n      continue\n     rounds=getattr(hasher,\"rounds\",None )or\\\n     getattr(hasher,\"iterations\",None )\n     if rounds is None :\n      continue\n      \n      \n      \n     handler.min_desired_rounds=handler.max_desired_rounds=handler.default_rounds=rounds\n     \n   _in_update=[False ]\n   \n   def update_wrapper(wrapped,*args,**kwds):\n    ''\n\n    \n    if not _in_update[0]:\n     _in_update[0]=True\n     try :\n      update_rounds()\n     finally :\n      _in_update[0]=False\n    return wrapped(*args,**kwds)\n    \n    \n   for attr in [\"schemes\",\"handler\",\"default_scheme\",\"hash\",\n   \"verify\",\"needs_update\",\"verify_and_update\"]:\n    self.patchAttr(context,attr,update_wrapper,wrap=True )\n    \n    \n   self.patchAttr(adapter,\"django_to_passlib\",update_wrapper,wrap=True )\n   \n  def tearDown(self):\n  \n   self.unload_extension()\n   super(HashersTest,self).tearDown()\n   \n   \n   \n   \n   \n   \n  _OMIT=lambda self:self.skipTest(\"omitted by passlib\")\n  \n  \n  \n  \n  test_pbkdf2_upgrade_new_hasher=_OMIT\n  \n  \n  \n  test_check_password_calls_harden_runtime=_OMIT\n  test_bcrypt_harden_runtime=_OMIT\n  test_pbkdf2_harden_runtime=_OMIT\n  \n  \n  \n  \n  \nelse :\n\n\n class HashersTest(TestCase):\n \n  def test_external_django_hasher_tests(self):\n   ''\n   raise self.skipTest(hashers_skip_msg)\n   \n   \n   \n   \n", ["__future__", "auth_tests", "django.contrib.auth", "django.core.signals", "django.dispatch", "django.utils.module_loading", "logging", "os", "passlib.ext.django.models", "passlib.ext.django.utils", "passlib.hash", "passlib.tests.test_ext_django", "passlib.tests.utils", "passlib.utils.compat", "sys"]], "passlib.tests.test_apps": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib import apps,hash as hashmod\nfrom passlib.tests.utils import TestCase\n\n\n\n\n\nclass AppsTest(TestCase):\n ''\n \n \n \n \n \n \n \n def test_master_context(self):\n  ctx=apps.master_context\n  self.assertGreater(len(ctx.schemes()),50)\n  \n def test_custom_app_context(self):\n  ctx=apps.custom_app_context\n  self.assertEqual(ctx.schemes(),(\"sha512_crypt\",\"sha256_crypt\"))\n  for hash in [\n  ('$6$rounds=41128$VoQLvDjkaZ6L6BIE$4pt.1Ll1XdDYduEwEYPCMOBiR6W6'\n  'znsyUEoNlcVXpv2gKKIbQolgmTGe6uEEVJ7azUxuc8Tf7zV9SD2z7Ij751'),\n  ('$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0itGny'\n  'xDGgMlDcOsfaI17'),\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n def test_django16_context(self):\n  ctx=apps.django16_context\n  for hash in [\n  'pbkdf2_sha256$29000$ZsgquwnCyBs2$fBxRQpfKd2PIeMxtkKPy0h7SrnrN+EU/cm67aitoZ2s=',\n  'sha1$0d082$cdb462ae8b6be8784ef24b20778c4d0c82d5957f',\n  'md5$b887a$37767f8a745af10612ad44c80ff52e92',\n  'crypt$95a6d$95x74hLDQKXI2',\n  '098f6bcd4621d373cade4e832627b4f6',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  self.assertEqual(ctx.identify(\"!\"),\"django_disabled\")\n  self.assertFalse(ctx.verify(\"test\",\"!\"))\n  \n def test_django_context(self):\n  ctx=apps.django_context\n  for hash in [\n  'pbkdf2_sha256$29000$ZsgquwnCyBs2$fBxRQpfKd2PIeMxtkKPy0h7SrnrN+EU/cm67aitoZ2s=',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  self.assertEqual(ctx.identify(\"!\"),\"django_disabled\")\n  self.assertFalse(ctx.verify(\"test\",\"!\"))\n  \n def test_ldap_nocrypt_context(self):\n  ctx=apps.ldap_nocrypt_context\n  for hash in [\n  '{SSHA}cPusOzd6d5n3OjSVK3R329ZGCNyFcC7F',\n  'test',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  self.assertIs(ctx.identify('{CRYPT}$5$rounds=31817$iZGmlyBQ99JSB5'\n  'n6$p4E.pdPBWx19OajgjLRiOW0itGnyxDGgMlDcOsfaI17'),None )\n  \n def test_ldap_context(self):\n  ctx=apps.ldap_context\n  for hash in [\n  ('{CRYPT}$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0'\n  'itGnyxDGgMlDcOsfaI17'),\n  '{SSHA}cPusOzd6d5n3OjSVK3R329ZGCNyFcC7F',\n  'test',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n def test_ldap_mysql_context(self):\n  ctx=apps.mysql_context\n  for hash in [\n  '*94BDCEBE19083CE2A1F959FD02F964C7AF4CFC29',\n  '378b243e220ca493',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n def test_postgres_context(self):\n  ctx=apps.postgres_context\n  hash='md55d9c68c6c50ed3d02a2fcf54f63993b6'\n  self.assertTrue(ctx.verify(\"test\",hash,user='user'))\n  \n def test_phppass_context(self):\n  ctx=apps.phpass_context\n  for hash in [\n  '$P$8Ja1vJsKa5qyy/b3mCJGXM7GyBnt6..',\n  '$H$8b95CoYQnQ9Y6fSTsACyphNh5yoM02.',\n  '_cD..aBxeRhYFJvtUvsI',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  h1=\"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n  if hashmod.bcrypt.has_backend():\n   self.assertTrue(ctx.verify(\"test\",h1))\n   self.assertEqual(ctx.default_scheme(),\"bcrypt\")\n   self.assertEqual(ctx.handler().name,\"bcrypt\")\n  else :\n   self.assertEqual(ctx.identify(h1),\"bcrypt\")\n   self.assertEqual(ctx.default_scheme(),\"phpass\")\n   self.assertEqual(ctx.handler().name,\"phpass\")\n   \n def test_phpbb3_context(self):\n  ctx=apps.phpbb3_context\n  for hash in [\n  '$P$8Ja1vJsKa5qyy/b3mCJGXM7GyBnt6..',\n  '$H$8b95CoYQnQ9Y6fSTsACyphNh5yoM02.',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n  self.assertTrue(ctx.hash(\"test\").startswith(\"$H$\"))\n  \n def test_roundup_context(self):\n  ctx=apps.roundup_context\n  for hash in [\n  '{PBKDF2}9849$JMTYu3eOUSoFYExprVVqbQ$N5.gV.uR1.BTgLSvi0qyPiRlGZ0',\n  '{SHA}a94a8fe5ccb19ba61c4c0873d391e987982fbbd3',\n  '{CRYPT}dptOmKDriOGfU',\n  '{plaintext}test',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n   \n   \n   \n", ["__future__", "logging", "passlib", "passlib.tests.utils"]], "passlib.tests.test_handlers_argon2": [".py", "''\n\n\n\n\nimport logging\nlog=logging.getLogger(__name__)\nimport re\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.utils.compat import unicode\nfrom passlib.tests.utils import HandlerCase,TEST_MODE\nfrom passlib.tests.test_handlers import UPASS_TABLE,PASS_TABLE_UTF8\n\n\n\n\n\n\ndef hashtest(version,t,logM,p,secret,salt,hex_digest,hash):\n return dict(version=version,rounds=t,logM=logM,memory_cost=1 <<logM,parallelism=p,\n secret=secret,salt=salt,hex_digest=hex_digest,hash=hash)\n \n \nversion=0x10\nreference_data=[\nhashtest(version,2,16,1,\"password\",\"somesalt\",\n\"f6c4db4a54e2a370627aff3db6176b94a2a209a62c8e36152711802f7b30c694\",\n\"$argon2i$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$9sTbSlTio3Biev89thdrlKKiCaYsjjYVJxGAL3swxpQ\"),\nhashtest(version,2,20,1,\"password\",\"somesalt\",\n\"9690ec55d28d3ed32562f2e73ea62b02b018757643a2ae6e79528459de8106e9\",\n\"$argon2i$m=1048576,t=2,p=1$c29tZXNhbHQ\"\n\"$lpDsVdKNPtMlYvLnPqYrArAYdXZDoq5ueVKEWd6BBuk\"),\nhashtest(version,2,18,1,\"password\",\"somesalt\",\n\"3e689aaa3d28a77cf2bc72a51ac53166761751182f1ee292e3f677a7da4c2467\",\n\"$argon2i$m=262144,t=2,p=1$c29tZXNhbHQ\"\n\"$Pmiaqj0op3zyvHKlGsUxZnYXURgvHuKS4/Z3p9pMJGc\"),\nhashtest(version,2,8,1,\"password\",\"somesalt\",\n\"fd4dd83d762c49bdeaf57c47bdcd0c2f1babf863fdeb490df63ede9975fccf06\",\n\"$argon2i$m=256,t=2,p=1$c29tZXNhbHQ\"\n\"$/U3YPXYsSb3q9XxHvc0MLxur+GP960kN9j7emXX8zwY\"),\nhashtest(version,2,8,2,\"password\",\"somesalt\",\n\"b6c11560a6a9d61eac706b79a2f97d68b4463aa3ad87e00c07e2b01e90c564fb\",\n\"$argon2i$m=256,t=2,p=2$c29tZXNhbHQ\"\n\"$tsEVYKap1h6scGt5ovl9aLRGOqOth+AMB+KwHpDFZPs\"),\nhashtest(version,1,16,1,\"password\",\"somesalt\",\n\"81630552b8f3b1f48cdb1992c4c678643d490b2b5eb4ff6c4b3438b5621724b2\",\n\"$argon2i$m=65536,t=1,p=1$c29tZXNhbHQ\"\n\"$gWMFUrjzsfSM2xmSxMZ4ZD1JCytetP9sSzQ4tWIXJLI\"),\nhashtest(version,4,16,1,\"password\",\"somesalt\",\n\"f212f01615e6eb5d74734dc3ef40ade2d51d052468d8c69440a3a1f2c1c2847b\",\n\"$argon2i$m=65536,t=4,p=1$c29tZXNhbHQ\"\n\"$8hLwFhXm6110c03D70Ct4tUdBSRo2MaUQKOh8sHChHs\"),\nhashtest(version,2,16,1,\"differentpassword\",\"somesalt\",\n\"e9c902074b6754531a3a0be519e5baf404b30ce69b3f01ac3bf21229960109a3\",\n\"$argon2i$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$6ckCB0tnVFMaOgvlGeW69ASzDOabPwGsO/ISKZYBCaM\"),\nhashtest(version,2,16,1,\"password\",\"diffsalt\",\n\"79a103b90fe8aef8570cb31fc8b22259778916f8336b7bdac3892569d4f1c497\",\n\"$argon2i$m=65536,t=2,p=1$ZGlmZnNhbHQ\"\n\"$eaEDuQ/orvhXDLMfyLIiWXeJFvgza3vaw4kladTxxJc\"),\n]\n\n\nversion=0x13\nreference_data.extend([\nhashtest(version,2,16,1,\"password\",\"somesalt\",\n\"c1628832147d9720c5bd1cfd61367078729f6dfb6f8fea9ff98158e0d7816ed0\",\n\"$argon2i$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$wWKIMhR9lyDFvRz9YTZweHKfbftvj+qf+YFY4NeBbtA\"),\nhashtest(version,2,20,1,\"password\",\"somesalt\",\n\"d1587aca0922c3b5d6a83edab31bee3c4ebaef342ed6127a55d19b2351ad1f41\",\n\"$argon2i$v=19$m=1048576,t=2,p=1$c29tZXNhbHQ\"\n\"$0Vh6ygkiw7XWqD7asxvuPE667zQu1hJ6VdGbI1GtH0E\"),\nhashtest(version,2,18,1,\"password\",\"somesalt\",\n\"296dbae80b807cdceaad44ae741b506f14db0959267b183b118f9b24229bc7cb\",\n\"$argon2i$v=19$m=262144,t=2,p=1$c29tZXNhbHQ\"\n\"$KW266AuAfNzqrUSudBtQbxTbCVkmexg7EY+bJCKbx8s\"),\nhashtest(version,2,8,1,\"password\",\"somesalt\",\n\"89e9029f4637b295beb027056a7336c414fadd43f6b208645281cb214a56452f\",\n\"$argon2i$v=19$m=256,t=2,p=1$c29tZXNhbHQ\"\n\"$iekCn0Y3spW+sCcFanM2xBT63UP2sghkUoHLIUpWRS8\"),\nhashtest(version,2,8,2,\"password\",\"somesalt\",\n\"4ff5ce2769a1d7f4c8a491df09d41a9fbe90e5eb02155a13e4c01e20cd4eab61\",\n\"$argon2i$v=19$m=256,t=2,p=2$c29tZXNhbHQ\"\n\"$T/XOJ2mh1/TIpJHfCdQan76Q5esCFVoT5MAeIM1Oq2E\"),\nhashtest(version,1,16,1,\"password\",\"somesalt\",\n\"d168075c4d985e13ebeae560cf8b94c3b5d8a16c51916b6f4ac2da3ac11bbecf\",\n\"$argon2i$v=19$m=65536,t=1,p=1$c29tZXNhbHQ\"\n\"$0WgHXE2YXhPr6uVgz4uUw7XYoWxRkWtvSsLaOsEbvs8\"),\nhashtest(version,4,16,1,\"password\",\"somesalt\",\n\"aaa953d58af3706ce3df1aefd4a64a84e31d7f54175231f1285259f88174ce5b\",\n\"$argon2i$v=19$m=65536,t=4,p=1$c29tZXNhbHQ\"\n\"$qqlT1YrzcGzj3xrv1KZKhOMdf1QXUjHxKFJZ+IF0zls\"),\nhashtest(version,2,16,1,\"differentpassword\",\"somesalt\",\n\"14ae8da01afea8700c2358dcef7c5358d9021282bd88663a4562f59fb74d22ee\",\n\"$argon2i$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$FK6NoBr+qHAMI1jc73xTWNkCEoK9iGY6RWL1n7dNIu4\"),\nhashtest(version,2,16,1,\"password\",\"diffsalt\",\n\"b0357cccfbef91f3860b0dba447b2348cbefecadaf990abfe9cc40726c521271\",\n\"$argon2i$v=19$m=65536,t=2,p=1$ZGlmZnNhbHQ\"\n\"$sDV8zPvvkfOGCw26RHsjSMvv7K2vmQq/6cxAcmxSEnE\"),\n])\n\n\nversion=0x13\nreference_data.extend([\nhashtest(version,2,16,1,\"password\",\"somesalt\",\n\"09316115d5cf24ed5a15a31a3ba326e5cf32edc24702987c02b6566f61913cf7\",\n\"$argon2id$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$CTFhFdXPJO1aFaMaO6Mm5c8y7cJHAph8ArZWb2GRPPc\"),\nhashtest(version,2,18,1,\"password\",\"somesalt\",\n\"78fe1ec91fb3aa5657d72e710854e4c3d9b9198c742f9616c2f085bed95b2e8c\",\n\"$argon2id$v=19$m=262144,t=2,p=1$c29tZXNhbHQ\"\n\"$eP4eyR+zqlZX1y5xCFTkw9m5GYx0L5YWwvCFvtlbLow\"),\nhashtest(version,2,8,1,\"password\",\"somesalt\",\n\"9dfeb910e80bad0311fee20f9c0e2b12c17987b4cac90c2ef54d5b3021c68bfe\",\n\"$argon2id$v=19$m=256,t=2,p=1$c29tZXNhbHQ\"\n\"$nf65EOgLrQMR/uIPnA4rEsF5h7TKyQwu9U1bMCHGi/4\"),\nhashtest(version,2,8,2,\"password\",\"somesalt\",\n\"6d093c501fd5999645e0ea3bf620d7b8be7fd2db59c20d9fff9539da2bf57037\",\n\"$argon2id$v=19$m=256,t=2,p=2$c29tZXNhbHQ\"\n\"$bQk8UB/VmZZF4Oo79iDXuL5/0ttZwg2f/5U52iv1cDc\"),\nhashtest(version,1,16,1,\"password\",\"somesalt\",\n\"f6a5adc1ba723dddef9b5ac1d464e180fcd9dffc9d1cbf76cca2fed795d9ca98\",\n\"$argon2id$v=19$m=65536,t=1,p=1$c29tZXNhbHQ\"\n\"$9qWtwbpyPd3vm1rB1GThgPzZ3/ydHL92zKL+15XZypg\"),\nhashtest(version,4,16,1,\"password\",\"somesalt\",\n\"9025d48e68ef7395cca9079da4c4ec3affb3c8911fe4f86d1a2520856f63172c\",\n\"$argon2id$v=19$m=65536,t=4,p=1$c29tZXNhbHQ\"\n\"$kCXUjmjvc5XMqQedpMTsOv+zyJEf5PhtGiUghW9jFyw\"),\nhashtest(version,2,16,1,\"differentpassword\",\"somesalt\",\n\"0b84d652cf6b0c4beaef0dfe278ba6a80df6696281d7e0d2891b817d8c458fde\",\n\"$argon2id$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$C4TWUs9rDEvq7w3+J4umqA32aWKB1+DSiRuBfYxFj94\"),\nhashtest(version,2,16,1,\"password\",\"diffsalt\",\n\"bdf32b05ccc42eb15d58fd19b1f856b113da1e9a5874fdcc544308565aa8141c\",\n\"$argon2id$v=19$m=65536,t=2,p=1$ZGlmZnNhbHQ\"\n\"$vfMrBczELrFdWP0ZsfhWsRPaHppYdP3MVEMIVlqoFBw\"),\n])\n\n\n\n\nclass _base_argon2_test(HandlerCase):\n handler=hash.argon2\n \n known_correct_hashes=[\n \n \n \n \n \n (\"password\",'$argon2i$v=19$m=256,t=1,p=1$c29tZXNhbHQ$AJFIsNZTMKTAewB4+ETN1A'),\n \n \n (\"password\",'$argon2i$v=19$m=380,t=2,p=2$c29tZXNhbHQ$SrssP8n7m/12VWPM8dvNrw'),\n \n \n (UPASS_TABLE,'$argon2i$v=19$m=512,t=2,p=2$1sV0O4PWLtc12Ypv1f7oGw$'\n 'z+yqzlKtrq3SaNfXDfIDnQ'),\n (PASS_TABLE_UTF8,'$argon2i$v=19$m=512,t=2,p=2$1sV0O4PWLtc12Ypv1f7oGw$'\n 'z+yqzlKtrq3SaNfXDfIDnQ'),\n \n \n ('password\\x00','$argon2i$v=19$m=512,t=2,p=2$c29tZXNhbHQ$Fb5+nPuLzZvtqKRwqUEtUQ'),\n \n \n (\"password\",'$argon2d$v=19$m=102400,t=2,p=8$g2RodLh8j8WbSdCp+lUy/A$zzAJqL/HSjm809PYQu6qkA'),\n \n ]\n \n known_malformed_hashes=[\n \n \"$argon2qq$v=19$t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$m=65536,t=8589934592,p=4$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$m=65536,t=2,p=4,q=5$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$t=2,m=65536,p=4,q=5$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$m=127,t=2,p=16$c29tZXNhbHQ$IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\",\n ]\n \n known_parsehash_results=[\n ('$argon2i$v=19$m=256,t=2,p=3$c29tZXNhbHQ$AJFIsNZTMKTAewB4+ETN1A',\n dict(type=\"i\",memory_cost=256,rounds=2,parallelism=3,salt=b'somesalt',\n checksum=b'\\x00\\x91H\\xb0\\xd6S0\\xa4\\xc0{\\x00x\\xf8D\\xcd\\xd4')),\n ]\n \n def setUpWarnings(self):\n  super(_base_argon2_test,self).setUpWarnings()\n  warnings.filterwarnings(\"ignore\",\".*Using argon2pure backend.*\")\n  \n def do_stub_encrypt(self,handler=None ,**settings):\n  if self.backend ==\"argon2_cffi\":\n  \n  \n   handler=(handler or self.handler).using(**settings)\n   self=handler(use_defaults=True )\n   self.checksum=self._stub_checksum\n   assert self.checksum\n   return self.to_string()\n  else :\n   return super(_base_argon2_test,self).do_stub_encrypt(handler,**settings)\n   \n def test_03_legacy_hash_workflow(self):\n \n  raise self.skipTest(\"legacy 1.6 workflow not supported\")\n  \n def test_keyid_parameter(self):\n \n \n \n \n  self.assertRaises(NotImplementedError,self.handler.verify,'password',\n  \"$argon2i$v=19$m=65536,t=2,p=4,keyid=ABCD$c29tZXNhbHQ$\"\n  \"IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\")\n  \n def test_data_parameter(self):\n \n \n \n \n  handler=self.handler\n  \n  \n  sample1='$argon2i$v=19$m=512,t=2,p=2,data=c29tZWRhdGE$c29tZXNhbHQ$KgHyCesFyyjkVkihZ5VNFw'\n  \n  \n  sample2='$argon2i$v=19$m=512,t=2,p=2,data=c29tZWRhdGE$c29tZXNhbHQ$uEeXt1dxN1iFKGhklseW4w'\n  \n  \n  sample3='$argon2i$v=19$m=512,t=2,p=2$c29tZXNhbHQ$uEeXt1dxN1iFKGhklseW4w'\n  \n  \n  \n  \n  \n  if self.backend ==\"argon2_cffi\":\n  \n  \n  \n   self.assertRaises(NotImplementedError,handler.verify,\"password\",sample1)\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample1),sample3)\n   \n  else :\n   assert self.backend ==\"argon2pure\"\n   \n   self.assertTrue(handler.verify(\"password\",sample1))\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample1),sample1)\n   \n   \n   \n   \n   \n  if self.backend ==\"argon2_cffi\":\n  \n  \n  \n   self.assertRaises(NotImplementedError,handler.verify,\"password\",sample2)\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample1),sample3)\n   \n  else :\n   assert self.backend ==\"argon2pure\"\n   \n   self.assertFalse(self.handler.verify(\"password\",sample2))\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample2),sample1)\n   \n def test_keyid_and_data_parameters(self):\n \n  self.assertRaises(NotImplementedError,self.handler.verify,'stub',\n  \"$argon2i$v=19$m=65536,t=2,p=4,keyid=ABCD,data=EFGH$c29tZXNhbHQ$\"\n  \"IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\")\n  \n def test_type_kwd(self):\n  cls=self.handler\n  \n  \n  \n  \n  \n  self.assertTrue(\"type\"in cls.setting_kwds)\n  \n  \n  for value in cls.type_values:\n   self.assertIsInstance(value,unicode)\n  self.assertTrue(\"i\"in cls.type_values)\n  self.assertTrue(\"d\"in cls.type_values)\n  \n  \n  self.assertTrue(cls.type in cls.type_values)\n  \n  \n  handler=cls\n  hash=self.get_sample_hash()[1]\n  kwds=handler.parsehash(hash)\n  del kwds['type']\n  \n  \n  handler(type=cls.type,**kwds)\n  \n  \n  \n  \n  handler(**kwds)\n  \n  \n  handler(use_defaults=True ,**kwds)\n  \n  \n  self.assertRaises(ValueError,handler,type='xXx',**kwds)\n  \n def test_type_using(self):\n  handler=self.handler\n  \n  \n  \n  \n  orig_type=handler.type\n  for alt_type in handler.type_values:\n   if alt_type !=orig_type:\n    break\n  else :\n   raise AssertionError(\"expected to find alternate type: default=%r values=%r\"%\n   (orig_type,handler.type_values))\n   \n  def effective_type(cls):\n   return cls(use_defaults=True ).type\n   \n   \n  subcls=handler.using()\n  self.assertEqual(subcls.type,orig_type)\n  \n  \n  subcls=handler.using(type=alt_type)\n  self.assertEqual(subcls.type,alt_type)\n  self.assertEqual(handler.type,orig_type)\n  \n  \n  \n  self.assertEqual(effective_type(subcls),alt_type)\n  self.assertEqual(effective_type(handler),orig_type)\n  \n  \n  self.assertRaises(ValueError,handler.using,type='xXx')\n  \n  \n  subcls=handler.using(type=alt_type)\n  self.assertEqual(subcls.type,alt_type)\n  self.assertEqual(handler.type,orig_type)\n  \n  \n  self.assertEqual(effective_type(handler.using(type=\"I\")),\"i\")\n  \n def test_needs_update_w_type(self):\n  handler=self.handler\n  \n  hash=handler.hash(\"stub\")\n  self.assertFalse(handler.needs_update(hash))\n  \n  hash2=re.sub(r\"\\$argon2\\w+\\$\",\"$argon2d$\",hash)\n  self.assertTrue(handler.needs_update(hash2))\n  \n def test_needs_update_w_version(self):\n  handler=self.handler.using(memory_cost=65536,time_cost=2,parallelism=4,\n  digest_size=32)\n  hash=(\"$argon2i$m=65536,t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$\"\n  \"QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\")\n  if handler.max_version ==0x10:\n   self.assertFalse(handler.needs_update(hash))\n  else :\n   self.assertTrue(handler.needs_update(hash))\n   \n def test_argon_byte_encoding(self):\n  ''\n  handler=self.handler\n  if handler.version !=0x13:\n  \n   raise self.skipTest(\"handler uses wrong version for sample hashes\")\n   \n   \n  salt=b'somesalt'\n  temp=handler.using(memory_cost=256,time_cost=2,parallelism=2,salt=salt,\n  checksum_size=32,type=\"i\")\n  hash=temp.hash(\"password\")\n  self.assertEqual(hash,\"$argon2i$v=19$m=256,t=2,p=2\"\n  \"$c29tZXNhbHQ\"\n  \"$T/XOJ2mh1/TIpJHfCdQan76Q5esCFVoT5MAeIM1Oq2E\")\n  \n  \n  salt=b'somesalt\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n  temp=handler.using(memory_cost=256,time_cost=2,parallelism=2,salt=salt,\n  checksum_size=32,type=\"i\")\n  hash=temp.hash(\"password\")\n  self.assertEqual(hash,\"$argon2i$v=19$m=256,t=2,p=2\"\n  \"$c29tZXNhbHQAAAAAAAAAAA\"\n  \"$rqnbEp1/jFDUEKZZmw+z14amDsFqMDC53dIe57ZHD38\")\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  settings_map=HandlerCase.FuzzHashGenerator.settings_map.copy()\n  settings_map.update(memory_cost=\"random_memory_cost\",type=\"random_type\")\n  \n  def random_type(self):\n   return self.rng.choice(self.handler.type_values)\n   \n  def random_memory_cost(self):\n   if self.test.backend ==\"argon2pure\":\n    return self.randintgauss(128,384,256,128)\n   else :\n    return self.randintgauss(128,32767,16384,4096)\n    \n    \n    \n    \n    \n    \n    \nclass argon2_argon2_cffi_test(_base_argon2_test.create_backend_case(\"argon2_cffi\")):\n\n\n known_correct_hashes=_base_argon2_test.known_correct_hashes+[\n \n \n \n \n \n \n ('password',\"$argon2i$m=65536,t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$\"\n \"QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\"),\n \n \n ('password',\"$argon2i$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\"),\n \n \n ('password',\"$argon2d$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"cZn5d+rFh+ZfuRhm2iGUGgcrW5YLeM6q7L3vBsdmFA0\"),\n \n \n ('password',\"$argon2id$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"GpZ3sK/oH9p7VIiV56G/64Zo/8GaUw434IimaPqxwCo\"),\n \n \n \n \n \n \n ('password\\x00',\"$argon2i$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"Vpzuc0v0SrP88LcVvmg+z5RoOYpMDKH/lt6O+CZabIQ\"),\n \n ]\n \n \n known_correct_hashes.extend(\n (info['secret'],info['hash'])for info in reference_data\n if info['logM']<=(18 if TEST_MODE(\"full\")else 16)\n )\n \nclass argon2_argon2pure_test(_base_argon2_test.create_backend_case(\"argon2pure\")):\n\n\n\n\n handler=hash.argon2.using(memory_cost=32,parallelism=2)\n \n \n \n handler.pure_use_threads=True\n \n \n known_correct_hashes=_base_argon2_test.known_correct_hashes[:]\n \n known_correct_hashes.extend(\n (info['secret'],info['hash'])for info in reference_data\n if info['logM']<16\n )\n \n class FuzzHashGenerator(_base_argon2_test.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(1,3,2,1)\n   \n   \n   \n   \n", ["logging", "passlib", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.compat", "re", "warnings"]], "passlib.tests.test_handlers_scrypt": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nimport warnings\nwarnings.filterwarnings(\"ignore\",\".*using builtin scrypt backend.*\")\n\n\nfrom passlib import hash\nfrom passlib.tests.utils import HandlerCase,TEST_MODE\nfrom passlib.tests.test_handlers import UPASS_TABLE,PASS_TABLE_UTF8\n\n\n\n\n\nclass _scrypt_test(HandlerCase):\n handler=hash.scrypt\n \n known_correct_hashes=[\n \n \n \n \n \n \n \n (\"\",\"$scrypt$ln=4,r=1,p=1$$d9ZXYjhleyA7GcpCwYoEl/FrSETjB0ro39/6P+3iFEI\"),\n \n \n (\"password\",\"$scrypt$ln=10,r=8,p=16$TmFDbA$/bq+HJ00cgB4VucZDQHp/nxq18vII3gw53N2Y0s3MWI\"),\n \n \n \n \n \n \n (\"test\",'$scrypt$ln=8,r=8,p=1$wlhLyXmP8b53bm1NKYVQqg$mTpvG8lzuuDk+DWz8HZIB6Vum6erDuUm0As5yU+VxWA'),\n \n \n (\"password\",'$scrypt$ln=8,r=2,p=1$dO6d0xoDoLT2PofQGoNQag$g/Wf2A0vhHhaJM+addK61QPBthSmYB6uVTtQzh8CM3o'),\n \n \n (UPASS_TABLE,'$scrypt$ln=7,r=8,p=1$jjGmtDamdA4BQAjBeA9BSA$OiWRHhQtpDx7M/793x6UXK14AD512jg/qNm/hkWZG4M'),\n \n \n (PASS_TABLE_UTF8,'$scrypt$ln=7,r=8,p=1$jjGmtDamdA4BQAjBeA9BSA$OiWRHhQtpDx7M/793x6UXK14AD512jg/qNm/hkWZG4M'),\n \n \n (\"nacl\",'$scrypt$ln=1,r=4,p=2$yhnD+J+Tci4lZCwFgHCuVQ$fAsEWmxSHuC0cHKMwKVFPzrQukgvK09Sj+NueTSxKds')\n ]\n \n if TEST_MODE(\"full\"):\n \n  known_correct_hashes.extend([\n  \n  \n  \n  \n  \n  (\"pleaseletmein\",\"$scrypt$ln=14,r=8,p=1$U29kaXVtQ2hsb3JpZGU\"\n  \"$cCO9yzr9c0hGHAbNgf046/2o+7qQT44+qbVD9lRdofI\"),\n  \n  \n  \n  \n  (\"pleaseletmein\",\n  \"$7$C6..../....SodiumChloride$kBGj9fHznVYFQMEn/qDCfrDevf9YDtcDdKvEqHJLV8D\"),\n  \n  ])\n  \n known_malformed_hashes=[\n \n '$scrypt$ln=10,r=1$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n \n \n '$scrypt$ln=0,r=1,p=1$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n \n \n '$scrypt$ln=10,r=A,p=1$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n \n \n '$scrypt$ln=10,r=134217728,p=8$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n ]\n \n def setUpWarnings(self):\n  super(_scrypt_test,self).setUpWarnings()\n  warnings.filterwarnings(\"ignore\",\".*using builtin scrypt backend.*\")\n  \n def populate_settings(self,kwds):\n \n  if self.backend ==\"builtin\":\n   kwds.setdefault(\"rounds\",6)\n  super(_scrypt_test,self).populate_settings(kwds)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(4,10,6,1)\n   \n   \nscrypt_stdlib_test=_scrypt_test.create_backend_case(\"stdlib\")\nscrypt_scrypt_test=_scrypt_test.create_backend_case(\"scrypt\")\nscrypt_builtin_test=_scrypt_test.create_backend_case(\"builtin\")\n\n\n\n\n", ["logging", "passlib", "passlib.tests.test_handlers", "passlib.tests.utils", "warnings"]], "passlib.tests": [".py", "''\n", [], 1], "passlib.tests.test_crypto_des": [".py", "''\n\n\n\nfrom __future__ import with_statement,division\n\nfrom functools import partial\n\n\n\nfrom passlib.utils import getrandbytes\nfrom passlib.tests.utils import TestCase\n\n\n\n\nclass DesTest(TestCase):\n descriptionPrefix=\"passlib.crypto.des\"\n \n \n des_test_vectors=[\n \n (0x0000000000000000,0x0000000000000000,0x8CA64DE9C1B123A7),\n (0xFFFFFFFFFFFFFFFF,0xFFFFFFFFFFFFFFFF,0x7359B2163E4EDC58),\n (0x3000000000000000,0x1000000000000001,0x958E6E627A05557B),\n (0x1111111111111111,0x1111111111111111,0xF40379AB9E0EC533),\n (0x0123456789ABCDEF,0x1111111111111111,0x17668DFC7292532D),\n (0x1111111111111111,0x0123456789ABCDEF,0x8A5AE1F81AB8F2DD),\n (0x0000000000000000,0x0000000000000000,0x8CA64DE9C1B123A7),\n (0xFEDCBA9876543210,0x0123456789ABCDEF,0xED39D950FA74BCC4),\n (0x7CA110454A1A6E57,0x01A1D6D039776742,0x690F5B0D9A26939B),\n (0x0131D9619DC1376E,0x5CD54CA83DEF57DA,0x7A389D10354BD271),\n (0x07A1133E4A0B2686,0x0248D43806F67172,0x868EBB51CAB4599A),\n (0x3849674C2602319E,0x51454B582DDF440A,0x7178876E01F19B2A),\n (0x04B915BA43FEB5B6,0x42FD443059577FA2,0xAF37FB421F8C4095),\n (0x0113B970FD34F2CE,0x059B5E0851CF143A,0x86A560F10EC6D85B),\n (0x0170F175468FB5E6,0x0756D8E0774761D2,0x0CD3DA020021DC09),\n (0x43297FAD38E373FE,0x762514B829BF486A,0xEA676B2CB7DB2B7A),\n (0x07A7137045DA2A16,0x3BDD119049372802,0xDFD64A815CAF1A0F),\n (0x04689104C2FD3B2F,0x26955F6835AF609A,0x5C513C9C4886C088),\n (0x37D06BB516CB7546,0x164D5E404F275232,0x0A2AEEAE3FF4AB77),\n (0x1F08260D1AC2465E,0x6B056E18759F5CCA,0xEF1BF03E5DFA575A),\n (0x584023641ABA6176,0x004BD6EF09176062,0x88BF0DB6D70DEE56),\n (0x025816164629B007,0x480D39006EE762F2,0xA1F9915541020B56),\n (0x49793EBC79B3258F,0x437540C8698F3CFA,0x6FBF1CAFCFFD0556),\n (0x4FB05E1515AB73A7,0x072D43A077075292,0x2F22E49BAB7CA1AC),\n (0x49E95D6D4CA229BF,0x02FE55778117F12A,0x5A6B612CC26CCE4A),\n (0x018310DC409B26D6,0x1D9D5C5018F728C2,0x5F4C038ED12B2E41),\n (0x1C587F1C13924FEF,0x305532286D6F295A,0x63FAC0D034D9F793),\n (0x0101010101010101,0x0123456789ABCDEF,0x617B3A0CE8F07100),\n (0x1F1F1F1F0E0E0E0E,0x0123456789ABCDEF,0xDB958605F8C8C606),\n (0xE0FEE0FEF1FEF1FE,0x0123456789ABCDEF,0xEDBFD1C66C29CCC7),\n (0x0000000000000000,0xFFFFFFFFFFFFFFFF,0x355550B2150E2451),\n (0xFFFFFFFFFFFFFFFF,0x0000000000000000,0xCAAAAF4DEAF1DBAE),\n (0x0123456789ABCDEF,0x0000000000000000,0xD5D44FF720683D0D),\n (0xFEDCBA9876543210,0xFFFFFFFFFFFFFFFF,0x2A2BB008DF97C2F2),\n ]\n \n def test_01_expand(self):\n  ''\n  from passlib.crypto.des import expand_des_key,shrink_des_key,\\\n  _KDATA_MASK,INT_56_MASK\n  \n  \n  \n  for key1,_,_ in self.des_test_vectors:\n   key2=shrink_des_key(key1)\n   key3=expand_des_key(key2)\n   \n   self.assertEqual(key3,key1&_KDATA_MASK)\n   \n   \n  self.assertRaises(TypeError,expand_des_key,1.0)\n  \n  \n  self.assertRaises(ValueError,expand_des_key,INT_56_MASK+1)\n  self.assertRaises(ValueError,expand_des_key,b\"\\x00\"*8)\n  \n  \n  self.assertRaises(ValueError,expand_des_key,-1)\n  self.assertRaises(ValueError,expand_des_key,b\"\\x00\"*6)\n  \n def test_02_shrink(self):\n  ''\n  from passlib.crypto.des import expand_des_key,shrink_des_key,INT_64_MASK\n  rng=self.getRandom()\n  \n  \n  \n  for i in range(20):\n   key1=getrandbytes(rng,7)\n   key2=expand_des_key(key1)\n   key3=shrink_des_key(key2)\n   self.assertEqual(key3,key1)\n   \n   \n  self.assertRaises(TypeError,shrink_des_key,1.0)\n  \n  \n  self.assertRaises(ValueError,shrink_des_key,INT_64_MASK+1)\n  self.assertRaises(ValueError,shrink_des_key,b\"\\x00\"*9)\n  \n  \n  self.assertRaises(ValueError,shrink_des_key,-1)\n  self.assertRaises(ValueError,shrink_des_key,b\"\\x00\"*7)\n  \n def _random_parity(self,key):\n  ''\n  from passlib.crypto.des import _KDATA_MASK,_KPARITY_MASK,INT_64_MASK\n  rng=self.getRandom()\n  return (key&_KDATA_MASK)|(rng.randint(0,INT_64_MASK)&_KPARITY_MASK)\n  \n def test_03_encrypt_bytes(self):\n  ''\n  from passlib.crypto.des import (des_encrypt_block,shrink_des_key,\n  _pack64,_unpack64)\n  \n  \n  for key,plaintext,correct in self.des_test_vectors:\n  \n   key=_pack64(key)\n   plaintext=_pack64(plaintext)\n   correct=_pack64(correct)\n   \n   \n   result=des_encrypt_block(key,plaintext)\n   self.assertEqual(result,correct,\"key=%r plaintext=%r:\"%\n   (key,plaintext))\n   \n   \n   key2=shrink_des_key(key)\n   result=des_encrypt_block(key2,plaintext)\n   self.assertEqual(result,correct,\"key=%r shrink(key)=%r plaintext=%r:\"%\n   (key,key2,plaintext))\n   \n   \n   for _ in range(20):\n    key3=_pack64(self._random_parity(_unpack64(key)))\n    result=des_encrypt_block(key3,plaintext)\n    self.assertEqual(result,correct,\"key=%r rndparity(key)=%r plaintext=%r:\"%\n    (key,key3,plaintext))\n    \n    \n  stub=b'\\x00'*8\n  self.assertRaises(TypeError,des_encrypt_block,0,stub)\n  self.assertRaises(ValueError,des_encrypt_block,b'\\x00'*6,stub)\n  \n  \n  self.assertRaises(TypeError,des_encrypt_block,stub,0)\n  self.assertRaises(ValueError,des_encrypt_block,stub,b'\\x00'*7)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_block,stub,stub,salt=-1)\n  self.assertRaises(ValueError,des_encrypt_block,stub,stub,salt=1 <<24)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_block,stub,stub,0,rounds=0)\n  \n def test_04_encrypt_ints(self):\n  ''\n  from passlib.crypto.des import des_encrypt_int_block\n  \n  \n  for key,plaintext,correct in self.des_test_vectors:\n  \n   result=des_encrypt_int_block(key,plaintext)\n   self.assertEqual(result,correct,\"key=%r plaintext=%r:\"%\n   (key,plaintext))\n   \n   \n   for _ in range(20):\n    key3=self._random_parity(key)\n    result=des_encrypt_int_block(key3,plaintext)\n    self.assertEqual(result,correct,\"key=%r rndparity(key)=%r plaintext=%r:\"%\n    (key,key3,plaintext))\n    \n    \n  self.assertRaises(TypeError,des_encrypt_int_block,b'\\x00',0)\n  self.assertRaises(ValueError,des_encrypt_int_block,-1,0)\n  \n  \n  self.assertRaises(TypeError,des_encrypt_int_block,0,b'\\x00')\n  self.assertRaises(ValueError,des_encrypt_int_block,0,-1)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_int_block,0,0,salt=-1)\n  self.assertRaises(ValueError,des_encrypt_int_block,0,0,salt=1 <<24)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_int_block,0,0,0,rounds=0)\n  \n  \n  \n  \n", ["__future__", "functools", "passlib.crypto.des", "passlib.tests.utils", "passlib.utils"]], "passlib.tests.test_handlers_bcrypt": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport os\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.handlers.bcrypt import IDENT_2,IDENT_2X\nfrom passlib.utils import repeat_string,to_bytes,is_safe_crypt_input\nfrom passlib.utils.compat import irange,PY3\nfrom passlib.tests.utils import HandlerCase,TEST_MODE\nfrom passlib.tests.test_handlers import UPASS_TABLE\n\n\n\n\n\nclass _bcrypt_test(HandlerCase):\n ''\n handler=hash.bcrypt\n reduce_default_rounds=True\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','$2a$05$c92SVSfjeiCD6F2nAD6y0uBpJDjdRkt0EgeC4/31Rf2LUZbDRDE.O'),\n ('U*U***U','$2a$05$WY62Xk2TXZ7EvVDQ5fmjNu7b0GEzSzUXUh2cllxJwhtOeMtWV3Ujq'),\n ('U*U***U*','$2a$05$Fa0iKV3E2SYVUlMknirWU.CFYGvJ67UwVKI1E2FP6XeLiZGcH3MJi'),\n ('*U*U*U*U','$2a$05$.WRrXibc1zPgIdRXYfv.4uu6TD1KWf0VnHzq/0imhUhuxSxCyeBs2'),\n ('','$2a$05$Otz9agnajgrAe0.kFVF9V.tzaStZ2s1s4ZWi/LY4sw2k/MTVFj/IO'),\n \n \n \n \n \n \n \n \n ('U*U','$2a$05$CCCCCCCCCCCCCCCCCCCCC.E5YPO9kmyuRGyh0XouQYb4YMJKvyOeW'),\n ('U*U*','$2a$05$CCCCCCCCCCCCCCCCCCCCC.VGOzA784oUp/Z0DY336zx7pLYAy0lwK'),\n ('U*U*U','$2a$05$XXXXXXXXXXXXXXXXXXXXXOAcXxm9kjPGEMsLznoKqmqw7tc8WCx4a'),\n ('','$2a$05$CCCCCCCCCCCCCCCCCCCCC.7uG0VCzI2bS7j6ymqJi9CdcdxiRTWNy'),\n ('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n '0123456789chars after 72 are ignored',\n '$2a$05$abcdefghijklmnopqrstuu5s2v8.iXieOjg/.AySBTTZIIVFJeBui'),\n (b'\\xa3',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.Sa7shbm4.OzKpvFnX1pQLmQW96oUlCq'),\n (b'\\xff\\xa3345',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.nRht2l/HRhr6zmCp9vYUvvsqynflf9e'),\n (b'\\xa3ab',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.6IflQkJytoRVc1yuaNtHfiuq.FRlSIS'),\n (b'\\xaa'*72+b'chars after 72 are ignored as usual',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.swQOIzjOiJ9GHEPuhEkvqrUyvWhEMx6'),\n (b'\\xaa\\x55'*36,\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.R9xrDjiycxMbQE2bp.vgqlYpW5wx2yy'),\n (b'\\x55\\xaa\\xff'*24,\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.9tQZzcJfm3uj2NvJ/n5xkhpqLrMpWCe'),\n \n \n (b'\\xa3',\n '$2y$05$/OK.fbVrR/bpIqNJ5ianF.Sa7shbm4.OzKpvFnX1pQLmQW96oUlCq'),\n \n \n \n \n \n \n (b\"\\xd1\\x91\",\"$2y$05$6bNw2HLQYeqHYyBfLMsv/OUcZd0LKP39b87nBw3.S2tVZSqiQX6eu\"),\n \n \n \n \n \n \n \n \n \n ((\"0123456789\"*26)[:254],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n ((\"0123456789\"*26)[:255],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n ((\"0123456789\"*26)[:256],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n ((\"0123456789\"*26)[:257],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n \n \n \n \n \n ('','$2a$06$DCq7YPn5Rq63x1Lad4cll.TV4S6ytwfsfvkgY8jIucDrjc8deX1s.'),\n ('a','$2a$10$k87L/MF28Q673VKh8/cPi.SUl7MU/rWuSiIDDFayrKk/1tBsSQu4u'),\n ('abc','$2a$10$WvvTPHKwdBJ3uk0Z37EMR.hLA2W6N9AEBhEgrAOljy2Ae5MtaSIUi'),\n ('abcdefghijklmnopqrstuvwxyz',\n '$2a$10$fVH8e28OQRj9tqiDXs1e1uxpsjN0c7II7YPKXua2NAKYvM6iQk7dq'),\n ('~!@#$%^&*()      ~!@#$%^&*()PNBFRD',\n '$2a$10$LgfYWkbzEvQ4JakH7rOvHe0y8pHKF9OaFgwUZ2q7W2FFZmZzJYlfS'),\n \n \n \n \n \n \n (UPASS_TABLE,\n '$2a$05$Z17AXnnlpzddNUvnC6cZNOSwMA/8oNiKnHTHTwLlBijfucQQlHjaG'),\n \n \n (UPASS_TABLE,\n '$2b$05$Z17AXnnlpzddNUvnC6cZNOSwMA/8oNiKnHTHTwLlBijfucQQlHjaG'),\n \n ]\n \n if TEST_MODE(\"full\"):\n \n \n \n  CONFIG_2='$2$05$'+'.'*22\n  CONFIG_A='$2a$05$'+'.'*22\n  known_correct_hashes.extend([\n  (\"\",CONFIG_2+'J2ihDv8vVf7QZ9BsaRrKyqs2tkn55Yq'),\n  (\"\",CONFIG_A+'J2ihDv8vVf7QZ9BsaRrKyqs2tkn55Yq'),\n  (\"abc\",CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\",CONFIG_A+'ev6gDwpVye3oMCUpLY85aTpfBNHD0Ga'),\n  (\"abc\"*23,CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*23,CONFIG_A+'2kIdfSj/4/R/Q6n847VTvc68BXiRYZC'),\n  (\"abc\"*24,CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*24,CONFIG_A+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*24+'x',CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*24+'x',CONFIG_A+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  ])\n  \n known_correct_configs=[\n ('$2a$04$uM6csdM8R9SXTex/gbTaye',UPASS_TABLE,\n '$2a$04$uM6csdM8R9SXTex/gbTayezuvzFEufYGd2uB6of7qScLjQ4GwcD4G'),\n ]\n \n known_unidentified_hashes=[\n \n \"$2f$12$EXRkfkdmXnagzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n \"$2`$12$EXRkfkdmXnagzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n ]\n \n known_malformed_hashes=[\n \n \n \"$2a$12$EXRkfkdmXn!gzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n \n \n \"$2x$12$EXRkfkdmXnagzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n \n \n '$2a$6$DCq7YPn5Rq63x1Lad4cll.TV4S6ytwfsfvkgY8jIucDrjc8deX1s.'\n \n \n \n ]\n \n platform_crypt_support=[\n (\"freedbsd|openbsd|netbsd\",True ),\n (\"darwin\",False ),\n (\"linux\",None ),\n (\"solaris\",None ),\n ]\n \n \n \n \n def setUp(self):\n \n  if TEST_MODE(\"full\")and self.backend ==\"builtin\":\n   key=\"PASSLIB_BUILTIN_BCRYPT\"\n   orig=os.environ.get(key)\n   if orig:\n    self.addCleanup(os.environ.__setitem__,key,orig)\n   else :\n    self.addCleanup(os.environ.__delitem__,key)\n   os.environ[key]=\"true\"\n   \n  super(_bcrypt_test,self).setUp()\n  \n  \n  warnings.filterwarnings(\"ignore\",\".*backend is vulnerable to the bsd wraparound bug.*\")\n  \n def populate_settings(self,kwds):\n \n  if self.backend ==\"builtin\":\n   kwds.setdefault(\"rounds\",4)\n  super(_bcrypt_test,self).populate_settings(kwds)\n  \n  \n  \n  \n def crypt_supports_variant(self,hash):\n  ''\n  from passlib.handlers.bcrypt import bcrypt,IDENT_2X,IDENT_2Y\n  from passlib.utils import safe_crypt\n  ident=bcrypt.from_string(hash)\n  return (safe_crypt(\"test\",ident+\"04$5BJqKfqMQvV7nS.yUguNcu\")or \"\").startswith(ident)\n  \n fuzz_verifiers=HandlerCase.fuzz_verifiers+(\n \"fuzz_verifier_bcrypt\",\n \"fuzz_verifier_pybcrypt\",\n \"fuzz_verifier_bcryptor\",\n )\n \n def fuzz_verifier_bcrypt(self):\n \n  from passlib.handlers.bcrypt import IDENT_2,IDENT_2A,IDENT_2B,IDENT_2X,IDENT_2Y,_detect_pybcrypt\n  from passlib.utils import to_native_str,to_bytes\n  try :\n   import bcrypt\n  except ImportError:\n   return\n  if _detect_pybcrypt():\n   return\n  def check_bcrypt(secret,hash):\n   ''\n   secret=to_bytes(secret,self.FuzzHashGenerator.password_encoding)\n   if hash.startswith(IDENT_2B):\n   \n    hash=IDENT_2A+hash[4:]\n   elif hash.startswith(IDENT_2):\n   \n   \n   \n    hash=IDENT_2A+hash[3:]\n    if secret:\n     secret=repeat_string(secret,72)\n   elif hash.startswith(IDENT_2Y)and bcrypt.__version__ ==\"3.0.0\":\n    hash=IDENT_2B+hash[4:]\n   hash=to_bytes(hash)\n   try :\n    return bcrypt.hashpw(secret,hash)==hash\n   except ValueError:\n    raise ValueError(\"bcrypt rejected hash: %r (secret=%r)\"%(hash,secret))\n  return check_bcrypt\n  \n def fuzz_verifier_pybcrypt(self):\n \n  from passlib.handlers.bcrypt import (\n  IDENT_2,IDENT_2A,IDENT_2B,IDENT_2X,IDENT_2Y,\n  _PyBcryptBackend,\n  )\n  from passlib.utils import to_native_str\n  \n  loaded=_PyBcryptBackend._load_backend_mixin(\"pybcrypt\",False )\n  if not loaded:\n   return\n   \n  from passlib.handlers.bcrypt import _pybcrypt as bcrypt_mod\n  \n  lock=_PyBcryptBackend._calc_lock\n  \n  def check_pybcrypt(secret,hash):\n   ''\n   secret=to_native_str(secret,self.FuzzHashGenerator.password_encoding)\n   if len(secret)>200:\n    secret=secret[:200]\n   if hash.startswith((IDENT_2B,IDENT_2Y)):\n    hash=IDENT_2A+hash[4:]\n   try :\n    if lock:\n     with lock:\n      return bcrypt_mod.hashpw(secret,hash)==hash\n    else :\n     return bcrypt_mod.hashpw(secret,hash)==hash\n   except ValueError:\n    raise ValueError(\"py-bcrypt rejected hash: %r\"%(hash,))\n  return check_pybcrypt\n  \n def fuzz_verifier_bcryptor(self):\n \n  from passlib.handlers.bcrypt import IDENT_2,IDENT_2A,IDENT_2Y,IDENT_2B\n  from passlib.utils import to_native_str\n  try :\n   from bcryptor.engine import Engine\n  except ImportError:\n   return\n  def check_bcryptor(secret,hash):\n   ''\n   secret=to_native_str(secret,self.FuzzHashGenerator.password_encoding)\n   if hash.startswith((IDENT_2B,IDENT_2Y)):\n    hash=IDENT_2A+hash[4:]\n   elif hash.startswith(IDENT_2):\n   \n   \n   \n    hash=IDENT_2A+hash[3:]\n    if secret:\n     secret=repeat_string(secret,72)\n   return Engine(False ).hash_key(secret,hash)==hash\n  return check_bcryptor\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def generate(self):\n   opts=super(_bcrypt_test.FuzzHashGenerator,self).generate()\n   \n   secret=opts['secret']\n   other=opts['other']\n   settings=opts['settings']\n   ident=settings.get('ident')\n   \n   if ident ==IDENT_2X:\n   \n    del settings['ident']\n    \n   elif ident ==IDENT_2 and other and repeat_string(to_bytes(other),len(to_bytes(secret)))==to_bytes(secret):\n   \n   \n    opts['secret'],opts['other']=self.random_password_pair()\n    \n   return opts\n   \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n   \n   \n   \n known_incorrect_padding=[\n \n \n \n \n \n \n (\"test\",\n '$2a$04$oaQbBqq8JnSM1NHRPQGXORY4Vw3bdHKLIXTecPDRAcJ98cz1ilveO',\n '$2a$04$oaQbBqq8JnSM1NHRPQGXOOY4Vw3bdHKLIXTecPDRAcJ98cz1ilveO'),\n \n \n \n \n \n (\"test\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSScrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"),\n \n \n (\"test\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIV\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"),\n ]\n \n def test_90_bcrypt_padding(self):\n  ''\n  self.require_TEST_MODE(\"full\")\n  \n  \n  \n  \n  \n  bcrypt=self.handler\n  corr_desc=\".*incorrectly set padding bits\"\n  \n  \n  \n  \n  def check_padding(hash):\n   assert hash.startswith((\"$2a$\",\"$2b$\"))and len(hash)>=28,\\\n   \"unexpectedly malformed hash: %r\"%(hash,)\n   self.assertTrue(hash[28]in '.Oeu',\n   \"unused bits incorrectly set in hash: %r\"%(hash,))\n  for i in irange(6):\n   check_padding(bcrypt.genconfig())\n  for i in irange(3):\n   check_padding(bcrypt.using(rounds=bcrypt.min_rounds).hash(\"bob\"))\n   \n   \n   \n   \n  with self.assertWarningList([\"salt too large\",corr_desc]):\n   hash=bcrypt.genconfig(salt=\".\"*21+\"A.\",rounds=5,relaxed=True )\n  self.assertEqual(hash,\"$2b$05$\"+\".\"*(22+31))\n  \n  \n  \n  \n  samples=self.known_incorrect_padding\n  for pwd,bad,good in samples:\n  \n  \n   with self.assertWarningList([corr_desc]):\n    self.assertEqual(bcrypt.genhash(pwd,bad),good)\n   with self.assertWarningList([]):\n    self.assertEqual(bcrypt.genhash(pwd,good),good)\n    \n    \n   with self.assertWarningList([corr_desc]):\n    self.assertTrue(bcrypt.verify(pwd,bad))\n   with self.assertWarningList([]):\n    self.assertTrue(bcrypt.verify(pwd,good))\n    \n    \n   with self.assertWarningList([corr_desc]):\n    self.assertEqual(bcrypt.normhash(bad),good)\n   with self.assertWarningList([]):\n    self.assertEqual(bcrypt.normhash(good),good)\n    \n    \n  self.assertEqual(bcrypt.normhash(\"$md5$abc\"),\"$md5$abc\")\n  \n def test_needs_update_w_padding(self):\n  ''\n  \n  bcrypt=self.handler.using(rounds=4)\n  \n  \n  \n  \n  BAD1=\"$2a$04$yjDgE74RJkeqC0/1NheSScrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n  GOOD1=\"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n  \n  self.assertTrue(bcrypt.needs_update(BAD1))\n  self.assertFalse(bcrypt.needs_update(GOOD1))\n  \n  \n  \n  \n  \n  \nbcrypt_bcrypt_test=_bcrypt_test.create_backend_case(\"bcrypt\")\nbcrypt_pybcrypt_test=_bcrypt_test.create_backend_case(\"pybcrypt\")\nbcrypt_bcryptor_test=_bcrypt_test.create_backend_case(\"bcryptor\")\n\nclass bcrypt_os_crypt_test(_bcrypt_test.create_backend_case(\"os_crypt\")):\n\n\n known_correct_hashes=[row for row in _bcrypt_test.known_correct_hashes\n if is_safe_crypt_input(row[0])]\n \n \n has_os_crypt_fallback=False\n \nbcrypt_builtin_test=_bcrypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass _bcrypt_sha256_test(HandlerCase):\n ''\n handler=hash.bcrypt_sha256\n reduce_default_rounds=True\n forbidden_characters=None\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n \n \n (\"\",\n '$bcrypt-sha256$2a,5$E/e/2AOhqM5W/KJTFQzLce$F6dYSxOdAEoJZO2eoHUZWZljW/e0TXO'),\n \n \n (\"password\",\n '$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu'),\n \n \n (UPASS_TABLE,\n '$bcrypt-sha256$2a,5$.US1fQ4TQS.ZTz/uJ5Kyn.$QNdPDOTKKT5/sovNz1iWg26quOU4Pje'),\n (UPASS_TABLE.encode(\"utf-8\"),\n '$bcrypt-sha256$2a,5$.US1fQ4TQS.ZTz/uJ5Kyn.$QNdPDOTKKT5/sovNz1iWg26quOU4Pje'),\n \n \n (\"password\",\n '$bcrypt-sha256$2b,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu'),\n (UPASS_TABLE,\n '$bcrypt-sha256$2b,5$.US1fQ4TQS.ZTz/uJ5Kyn.$QNdPDOTKKT5/sovNz1iWg26quOU4Pje'),\n \n \n \n (repeat_string(\"abc123\",72),\n '$bcrypt-sha256$2b,5$X1g1nh3g0v4h6970O68cxe$r/hyEtqJ0teqPEmfTLoZ83ciAI1Q74.'),\n (repeat_string(\"abc123\",72)+\"qwr\",\n '$bcrypt-sha256$2b,5$X1g1nh3g0v4h6970O68cxe$021KLEif6epjot5yoxk0m8I0929ohEa'),\n (repeat_string(\"abc123\",72)+\"xyz\",\n '$bcrypt-sha256$2b,5$X1g1nh3g0v4h6970O68cxe$7.1kgpHduMGEjvM3fX6e/QCvfn6OKja'),\n \n \n \n \n \n \n \n (\"\",\n '$bcrypt-sha256$v=2,t=2b,r=5$E/e/2AOhqM5W/KJTFQzLce$WFPIZKtDDTriqWwlmRFfHiOTeheAZWe'),\n \n \n (\"password\",\n '$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$wOK1VFFtS8IGTrGa7.h5fs0u84qyPbS'),\n \n \n (UPASS_TABLE,\n '$bcrypt-sha256$v=2,t=2b,r=5$.US1fQ4TQS.ZTz/uJ5Kyn.$pzzgp40k8reM1CuQb03PvE0IDPQSdV6'),\n (UPASS_TABLE.encode(\"utf-8\"),\n '$bcrypt-sha256$v=2,t=2b,r=5$.US1fQ4TQS.ZTz/uJ5Kyn.$pzzgp40k8reM1CuQb03PvE0IDPQSdV6'),\n \n \n \n (repeat_string(\"abc123\",72),\n '$bcrypt-sha256$v=2,t=2b,r=5$X1g1nh3g0v4h6970O68cxe$zu1cloESVFIOsUIo7fCEgkdHaI9SSue'),\n (repeat_string(\"abc123\",72)+\"qwr\",\n '$bcrypt-sha256$v=2,t=2b,r=5$X1g1nh3g0v4h6970O68cxe$CBF9csfEdW68xv3DwE6xSULXMtqEFP.'),\n (repeat_string(\"abc123\",72)+\"xyz\",\n '$bcrypt-sha256$v=2,t=2b,r=5$X1g1nh3g0v4h6970O68cxe$zC/1UDUG2ofEXB6Onr2vvyFzfhEOS3S'),\n ]\n \n known_correct_configs=[\n \n ('$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe',\n \"password\",'$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu'),\n \n ('$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe',\n \"password\",'$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$wOK1VFFtS8IGTrGa7.h5fs0u84qyPbS'),\n ]\n \n known_malformed_hashes=[\n \n \n \n \n \n \n '$bcrypt-sha256$2a,5$5Hg1DKF!PE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2c,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2x,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2a,05$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe$',\n \n \n \n \n \n \n \n '$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKF!PE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=1,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=3,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2c,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2a,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n '$bcrypt-sha256$v=2,t=2x,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2b,r=05$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$',\n ]\n \n \n \n \n def setUp(self):\n \n  if TEST_MODE(\"full\")and self.backend ==\"builtin\":\n   key=\"PASSLIB_BUILTIN_BCRYPT\"\n   orig=os.environ.get(key)\n   if orig:\n    self.addCleanup(os.environ.__setitem__,key,orig)\n   else :\n    self.addCleanup(os.environ.__delitem__,key)\n   os.environ[key]=\"enabled\"\n  super(_bcrypt_sha256_test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*backend is vulnerable to the bsd wraparound bug.*\")\n  \n def populate_settings(self,kwds):\n \n  if self.backend ==\"builtin\":\n   kwds.setdefault(\"rounds\",4)\n  super(_bcrypt_sha256_test,self).populate_settings(kwds)\n  \n  \n  \n  \n  \n def require_many_idents(self):\n  raise self.skipTest(\"multiple idents not supported\")\n  \n def test_30_HasOneIdent(self):\n \n  handler=self.handler\n  handler(use_defaults=True )\n  self.assertRaises(ValueError,handler,ident=\"$2y$\",use_defaults=True )\n  \n  \n  \n  \n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n  def random_ident(self):\n   return \"2b\"\n   \n   \n   \n   \n   \n def test_using_version(self):\n \n  handler=self.handler\n  self.assertEqual(handler.version,2)\n  \n  \n  subcls=handler.using(version=1)\n  self.assertEqual(subcls.version,1)\n  \n  \n  self.assertRaises(ValueError,handler.using,version=999)\n  \n  \n  subcls=handler.using(version=1,ident=\"2a\")\n  self.assertRaises(ValueError,handler.using,ident=\"2a\")\n  \n def test_calc_digest_v2(self):\n  ''\n\n  \n  from passlib.hash import bcrypt\n  from passlib.crypto.digest import compile_hmac\n  from passlib.utils.binary import b64encode\n  \n  \n  salt=\"nyKYxTAvjmy6lMDYMl11Uu\"\n  secret=\"test\"\n  temp_digest=compile_hmac(\"sha256\",salt.encode(\"ascii\"))(secret.encode(\"ascii\"))\n  temp_digest=b64encode(temp_digest).decode(\"ascii\")\n  self.assertEqual(temp_digest,\"J5TlyIDm+IcSWmKiDJm+MeICndBkFVPn4kKdJW8f+xY=\")\n  \n  \n  \n  bcrypt_digest=bcrypt(ident=\"2b\",salt=salt,rounds=12)._calc_checksum(temp_digest)\n  self.assertEqual(bcrypt_digest,\"M0wE0Ov/9LXoQFCe.jRHu3MSHPF54Ta\")\n  self.assertTrue(bcrypt.verify(temp_digest,\"$2b$12$\"+salt+bcrypt_digest))\n  \n  \n  \n  result=self.handler(ident=\"2b\",salt=salt,rounds=12)._calc_checksum(secret)\n  self.assertEqual(result,bcrypt_digest)\n  \n  \n  \n  \n  \n  \nbcrypt_sha256_bcrypt_test=_bcrypt_sha256_test.create_backend_case(\"bcrypt\")\nbcrypt_sha256_pybcrypt_test=_bcrypt_sha256_test.create_backend_case(\"pybcrypt\")\nbcrypt_sha256_bcryptor_test=_bcrypt_sha256_test.create_backend_case(\"bcryptor\")\n\nclass bcrypt_sha256_os_crypt_test(_bcrypt_sha256_test.create_backend_case(\"os_crypt\")):\n\n @classmethod\n def _get_safe_crypt_handler_backend(cls):\n  return bcrypt_os_crypt_test._get_safe_crypt_handler_backend()\n  \n has_os_crypt_fallback=False\n \nbcrypt_sha256_builtin_test=_bcrypt_sha256_test.create_backend_case(\"builtin\")\n\n\n\n\n", ["__future__", "bcrypt", "bcryptor.engine", "logging", "os", "passlib", "passlib.crypto.digest", "passlib.handlers.bcrypt", "passlib.hash", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "warnings"]], "passlib.tests.utils": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom binascii import unhexlify\nimport contextlib\nfrom functools import wraps,partial\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\nimport random\nimport re\nimport os\nimport sys\nimport tempfile\nimport threading\nimport time\nfrom passlib.exc import PasslibHashWarning,PasslibConfigWarning\nfrom passlib.utils.compat import PY3,JYTHON\nimport warnings\nfrom warnings import warn\n\n\nfrom passlib import exc\nfrom passlib.exc import MissingBackendError\nimport passlib.registry as registry\nfrom passlib.tests.backports import TestCase as _TestCase,skip,skipIf,skipUnless,SkipTest\nfrom passlib.utils import has_rounds_info,has_salt_info,rounds_cost_values,\\\nrng as sys_rng,getrandstr,is_ascii_safe,to_native_str,\\\nrepeat_string,tick,batch\nfrom passlib.utils.compat import iteritems,irange,u,unicode,PY2,nullcontext\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\n'TEST_MODE',\n'set_file','get_file',\n\n\n'TestCase',\n'HandlerCase',\n]\n\n\n\n\n\n\n\ntry :\n import google.appengine\nexcept ImportError:\n GAE=False\nelse :\n GAE=True\n \ndef ensure_mtime_changed(path):\n ''\n \n \n last=os.path.getmtime(path)\n while os.path.getmtime(path)==last:\n  time.sleep(0.1)\n  os.utime(path,None )\n  \ndef _get_timer_resolution(timer):\n def sample():\n  start=cur=timer()\n  while start ==cur:\n   cur=timer()\n  return cur -start\n return min(sample()for _ in range(3))\nTICK_RESOLUTION=_get_timer_resolution(tick)\n\n\n\n\n_TEST_MODES=[\"quick\",\"default\",\"full\"]\n_test_mode=_TEST_MODES.index(os.environ.get(\"PASSLIB_TEST_MODE\",\n\"default\").strip().lower())\n\ndef TEST_MODE(min=None ,max=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if min and _test_mode <_TEST_MODES.index(min):\n  return False\n if max and _test_mode >_TEST_MODES.index(max):\n  return False\n return True\n \n \n \n \ndef has_relaxed_setting(handler):\n ''\n \n \n \n \n if hasattr(handler,\"orig_prefix\"):\n  return False\n  \n return 'relaxed'in handler.setting_kwds or issubclass(handler,\n uh.GenericHandler)\n \ndef get_effective_rounds(handler,rounds=None ):\n ''\n handler=unwrap_handler(handler)\n return handler(rounds=rounds,use_defaults=True ).rounds\n \ndef is_default_backend(handler,backend):\n ''\n try :\n  orig=handler.get_backend()\n except MissingBackendError:\n  return False\n try :\n  handler.set_backend(\"default\")\n  return handler.get_backend()==backend\n finally :\n  handler.set_backend(orig)\n  \ndef iter_alt_backends(handler,current=None ,fallback=False ):\n ''\n\n\n\n\n \n if current is None :\n  current=handler.get_backend()\n backends=handler.backends\n idx=backends.index(current)+1 if fallback else 0\n for backend in backends[idx:]:\n  if backend !=current and handler.has_backend(backend):\n   yield backend\n   \ndef get_alt_backend(*args,**kwds):\n for backend in iter_alt_backends(*args,**kwds):\n  return backend\n return None\n \ndef unwrap_handler(handler):\n ''\n while hasattr(handler,\"wrapped\"):\n  handler=handler.wrapped\n return handler\n \ndef handler_derived_from(handler,base):\n ''\n\n \n \n \n if handler ==base:\n  return True\n elif isinstance(handler,uh.PrefixWrapper):\n  while handler:\n   if handler ==base:\n    return True\n    \n   handler=handler._derived_from\n  return False\n elif isinstance(handler,type)and issubclass(handler,uh.MinimalHandler):\n  return issubclass(handler,base)\n else :\n  raise NotImplementedError(\"don't know how to inspect handler: %r\"%(handler,))\n  \n@contextlib.contextmanager\ndef patch_calc_min_rounds(handler):\n ''\n\n\n\n\n \n if isinstance(handler,type)and issubclass(handler,uh.HasRounds):\n \n  wrapped=handler._calc_checksum\n  def wrapper(self,*args,**kwds):\n   rounds=self.rounds\n   try :\n    self.rounds=self.min_rounds\n    return wrapped(self,*args,**kwds)\n   finally :\n    self.rounds=rounds\n  handler._calc_checksum=wrapper\n  try :\n   yield\n  finally :\n   handler._calc_checksum=wrapped\n elif isinstance(handler,uh.PrefixWrapper):\n  with patch_calc_min_rounds(handler.wrapped):\n   yield\n else :\n  yield\n  return\n  \n  \n  \n  \ndef set_file(path,content):\n ''\n if isinstance(content,unicode):\n  content=content.encode(\"utf-8\")\n with open(path,\"wb\")as fh:\n  fh.write(content)\n  \ndef get_file(path):\n ''\n with open(path,\"rb\")as fh:\n  return fh.read()\n  \ndef tonn(source):\n ''\n if not isinstance(source,str):\n  return source\n elif PY3:\n  return source.encode(\"utf-8\")\n else :\n  try :\n   return source.decode(\"utf-8\")\n  except UnicodeDecodeError:\n   return source.decode(\"latin-1\")\n   \ndef hb(source):\n ''\n\n\n\n \n return unhexlify(re.sub(r\"\\s\",\"\",source))\n \ndef limit(value,lower,upper):\n if value <lower:\n  return lower\n elif value >upper:\n  return upper\n return value\n \ndef quicksleep(delay):\n ''\n start=tick()\n while tick()-start <delay:\n  pass\n  \ndef time_call(func,setup=None ,maxtime=1,bestof=10):\n ''\n\n\n\n\n \n from timeit import Timer\n from math import log\n timer=Timer(func,setup=setup or '')\n number=1\n end=tick()+maxtime\n while True :\n  delta=min(timer.repeat(bestof,number))\n  if tick()>=end:\n   return delta /number,int(log(number,10))\n  number *=10\n  \ndef run_with_fixed_seeds(count=128,master_seed=0x243F6A8885A308D3):\n ''\n\n \n def builder(func):\n  @wraps(func)\n  def wrapper(*args,**kwds):\n   rng=random.Random(master_seed)\n   for _ in irange(count):\n    kwds['seed']=rng.getrandbits(32)\n    func(*args,**kwds)\n  return wrapper\n return builder\n \n \n \n \n \nclass TestCase(_TestCase):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n descriptionPrefix=None\n \n def shortDescription(self):\n  ''\n  desc=super(TestCase,self).shortDescription()\n  prefix=self.descriptionPrefix\n  if prefix:\n   desc=\"%s: %s\"%(prefix,desc or str(self))\n  return desc\n  \n  \n  \n  \n  \n @classproperty\n def __unittest_skip__(cls):\n \n  name=cls.__name__\n  return name.startswith(\"_\")or\\\n  getattr(cls,\"_%s__unittest_skip\"%name,False )\n  \n @classproperty\n def __test__(cls):\n \n  return not cls.__unittest_skip__\n  \n  \n __unittest_skip=True\n \n \n \n \n \n \n resetWarningState=True\n \n def setUp(self):\n  super(TestCase,self).setUp()\n  self.setUpWarnings()\n  \n  self.patchAttr(exc,\"ENABLE_DEBUG_ONLY_REPR\",True )\n  \n def setUpWarnings(self):\n  ''\n  if self.resetWarningState:\n   ctx=reset_warnings()\n   ctx.__enter__()\n   self.addCleanup(ctx.__exit__)\n   \n   \n   \n   \n   \n   \n   \n   \n   warnings.filterwarnings(\"ignore\",r\"the method .*\\.(encrypt|genconfig|genhash)\\(\\) is deprecated\")\n   warnings.filterwarnings(\"ignore\",r\"the 'vary_rounds' option is deprecated\")\n   warnings.filterwarnings(\"ignore\",r\"Support for `(py-bcrypt|bcryptor)` is deprecated\")\n   \n   \n   \n   \n   \n longMessage=True\n \n def _formatMessage(self,msg,std):\n  if self.longMessage and msg and msg.rstrip().endswith(\":\"):\n   return '%s %s'%(msg.rstrip(),std)\n  else :\n   return msg or std\n   \n   \n   \n   \n   \n def assertRaises(self,_exc_type,_callable=None ,*args,**kwds):\n  msg=kwds.pop(\"__msg__\",None )\n  if _callable is None :\n  \n   return super(TestCase,self).assertRaises(_exc_type,None ,\n   *args,**kwds)\n  try :\n   result=_callable(*args,**kwds)\n  except _exc_type as err:\n   return err\n  std=\"function returned %r, expected it to raise %r\"%(result,\n  _exc_type)\n  raise self.failureException(self._formatMessage(msg,std))\n  \n  \n  \n  \n def assertEquals(self,*a,**k):\n  raise AssertionError(\"this alias is deprecated by unittest2\")\n assertNotEquals=assertRegexMatches=assertEquals\n \n \n \n \n def assertWarning(self,warning,\n message_re=None ,message=None ,\n category=None ,\n filename_re=None ,filename=None ,\n lineno=None ,\n msg=None ,\n ):\n  ''\n\n\n  \n  \n  if hasattr(warning,\"category\"):\n  \n   wmsg=warning\n   warning=warning.message\n  else :\n  \n   wmsg=None\n   \n   \n  if message:\n   self.assertEqual(str(warning),message,msg)\n  if message_re:\n   self.assertRegex(str(warning),message_re,msg)\n  if category:\n   self.assertIsInstance(warning,category,msg)\n   \n   \n  if filename or filename_re:\n   if not wmsg:\n    raise TypeError(\"matching on filename requires a \"\n    \"WarningMessage instance\")\n   real=wmsg.filename\n   if real.endswith(\".pyc\")or real.endswith(\".pyo\"):\n   \n   \n    real=real[:-1]\n   if filename:\n    self.assertEqual(real,filename,msg)\n   if filename_re:\n    self.assertRegex(real,filename_re,msg)\n  if lineno:\n   if not wmsg:\n    raise TypeError(\"matching on lineno requires a \"\n    \"WarningMessage instance\")\n   self.assertEqual(wmsg.lineno,lineno,msg)\n   \n class _AssertWarningList(warnings.catch_warnings):\n  ''\n  def __init__(self,case,**kwds):\n   self.case=case\n   self.kwds=kwds\n   self.__super=super(TestCase._AssertWarningList,self)\n   self.__super.__init__(record=True )\n   \n  def __enter__(self):\n   self.log=self.__super.__enter__()\n   \n  def __exit__(self,*exc_info):\n   self.__super.__exit__(*exc_info)\n   if exc_info[0]is None :\n    self.case.assertWarningList(self.log,**self.kwds)\n    \n def assertWarningList(self,wlist=None ,desc=None ,msg=None ):\n  ''\n  if desc is None :\n   assert wlist is not None\n   return self._AssertWarningList(self,desc=wlist,msg=msg)\n   \n  assert desc is not None\n  if not isinstance(desc,(list,tuple)):\n   desc=[desc]\n  for idx,entry in enumerate(desc):\n   if isinstance(entry,str):\n    entry=dict(message_re=entry)\n   elif isinstance(entry,type)and issubclass(entry,Warning):\n    entry=dict(category=entry)\n   elif not isinstance(entry,dict):\n    raise TypeError(\"entry must be str, warning, or dict\")\n   try :\n    data=wlist[idx]\n   except IndexError:\n    break\n   self.assertWarning(data,msg=msg,**entry)\n  else :\n   if len(wlist)==len(desc):\n    return\n  std=\"expected %d warnings, found %d: wlist=%s desc=%r\"%\\\n  (len(desc),len(wlist),self._formatWarningList(wlist),desc)\n  raise self.failureException(self._formatMessage(msg,std))\n  \n def consumeWarningList(self,wlist,desc=None ,*args,**kwds):\n  ''\n  if desc is None :\n   desc=[]\n  self.assertWarningList(wlist,desc,*args,**kwds)\n  del wlist[:]\n  \n def _formatWarning(self,entry):\n  tail=\"\"\n  if hasattr(entry,\"message\"):\n  \n   tail=\" filename=%r lineno=%r\"%(entry.filename,entry.lineno)\n   if entry.line:\n    tail +=\" line=%r\"%(entry.line,)\n   entry=entry.message\n  cls=type(entry)\n  return \"<%s.%s message=%r%s>\"%(cls.__module__,cls.__name__,\n  str(entry),tail)\n  \n def _formatWarningList(self,wlist):\n  return \"[%s]\"%\", \".join(self._formatWarning(entry)for entry in wlist)\n  \n  \n  \n  \n def require_stringprep(self):\n  ''\n  from passlib.utils import stringprep\n  if not stringprep:\n   from passlib.utils import _stringprep_missing_reason\n   raise self.skipTest(\"not available - stringprep module is \"+\n   _stringprep_missing_reason)\n   \n def require_TEST_MODE(self,level):\n  ''\n  if not TEST_MODE(level):\n   raise self.skipTest(\"requires >= %r test mode\"%level)\n   \n def require_writeable_filesystem(self):\n  ''\n  if GAE:\n   return self.skipTest(\"GAE doesn't offer read/write filesystem access\")\n   \n   \n   \n   \n   \n   \n   \n _random_global_lock=threading.Lock()\n \n \n _random_global_seed=None\n \n \n _random_cache=None\n \n def getRandom(self,name=\"default\",seed=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  cache=self._random_cache\n  if cache and name in cache:\n   return cache[name]\n   \n  with self._random_global_lock:\n  \n  \n   cache=self._random_cache\n   if cache and name in cache:\n    return cache[name]\n   elif not cache:\n    cache=self._random_cache={}\n    \n    \n   global_seed=seed or TestCase._random_global_seed\n   if global_seed is None :\n   \n   \n    global_seed=TestCase._random_global_seed=\\\n    int(os.environ.get(\"RANDOM_TEST_SEED\")or\n    os.environ.get(\"PYTHONHASHSEED\")or\n    sys_rng.getrandbits(32))\n    \n    log.info(\"using RANDOM_TEST_SEED=%d\",global_seed)\n    \n    \n   cls=type(self)\n   source=\"\\n\".join([str(global_seed),cls.__module__,cls.__name__,\n   self._testMethodName,name])\n   digest=hashlib.sha256(source.encode(\"utf-8\")).hexdigest()\n   seed=int(digest[:16],16)\n   \n   \n   value=cache[name]=random.Random(seed)\n   return value\n   \n   \n   \n   \n   \n has_real_subtest=hasattr(_TestCase,\"subTest\")\n \n @contextlib.contextmanager\n def subTest(self,*args,**kwds):\n  ''\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def _render_title(_msg=None ,**params):\n   out=(\"[%s] \"%_msg if _msg else \"\")\n   if params:\n    out +=\"(%s)\"%\" \".join(\"%s=%r\"%tuple(item)for item in params.items())\n   return out.strip()or \"<subtest>\"\n   \n  test_log=self.getLogger()\n  title=_render_title(*args,**kwds)\n  \n  \n  if self.has_real_subtest:\n   ctx=super(TestCase,self).subTest(*args,**kwds)\n  else :\n   ctx=nullcontext()\n   \n   \n  with ctx:\n   test_log.info(\"running subtest: %s\",title)\n   try :\n    yield\n   except SkipTest:\n   \n    test_log.info(\"subtest skipped: %s\",title)\n    pass\n   except Exception as err:\n   \n   \n    test_log.warning(\"subtest failed: %s: %s: %r\",title,type(err).__name__,str(err))\n    raise\n    \n    \n  test_log.info(\"subtest passed: %s\",title)\n  \n  \n  \n  \n _mktemp_queue=None\n \n def mktemp(self,*args,**kwds):\n  ''\n  self.require_writeable_filesystem()\n  fd,path=tempfile.mkstemp(*args,**kwds)\n  os.close(fd)\n  queue=self._mktemp_queue\n  if queue is None :\n   queue=self._mktemp_queue=[]\n   def cleaner():\n    for path in queue:\n     if os.path.exists(path):\n      os.remove(path)\n    del queue[:]\n   self.addCleanup(cleaner)\n  queue.append(path)\n  return path\n  \n def patchAttr(self,obj,attr,value,require_existing=True ,wrap=False ):\n  ''\n  try :\n   orig=getattr(obj,attr)\n  except AttributeError:\n   if require_existing:\n    raise\n   def cleanup():\n    try :\n     delattr(obj,attr)\n    except AttributeError:\n     pass\n   self.addCleanup(cleanup)\n  else :\n   self.addCleanup(setattr,obj,attr,orig)\n  if wrap:\n   value=partial(value,orig)\n   wraps(orig)(value)\n  setattr(obj,attr,value)\n  \n def getLogger(self):\n  ''\n\n  \n  cls=type(self)\n  \n  path=cls.__module__+\".\"+getattr(cls,\"__qualname__\",cls.__name__)\n  name=self._testMethodName\n  if name:\n   path=path+\".\"+name\n  return logging.getLogger(path)\n  \n  \n  \n  \n  \n  \n  \n  \n  \nRESERVED_BACKEND_NAMES=[\"any\",\"default\"]\n\n\ndef doesnt_require_backend(func):\n ''\n\n\n\n\n\n \n func._doesnt_require_backend=True\n return func\n \n \nclass HandlerCase(TestCase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n handler=None\n \n \n backend=None\n \n \n \n \n \n \n known_correct_hashes=[]\n \n \n known_correct_configs=[]\n \n \n \n \n \n known_alternate_hashes=[]\n \n \n known_unidentified_hashes=[]\n \n \n \n known_malformed_hashes=[]\n \n \n \n \n known_other_hashes=[\n ('des_crypt','6f8c114b58f2c'),\n ('md5_crypt','$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.'),\n ('sha512_crypt',\"$6$rounds=123456$asaltof16chars..$BtCwjqMJGx5hrJhZywW\"\n \"vt0RLE8uZ4oPwcelCjmw2kSYu.Ec6ycULevoBK25fs2xXgMNrCzIMVcgEJAstJeonj1\"),\n ]\n \n \n \n stock_passwords=[\n u(\"test\"),\n u(\"\\u20AC\\u00A5$\"),\n b'\\xe2\\x82\\xac\\xc2\\xa5$'\n ]\n \n \n \n \n \n \n \n \n secret_case_insensitive=False\n \n \n accepts_all_hashes=False\n \n \n disabled_contains_salt=False\n \n \n filter_config_warnings=False\n \n \n @classproperty\n def forbidden_characters(cls):\n \n \n  if 'os_crypt'in getattr(cls.handler,\"backends\",()):\n   return b\"\\x00\"\n  return None\n  \n  \n  \n  \n __unittest_skip=True\n \n @property\n def descriptionPrefix(self):\n  handler=self.handler\n  name=handler.name\n  if hasattr(handler,\"get_backend\"):\n   name +=\" (%s backend)\"%(handler.get_backend(),)\n  return name\n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def iter_known_hashes(cls):\n  ''\n  for secret,hash in cls.known_correct_hashes:\n   yield secret,hash\n  for config,secret,hash in cls.known_correct_configs:\n   yield secret,hash\n  for alt,secret,hash in cls.known_alternate_hashes:\n   yield secret,hash\n   \n def get_sample_hash(self):\n  ''\n  known=list(self.iter_known_hashes())\n  return self.getRandom().choice(known)\n  \n  \n  \n  \n def check_verify(self,secret,hash,msg=None ,negate=False ):\n  ''\n  result=self.do_verify(secret,hash)\n  self.assertTrue(result is True or result is False ,\n  \"verify() returned non-boolean value: %r\"%(result,))\n  if self.handler.is_disabled or negate:\n   if not result:\n    return\n   if not msg:\n    msg=(\"verify incorrectly returned True: secret=%r, hash=%r\"%\n    (secret,hash))\n   raise self.failureException(msg)\n  else :\n   if result:\n    return\n   if not msg:\n    msg=\"verify failed: secret=%r, hash=%r\"%(secret,hash)\n   raise self.failureException(msg)\n   \n def check_returned_native_str(self,result,func_name):\n  self.assertIsInstance(result,str,\n  \"%s() failed to return native string: %r\"%(func_name,result,))\n  \n  \n  \n  \n  \n def populate_settings(self,kwds):\n  ''\n  \n  handler=self.handler\n  if 'rounds'in handler.setting_kwds and 'rounds'not in kwds:\n   mn=handler.min_rounds\n   df=handler.default_rounds\n   if TEST_MODE(max=\"quick\"):\n   \n    kwds['rounds']=max(3,mn)\n   else :\n   \n    factor=3\n    if getattr(handler,\"rounds_cost\",None )==\"log2\":\n     df -=factor\n    else :\n     df //=(1 <<factor)\n    kwds['rounds']=max(3,mn,df)\n    \n def populate_context(self,secret,kwds):\n  ''\n  return secret\n  \n  \n def do_encrypt(self,secret,use_encrypt=False ,handler=None ,context=None ,**settings):\n  ''\n  self.populate_settings(settings)\n  if context is None :\n   context={}\n  secret=self.populate_context(secret,context)\n  if use_encrypt:\n  \n   warnings=[]\n   if settings:\n    context.update(**settings)\n    warnings.append(\"passing settings to.*is deprecated\")\n   with self.assertWarningList(warnings):\n    return (handler or self.handler).encrypt(secret,**context)\n  else :\n  \n   return (handler or self.handler).using(**settings).hash(secret,**context)\n   \n def do_verify(self,secret,hash,handler=None ,**kwds):\n  ''\n  secret=self.populate_context(secret,kwds)\n  return (handler or self.handler).verify(secret,hash,**kwds)\n  \n def do_identify(self,hash):\n  ''\n  return self.handler.identify(hash)\n  \n def do_genconfig(self,**kwds):\n  ''\n  self.populate_settings(kwds)\n  return self.handler.genconfig(**kwds)\n  \n def do_genhash(self,secret,config,**kwds):\n  ''\n  secret=self.populate_context(secret,kwds)\n  return self.handler.genhash(secret,config,**kwds)\n  \n def do_stub_encrypt(self,handler=None ,context=None ,**settings):\n  ''\n\n\n  \n  handler=(handler or self.handler).using(**settings)\n  if context is None :\n   context={}\n  secret=self.populate_context(\"\",context)\n  with patch_calc_min_rounds(handler):\n   return handler.hash(secret,**context)\n   \n   \n   \n   \n   \n   \n   \n _BACKEND_NOT_AVAILABLE=\"backend not available\"\n \n @classmethod\n def _get_skip_backend_reason(cls,backend):\n  ''\n\n\n  \n  handler=cls.handler\n  if not is_default_backend(handler,backend)and not TEST_MODE(\"full\"):\n   return \"only default backend is being tested\"\n  if handler.has_backend(backend):\n   return None\n  return cls._BACKEND_NOT_AVAILABLE\n  \n @classmethod\n def create_backend_case(cls,backend):\n  handler=cls.handler\n  name=handler.name\n  assert hasattr(handler,\"backends\"),\"handler must support uh.HasManyBackends protocol\"\n  assert backend in handler.backends,\"unknown backend: %r\"%(backend,)\n  bases=(cls,)\n  if backend ==\"os_crypt\":\n   bases +=(OsCryptMixin,)\n  subcls=type(\n  \"%s_%s_test\"%(name,backend),\n  bases,\n  dict(\n  descriptionPrefix=\"%s (%s backend)\"%(name,backend),\n  backend=backend,\n  _skip_backend_reason=cls._get_skip_backend_reason(backend),\n  __module__=cls.__module__,\n  )\n  )\n  return subcls\n  \n  \n  \n _skip_backend_reason=None\n \n def _test_requires_backend(self):\n  ''\n\n  \n  meth=getattr(self,self._testMethodName,None )\n  return not getattr(meth,\"_doesnt_require_backend\",False )\n  \n  \n  \n  \n def setUp(self):\n \n \n \n  test_requires_backend=self._test_requires_backend()\n  if test_requires_backend and self._skip_backend_reason:\n   raise self.skipTest(self._skip_backend_reason)\n   \n  super(HandlerCase,self).setUp()\n  \n  \n  \n  \n  handler=self.handler\n  backend=self.backend\n  if backend:\n   if not hasattr(handler,\"set_backend\"):\n    raise RuntimeError(\"handler doesn't support multiple backends\")\n   try :\n    self.addCleanup(handler.set_backend,handler.get_backend())\n    handler.set_backend(backend)\n   except uh.exc.MissingBackendError:\n    if test_requires_backend:\n     raise\n     \n     \n     \n  from passlib.utils import handlers\n  self.patchAttr(handlers,\"rng\",self.getRandom(\"salt generator\"))\n  \n  \n  \n  \n def test_01_required_attributes(self):\n  ''\n  handler=self.handler\n  def ga(name):\n   return getattr(handler,name,None )\n   \n   \n   \n   \n  name=ga(\"name\")\n  self.assertTrue(name,\"name not defined:\")\n  self.assertIsInstance(name,str,\"name must be native str\")\n  self.assertTrue(name.lower()==name,\"name not lower-case:\")\n  self.assertTrue(re.match(\"^[a-z0-9_]+$\",name),\n  \"name must be alphanum + underscore: %r\"%(name,))\n  \n  \n  \n  \n  settings=ga(\"setting_kwds\")\n  self.assertTrue(settings is not None ,\"setting_kwds must be defined:\")\n  self.assertIsInstance(settings,tuple,\"setting_kwds must be a tuple:\")\n  \n  \n  \n  \n  context=ga(\"context_kwds\")\n  self.assertTrue(context is not None ,\"context_kwds must be defined:\")\n  self.assertIsInstance(context,tuple,\"context_kwds must be a tuple:\")\n  \n  \n  \n def test_02_config_workflow(self):\n  ''\n\n\n\n  \n  \n  \n  \n  \n  config=self.do_genconfig()\n  self.check_returned_native_str(config,\"genconfig\")\n  \n  \n  \n  \n  \n  result=self.do_genhash('stub',config)\n  self.check_returned_native_str(result,\"genhash\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self.do_verify('',config)\n  \n  \n  \n  \n  \n  \n  \n  self.assertTrue(self.do_identify(config),\n  \"identify() failed to identify genconfig() output: %r\"%\n  (config,))\n  \n def test_02_using_workflow(self):\n  ''\n  handler=self.handler\n  subcls=handler.using()\n  self.assertIsNot(subcls,handler)\n  self.assertEqual(subcls.name,handler.name)\n  \n  \n  \n def test_03_hash_workflow(self,use_16_legacy=False ):\n  ''\n\n\n\n\n  \n  wrong_secret='stub'\n  for secret in self.stock_passwords:\n  \n  \n  \n  \n   result=self.do_encrypt(secret,use_encrypt=use_16_legacy)\n   self.check_returned_native_str(result,\"hash\")\n   \n   \n   \n   \n   self.check_verify(secret,result)\n   self.check_verify(wrong_secret,result,negate=True )\n   \n   \n   \n   \n   other=self.do_genhash(secret,result)\n   self.check_returned_native_str(other,\"genhash\")\n   if self.handler.is_disabled and self.disabled_contains_salt:\n    self.assertNotEqual(other,result,\"genhash() failed to salt result \"\n    \"hash: secret=%r hash=%r: result=%r\"%\n    (secret,result,other))\n   else :\n    self.assertEqual(other,result,\"genhash() failed to reproduce \"\n    \"hash: secret=%r hash=%r: result=%r\"%\n    (secret,result,other))\n    \n    \n    \n    \n   other=self.do_genhash(wrong_secret,result)\n   self.check_returned_native_str(other,\"genhash\")\n   if self.handler.is_disabled and not self.disabled_contains_salt:\n    self.assertEqual(other,result,\"genhash() failed to reproduce \"\n    \"disabled-hash: secret=%r hash=%r other_secret=%r: result=%r\"%\n    (secret,result,wrong_secret,other))\n   else :\n    self.assertNotEqual(other,result,\"genhash() duplicated \"\n    \"hash: secret=%r hash=%r wrong_secret=%r: result=%r\"%\n    (secret,result,wrong_secret,other))\n    \n    \n    \n    \n   self.assertTrue(self.do_identify(result))\n   \n def test_03_legacy_hash_workflow(self):\n  ''\n  self.test_03_hash_workflow(use_16_legacy=True )\n  \n def test_04_hash_types(self):\n  ''\n  \n  \n  \n  \n  \n  result=self.do_encrypt(tonn('stub'))\n  self.check_returned_native_str(result,\"hash\")\n  \n  \n  self.check_verify('stub',tonn(result))\n  \n  \n  self.check_verify(tonn('stub'),tonn(result))\n  \n  \n  other=self.do_genhash('stub',tonn(result))\n  self.check_returned_native_str(other,\"genhash\")\n  if self.handler.is_disabled and self.disabled_contains_salt:\n   self.assertNotEqual(other,result)\n  else :\n   self.assertEqual(other,result)\n   \n   \n  other=self.do_genhash(tonn('stub'),tonn(result))\n  self.check_returned_native_str(other,\"genhash\")\n  if self.handler.is_disabled and self.disabled_contains_salt:\n   self.assertNotEqual(other,result)\n  else :\n   self.assertEqual(other,result)\n   \n   \n  self.assertTrue(self.do_identify(tonn(result)))\n  \n def test_05_backends(self):\n  ''\n  \n  \n  handler=self.handler\n  if not hasattr(handler,\"set_backend\"):\n   raise self.skipTest(\"handler only has one backend\")\n   \n   \n  self.addCleanup(handler.set_backend,handler.get_backend())\n  \n  \n  for backend in handler.backends:\n  \n  \n  \n  \n   self.assertIsInstance(backend,str)\n   self.assertNotIn(backend,RESERVED_BACKEND_NAMES,\n   \"invalid backend name: %r\"%(backend,))\n   \n   \n   \n   \n   ret=handler.has_backend(backend)\n   if ret is True :\n   \n    handler.set_backend(backend)\n    self.assertEqual(handler.get_backend(),backend)\n    \n   elif ret is False :\n   \n    self.assertRaises(MissingBackendError,handler.set_backend,\n    backend)\n    \n   else :\n   \n   \n    raise TypeError(\"has_backend(%r) returned invalid \"\n    \"value: %r\"%(backend,ret))\n    \n    \n    \n    \n def require_salt(self):\n  if 'salt'not in self.handler.setting_kwds:\n   raise self.skipTest(\"handler doesn't have salt\")\n   \n def require_salt_info(self):\n  self.require_salt()\n  if not has_salt_info(self.handler):\n   raise self.skipTest(\"handler doesn't provide salt info\")\n   \n def test_10_optional_salt_attributes(self):\n  ''\n  self.require_salt_info()\n  AssertionError=self.failureException\n  cls=self.handler\n  \n  \n  mx_set=(cls.max_salt_size is not None )\n  if mx_set and cls.max_salt_size <1:\n   raise AssertionError(\"max_salt_chars must be >= 1\")\n   \n   \n  if cls.min_salt_size <0:\n   raise AssertionError(\"min_salt_chars must be >= 0\")\n  if mx_set and cls.min_salt_size >cls.max_salt_size:\n   raise AssertionError(\"min_salt_chars must be <= max_salt_chars\")\n   \n   \n  if cls.default_salt_size <cls.min_salt_size:\n   raise AssertionError(\"default_salt_size must be >= min_salt_size\")\n  if mx_set and cls.default_salt_size >cls.max_salt_size:\n   raise AssertionError(\"default_salt_size must be <= max_salt_size\")\n   \n   \n   \n   \n  if 'salt_size'not in cls.setting_kwds and (not mx_set or cls.default_salt_size <cls.max_salt_size):\n   warn('%s: hash handler supports range of salt sizes, '\n   'but doesn\\'t offer \\'salt_size\\' setting'%(cls.name,))\n   \n   \n  if cls.salt_chars:\n   if not cls.default_salt_chars:\n    raise AssertionError(\"default_salt_chars must not be empty\")\n   for c in cls.default_salt_chars:\n    if c not in cls.salt_chars:\n     raise AssertionError(\"default_salt_chars must be subset of salt_chars: %r not in salt_chars\"%(c,))\n  else :\n   if not cls.default_salt_chars:\n    raise AssertionError(\"default_salt_chars MUST be specified if salt_chars is empty\")\n    \n @property\n def salt_bits(self):\n  ''\n  \n  handler=self.handler\n  assert has_salt_info(handler),\"need explicit bit-size for \"+handler.name\n  from math import log\n  \n  \n  return int(handler.default_salt_size *\n  log(len(handler.default_salt_chars),2))\n  \n def test_11_unique_salt(self):\n  ''\n  self.require_salt()\n  \n  \n  \n  \n  \n  samples=max(1,4+12 -self.salt_bits)\n  \n  def sampler(func):\n   value1=func()\n   for _ in irange(samples):\n    value2=func()\n    if value1 !=value2:\n     return\n   raise self.failureException(\"failed to find different salt after \"\n   \"%d samples\"%(samples,))\n  sampler(self.do_genconfig)\n  sampler(lambda :self.do_encrypt(\"stub\"))\n  \n def test_12_min_salt_size(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  salt_char=handler.salt_chars[0:1]\n  min_size=handler.min_salt_size\n  \n  \n  \n  \n  s1=salt_char *min_size\n  self.do_genconfig(salt=s1)\n  \n  self.do_encrypt('stub',salt_size=min_size)\n  \n  \n  \n  \n  if min_size >0:\n   self.assertRaises(ValueError,self.do_genconfig,\n   salt=s1[:-1])\n   \n  self.assertRaises(ValueError,self.do_encrypt,'stub',\n  salt_size=min_size -1)\n  \n def test_13_max_salt_size(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  max_size=handler.max_salt_size\n  salt_char=handler.salt_chars[0:1]\n  \n  \n  if max_size is None or max_size >(1 <<20):\n  \n  \n  \n  \n   s1=salt_char *1024\n   c1=self.do_stub_encrypt(salt=s1)\n   c2=self.do_stub_encrypt(salt=s1+salt_char)\n   self.assertNotEqual(c1,c2)\n   \n   self.do_stub_encrypt(salt_size=1024)\n   \n  else :\n  \n  \n  \n   s1=salt_char *max_size\n   c1=self.do_stub_encrypt(salt=s1)\n   \n   self.do_stub_encrypt(salt_size=max_size)\n   \n   \n   \n   \n   s2=s1+salt_char\n   self.assertRaises(ValueError,self.do_stub_encrypt,salt=s2)\n   \n   self.assertRaises(ValueError,self.do_stub_encrypt,salt_size=max_size+1)\n   \n   \n   \n   \n   if has_relaxed_setting(handler):\n    with warnings.catch_warnings(record=True ):\n     c2=self.do_stub_encrypt(salt=s2,relaxed=True )\n    self.assertEqual(c2,c1)\n    \n    \n    \n    \n   if handler.min_salt_size <max_size:\n    c3=self.do_stub_encrypt(salt=s1[:-1])\n    self.assertNotEqual(c3,c1)\n    \n    \n fuzz_salts_need_bcrypt_repair=False\n \n def prepare_salt(self,salt):\n  ''\n  if self.fuzz_salts_need_bcrypt_repair:\n   from passlib.utils.binary import bcrypt64\n   salt=bcrypt64.repair_unused(salt)\n  return salt\n  \n def test_14_salt_chars(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  mx=handler.max_salt_size\n  mn=handler.min_salt_size\n  cs=handler.salt_chars\n  raw=isinstance(cs,bytes)\n  \n  \n  for salt in batch(cs,mx or 32):\n   if len(salt)<mn:\n    salt=repeat_string(salt,mn)\n   salt=self.prepare_salt(salt)\n   self.do_stub_encrypt(salt=salt)\n   \n   \n  source=u('\\x00\\xff')\n  if raw:\n   source=source.encode(\"latin-1\")\n  chunk=max(mn,1)\n  for c in source:\n   if c not in cs:\n    self.assertRaises(ValueError,self.do_stub_encrypt,salt=c *chunk,\n    __msg__=\"invalid salt char %r:\"%(c,))\n    \n @property\n def salt_type(self):\n  ''\n  \n  if getattr(self.handler,\"_salt_is_bytes\",False ):\n   return bytes\n  else :\n   return unicode\n   \n def test_15_salt_type(self):\n  ''\n  self.require_salt()\n  salt_type=self.salt_type\n  salt_size=getattr(self.handler,\"min_salt_size\",0)or 8\n  \n  \n  class fake(object):\n   pass\n  self.assertRaises(TypeError,self.do_encrypt,'stub',salt=fake())\n  \n  \n  if salt_type is not unicode:\n   self.assertRaises(TypeError,self.do_encrypt,'stub',salt=u('x')*salt_size)\n   \n   \n   \n  if not (salt_type is bytes or (PY2 and salt_type is unicode)):\n   self.assertRaises(TypeError,self.do_encrypt,'stub',salt=b'x'*salt_size)\n   \n def test_using_salt_size(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  mn=handler.min_salt_size\n  mx=handler.max_salt_size\n  df=handler.default_salt_size\n  \n  \n  self.assertRaises(ValueError,handler.using,default_salt_size=-1)\n  with self.assertWarningList([PasslibHashWarning]):\n   temp=handler.using(default_salt_size=-1,relaxed=True )\n  self.assertEqual(temp.default_salt_size,mn)\n  \n  \n  if mx:\n   self.assertRaises(ValueError,handler.using,default_salt_size=mx+1)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(default_salt_size=mx+1,relaxed=True )\n   self.assertEqual(temp.default_salt_size,mx)\n   \n   \n  if mn !=mx:\n   temp=handler.using(default_salt_size=mn+1)\n   self.assertEqual(temp.default_salt_size,mn+1)\n   self.assertEqual(handler.default_salt_size,df)\n   \n   temp=handler.using(default_salt_size=mn+2)\n   self.assertEqual(temp.default_salt_size,mn+2)\n   self.assertEqual(handler.default_salt_size,df)\n   \n   \n  if mn ==mx:\n   ref=mn\n  else :\n   ref=mn+1\n  temp=handler.using(default_salt_size=str(ref))\n  self.assertEqual(temp.default_salt_size,ref)\n  \n  \n  self.assertRaises(ValueError,handler.using,default_salt_size=str(ref)+\"xxx\")\n  \n  \n  temp=handler.using(salt_size=ref)\n  self.assertEqual(temp.default_salt_size,ref)\n  \n  \n  \n  \n def require_rounds_info(self):\n  if not has_rounds_info(self.handler):\n   raise self.skipTest(\"handler lacks rounds attributes\")\n   \n def test_20_optional_rounds_attributes(self):\n  ''\n  self.require_rounds_info()\n  \n  cls=self.handler\n  AssertionError=self.failureException\n  \n  \n  if cls.max_rounds is None :\n   raise AssertionError(\"max_rounds not specified\")\n  if cls.max_rounds <1:\n   raise AssertionError(\"max_rounds must be >= 1\")\n   \n   \n  if cls.min_rounds <0:\n   raise AssertionError(\"min_rounds must be >= 0\")\n  if cls.min_rounds >cls.max_rounds:\n   raise AssertionError(\"min_rounds must be <= max_rounds\")\n   \n   \n  if cls.default_rounds is not None :\n   if cls.default_rounds <cls.min_rounds:\n    raise AssertionError(\"default_rounds must be >= min_rounds\")\n   if cls.default_rounds >cls.max_rounds:\n    raise AssertionError(\"default_rounds must be <= max_rounds\")\n    \n    \n  if cls.rounds_cost not in rounds_cost_values:\n   raise AssertionError(\"unknown rounds cost constant: %r\"%(cls.rounds_cost,))\n   \n def test_21_min_rounds(self):\n  ''\n  self.require_rounds_info()\n  handler=self.handler\n  min_rounds=handler.min_rounds\n  \n  \n  self.do_genconfig(rounds=min_rounds)\n  self.do_encrypt('stub',rounds=min_rounds)\n  \n  \n  self.assertRaises(ValueError,self.do_genconfig,rounds=min_rounds -1)\n  self.assertRaises(ValueError,self.do_encrypt,'stub',rounds=min_rounds -1)\n  \n  \n  \n def test_21b_max_rounds(self):\n  ''\n  self.require_rounds_info()\n  handler=self.handler\n  max_rounds=handler.max_rounds\n  \n  if max_rounds is not None :\n  \n   self.assertRaises(ValueError,self.do_genconfig,rounds=max_rounds+1)\n   self.assertRaises(ValueError,self.do_encrypt,'stub',rounds=max_rounds+1)\n   \n   \n  if max_rounds is None :\n   self.do_stub_encrypt(rounds=(1 <<31)-1)\n  else :\n   self.do_stub_encrypt(rounds=max_rounds)\n   \n   \n   \n   \n   \n   \n def _create_using_rounds_helper(self):\n  ''\n\n  \n  self.require_rounds_info()\n  handler=self.handler\n  \n  if handler.name ==\"bsdi_crypt\":\n  \n   orig_handler=handler\n   handler=handler.using()\n   handler._generate_rounds=classmethod(lambda cls:super(orig_handler,cls)._generate_rounds())\n   \n   \n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  orig_default_rounds=handler.default_rounds\n  medium=((orig_max_rounds or 9999)+orig_min_rounds)//2\n  if medium ==orig_default_rounds:\n   medium +=1\n  small=(orig_min_rounds+medium)//2\n  large=((orig_max_rounds or 9999)+medium)//2\n  \n  if handler.name ==\"bsdi_crypt\":\n  \n   small |=1\n   medium |=1\n   large |=1\n   adj=2\n  else :\n   adj=1\n   \n   \n  with self.assertWarningList([]):\n   subcls=handler.using(\n   min_desired_rounds=small,\n   max_desired_rounds=large,\n   default_rounds=medium,\n   )\n   \n   \n  return handler,subcls,small,medium,large,adj\n  \n def test_has_rounds_using_harness(self):\n  ''\n\n  \n  \n  self.require_rounds_info()\n  handler=self.handler\n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  orig_default_rounds=handler.default_rounds\n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  \n  self.assertEqual(handler.min_rounds,orig_min_rounds)\n  self.assertEqual(handler.max_rounds,orig_max_rounds)\n  self.assertEqual(handler.min_desired_rounds,None )\n  self.assertEqual(handler.max_desired_rounds,None )\n  self.assertEqual(handler.default_rounds,orig_default_rounds)\n  \n  \n  self.assertEqual(subcls.min_rounds,orig_min_rounds)\n  self.assertEqual(subcls.max_rounds,orig_max_rounds)\n  self.assertEqual(subcls.default_rounds,medium)\n  self.assertEqual(subcls.min_desired_rounds,small)\n  self.assertEqual(subcls.max_desired_rounds,large)\n  \n def test_has_rounds_using_w_min_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  orig_default_rounds=handler.default_rounds\n  \n  \n  if orig_min_rounds >0:\n   self.assertRaises(ValueError,handler.using,min_desired_rounds=orig_min_rounds -adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(min_desired_rounds=orig_min_rounds -adj,relaxed=True )\n   self.assertEqual(temp.min_desired_rounds,orig_min_rounds)\n   \n   \n  if orig_max_rounds:\n   self.assertRaises(ValueError,handler.using,min_desired_rounds=orig_max_rounds+adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(min_desired_rounds=orig_max_rounds+adj,relaxed=True )\n   self.assertEqual(temp.min_desired_rounds,orig_max_rounds)\n   \n   \n  with self.assertWarningList([]):\n   temp=subcls.using(min_desired_rounds=small -adj)\n  self.assertEqual(temp.min_desired_rounds,small -adj)\n  \n  \n  temp=subcls.using(min_desired_rounds=small+2 *adj)\n  self.assertEqual(temp.min_desired_rounds,small+2 *adj)\n  \n  \n  with self.assertWarningList([]):\n   temp=subcls.using(min_desired_rounds=large+adj)\n  self.assertEqual(temp.min_desired_rounds,large+adj)\n  \n  \n  \n  self.assertEqual(get_effective_rounds(subcls,small+adj),small+adj)\n  self.assertEqual(get_effective_rounds(subcls,small),small)\n  with self.assertWarningList([]):\n   self.assertEqual(get_effective_rounds(subcls,small -adj),small -adj)\n   \n   \n  temp=handler.using(min_rounds=small)\n  self.assertEqual(temp.min_desired_rounds,small)\n  \n  \n  temp=handler.using(min_rounds=str(small))\n  self.assertEqual(temp.min_desired_rounds,small)\n  \n  \n  self.assertRaises(ValueError,handler.using,min_rounds=str(small)+\"xxx\")\n  \n def test_has_rounds_replace_w_max_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  \n  \n  if orig_min_rounds >0:\n   self.assertRaises(ValueError,handler.using,max_desired_rounds=orig_min_rounds -adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(max_desired_rounds=orig_min_rounds -adj,relaxed=True )\n   self.assertEqual(temp.max_desired_rounds,orig_min_rounds)\n   \n   \n  if orig_max_rounds:\n   self.assertRaises(ValueError,handler.using,max_desired_rounds=orig_max_rounds+adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(max_desired_rounds=orig_max_rounds+adj,relaxed=True )\n   self.assertEqual(temp.max_desired_rounds,orig_max_rounds)\n   \n   \n  with self.assertWarningList([PasslibConfigWarning]):\n   temp=subcls.using(max_desired_rounds=small -adj)\n  self.assertEqual(temp.max_desired_rounds,small)\n  \n  \n  self.assertRaises(ValueError,subcls.using,\n  min_desired_rounds=medium+adj,\n  max_desired_rounds=medium -adj)\n  \n  \n  temp=subcls.using(min_desired_rounds=large -2 *adj)\n  self.assertEqual(temp.min_desired_rounds,large -2 *adj)\n  \n  \n  with self.assertWarningList([]):\n   temp=subcls.using(max_desired_rounds=large+adj)\n  self.assertEqual(temp.max_desired_rounds,large+adj)\n  \n  \n  \n  self.assertEqual(get_effective_rounds(subcls,large -adj),large -adj)\n  self.assertEqual(get_effective_rounds(subcls,large),large)\n  with self.assertWarningList([]):\n   self.assertEqual(get_effective_rounds(subcls,large+adj),large+adj)\n   \n   \n  temp=handler.using(max_rounds=large)\n  self.assertEqual(temp.max_desired_rounds,large)\n  \n  \n  temp=handler.using(max_desired_rounds=str(large))\n  self.assertEqual(temp.max_desired_rounds,large)\n  \n  \n  self.assertRaises(ValueError,handler.using,max_desired_rounds=str(large)+\"xxx\")\n  \n def test_has_rounds_using_w_default_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_max_rounds=handler.max_rounds\n  \n  \n  \n  \n  temp=subcls.using(min_rounds=medium+adj)\n  self.assertEqual(temp.default_rounds,medium+adj)\n  \n  \n  temp=subcls.using(max_rounds=medium -adj)\n  self.assertEqual(temp.default_rounds,medium -adj)\n  \n  \n  \n  self.assertRaises(ValueError,subcls.using,default_rounds=small -adj)\n  \n  \n  \n  if orig_max_rounds:\n   self.assertRaises(ValueError,subcls.using,default_rounds=large+adj)\n   \n   \n  self.assertEqual(get_effective_rounds(subcls),medium)\n  self.assertEqual(get_effective_rounds(subcls,medium+adj),medium+adj)\n  \n  \n  temp=handler.using(default_rounds=str(medium))\n  self.assertEqual(temp.default_rounds,medium)\n  \n  \n  self.assertRaises(ValueError,handler.using,default_rounds=str(medium)+\"xxx\")\n  \n def test_has_rounds_using_w_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_max_rounds=handler.max_rounds\n  \n  \n  temp=subcls.using(rounds=medium+adj)\n  self.assertEqual(temp.min_desired_rounds,medium+adj)\n  self.assertEqual(temp.default_rounds,medium+adj)\n  self.assertEqual(temp.max_desired_rounds,medium+adj)\n  \n  \n  temp=subcls.using(rounds=medium+1,min_rounds=small+adj,\n  default_rounds=medium,max_rounds=large -adj)\n  self.assertEqual(temp.min_desired_rounds,small+adj)\n  self.assertEqual(temp.default_rounds,medium)\n  self.assertEqual(temp.max_desired_rounds,large -adj)\n  \n def test_has_rounds_using_w_vary_rounds_parsing(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  def parse(value):\n   return subcls.using(vary_rounds=value).vary_rounds\n   \n   \n  self.assertEqual(parse(0.1),0.1)\n  self.assertEqual(parse('0.1'),0.1)\n  \n  \n  self.assertEqual(parse('10%'),0.1)\n  \n  \n  self.assertEqual(parse(1000),1000)\n  self.assertEqual(parse('1000'),1000)\n  \n  \n  self.assertRaises(ValueError,parse,-0.1)\n  self.assertRaises(ValueError,parse,1.1)\n  \n def test_has_rounds_using_w_vary_rounds_generation(self):\n  ''\n\n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  def get_effective_range(cls):\n   seen=set(get_effective_rounds(cls)for _ in irange(1000))\n   return min(seen),max(seen)\n   \n  def assert_rounds_range(vary_rounds,lower,upper):\n   temp=subcls.using(vary_rounds=vary_rounds)\n   seen_lower,seen_upper=get_effective_range(temp)\n   self.assertEqual(seen_lower,lower,\"vary_rounds had wrong lower limit:\")\n   self.assertEqual(seen_upper,upper,\"vary_rounds had wrong upper limit:\")\n   \n   \n  assert_rounds_range(0,medium,medium)\n  assert_rounds_range(\"0%\",medium,medium)\n  \n  \n  assert_rounds_range(adj,medium -adj,medium+adj)\n  assert_rounds_range(50,max(small,medium -50),min(large,medium+50))\n  \n  \n  if handler.rounds_cost ==\"log2\":\n  \n   assert_rounds_range(\"1%\",medium,medium)\n   assert_rounds_range(\"49%\",medium,medium)\n   assert_rounds_range(\"50%\",medium -adj,medium)\n  else :\n  \n  \n   lower,upper=get_effective_range(subcls.using(vary_rounds=\"50%\"))\n   \n   self.assertGreaterEqual(lower,max(small,medium *0.5))\n   self.assertLessEqual(lower,max(small,medium *0.8))\n   \n   self.assertGreaterEqual(upper,min(large,medium *1.2))\n   self.assertLessEqual(upper,min(large,medium *1.5))\n   \n def test_has_rounds_using_and_needs_update(self):\n  ''\n\n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  temp=subcls.using(min_desired_rounds=small+2,max_desired_rounds=large -2)\n  \n  \n  small_hash=self.do_stub_encrypt(subcls,rounds=small)\n  medium_hash=self.do_stub_encrypt(subcls,rounds=medium)\n  large_hash=self.do_stub_encrypt(subcls,rounds=large)\n  \n  \n  self.assertFalse(subcls.needs_update(small_hash))\n  self.assertFalse(subcls.needs_update(medium_hash))\n  self.assertFalse(subcls.needs_update(large_hash))\n  \n  \n  self.assertTrue(temp.needs_update(small_hash))\n  self.assertFalse(temp.needs_update(medium_hash))\n  self.assertTrue(temp.needs_update(large_hash))\n  \n  \n  \n  \n def require_many_idents(self):\n  handler=self.handler\n  if not isinstance(handler,type)or not issubclass(handler,uh.HasManyIdents):\n   raise self.skipTest(\"handler doesn't derive from HasManyIdents\")\n   \n def test_30_HasManyIdents(self):\n  ''\n  cls=self.handler\n  self.require_many_idents()\n  \n  \n  self.assertTrue('ident'in cls.setting_kwds)\n  \n  \n  for value in cls.ident_values:\n   self.assertIsInstance(value,unicode,\n   \"cls.ident_values must be unicode:\")\n  self.assertTrue(len(cls.ident_values)>1,\n  \"cls.ident_values must have 2+ elements:\")\n  \n  \n  self.assertIsInstance(cls.default_ident,unicode,\n  \"cls.default_ident must be unicode:\")\n  self.assertTrue(cls.default_ident in cls.ident_values,\n  \"cls.default_ident must specify member of cls.ident_values\")\n  \n  \n  if cls.ident_aliases:\n   for alias,ident in iteritems(cls.ident_aliases):\n    self.assertIsInstance(alias,unicode,\n    \"cls.ident_aliases keys must be unicode:\")\n    self.assertIsInstance(ident,unicode,\n    \"cls.ident_aliases values must be unicode:\")\n    self.assertTrue(ident in cls.ident_values,\n    \"cls.ident_aliases must map to cls.ident_values members: %r\"%(ident,))\n    \n    \n  handler=cls\n  hash=self.get_sample_hash()[1]\n  kwds=handler.parsehash(hash)\n  del kwds['ident']\n  \n  \n  handler(ident=cls.default_ident,**kwds)\n  \n  \n  self.assertRaises(TypeError,handler,**kwds)\n  \n  \n  handler(use_defaults=True ,**kwds)\n  \n  \n  self.assertRaises(ValueError,handler,ident='xXx',**kwds)\n  \n  \n  \n def test_has_many_idents_using(self):\n  ''\n  self.require_many_idents()\n  \n  \n  handler=self.handler\n  orig_ident=handler.default_ident\n  for alt_ident in handler.ident_values:\n   if alt_ident !=orig_ident:\n    break\n  else :\n   raise AssertionError(\"expected to find alternate ident: default=%r values=%r\"%\n   (orig_ident,handler.ident_values))\n   \n  def effective_ident(cls):\n   cls=unwrap_handler(cls)\n   return cls(use_defaults=True ).ident\n   \n   \n  subcls=handler.using()\n  self.assertEqual(subcls.default_ident,orig_ident)\n  \n  \n  subcls=handler.using(default_ident=alt_ident)\n  self.assertEqual(subcls.default_ident,alt_ident)\n  self.assertEqual(handler.default_ident,orig_ident)\n  \n  \n  \n  self.assertEqual(effective_ident(subcls),alt_ident)\n  self.assertEqual(effective_ident(handler),orig_ident)\n  \n  \n  self.assertRaises(ValueError,handler.using,default_ident='xXx')\n  \n  \n  subcls=handler.using(ident=alt_ident)\n  self.assertEqual(subcls.default_ident,alt_ident)\n  self.assertEqual(handler.default_ident,orig_ident)\n  \n  \n  self.assertRaises(TypeError,handler.using,default_ident=alt_ident,ident=alt_ident)\n  \n  \n  if handler.ident_aliases:\n   for alias,ident in handler.ident_aliases.items():\n    subcls=handler.using(ident=alias)\n    self.assertEqual(subcls.default_ident,ident,msg=\"alias %r:\"%alias)\n    \n    \n    \n    \n def test_truncate_error_setting(self):\n  ''\n\n  \n  \n  \n  hasher=self.handler\n  if hasher.truncate_size is None :\n   self.assertNotIn(\"truncate_error\",hasher.setting_kwds)\n   return\n   \n   \n   \n   \n  if not hasher.truncate_error:\n   self.assertFalse(hasher.truncate_verify_reject)\n   \n   \n   \n  if \"truncate_error\"not in hasher.setting_kwds:\n   self.assertTrue(hasher.truncate_error)\n   return\n   \n   \n  def parse_value(value):\n   return hasher.using(truncate_error=value).truncate_error\n  self.assertEqual(parse_value(None ),hasher.truncate_error)\n  self.assertEqual(parse_value(True ),True )\n  self.assertEqual(parse_value(\"true\"),True )\n  self.assertEqual(parse_value(False ),False )\n  self.assertEqual(parse_value(\"false\"),False )\n  self.assertRaises(ValueError,parse_value,\"xxx\")\n  \n def test_secret_wo_truncate_size(self):\n  ''\n\n  \n  \n  hasher=self.handler\n  if hasher.truncate_size is not None :\n   self.assertGreaterEqual(hasher.truncate_size,1)\n   raise self.skipTest(\"truncate_size is set\")\n   \n   \n   \n   \n   \n   \n   \n   \n  secret=\"too many secrets\"*16\n  alt=\"x\"\n  hash=self.do_encrypt(secret)\n  \n  \n  \n  verify_success=not hasher.is_disabled\n  self.assertEqual(self.do_verify(secret,hash),verify_success,\n  msg=\"verify rejected correct secret\")\n  \n  \n  alt_secret=secret[:-1]+alt\n  self.assertFalse(self.do_verify(alt_secret,hash),\n  \"full password not used in digest\")\n  \n def test_secret_w_truncate_size(self):\n  ''\n\n  \n  \n  \n  \n  handler=self.handler\n  truncate_size=handler.truncate_size\n  if not truncate_size:\n   raise self.skipTest(\"truncate_size not set\")\n   \n   \n   \n   \n   \n   \n  size_error_type=exc.PasswordSizeError\n  if \"truncate_error\"in handler.setting_kwds:\n   without_error=handler.using(truncate_error=False )\n   with_error=handler.using(truncate_error=True )\n   size_error_type=exc.PasswordTruncateError\n  elif handler.truncate_error:\n   without_error=None\n   with_error=handler\n  else :\n  \n   without_error=handler\n   with_error=None\n   \n   \n  base=\"too many secrets\"\n  alt=\"x\"\n  long_secret=repeat_string(base,truncate_size+1)\n  short_secret=long_secret[:-1]\n  alt_long_secret=long_secret[:-1]+alt\n  alt_short_secret=short_secret[:-1]+alt\n  \n  \n  short_verify_success=not handler.is_disabled\n  long_verify_success=short_verify_success and\\\n  not handler.truncate_verify_reject\n  \n  \n  \n  \n  \n  assert without_error or with_error\n  for cand_hasher in [without_error,with_error]:\n  \n  \n   short_hash=self.do_encrypt(short_secret,handler=cand_hasher)\n   \n   \n   self.assertEqual(self.do_verify(short_secret,short_hash,\n   handler=cand_hasher),\n   short_verify_success)\n   \n   \n   \n   self.assertFalse(self.do_verify(alt_short_secret,short_hash,\n   handler=with_error),\n   \"truncate_size value is too large\")\n   \n   \n   \n   self.assertEqual(self.do_verify(long_secret,short_hash,\n   handler=cand_hasher),\n   long_verify_success)\n   \n   \n   \n   \n   \n  if without_error:\n  \n  \n   long_hash=self.do_encrypt(long_secret,handler=without_error)\n   \n   \n   self.assertEqual(self.do_verify(long_secret,long_hash,\n   handler=without_error),\n   short_verify_success)\n   \n   \n   \n   self.assertEqual(self.do_verify(alt_long_secret,long_hash,\n   handler=without_error),\n   short_verify_success)\n   \n   \n   \n   self.assertTrue(self.do_verify(short_secret,long_hash,\n   handler=without_error))\n   \n   \n   \n   \n   \n  if with_error:\n  \n  \n   err=self.assertRaises(size_error_type,self.do_encrypt,\n   long_secret,handler=with_error)\n   self.assertEqual(err.max_size,truncate_size)\n   \n   \n   \n   \n def test_61_secret_case_sensitive(self):\n  ''\n  hash_insensitive=self.secret_case_insensitive is True\n  verify_insensitive=self.secret_case_insensitive in [True ,\n  \"verify-only\"]\n  \n  \n  lower='test'\n  upper='TEST'\n  h1=self.do_encrypt(lower)\n  if verify_insensitive and not self.handler.is_disabled:\n   self.assertTrue(self.do_verify(upper,h1),\n   \"verify() should not be case sensitive\")\n  else :\n   self.assertFalse(self.do_verify(upper,h1),\n   \"verify() should be case sensitive\")\n   \n   \n  h2=self.do_encrypt(upper)\n  if verify_insensitive and not self.handler.is_disabled:\n   self.assertTrue(self.do_verify(lower,h2),\n   \"verify() should not be case sensitive\")\n  else :\n   self.assertFalse(self.do_verify(lower,h2),\n   \"verify() should be case sensitive\")\n   \n   \n   \n   \n   \n  h2=self.do_genhash(upper,h1)\n  if hash_insensitive or (self.handler.is_disabled and not self.disabled_contains_salt):\n   self.assertEqual(h2,h1,\n   \"genhash() should not be case sensitive\")\n  else :\n   self.assertNotEqual(h2,h1,\n   \"genhash() should be case sensitive\")\n   \n def test_62_secret_border(self):\n  ''\n  hash=self.get_sample_hash()[1]\n  \n  \n  self.assertRaises(TypeError,self.do_encrypt,None )\n  self.assertRaises(TypeError,self.do_genhash,None ,hash)\n  self.assertRaises(TypeError,self.do_verify,None ,hash)\n  \n  \n  self.assertRaises(TypeError,self.do_encrypt,1)\n  self.assertRaises(TypeError,self.do_genhash,1,hash)\n  self.assertRaises(TypeError,self.do_verify,1,hash)\n  \n  \n def test_63_large_secret(self):\n  ''\n  from passlib.exc import PasswordSizeError\n  from passlib.utils import MAX_PASSWORD_SIZE\n  secret='.'*(1+MAX_PASSWORD_SIZE)\n  hash=self.get_sample_hash()[1]\n  err=self.assertRaises(PasswordSizeError,self.do_genhash,secret,hash)\n  self.assertEqual(err.max_size,MAX_PASSWORD_SIZE)\n  self.assertRaises(PasswordSizeError,self.do_encrypt,secret)\n  self.assertRaises(PasswordSizeError,self.do_verify,secret,hash)\n  \n def test_64_forbidden_chars(self):\n  ''\n  chars=self.forbidden_characters\n  if not chars:\n   raise self.skipTest(\"none listed\")\n  base=u('stub')\n  if isinstance(chars,bytes):\n   from passlib.utils.compat import iter_byte_chars\n   chars=iter_byte_chars(chars)\n   base=base.encode(\"ascii\")\n  for c in chars:\n   self.assertRaises(ValueError,self.do_encrypt,base+c+base)\n   \n   \n   \n   \n def is_secret_8bit(self,secret):\n  secret=self.populate_context(secret,{})\n  return not is_ascii_safe(secret)\n  \n def expect_os_crypt_failure(self,secret):\n  ''\n\n  \n  if PY3 and self.backend ==\"os_crypt\"and isinstance(secret,bytes):\n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n    return True\n  return False\n  \n def test_70_hashes(self):\n  ''\n  \n  \n  self.assertTrue(self.known_correct_hashes or self.known_correct_configs,\n  \"test must set at least one of 'known_correct_hashes' \"\n  \"or 'known_correct_configs'\")\n  \n  \n  saw8bit=False\n  for secret,hash in self.iter_known_hashes():\n   if self.is_secret_8bit(secret):\n    saw8bit=True\n    \n    \n   self.assertTrue(self.do_identify(hash),\n   \"identify() failed to identify hash: %r\"%(hash,))\n   \n   \n   expect_os_crypt_failure=self.expect_os_crypt_failure(secret)\n   try :\n   \n   \n    self.check_verify(secret,hash,\"verify() of known hash failed: \"\n    \"secret=%r, hash=%r\"%(secret,hash))\n    \n    \n    result=self.do_genhash(secret,hash)\n    self.assertIsInstance(result,str,\n    \"genhash() failed to return native string: %r\"%(result,))\n    if self.handler.is_disabled and self.disabled_contains_salt:\n     continue\n    self.assertEqual(result,hash,\"genhash() failed to reproduce \"\n    \"known hash: secret=%r, hash=%r: result=%r\"%\n    (secret,hash,result))\n    \n   except MissingBackendError:\n    if not expect_os_crypt_failure:\n     raise\n     \n     \n  if not saw8bit:\n   warn(\"%s: no 8-bit secrets tested\"%self.__class__)\n   \n def test_71_alternates(self):\n  ''\n  if not self.known_alternate_hashes:\n   raise self.skipTest(\"no alternate hashes provided\")\n  for alt,secret,hash in self.known_alternate_hashes:\n  \n  \n   self.assertTrue(self.do_identify(hash),\n   \"identify() failed to identify alternate hash: %r\"%\n   (hash,))\n   \n   \n   self.check_verify(secret,alt,\"verify() of known alternate hash \"\n   \"failed: secret=%r, hash=%r\"%(secret,alt))\n   \n   \n   result=self.do_genhash(secret,alt)\n   self.assertIsInstance(result,str,\n   \"genhash() failed to return native string: %r\"%(result,))\n   if self.handler.is_disabled and self.disabled_contains_salt:\n    continue\n   self.assertEqual(result,hash,\"genhash() failed to normalize \"\n   \"known alternate hash: secret=%r, alt=%r, hash=%r: \"\n   \"result=%r\"%(secret,alt,hash,result))\n   \n def test_72_configs(self):\n  ''\n  \n  if not self.handler.setting_kwds:\n   self.assertFalse(self.known_correct_configs,\n   \"handler should not have config strings\")\n   raise self.skipTest(\"hash has no settings\")\n   \n  if not self.known_correct_configs:\n  \n   raise self.skipTest(\"no config strings provided\")\n   \n   \n  if self.filter_config_warnings:\n   warnings.filterwarnings(\"ignore\",category=PasslibHashWarning)\n  for config,secret,hash in self.known_correct_configs:\n  \n  \n   self.assertTrue(self.do_identify(config),\n   \"identify() failed to identify known config string: %r\"%\n   (config,))\n   \n   \n   self.assertRaises(ValueError,self.do_verify,secret,config,\n   __msg__=\"verify() failed to reject config string: %r\"%\n   (config,))\n   \n   \n   result=self.do_genhash(secret,config)\n   self.assertIsInstance(result,str,\n   \"genhash() failed to return native string: %r\"%(result,))\n   self.assertEqual(result,hash,\"genhash() failed to reproduce \"\n   \"known hash from config: secret=%r, config=%r, hash=%r: \"\n   \"result=%r\"%(secret,config,hash,result))\n   \n def test_73_unidentified(self):\n  ''\n  if not self.known_unidentified_hashes:\n   raise self.skipTest(\"no unidentified hashes provided\")\n  for hash in self.known_unidentified_hashes:\n  \n  \n   self.assertFalse(self.do_identify(hash),\n   \"identify() incorrectly identified known unidentifiable \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_verify,'stub',hash,\n   __msg__=\"verify() failed to throw error for unidentifiable \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n   __msg__=\"genhash() failed to throw error for unidentifiable \"\n   \"hash: %r\"%(hash,))\n   \n def test_74_malformed(self):\n  ''\n  if not self.known_malformed_hashes:\n   raise self.skipTest(\"no malformed hashes provided\")\n  for hash in self.known_malformed_hashes:\n  \n  \n   self.assertTrue(self.do_identify(hash),\n   \"identify() failed to identify known malformed \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_verify,'stub',hash,\n   __msg__=\"verify() failed to throw error for malformed \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n   __msg__=\"genhash() failed to throw error for malformed \"\n   \"hash: %r\"%(hash,))\n   \n def test_75_foreign(self):\n  ''\n  if self.accepts_all_hashes:\n   raise self.skipTest(\"not applicable\")\n  if not self.known_other_hashes:\n   raise self.skipTest(\"no foreign hashes provided\")\n  for name,hash in self.known_other_hashes:\n  \n  \n  \n  \n   if name ==self.handler.name:\n   \n    self.assertTrue(self.do_identify(hash),\n    \"identify() failed to identify known hash: %r\"%(hash,))\n    \n    \n    self.do_verify('stub',hash)\n    result=self.do_genhash('stub',hash)\n    self.assertIsInstance(result,str,\n    \"genhash() failed to return native string: %r\"%(result,))\n    \n   else :\n   \n    self.assertFalse(self.do_identify(hash),\n    \"identify() incorrectly identified hash belonging to \"\n    \"%s: %r\"%(name,hash))\n    \n    \n    self.assertRaises(ValueError,self.do_verify,'stub',hash,\n    __msg__=\"verify() failed to throw error for hash \"\n    \"belonging to %s: %r\"%(name,hash,))\n    \n    \n    self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n    __msg__=\"genhash() failed to throw error for hash \"\n    \"belonging to %s: %r\"%(name,hash))\n    \n def test_76_hash_border(self):\n  ''\n  \n  \n  \n  self.assertRaises(TypeError,self.do_identify,None )\n  self.assertRaises(TypeError,self.do_verify,'stub',None )\n  \n  \n  self.assertRaises(TypeError,self.do_genhash,'stub',None )\n  \n  \n  \n  \n  self.assertRaises(TypeError,self.do_identify,1)\n  self.assertRaises(TypeError,self.do_verify,'stub',1)\n  self.assertRaises(TypeError,self.do_genhash,'stub',1)\n  \n  \n  \n  \n  for hash in [u(''),b'']:\n   if self.accepts_all_hashes:\n   \n    self.assertTrue(self.do_identify(hash))\n    self.do_verify('stub',hash)\n    result=self.do_genhash('stub',hash)\n    self.check_returned_native_str(result,\"genhash\")\n   else :\n   \n    self.assertFalse(self.do_identify(hash),\n    \"identify() incorrectly identified empty hash\")\n    self.assertRaises(ValueError,self.do_verify,'stub',hash,\n    __msg__=\"verify() failed to reject empty hash\")\n    self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n    __msg__=\"genhash() failed to reject empty hash\")\n    \n    \n    \n    \n  self.do_identify('\\xe2\\x82\\xac\\xc2\\xa5$')\n  self.do_identify('abc\\x91\\x00')\n  \n  \n  \n  \n  \n  \n known_parsehash_results=[]\n \n def require_parsehash(self):\n  if not hasattr(self.handler,\"parsehash\"):\n   raise SkipTest(\"parsehash() not implemented\")\n   \n def test_70_parsehash(self):\n  ''\n\n  \n  \n  \n  self.require_parsehash()\n  handler=self.handler\n  \n  \n  hash=self.do_encrypt(\"stub\")\n  result=handler.parsehash(hash)\n  self.assertIsInstance(result,dict)\n  \n  \n  \n  \n  result2=handler.parsehash(hash,checksum=False )\n  correct2=result.copy()\n  correct2.pop(\"checksum\",None )\n  self.assertEqual(result2,correct2)\n  \n  \n  \n  \n  result3=handler.parsehash(hash,sanitize=True )\n  correct3=result.copy()\n  if PY2:\n  \n  \n   warnings.filterwarnings(\"ignore\",\".*unequal comparison failed to convert.*\",\n   category=UnicodeWarning)\n  for key in (\"salt\",\"checksum\"):\n   if key in result3:\n    self.assertNotEqual(result3[key],correct3[key])\n    self.assert_is_masked(result3[key])\n    correct3[key]=result3[key]\n  self.assertEqual(result3,correct3)\n  \n def assert_is_masked(self,value):\n  ''\n\n  \n  if value is None :\n   return\n  self.assertIsInstance(value,unicode)\n  \n  \n  ref=value if len(value)<8 else value[4:]\n  if set(ref)==set([\"*\"]):\n   return True\n  raise self.fail(\"value not masked: %r\"%value)\n  \n def test_71_parsehash_results(self):\n  ''\n\n  \n  self.require_parsehash()\n  samples=self.known_parsehash_results\n  if not samples:\n   raise self.skipTest(\"no samples present\")\n   \n   \n  for hash,correct in self.known_parsehash_results:\n   result=self.handler.parsehash(hash)\n   self.assertEqual(result,correct,\"hash=%r:\"%hash)\n   \n   \n   \n   \n def test_77_fuzz_input(self,threaded=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.handler.is_disabled:\n   raise self.skipTest(\"not applicable\")\n   \n   \n  from passlib.utils import tick\n  max_time=self.max_fuzz_time\n  if max_time <=0:\n   raise self.skipTest(\"disabled by test mode\")\n  verifiers=self.get_fuzz_verifiers(threaded=threaded)\n  def vname(v):\n   return (v.__doc__ or v.__name__).splitlines()[0]\n   \n   \n   \n   \n  if threaded:\n   thread_name=threading.current_thread().name\n  else :\n   thread_name=\"fuzz test\"\n  rng=self.getRandom(name=thread_name)\n  generator=self.FuzzHashGenerator(self,rng)\n  \n  \n  log.debug(\"%s: %s: started; max_time=%r verifiers=%d (%s)\",\n  self.descriptionPrefix,thread_name,max_time,len(verifiers),\n  \", \".join(vname(v)for v in verifiers))\n  start=tick()\n  stop=start+max_time\n  count=0\n  while tick()<=stop:\n  \n   opts=generator.generate()\n   secret=opts['secret']\n   other=opts['other']\n   settings=opts['settings']\n   ctx=opts['context']\n   if ctx:\n    settings['context']=ctx\n    \n    \n   hash=self.do_encrypt(secret,**settings)\n   \n   \n   \n   \n   for verify in verifiers:\n    name=vname(verify)\n    result=verify(secret,hash,**ctx)\n    if result ==\"skip\":\n     continue\n    assert result is True or result is False\n    if not result:\n     raise self.failureException(\"failed to verify against %r verifier: \"\n     \"secret=%r config=%r hash=%r\"%\n     (name,secret,settings,hash))\n     \n     \n    if rng.random()<.1:\n     result=verify(other,hash,**ctx)\n     if result and result !=\"skip\":\n      raise self.failureException(\"was able to verify wrong \"\n      \"password using %s: wrong_secret=%r real_secret=%r \"\n      \"config=%r hash=%r\"%(name,other,secret,settings,hash))\n   count +=1\n   \n  log.debug(\"%s: %s: done; elapsed=%r count=%r\",\n  self.descriptionPrefix,thread_name,tick()-start,count)\n  \n def test_78_fuzz_threading(self):\n  ''\n\n\n\n\n  \n  self.require_TEST_MODE(\"full\")\n  import threading\n  \n  \n  if self.handler.is_disabled:\n   raise self.skipTest(\"not applicable\")\n  thread_count=self.fuzz_thread_count\n  if thread_count <1 or self.max_fuzz_time <=0:\n   raise self.skipTest(\"disabled by test mode\")\n   \n   \n  failed_lock=threading.Lock()\n  failed=[0]\n  \n  \n  \n  \n  def wrapper():\n   try :\n    self.test_77_fuzz_input(threaded=True )\n   except SkipTest:\n    pass\n   except :\n    with failed_lock:\n     failed[0]+=1\n    raise\n  def launch(n):\n   cls=type(self)\n   name=\"Fuzz-Thread-%d ('%s:%s.%s')\"%(n,cls.__module__,cls.__name__,\n   self._testMethodName)\n   thread=threading.Thread(target=wrapper,name=name)\n   thread.setDaemon(True )\n   thread.start()\n   return thread\n  threads=[launch(n)for n in irange(thread_count)]\n  \n  \n  timeout=self.max_fuzz_time *thread_count *4\n  stalled=0\n  for thread in threads:\n   thread.join(timeout)\n   if not thread.is_alive():\n    continue\n    \n   log.error(\"%s timed out after %f seconds\",thread.name,timeout)\n   stalled +=1\n   \n   \n  if failed[0]:\n   raise self.fail(\"%d/%d threads failed concurrent fuzz testing \"\n   \"(see error log for details)\"%(failed[0],thread_count))\n  if stalled:\n   raise self.fail(\"%d/%d threads stalled during concurrent fuzz testing \"\n   \"(see error log for details)\"%(stalled,thread_count))\n   \n   \n   \n   \n   \n @property\n def max_fuzz_time(self):\n  ''\n  value=float(os.environ.get(\"PASSLIB_TEST_FUZZ_TIME\")or 0)\n  if value:\n   return value\n  elif TEST_MODE(max=\"quick\"):\n   return 0\n  elif TEST_MODE(max=\"default\"):\n   return 1\n  else :\n   return 5\n   \n @property\n def fuzz_thread_count(self):\n  ''\n  value=int(os.environ.get(\"PASSLIB_TEST_FUZZ_THREADS\")or 0)\n  if value:\n   return value\n  elif TEST_MODE(max=\"quick\"):\n   return 0\n  else :\n   return 10\n   \n   \n   \n   \n   \n   \n   \n   \n fuzz_verifiers=(\"fuzz_verifier_default\",)\n \n def get_fuzz_verifiers(self,threaded=False ):\n  ''\n\n\n\n\n  \n  handler=self.handler\n  verifiers=[]\n  \n  \n  for method_name in self.fuzz_verifiers:\n   func=getattr(self,method_name)()\n   if func is not None :\n    verifiers.append(func)\n    \n    \n    \n    \n  if hasattr(handler,\"backends\")and TEST_MODE(\"full\")and not threaded:\n   def maker(backend):\n    def func(secret,hash):\n     orig_backend=handler.get_backend()\n     try :\n      handler.set_backend(backend)\n      return handler.verify(secret,hash)\n     finally :\n      handler.set_backend(orig_backend)\n    func.__name__=\"check_\"+backend+\"_backend\"\n    func.__doc__=backend+\"-backend\"\n    return func\n   for backend in iter_alt_backends(handler):\n    verifiers.append(maker(backend))\n    \n  return verifiers\n  \n def fuzz_verifier_default(self):\n \n  def check_default(secret,hash,**ctx):\n   return self.do_verify(secret,hash,**ctx)\n  if self.backend:\n   check_default.__doc__=self.backend+\"-backend\"\n  else :\n   check_default.__doc__=\"self\"\n  return check_default\n  \n  \n  \n  \n class FuzzHashGenerator(object):\n  ''\n\n\n\n  \n  \n  \n  \n  \n  \n  password_alphabet=u('qwertyASDF1234<>.@*#! \\u00E1\\u0259\\u0411\\u2113')\n  \n  \n  password_encoding=\"utf-8\"\n  \n  \n  \n  \n  settings_map=dict(rounds=\"random_rounds\",\n  salt_size=\"random_salt_size\",\n  ident=\"random_ident\")\n  \n  \n  context_map={}\n  \n  \n  \n  \n  \n  def __init__(self,test,rng):\n   self.test=test\n   self.handler=test.handler\n   self.rng=rng\n   \n  def generate(self):\n   ''\n\n\n\n   \n   def gendict(map):\n    out={}\n    for key,meth in map.items():\n     value=getattr(self,meth)()\n     if value is not None :\n      out[key]=value\n    return out\n   secret,other=self.random_password_pair()\n   return dict(secret=secret,\n   other=other,\n   settings=gendict(self.settings_map),\n   context=gendict(self.context_map),\n   )\n   \n   \n   \n   \n  def randintgauss(self,lower,upper,mu,sigma):\n   ''\n   value=self.rng.normalvariate(mu,sigma)\n   return int(limit(value,lower,upper))\n   \n   \n   \n   \n   \n  def random_rounds(self):\n   handler=self.handler\n   if not has_rounds_info(handler):\n    return None\n   default=handler.default_rounds or handler.min_rounds\n   lower=handler.min_rounds\n   if handler.rounds_cost ==\"log2\":\n    upper=default\n   else :\n    upper=min(default *2,handler.max_rounds)\n   return self.randintgauss(lower,upper,default,default *.5)\n   \n  def random_salt_size(self):\n   handler=self.handler\n   if not (has_salt_info(handler)and 'salt_size'in handler.setting_kwds):\n    return None\n   default=handler.default_salt_size\n   lower=handler.min_salt_size\n   upper=handler.max_salt_size or default *4\n   return self.randintgauss(lower,upper,default,default *.5)\n   \n  def random_ident(self):\n   rng=self.rng\n   handler=self.handler\n   if 'ident'not in handler.setting_kwds or not hasattr(handler,\"ident_values\"):\n    return None\n   if rng.random()<.5:\n    return None\n    \n   handler=getattr(handler,\"wrapped\",handler)\n   return rng.choice(handler.ident_values)\n   \n   \n   \n   \n  def random_password_pair(self):\n   ''\n   secret=self.random_password()\n   while True :\n    other=self.random_password()\n    if self.accept_password_pair(secret,other):\n     break\n   rng=self.rng\n   if rng.randint(0,1):\n    secret=secret.encode(self.password_encoding)\n   if rng.randint(0,1):\n    other=other.encode(self.password_encoding)\n   return secret,other\n   \n  def random_password(self):\n   ''\n   \n   rng=self.rng\n   if rng.random()<.0001:\n    return u('')\n    \n    \n   handler=self.handler\n   truncate_size=handler.truncate_error and handler.truncate_size\n   max_size=truncate_size or 999999\n   \n   \n   if max_size <50 or rng.random()<.5:\n   \n    size=self.randintgauss(1,min(max_size,50),15,15)\n   else :\n   \n    size=self.randintgauss(50,min(max_size,99),70,20)\n    \n    \n   result=getrandstr(rng,self.password_alphabet,size)\n   \n   \n   if truncate_size and isinstance(result,unicode):\n    while len(result.encode(\"utf-8\"))>truncate_size:\n     result=result[:-1]\n     \n   return result\n   \n  def accept_password_pair(self,secret,other):\n   ''\n   return secret !=other\n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_disable_and_enable(self):\n  ''\n  \n  \n  \n  handler=self.handler\n  if not handler.is_disabled:\n   self.assertFalse(hasattr(handler,\"disable\"))\n   self.assertFalse(hasattr(handler,\"enable\"))\n   self.assertFalse(self.disabled_contains_salt)\n   raise self.skipTest(\"not applicable\")\n   \n   \n   \n   \n   \n   \n  disabled_default=handler.disable()\n  self.assertIsInstance(disabled_default,str,\n  msg=\"disable() must return native string\")\n  self.assertTrue(handler.identify(disabled_default),\n  msg=\"identify() didn't recognize disable() result: %r\"%(disabled_default))\n  \n  \n  stub=self.getRandom().choice(self.known_other_hashes)[1]\n  disabled_stub=handler.disable(stub)\n  self.assertIsInstance(disabled_stub,str,\n  msg=\"disable() must return native string\")\n  self.assertTrue(handler.identify(disabled_stub),\n  msg=\"identify() didn't recognize disable() result: %r\"%(disabled_stub))\n  \n  \n  \n  \n  \n  \n  self.assertRaisesRegex(ValueError,\"cannot restore original hash\",\n  handler.enable,disabled_default)\n  \n  \n  try :\n   result=handler.enable(disabled_stub)\n   error=None\n  except ValueError as e:\n   result=None\n   error=e\n   \n  if error is None :\n  \n   self.assertIsInstance(result,str,\n   msg=\"enable() must return native string\")\n   self.assertEqual(result,stub)\n  else :\n  \n   self.assertIsInstance(error,ValueError)\n   self.assertRegex(\"cannot restore original hash\",str(error))\n   \n   \n   \n   \n   \n   \n  disabled_default2=handler.disable()\n  if self.disabled_contains_salt:\n  \n   self.assertNotEqual(disabled_default2,disabled_default)\n  elif error is None :\n  \n   self.assertEqual(disabled_default2,disabled_default)\n   \n   \n  disabled_stub2=handler.disable(stub)\n  if self.disabled_contains_salt:\n  \n   self.assertNotEqual(disabled_stub2,disabled_stub)\n  else :\n  \n   self.assertEqual(disabled_stub2,disabled_stub)\n   \n   \n  disabled_other=handler.disable(stub+'xxx')\n  if self.disabled_contains_salt or error is None :\n  \n   self.assertNotEqual(disabled_other,disabled_stub)\n  else :\n  \n   self.assertEqual(disabled_other,disabled_stub)\n   \n   \n   \n   \n   \n   \n   \n   \nclass OsCryptMixin(HandlerCase):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n platform_crypt_support=[]\n \n \n \n \n __unittest_skip=True\n \n \n backend=\"os_crypt\"\n \n \n using_patched_crypt=False\n \n \n \n \n def setUp(self):\n  assert self.backend ==\"os_crypt\"\n  if not self.handler.has_backend(\"os_crypt\"):\n  \n   self._patch_safe_crypt()\n  super(OsCryptMixin,self).setUp()\n  \n @classmethod\n def _get_safe_crypt_handler_backend(cls):\n  ''\n\n\n  \n  \n  handler=unwrap_handler(cls.handler)\n  \n  \n  handler.get_backend()\n  \n  \n  alt_backend=get_alt_backend(handler,\"os_crypt\")\n  return handler,alt_backend\n  \n @property\n def has_os_crypt_fallback(self):\n  ''\n\n\n  \n  return self._get_safe_crypt_handler_backend()[0]is not None\n  \n def _patch_safe_crypt(self):\n  ''\n\n\n\n  \n  \n  handler,alt_backend=self._get_safe_crypt_handler_backend()\n  if not alt_backend:\n   raise AssertionError(\"handler has no available alternate backends!\")\n   \n   \n  alt_handler=handler.using()\n  alt_handler.set_backend(alt_backend)\n  \n  def crypt_stub(secret,hash):\n   hash=alt_handler.genhash(secret,hash)\n   assert isinstance(hash,str)\n   return hash\n   \n  import passlib.utils as mod\n  self.patchAttr(mod,\"_crypt\",crypt_stub)\n  self.using_patched_crypt=True\n  \n @classmethod\n def _get_skip_backend_reason(cls,backend):\n  ''\n\n\n  \n  assert backend ==\"os_crypt\"\n  reason=super(OsCryptMixin,cls)._get_skip_backend_reason(backend)\n  \n  from passlib.utils import has_crypt\n  if reason ==cls._BACKEND_NOT_AVAILABLE and has_crypt:\n   if TEST_MODE(\"full\")and cls._get_safe_crypt_handler_backend()[1]:\n   \n   \n    return None\n   else :\n    return \"hash not supported by os crypt()\"\n    \n  return reason\n  \n  \n  \n  \n  \n  \n def _use_mock_crypt(self):\n  ''\n\n\n\n  \n  import passlib.utils as mod\n  \n  def mock_crypt(secret,config):\n  \n   if secret ==\"test\":\n    return mock_crypt.__wrapped__(secret,config)\n   else :\n    return mock_crypt.return_value\n    \n  mock_crypt.__wrapped__=mod._crypt\n  mock_crypt.return_value=None\n  \n  self.patchAttr(mod,\"_crypt\",mock_crypt)\n  \n  return mock_crypt\n  \n def test_80_faulty_crypt(self):\n  ''\n  hash=self.get_sample_hash()[1]\n  exc_types=(exc.InternalBackendError,)\n  mock_crypt=self._use_mock_crypt()\n  \n  def test(value):\n  \n  \n   mock_crypt.return_value=value\n   self.assertRaises(exc_types,self.do_genhash,\"stub\",hash)\n   self.assertRaises(exc_types,self.do_encrypt,\"stub\")\n   self.assertRaises(exc_types,self.do_verify,\"stub\",hash)\n   \n  test('$x'+hash[2:])\n  test(hash[:-1])\n  test(hash+'x')\n  \n def test_81_crypt_fallback(self):\n  ''\n  \n  \n  mock_crypt=self._use_mock_crypt()\n  mock_crypt.return_value=None\n  \n  if self.has_os_crypt_fallback:\n  \n   h1=self.do_encrypt(\"stub\")\n   h2=self.do_genhash(\"stub\",h1)\n   self.assertEqual(h2,h1)\n   self.assertTrue(self.do_verify(\"stub\",h1))\n  else :\n  \n   from passlib.exc import InternalBackendError as err_type\n   hash=self.get_sample_hash()[1]\n   self.assertRaises(err_type,self.do_encrypt,'stub')\n   self.assertRaises(err_type,self.do_genhash,'stub',hash)\n   self.assertRaises(err_type,self.do_verify,'stub',hash)\n   \n @doesnt_require_backend\n def test_82_crypt_support(self):\n  ''\n\n\n\n\n\n  \n  \n  \n  if hasattr(self.handler,\"orig_prefix\"):\n   raise self.skipTest(\"not applicable to wrappers\")\n   \n   \n   \n   \n   \n  using_backend=not self.using_patched_crypt\n  name=self.handler.name\n  platform=sys.platform\n  for pattern,expected in self.platform_crypt_support:\n   if re.match(pattern,platform):\n    break\n  else :\n   raise self.skipTest(\"no data for %r platform (current host support = %r)\"%\n   (platform,using_backend))\n   \n   \n   \n  if expected is None :\n   raise self.skipTest(\"varied support on %r platform (current host support = %r)\"%\n   (platform,using_backend))\n   \n   \n  if expected ==using_backend:\n   pass\n  elif expected:\n   self.fail(\"expected %r platform would have native support for %r\"%\n   (platform,name))\n  else :\n   self.fail(\"did not expect %r platform would have native support for %r\"%\n   (platform,name))\n   \n   \n   \n   \n   \n def fuzz_verifier_crypt(self):\n  ''\n  \n  \n  \n  handler=self.handler\n  if self.using_patched_crypt or hasattr(handler,\"wrapped\"):\n   return None\n   \n   \n  from crypt import crypt\n  from passlib.utils import _safe_crypt_lock\n  encoding=self.FuzzHashGenerator.password_encoding\n  \n  def check_crypt(secret,hash):\n   ''\n   if not self.crypt_supports_variant(hash):\n    return \"skip\"\n    \n   secret=to_native_str(secret,encoding)\n   with _safe_crypt_lock:\n    return crypt(secret,hash)==hash\n    \n  return check_crypt\n  \n def crypt_supports_variant(self,hash):\n  ''\n\n\n  \n  return True\n  \n  \n  \n  \n  \nclass UserHandlerMixin(HandlerCase):\n ''\n\n\n\n\n\n \n \n \n \n default_user=\"user\"\n requires_user=True\n user_case_insensitive=False\n \n \n \n \n __unittest_skip=True\n \n \n \n \n def test_80_user(self):\n  ''\n  handler=self.handler\n  password='stub'\n  hash=handler.hash(password,user=self.default_user)\n  \n  if self.requires_user:\n   self.assertRaises(TypeError,handler.hash,password)\n   self.assertRaises(TypeError,handler.genhash,password,hash)\n   self.assertRaises(TypeError,handler.verify,password,hash)\n  else :\n  \n   handler.hash(password)\n   handler.genhash(password,hash)\n   handler.verify(password,hash)\n   \n def test_81_user_case(self):\n  ''\n  lower=self.default_user.lower()\n  upper=lower.upper()\n  hash=self.do_encrypt('stub',context=dict(user=lower))\n  if self.user_case_insensitive:\n   self.assertTrue(self.do_verify('stub',hash,user=upper),\n   \"user should not be case sensitive\")\n  else :\n   self.assertFalse(self.do_verify('stub',hash,user=upper),\n   \"user should be case sensitive\")\n   \n def test_82_user_salt(self):\n  ''\n  config=self.do_stub_encrypt()\n  h1=self.do_genhash('stub',config,user='admin')\n  h2=self.do_genhash('stub',config,user='admin')\n  self.assertEqual(h2,h1)\n  h3=self.do_genhash('stub',config,user='root')\n  self.assertNotEqual(h3,h1)\n  \n  \n  \n  \n  \n  \n def populate_context(self,secret,kwds):\n  ''\n  if isinstance(secret,tuple):\n   secret,user=secret\n  elif not self.requires_user:\n   return secret\n  else :\n   user=self.default_user\n  if 'user'not in kwds:\n   kwds['user']=user\n  return secret\n  \n  \n  \n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  context_map=HandlerCase.FuzzHashGenerator.context_map.copy()\n  context_map.update(user=\"random_user\")\n  \n  user_alphabet=u(\"asdQWE123\")\n  \n  def random_user(self):\n   rng=self.rng\n   if not self.test.requires_user and rng.random()<.1:\n    return None\n   return getrandstr(rng,self.user_alphabet,rng.randint(2,10))\n   \n   \n   \n   \n   \nclass EncodingHandlerMixin(HandlerCase):\n ''\n\n\n\n\n\n \n \n \n \n __unittest_skip=True\n \n \n \n stock_passwords=[\n u(\"test\"),\n b\"test\",\n u(\"\\u00AC\\u00BA\"),\n ]\n \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  password_alphabet=u('qwerty1234<>.@*#! \\u00AC')\n  \n def populate_context(self,secret,kwds):\n  ''\n  if isinstance(secret,tuple):\n   secret,encoding=secret\n   kwds.setdefault('encoding',encoding)\n  return secret\n  \n  \n  \n  \n  \n  \n  \nclass reset_warnings(warnings.catch_warnings):\n ''\n \n def __init__(self,reset_filter=\"always\",reset_registry=\".*\",**kwds):\n  super(reset_warnings,self).__init__(**kwds)\n  self._reset_filter=reset_filter\n  self._reset_registry=re.compile(reset_registry)if reset_registry else None\n  \n def __enter__(self):\n \n  ret=super(reset_warnings,self).__enter__()\n  \n  \n  if self._reset_filter:\n   warnings.resetwarnings()\n   warnings.simplefilter(self._reset_filter)\n   \n   \n   \n  pattern=self._reset_registry\n  if pattern:\n   backup=self._orig_registry={}\n   for name,mod in list(sys.modules.items()):\n    if mod is None or not pattern.match(name):\n     continue\n    reg=getattr(mod,\"__warningregistry__\",None )\n    if reg:\n     backup[name]=reg.copy()\n     reg.clear()\n  return ret\n  \n def __exit__(self,*exc_info):\n \n  pattern=self._reset_registry\n  if pattern:\n  \n   backup=self._orig_registry\n   for name,mod in list(sys.modules.items()):\n    if mod is None or not pattern.match(name):\n     continue\n    reg=getattr(mod,\"__warningregistry__\",None )\n    if reg:\n     reg.clear()\n    orig=backup.get(name)\n    if orig:\n     if reg is None :\n      setattr(mod,\"__warningregistry__\",orig)\n     else :\n      reg.update(orig)\n  super(reset_warnings,self).__exit__(*exc_info)\n  \n  \n  \n  \n", ["__future__", "binascii", "contextlib", "crypt", "functools", "google.appengine", "hashlib", "logging", "math", "os", "passlib", "passlib.exc", "passlib.registry", "passlib.tests.backports", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers", "random", "re", "sys", "tempfile", "threading", "time", "timeit", "warnings"]], "passlib.tests.test_handlers_pbkdf2": [".py", "''\n\n\n\n\nimport logging\nlog=logging.getLogger(__name__)\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.utils.compat import u\nfrom passlib.tests.utils import TestCase,HandlerCase\nfrom passlib.tests.test_handlers import UPASS_WAV\n\n\n\n\n\n\n\n\nclass ldap_pbkdf2_test(TestCase):\n\n def test_wrappers(self):\n  ''\n  \n  self.assertTrue(\n  hash.ldap_pbkdf2_sha1.verify(\n  \"password\",\n  '{PBKDF2}1212$OB.dtnSEXZK8U5cgxU/GYQ$y5LKPOplRmok7CZp/aqVDVg8zGI',\n  )\n  )\n  \n  self.assertTrue(\n  hash.ldap_pbkdf2_sha256.verify(\n  \"password\",\n  '{PBKDF2-SHA256}1212$4vjV83LKPjQzk31VI4E0Vw$hsYF68OiOUPdDZ1Fg'\n  '.fJPeq1h/gXXY7acBp9/6c.tmQ'\n  )\n  )\n  \n  self.assertTrue(\n  hash.ldap_pbkdf2_sha512.verify(\n  \"password\",\n  '{PBKDF2-SHA512}1212$RHY0Fr3IDMSVO/RSZyb5ow$eNLfBK.eVozomMr.1gYa1'\n  '7k9B7KIK25NOEshvhrSX.esqY3s.FvWZViXz4KoLlQI.BzY/YTNJOiKc5gBYFYGww'\n  )\n  )\n  \n  \n  \n  \nclass atlassian_pbkdf2_sha1_test(HandlerCase):\n handler=hash.atlassian_pbkdf2_sha1\n \n known_correct_hashes=[\n \n \n \n (\"admin\",'{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy60IPksHChwoTAVYFrhsgoq8/p'),\n (UPASS_WAV,\n \"{PKCS5S2}cE9Yq6Am5tQGdHSHhky2XLeOnURwzaLBG2sur7FHKpvy2u0qDn6GcVGRjlmJoIUy\"),\n ]\n \n known_malformed_hashes=[\n \n '{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy!0IPksHChwoTAVYFrhsgoq8/p'\n \n \n '{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy60IPksHChwoTAVYFrhsgoq8/'\n \n \n '{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy60IPksHChwoTAVYFrhsgoq8/='\n ]\n \nclass pbkdf2_sha1_test(HandlerCase):\n handler=hash.pbkdf2_sha1\n known_correct_hashes=[\n (\"password\",'$pbkdf2$1212$OB.dtnSEXZK8U5cgxU/GYQ$y5LKPOplRmok7CZp/aqVDVg8zGI'),\n (UPASS_WAV,\n '$pbkdf2$1212$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc'),\n ]\n \n known_malformed_hashes=[\n \n '$pbkdf2$01212$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc',\n \n \n '$pbkdf2$$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc',\n \n \n '$pbkdf2$1212$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc$',\n ]\n \nclass pbkdf2_sha256_test(HandlerCase):\n handler=hash.pbkdf2_sha256\n known_correct_hashes=[\n (\"password\",\n '$pbkdf2-sha256$1212$4vjV83LKPjQzk31VI4E0Vw$hsYF68OiOUPdDZ1Fg.fJPeq1h/gXXY7acBp9/6c.tmQ'\n ),\n (UPASS_WAV,\n '$pbkdf2-sha256$1212$3SABFJGDtyhrQMVt1uABPw$WyaUoqCLgvz97s523nF4iuOqZNbp5Nt8do/cuaa7AiI'\n ),\n ]\n \nclass pbkdf2_sha512_test(HandlerCase):\n handler=hash.pbkdf2_sha512\n known_correct_hashes=[\n (\"password\",\n '$pbkdf2-sha512$1212$RHY0Fr3IDMSVO/RSZyb5ow$eNLfBK.eVozomMr.1gYa1'\n '7k9B7KIK25NOEshvhrSX.esqY3s.FvWZViXz4KoLlQI.BzY/YTNJOiKc5gBYFYGww'\n ),\n (UPASS_WAV,\n '$pbkdf2-sha512$1212$KkbvoKGsAIcF8IslDR6skQ$8be/PRmd88Ps8fmPowCJt'\n 'tH9G3vgxpG.Krjt3KT.NP6cKJ0V4Prarqf.HBwz0dCkJ6xgWnSj2ynXSV7MlvMa8Q'\n ),\n ]\n \nclass cta_pbkdf2_sha1_test(HandlerCase):\n handler=hash.cta_pbkdf2_sha1\n known_correct_hashes=[\n \n \n \n (u(\"hashy the \\N{SNOWMAN}\"),'$p5k2$1000$ZxK4ZBJCfQg=$jJZVscWtO--p1-xIZl6jhO2LKR0='),\n \n \n \n \n (\"password\",\"$p5k2$1$$h1TDLGSw9ST8UMAPeIE13i0t12c=\"),\n (UPASS_WAV,\n \"$p5k2$4321$OTg3NjU0MzIx$jINJrSvZ3LXeIbUdrJkRpN62_WQ=\"),\n ]\n \nclass dlitz_pbkdf2_sha1_test(HandlerCase):\n handler=hash.dlitz_pbkdf2_sha1\n known_correct_hashes=[\n \n \n \n ('cloadm','$p5k2$$exec$r1EWMCMk7Rlv3L/RNcFXviDefYa0hlql'),\n ('gnu','$p5k2$c$u9HvcT4d$Sd1gwSVCLZYAuqZ25piRnbBEoAesaa/g'),\n ('dcl','$p5k2$d$tUsch7fU$nqDkaxMDOFBeJsTSfABsyn.PYUXilHwL'),\n ('spam','$p5k2$3e8$H0NX9mT/$wk/sE8vv6OMKuMaqazCJYDSUhWY9YB2J'),\n (UPASS_WAV,\n '$p5k2$$KosHgqNo$9mjN8gqjt02hDoP0c2J0ABtLIwtot8cQ'),\n ]\n \nclass grub_pbkdf2_sha512_test(HandlerCase):\n handler=hash.grub_pbkdf2_sha512\n known_correct_hashes=[\n \n \n \n \n \n (UPASS_WAV,\n 'grub.pbkdf2.sha512.10000.BCAC1CEC5E4341C8C511C529'\n '7FA877BE91C2817B32A35A3ECF5CA6B8B257F751.6968526A'\n '2A5B1AEEE0A29A9E057336B48D388FFB3F600233237223C21'\n '04DE1752CEC35B0DD1ED49563398A282C0F471099C2803FBA'\n '47C7919CABC43192C68F60'),\n \n \n ('toomanysecrets',\n 'grub.pbkdf2.sha512.10000.9B436BB6978682363D5C449B'\n 'BEAB322676946C632208BC1294D51F47174A9A3B04A7E4785'\n '986CD4EA7470FAB8FE9F6BD522D1FC6C51109A8596FB7AD48'\n '7C4493.0FE5EF169AFFCB67D86E2581B1E251D88C777B98BA'\n '2D3256ECC9F765D84956FC5CA5C4B6FD711AA285F0A04DCF4'\n '634083F9A20F4B6F339A52FBD6BED618E527B'),\n \n ]\n \n \n \n \nclass scram_test(HandlerCase):\n handler=hash.scram\n \n \n \n known_correct_hashes=[\n \n \n \n ('pencil','$scram$4096$QSXCR.Q6sek8bf92$'\n 'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30'),\n \n \n \n \n \n \n ('pencil','$scram$4096$QSXCR.Q6sek8bf92$'\n 'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n 'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY,'\n 'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n 'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ'),\n \n \n \n (u('IX \\xE0'),'$scram$6400$0BojBCBE6P2/N4bQ$'\n 'sha-1=YniLes.b8WFMvBhtSACZyyvxeCc'),\n (u('\\u2168\\u3000a\\u0300'),'$scram$6400$0BojBCBE6P2/N4bQ$'\n 'sha-1=YniLes.b8WFMvBhtSACZyyvxeCc'),\n (u('\\u00ADIX \\xE0'),'$scram$6400$0BojBCBE6P2/N4bQ$'\n 'sha-1=YniLes.b8WFMvBhtSACZyyvxeCc'),\n ]\n \n known_malformed_hashes=[\n \n '$scram$04096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$409A$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf9-$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX3-',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92',\n '$scram$4096$QSXCR.Q6sek8bf92$',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30$',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30'\n 'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n 'shaxxx-190=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-256=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha1=HZbuOlKbWl.eR8AfIposuKbhX30',\n ]\n \n def setUp(self):\n  super(scram_test,self).setUp()\n  \n  \n  self.require_stringprep()\n  \n  \n  warnings.filterwarnings(\"ignore\",r\"norm_hash_name\\(\\): unknown hash\")\n  \n def test_90_algs(self):\n  ''\n  defaults=dict(salt=b'A'*10,rounds=1000)\n  def parse(algs,**kwds):\n   for k in defaults:\n    kwds.setdefault(k,defaults[k])\n   return self.handler(algs=algs,**kwds).algs\n   \n   \n  self.assertEqual(parse(None ,use_defaults=True ),hash.scram.default_algs)\n  self.assertRaises(TypeError,parse,None )\n  \n  \n  self.assertEqual(parse(\"sha1\"),[\"sha-1\"])\n  self.assertEqual(parse(\"sha1, sha256, md5\"),[\"md5\",\"sha-1\",\"sha-256\"])\n  \n  \n  self.assertEqual(parse([\"sha-1\",\"sha256\"]),[\"sha-1\",\"sha-256\"])\n  \n  \n  self.assertRaises(ValueError,parse,[\"sha-256\"])\n  self.assertRaises(ValueError,parse,algs=[],use_defaults=True )\n  \n  \n  self.assertRaises(ValueError,parse,[\"sha-1\",\"shaxxx-190\"])\n  \n  \n  self.assertRaises(RuntimeError,parse,['sha-1'],\n  checksum={\"sha-1\":b\"\\x00\"*20})\n  \n def test_90_checksums(self):\n  ''\n  \n  self.assertRaises(TypeError,self.handler,use_defaults=True ,\n  checksum={'sha-1':u('X')*20})\n  \n  \n  self.assertRaises(ValueError,self.handler,use_defaults=True ,\n  checksum={'sha-256':b'X'*32})\n  \n  \n  \n def test_91_extract_digest_info(self):\n  ''\n  edi=self.handler.extract_digest_info\n  \n  \n  h=\"$scram$10$AAAAAA$sha-1=AQ,bbb=Ag,ccc=Aw\"\n  s=b'\\x00'*4\n  self.assertEqual(edi(h,\"SHA1\"),(s,10,b'\\x01'))\n  self.assertEqual(edi(h,\"bbb\"),(s,10,b'\\x02'))\n  self.assertEqual(edi(h,\"ccc\"),(s,10,b'\\x03'))\n  self.assertRaises(KeyError,edi,h,\"ddd\")\n  \n  \n  c=\"$scram$10$....$sha-1,bbb,ccc\"\n  self.assertRaises(ValueError,edi,c,\"sha-1\")\n  self.assertRaises(ValueError,edi,c,\"bbb\")\n  self.assertRaises(ValueError,edi,c,\"ddd\")\n  \n def test_92_extract_digest_algs(self):\n  ''\n  eda=self.handler.extract_digest_algs\n  \n  self.assertEqual(eda('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30'),[\"sha-1\"])\n  \n  self.assertEqual(eda('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',format=\"hashlib\"),\n  [\"sha1\"])\n  \n  self.assertEqual(eda('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ'),\n  [\"sha-1\",\"sha-256\",\"sha-512\"])\n  \n def test_93_derive_digest(self):\n  ''\n  \n  \n  hash=self.handler.derive_digest\n  \n  \n  s1=b'\\x01\\x02\\x03'\n  d1=b'\\xb2\\xfb\\xab\\x82[tNuPnI\\x8aZZ\\x19\\x87\\xcen\\xe9\\xd3'\n  self.assertEqual(hash(u(\"\\u2168\"),s1,1000,'sha-1'),d1)\n  self.assertEqual(hash(b\"\\xe2\\x85\\xa8\",s1,1000,'SHA-1'),d1)\n  self.assertEqual(hash(u(\"IX\"),s1,1000,'sha1'),d1)\n  self.assertEqual(hash(b\"IX\",s1,1000,'SHA1'),d1)\n  \n  \n  self.assertEqual(hash(\"IX\",s1,1000,'md5'),\n  b'3\\x19\\x18\\xc0\\x1c/\\xa8\\xbf\\xe4\\xa3\\xc2\\x8eM\\xe8od')\n  self.assertRaises(ValueError,hash,\"IX\",s1,1000,'sha-666')\n  \n  \n  self.assertRaises(ValueError,hash,\"IX\",s1,0,'sha-1')\n  \n  \n  self.assertEqual(hash(u(\"IX\"),s1.decode(\"latin-1\"),1000,'sha1'),d1)\n  \n def test_94_saslprep(self):\n  ''\n  \n  \n  \n  \n  \n  h=self.do_encrypt(u(\"I\\u00ADX\"))\n  self.assertTrue(self.do_verify(u(\"IX\"),h))\n  self.assertTrue(self.do_verify(u(\"\\u2168\"),h))\n  \n  \n  h=self.do_encrypt(u(\"\\xF3\"))\n  self.assertTrue(self.do_verify(u(\"o\\u0301\"),h))\n  self.assertTrue(self.do_verify(u(\"\\u200Do\\u0301\"),h))\n  \n  \n  self.assertRaises(ValueError,self.do_encrypt,u(\"\\uFDD0\"))\n  self.assertRaises(ValueError,self.do_verify,u(\"\\uFDD0\"),h)\n  \n def test_94_using_w_default_algs(self,param=\"default_algs\"):\n  ''\n  \n  handler=self.handler\n  orig=list(handler.default_algs)\n  subcls=handler.using(**{param:\"sha1,md5\"})\n  \n  \n  self.assertEqual(handler.default_algs,orig)\n  \n  \n  self.assertEqual(subcls.default_algs,[\"md5\",\"sha-1\"])\n  \n  \n  h1=subcls.hash(\"dummy\")\n  self.assertEqual(handler.extract_digest_algs(h1),[\"md5\",\"sha-1\"])\n  \n def test_94_using_w_algs(self):\n  ''\n  self.test_94_using_w_default_algs(param=\"algs\")\n  \n def test_94_needs_update_algs(self):\n  ''\n  handler1=self.handler.using(algs=\"sha1,md5\")\n  \n  \n  h1=handler1.hash(\"dummy\")\n  self.assertFalse(handler1.needs_update(h1))\n  \n  \n  \n  handler2=handler1.using(algs=\"sha1\")\n  self.assertFalse(handler2.needs_update(h1))\n  \n  \n  handler3=handler1.using(algs=\"sha1,sha256\")\n  self.assertTrue(handler3.needs_update(h1))\n  \n def test_95_context_algs(self):\n  ''\n  handler=self.handler\n  from passlib.context import CryptContext\n  c1=CryptContext([\"scram\"],scram__algs=\"sha1,md5\")\n  \n  h=c1.hash(\"dummy\")\n  self.assertEqual(handler.extract_digest_algs(h),[\"md5\",\"sha-1\"])\n  self.assertFalse(c1.needs_update(h))\n  \n  c2=c1.copy(scram__algs=\"sha1\")\n  self.assertFalse(c2.needs_update(h))\n  \n  c2=c1.copy(scram__algs=\"sha1,sha256\")\n  self.assertTrue(c2.needs_update(h))\n  \n def test_96_full_verify(self):\n  ''\n  def vpart(s,h):\n   return self.handler.verify(s,h)\n  def vfull(s,h):\n   return self.handler.verify(s,h,full=True )\n   \n   \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertTrue(vfull('pencil',h))\n  self.assertFalse(vfull('tape',h))\n  \n  \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhV,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertRaises(ValueError,vfull,'pencil',h)\n  \n  \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVYa,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertRaises(ValueError,vfull,'pencil',h)\n  \n  \n  \n  \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=R7RJDWIbeKRTFwhE9oxh04kab0CllrQ3kCcpZUcligc,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertTrue(vpart('tape',h))\n  self.assertFalse(vpart('pencil',h))\n  self.assertRaises(ValueError,vfull,'pencil',h)\n  self.assertRaises(ValueError,vfull,'tape',h)\n  \n  \n  \n  \n", ["logging", "passlib", "passlib.context", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.compat", "warnings"]], "passlib.tests.test_utils_pbkdf2": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement\n\nimport hashlib\nimport warnings\n\n\n\nfrom passlib.utils.compat import u,JYTHON\nfrom passlib.tests.utils import TestCase,hb\n\n\n\n\nclass UtilsTest(TestCase):\n ''\n descriptionPrefix=\"passlib.utils.pbkdf2\"\n \n ndn_formats=[\"hashlib\",\"iana\"]\n ndn_values=[\n \n (\"md5\",\"md5\",\"SCRAM-MD5-PLUS\",\"MD-5\"),\n (\"sha1\",\"sha-1\",\"SCRAM-SHA-1\",\"SHA1\"),\n (\"sha256\",\"sha-256\",\"SHA_256\",\"sha2-256\"),\n (\"ripemd160\",\"ripemd-160\",\"SCRAM-RIPEMD-160\",\"RIPEmd160\",\n \n \n \"ripemd\",\"SCRAM-RIPEMD\"),\n (\"test128\",\"test-128\",\"TEST128\"),\n (\"test2\",\"test2\",\"TEST-2\"),\n (\"test3_128\",\"test3-128\",\"TEST-3-128\"),\n ]\n \n def setUp(self):\n  super(UtilsTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.pbkdf2.*deprecated\",DeprecationWarning)\n  \n def test_norm_hash_name(self):\n  ''\n  from itertools import chain\n  from passlib.utils.pbkdf2 import norm_hash_name\n  from passlib.crypto.digest import _known_hash_names\n  \n  \n  for format in self.ndn_formats:\n   norm_hash_name(\"md4\",format)\n  self.assertRaises(ValueError,norm_hash_name,\"md4\",None )\n  self.assertRaises(ValueError,norm_hash_name,\"md4\",\"fake\")\n  \n  \n  self.assertEqual(norm_hash_name(u(\"MD4\")),\"md4\")\n  self.assertEqual(norm_hash_name(b\"MD4\"),\"md4\")\n  self.assertRaises(TypeError,norm_hash_name,None )\n  \n  \n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\",'.*unknown hash')\n   for row in chain(_known_hash_names,self.ndn_values):\n    for idx,format in enumerate(self.ndn_formats):\n     correct=row[idx]\n     for value in row:\n      result=norm_hash_name(value,format)\n      self.assertEqual(result,correct,\n      \"name=%r, format=%r:\"%(value,\n      format))\n      \n      \n      \n      \nclass Pbkdf1_Test(TestCase):\n ''\n descriptionPrefix=\"passlib.utils.pbkdf2.pbkdf1()\"\n \n pbkdf1_tests=[\n \n \n \n \n \n (b'password',hb('78578E5A5D63CB06'),1000,16,'sha1',hb('dc19847e05c64d2faf10ebfb4a3d2a20')),\n \n \n \n \n (b'password',b'salt',1000,0,'md5',b''),\n (b'password',b'salt',1000,1,'md5',hb('84')),\n (b'password',b'salt',1000,8,'md5',hb('8475c6a8531a5d27')),\n (b'password',b'salt',1000,16,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'sha1',hb('4a8fd48e426ed081b535be5769892fa396293efb')),\n ]\n if not JYTHON:\n  pbkdf1_tests.append(\n  (b'password',b'salt',1000,None ,'md4',hb('f7f2e91100a8f96190f2dd177cb26453'))\n  )\n  \n def setUp(self):\n  super(Pbkdf1_Test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.pbkdf2.*deprecated\",DeprecationWarning)\n  \n def test_known(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf1\n  for secret,salt,rounds,keylen,digest,correct in self.pbkdf1_tests:\n   result=pbkdf1(secret,salt,rounds,keylen,digest)\n   self.assertEqual(result,correct)\n   \n def test_border(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf1\n  def helper(secret=b'secret',salt=b'salt',rounds=1,keylen=1,hash='md5'):\n   return pbkdf1(secret,salt,rounds,keylen,hash)\n  helper()\n  \n  \n  self.assertRaises(TypeError,helper,secret=1)\n  self.assertRaises(TypeError,helper,salt=1)\n  \n  \n  self.assertRaises(ValueError,helper,hash='missing')\n  \n  \n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='1')\n  \n  \n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=17,hash='md5')\n  self.assertRaises(TypeError,helper,keylen='1')\n  \n  \n  \n  \nclass Pbkdf2_Test(TestCase):\n ''\n descriptionPrefix=\"passlib.utils.pbkdf2.pbkdf2()\"\n \n pbkdf2_test_vectors=[\n \n \n \n \n \n \n \n (\n hb(\"cdedb5281bb2f801565a1122b2563515\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935d\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,32\n ),\n \n \n (\n hb(\"5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1200,32\n ),\n \n \n (\n hb(\"d1daa78615f287e6a1c8b120d7062a493f98d203e6be49a6adf4fa574b6e64ee\"),\n b\"password\",b'\\x12\\x34\\x56\\x78\\x78\\x56\\x34\\x12',5,32\n ),\n \n \n (\n hb(\"139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1\"),\n b\"X\"*64,b\"pass phrase equals block size\",1200,32\n ),\n \n \n (\n hb(\"9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a\"),\n b\"X\"*65,b\"pass phrase exceeds block size\",1200,32\n ),\n \n \n \n \n (\n hb(\"0c60c80f961f0e71f3a9b524af6012062fe037a6\"),\n b\"password\",b\"salt\",1,20,\n ),\n \n (\n hb(\"ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957\"),\n b\"password\",b\"salt\",2,20,\n ),\n \n (\n hb(\"4b007901b765489abead49d926f721d065a429c1\"),\n b\"password\",b\"salt\",4096,20,\n ),\n \n \n \n \n \n \n \n \n (\n hb(\"3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038\"),\n b\"passwordPASSWORDpassword\",\n b\"saltSALTsaltSALTsaltSALTsaltSALTsalt\",\n 4096,25,\n ),\n \n (\n hb(\"56fa6aa75548099dcc37d7f03425e0c3\"),\n b\"pass\\00word\",b\"sa\\00lt\",4096,16,\n ),\n \n \n \n \n (\n hb(\"887CFF169EA8335235D8004242AA7D6187A41E3187DF0CE14E256D85ED\"\n \"97A97357AAA8FF0A3871AB9EEFF458392F462F495487387F685B7472FC\"\n \"6C29E293F0A0\"),\n b\"hello\",\n hb(\"9290F727ED06C38BA4549EF7DE25CF5642659211B7FC076F2D28FEFD71\"\n \"784BB8D8F6FB244A8CC5C06240631B97008565A120764C0EE9C2CB0073\"\n \"994D79080136\"),\n 10000,64,\"hmac-sha512\"\n ),\n \n \n \n \n (\n hb('e248fb6b13365146f8ac6307cc222812'),\n b\"secret\",b\"salt\",10,16,\"hmac-sha1\",\n ),\n (\n hb('e248fb6b13365146f8ac6307cc2228127872da6d'),\n b\"secret\",b\"salt\",10,None ,\"hmac-sha1\",\n ),\n \n ]\n \n def setUp(self):\n  super(Pbkdf2_Test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.pbkdf2.*deprecated\",DeprecationWarning)\n  \n def test_known(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  for row in self.pbkdf2_test_vectors:\n   correct,secret,salt,rounds,keylen=row[:5]\n   prf=row[5]if len(row)==6 else \"hmac-sha1\"\n   result=pbkdf2(secret,salt,rounds,keylen,prf)\n   self.assertEqual(result,correct)\n   \n def test_border(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,prf=\"hmac-sha1\"):\n   return pbkdf2(secret,salt,rounds,keylen,prf)\n  helper()\n  \n  \n  self.assertRaises(ValueError,helper,rounds=-1)\n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='x')\n  \n  \n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=0)\n  helper(keylen=1)\n  self.assertRaises(OverflowError,helper,keylen=20 *(2 **32 -1)+1)\n  self.assertRaises(TypeError,helper,keylen='x')\n  \n  \n  self.assertRaises(TypeError,helper,salt=5)\n  self.assertRaises(TypeError,helper,secret=5)\n  \n  \n  self.assertRaises(ValueError,helper,prf='hmac-foo')\n  self.assertRaises(NotImplementedError,helper,prf='foo')\n  self.assertRaises(TypeError,helper,prf=5)\n  \n def test_default_keylen(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,prf=\"hmac-sha1\"):\n   return pbkdf2(secret,salt,rounds,keylen,prf)\n  self.assertEqual(len(helper(prf='hmac-sha1')),20)\n  self.assertEqual(len(helper(prf='hmac-sha256')),32)\n  \n def test_custom_prf(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  def prf(key,msg):\n   return hashlib.md5(key+msg+b'fooey').digest()\n  self.assertRaises(NotImplementedError,pbkdf2,b'secret',b'salt',1000,20,prf)\n  \n  \n  \n  \n", ["__future__", "hashlib", "itertools", "passlib.crypto.digest", "passlib.tests.utils", "passlib.utils.compat", "passlib.utils.pbkdf2", "warnings"]], "passlib.tests.test_crypto_digest": [".py", "''\n\n\n\nfrom __future__ import with_statement,division\n\nfrom binascii import hexlify\nimport hashlib\nimport warnings\n\n\n\nfrom passlib.exc import UnknownHashError\nfrom passlib.utils.compat import PY3,u,JYTHON\nfrom passlib.tests.utils import TestCase,TEST_MODE,skipUnless,hb\n\n\n\n\nclass HashInfoTest(TestCase):\n ''\n descriptionPrefix=\"passlib.crypto.digest\"\n \n \n norm_hash_formats=[\"hashlib\",\"iana\"]\n \n \n \n norm_hash_samples=[\n \n (\"md5\",\"md5\",\"SCRAM-MD5-PLUS\",\"MD-5\"),\n (\"sha1\",\"sha-1\",\"SCRAM-SHA-1\",\"SHA1\"),\n (\"sha256\",\"sha-256\",\"SHA_256\",\"sha2-256\"),\n (\"ripemd160\",\"ripemd-160\",\"SCRAM-RIPEMD-160\",\"RIPEmd160\",\n \n \n \"ripemd\",\"SCRAM-RIPEMD\"),\n \n \n (\"sha4_256\",\"sha4-256\",\"SHA4-256\",\"SHA-4-256\"),\n (\"test128\",\"test-128\",\"TEST128\"),\n (\"test2\",\"test2\",\"TEST-2\"),\n (\"test3_128\",\"test3-128\",\"TEST-3-128\"),\n ]\n \n def test_norm_hash_name(self):\n  ''\n  from itertools import chain\n  from passlib.crypto.digest import norm_hash_name,_known_hash_names\n  \n  \n  ctx=warnings.catch_warnings()\n  ctx.__enter__()\n  self.addCleanup(ctx.__exit__)\n  warnings.filterwarnings(\"ignore\",'.*unknown hash')\n  warnings.filterwarnings(\"ignore\",'.*unsupported hash')\n  \n  \n  self.assertEqual(norm_hash_name(u(\"MD4\")),\"md4\")\n  self.assertEqual(norm_hash_name(b\"MD4\"),\"md4\")\n  self.assertRaises(TypeError,norm_hash_name,None )\n  \n  \n  for row in chain(_known_hash_names,self.norm_hash_samples):\n   for idx,format in enumerate(self.norm_hash_formats):\n    correct=row[idx]\n    for value in row:\n     result=norm_hash_name(value,format)\n     self.assertEqual(result,correct,\n     \"name=%r, format=%r:\"%(value,\n     format))\n     \n def test_lookup_hash_ctor(self):\n  ''\n  from passlib.crypto.digest import lookup_hash\n  \n  \n  self.assertRaises(ValueError,lookup_hash,\"new\")\n  self.assertRaises(ValueError,lookup_hash,\"__name__\")\n  self.assertRaises(ValueError,lookup_hash,\"sha4\")\n  \n  \n  self.assertEqual(lookup_hash(\"md5\"),(hashlib.md5,16,64))\n  \n  \n  try :\n   hashlib.new(\"sha\")\n   has_sha=True\n  except ValueError:\n   has_sha=False\n  if has_sha:\n   record=lookup_hash(\"sha\")\n   const=record[0]\n   self.assertEqual(record,(const,20,64))\n   self.assertEqual(hexlify(const(b\"abc\").digest()),\n   b\"0164b8a914cd2a5e74c4f7ff082c4d97f1edf880\")\n   \n  else :\n   self.assertRaises(ValueError,lookup_hash,\"sha\")\n   \n   \n  try :\n   hashlib.new(\"md4\")\n   has_md4=True\n  except ValueError:\n   has_md4=False\n  record=lookup_hash(\"md4\")\n  const=record[0]\n  if not has_md4:\n   from passlib.crypto._md4 import md4\n   self.assertIs(const,md4)\n  self.assertEqual(record,(const,16,64))\n  self.assertEqual(hexlify(const(b\"abc\").digest()),\n  b\"a448017aaf21d8525fc10ae87aa6729d\")\n  \n  \n  self.assertIs(lookup_hash(\"md5\"),lookup_hash(\"md5\"))\n  \n def test_lookup_hash_w_unknown_name(self):\n  ''\n  from passlib.crypto.digest import lookup_hash\n  \n  \n  self.assertRaises(UnknownHashError,lookup_hash,\"xxx256\")\n  \n  \n  info=lookup_hash(\"xxx256\",required=False )\n  self.assertFalse(info.supported)\n  self.assertRaisesRegex(UnknownHashError,\"unknown hash: 'xxx256'\",info.const)\n  self.assertEqual(info.name,\"xxx256\")\n  self.assertEqual(info.digest_size,None )\n  self.assertEqual(info.block_size,None )\n  \n  \n  info2=lookup_hash(\"xxx256\",required=False )\n  self.assertIs(info2,info)\n  \n def test_mock_fips_mode(self):\n  ''\n\n  \n  from passlib.crypto.digest import lookup_hash,_set_mock_fips_mode\n  \n  \n  if not lookup_hash(\"md5\",required=False ).supported:\n   raise self.skipTest(\"md5 not supported\")\n   \n   \n  _set_mock_fips_mode()\n  self.addCleanup(_set_mock_fips_mode,False )\n  \n  pat=\"'md5' hash disabled for fips\"\n  self.assertRaisesRegex(UnknownHashError,pat,lookup_hash,\"md5\")\n  \n  info=lookup_hash(\"md5\",required=False )\n  self.assertRegex(info.error_text,pat)\n  self.assertRaisesRegex(UnknownHashError,pat,info.const)\n  \n  \n  self.assertEqual(info.digest_size,16)\n  self.assertEqual(info.block_size,64)\n  \n def test_lookup_hash_metadata(self):\n  ''\n  \n  from passlib.crypto.digest import lookup_hash\n  \n  \n  info=lookup_hash(\"sha256\")\n  self.assertEqual(info.name,\"sha256\")\n  self.assertEqual(info.iana_name,\"sha-256\")\n  self.assertEqual(info.block_size,64)\n  self.assertEqual(info.digest_size,32)\n  self.assertIs(lookup_hash(\"SHA2-256\"),info)\n  \n  \n  info=lookup_hash(\"md5\")\n  self.assertEqual(info.name,\"md5\")\n  self.assertEqual(info.iana_name,\"md5\")\n  self.assertEqual(info.block_size,64)\n  self.assertEqual(info.digest_size,16)\n  \n def test_lookup_hash_alt_types(self):\n  ''\n  \n  from passlib.crypto.digest import lookup_hash\n  \n  info=lookup_hash(\"sha256\")\n  self.assertIs(lookup_hash(info),info)\n  self.assertIs(lookup_hash(info.const),info)\n  \n  self.assertRaises(TypeError,lookup_hash,123)\n  \n  \n  \n  \n  \n  \nclass Pbkdf1_Test(TestCase):\n ''\n descriptionPrefix=\"passlib.crypto.digest.pbkdf1\"\n \n pbkdf1_tests=[\n \n \n \n \n \n (b'password',hb('78578E5A5D63CB06'),1000,16,'sha1',hb('dc19847e05c64d2faf10ebfb4a3d2a20')),\n \n \n \n \n (b'password',b'salt',1000,0,'md5',b''),\n (b'password',b'salt',1000,1,'md5',hb('84')),\n (b'password',b'salt',1000,8,'md5',hb('8475c6a8531a5d27')),\n (b'password',b'salt',1000,16,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'sha1',hb('4a8fd48e426ed081b535be5769892fa396293efb')),\n ]\n if not JYTHON:\n  pbkdf1_tests.append(\n  (b'password',b'salt',1000,None ,'md4',hb('f7f2e91100a8f96190f2dd177cb26453'))\n  )\n  \n def test_known(self):\n  ''\n  from passlib.crypto.digest import pbkdf1\n  for secret,salt,rounds,keylen,digest,correct in self.pbkdf1_tests:\n   result=pbkdf1(digest,secret,salt,rounds,keylen)\n   self.assertEqual(result,correct)\n   \n def test_border(self):\n  ''\n  from passlib.crypto.digest import pbkdf1\n  def helper(secret=b'secret',salt=b'salt',rounds=1,keylen=1,hash='md5'):\n   return pbkdf1(hash,secret,salt,rounds,keylen)\n  helper()\n  \n  \n  self.assertRaises(TypeError,helper,secret=1)\n  self.assertRaises(TypeError,helper,salt=1)\n  \n  \n  self.assertRaises(ValueError,helper,hash='missing')\n  \n  \n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='1')\n  \n  \n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=17,hash='md5')\n  self.assertRaises(TypeError,helper,keylen='1')\n  \n  \n  \n  \n  \n  \nfrom passlib.crypto.digest import pbkdf2_hmac,PBKDF2_BACKENDS\n\n\nclass Pbkdf2Test(TestCase):\n ''\n descriptionPrefix=\"passlib.crypto.digest.pbkdf2_hmac() <backends: %s>\"%\", \".join(PBKDF2_BACKENDS)\n \n pbkdf2_test_vectors=[\n \n \n \n \n \n \n \n (\n hb(\"cdedb5281bb2f801565a1122b2563515\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935d\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,32\n ),\n \n \n (\n hb(\"5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1200,32\n ),\n \n \n (\n hb(\"d1daa78615f287e6a1c8b120d7062a493f98d203e6be49a6adf4fa574b6e64ee\"),\n b\"password\",b'\\x12\\x34\\x56\\x78\\x78\\x56\\x34\\x12',5,32\n ),\n \n \n (\n hb(\"139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1\"),\n b\"X\"*64,b\"pass phrase equals block size\",1200,32\n ),\n \n \n (\n hb(\"9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a\"),\n b\"X\"*65,b\"pass phrase exceeds block size\",1200,32\n ),\n \n \n \n \n (\n hb(\"0c60c80f961f0e71f3a9b524af6012062fe037a6\"),\n b\"password\",b\"salt\",1,20,\n ),\n \n (\n hb(\"ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957\"),\n b\"password\",b\"salt\",2,20,\n ),\n \n (\n hb(\"4b007901b765489abead49d926f721d065a429c1\"),\n b\"password\",b\"salt\",4096,20,\n ),\n \n \n \n \n \n \n \n \n (\n hb(\"3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038\"),\n b\"passwordPASSWORDpassword\",\n b\"saltSALTsaltSALTsaltSALTsaltSALTsalt\",\n 4096,25,\n ),\n \n (\n hb(\"56fa6aa75548099dcc37d7f03425e0c3\"),\n b\"pass\\00word\",b\"sa\\00lt\",4096,16,\n ),\n \n \n \n \n (\n hb(\"887CFF169EA8335235D8004242AA7D6187A41E3187DF0CE14E256D85ED\"\n \"97A97357AAA8FF0A3871AB9EEFF458392F462F495487387F685B7472FC\"\n \"6C29E293F0A0\"),\n b\"hello\",\n hb(\"9290F727ED06C38BA4549EF7DE25CF5642659211B7FC076F2D28FEFD71\"\n \"784BB8D8F6FB244A8CC5C06240631B97008565A120764C0EE9C2CB0073\"\n \"994D79080136\"),\n 10000,64,\"sha512\"\n ),\n \n \n \n \n (\n hb('55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc'\n '49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783'),\n b'passwd',b'salt',1,64,'sha256',\n ),\n \n (\n hb('4ddcd8f60b98be21830cee5ef22701f9641a4418d04c0414aeff08876b34ab56'\n 'a1d425a1225833549adb841b51c9b3176a272bdebba1d078478f62b397f33c8d'),\n b'Password',b'NaCl',80000,64,'sha256',\n ),\n \n (\n hb('120fb6cffcf8b32c43e7225256c4f837a86548c92ccc35480805987cb70be17b'),\n b'password',b'salt',1,32,'sha256',\n ),\n \n (\n hb('ae4d0c95af6b46d32d0adff928f06dd02a303f8ef3c251dfd6e2d85a95474c43'),\n b'password',b'salt',2,32,'sha256',\n ),\n \n (\n hb('c5e478d59288c841aa530db6845c4c8d962893a001ce4e11a4963873aa98134a'),\n b'password',b'salt',4096,32,'sha256',\n ),\n \n (\n hb('348c89dbcbd32b2f32d814b8116e84cf2b17347ebc1800181c4e2a1fb8dd53e1c'\n '635518c7dac47e9'),\n b'passwordPASSWORDpassword',b'saltSALTsaltSALTsaltSALTsaltSALTsalt',\n 4096,40,'sha256',\n ),\n \n (\n hb('9e83f279c040f2a11aa4a02b24c418f2d3cb39560c9627fa4f47e3bcc2897c3d'),\n b'',b'salt',1024,32,'sha256',\n ),\n \n (\n hb('ea5808411eb0c7e830deab55096cee582761e22a9bc034e3ece925225b07bf46'),\n b'password',b'',1024,32,'sha256',\n ),\n \n (\n hb('89b69d0516f829893c696226650a8687'),\n b'pass\\x00word',b'sa\\x00lt',4096,16,'sha256',\n ),\n \n (\n hb('867f70cf1ade02cff3752599a3a53dc4af34c7a669815ae5d513554e1c8cf252'),\n b'password',b'salt',1,32,'sha512',\n ),\n \n (\n hb('e1d9c16aa681708a45f5c7c4e215ceb66e011a2e9f0040713f18aefdb866d53c'),\n b'password',b'salt',2,32,'sha512',\n ),\n \n (\n hb('d197b1b33db0143e018b12f3d1d1479e6cdebdcc97c5c0f87f6902e072f457b5'),\n b'password',b'salt',4096,32,'sha512',\n ),\n \n (\n hb('6e23f27638084b0f7ea1734e0d9841f55dd29ea60a834466f3396bac801fac1eeb'\n '63802f03a0b4acd7603e3699c8b74437be83ff01ad7f55dac1ef60f4d56480c35e'\n 'e68fd52c6936'),\n b'passwordPASSWORDpassword',b'saltSALTsaltSALTsaltSALTsaltSALTsalt',\n 1,72,'sha512',\n ),\n \n (\n hb('0c60c80f961f0e71f3a9b524af6012062fe037a6'),\n b'password',b'salt',1,20,'sha1',\n ),\n \n \n \n \n (\n hb('e248fb6b13365146f8ac6307cc222812'),\n b\"secret\",b\"salt\",10,16,\"sha1\",\n ),\n (\n hb('e248fb6b13365146f8ac6307cc2228127872da6d'),\n b\"secret\",b\"salt\",10,None ,\"sha1\",\n ),\n (\n hb('b1d5485772e6f76d5ebdc11b38d3eff0a5b2bd50dc11f937e86ecacd0cd40d1b'\n '9113e0734e3b76a3'),\n b\"secret\",b\"salt\",62,40,\"md5\",\n ),\n (\n hb('ea014cc01f78d3883cac364bb5d054e2be238fb0b6081795a9d84512126e3129'\n '062104d2183464c4'),\n b\"secret\",b\"salt\",62,40,\"md4\",\n ),\n ]\n \n def test_known(self):\n  ''\n  for row in self.pbkdf2_test_vectors:\n   correct,secret,salt,rounds,keylen=row[:5]\n   digest=row[5]if len(row)==6 else \"sha1\"\n   result=pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n   self.assertEqual(result,correct)\n   \n def test_backends(self):\n  ''\n  from passlib.crypto.digest import PBKDF2_BACKENDS\n  \n  \n  try :\n   import fastpbkdf2\n   has_fastpbkdf2=True\n  except ImportError:\n   has_fastpbkdf2=False\n  self.assertEqual(\"fastpbkdf2\"in PBKDF2_BACKENDS,has_fastpbkdf2)\n  \n  \n  try :\n   from hashlib import pbkdf2_hmac\n   has_hashlib_ssl=pbkdf2_hmac.__module__ !=\"hashlib\"\n  except ImportError:\n   has_hashlib_ssl=False\n  self.assertEqual(\"hashlib-ssl\"in PBKDF2_BACKENDS,has_hashlib_ssl)\n  \n  \n  from passlib.utils.compat import PY3\n  if PY3:\n   self.assertIn(\"builtin-from-bytes\",PBKDF2_BACKENDS)\n  else :\n  \n   self.assertIn(\"builtin-unpack\",PBKDF2_BACKENDS)\n   \n def test_border(self):\n  ''\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,digest=\"sha1\"):\n   return pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n  helper()\n  \n  \n  self.assertRaises(ValueError,helper,rounds=-1)\n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='x')\n  \n  \n  helper(keylen=1)\n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=0)\n  \n  \n  self.assertRaises(OverflowError,helper,keylen=20 *(2 **32 -1)+1)\n  self.assertRaises(TypeError,helper,keylen='x')\n  \n  \n  self.assertRaises(TypeError,helper,salt=5)\n  self.assertRaises(TypeError,helper,secret=5)\n  \n  \n  self.assertRaises(ValueError,helper,digest='foo')\n  self.assertRaises(TypeError,helper,digest=5)\n  \n def test_default_keylen(self):\n  ''\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,digest=\"sha1\"):\n   return pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n  self.assertEqual(len(helper(digest='sha1')),20)\n  self.assertEqual(len(helper(digest='sha256')),32)\n  \n  \n  \n  \n", ["__future__", "binascii", "fastpbkdf2", "hashlib", "itertools", "passlib.crypto._md4", "passlib.crypto.digest", "passlib.exc", "passlib.tests.utils", "passlib.utils.compat", "warnings"]], "passlib.tests.backports": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport re\nimport sys\n\n\n\nfrom passlib.utils.compat import PY26\n\n__all__=[\n\"TestCase\",\n\"unittest\",\n\n\"skip\",\"skipIf\",\"skipUnless\",\n]\n\n\n\n\ntry :\n import unittest2 as unittest\nexcept ImportError:\n if PY26:\n  raise ImportError(\"Passlib's tests require 'unittest2' under Python 2.6 (as of Passlib 1.7)\")\n  \n import unittest\n \n \n \n \nskip=unittest.skip\nskipIf=unittest.skipIf\nskipUnless=unittest.skipUnless\nSkipTest=unittest.SkipTest\n\n\n\n\nclass TestCase(unittest.TestCase):\n ''\n \n \n \n \n \n \n \n \n \n if not hasattr(unittest.TestCase,\"assertRegex\"):\n  assertRegex=unittest.TestCase.assertRegexpMatches\n  \n if not hasattr(unittest.TestCase,\"assertRaisesRegex\"):\n  assertRaisesRegex=unittest.TestCase.assertRaisesRegexp\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "passlib.utils.compat", "re", "sys", "unittest", "unittest2"]], "passlib.tests.test_context": [".py", "''\n\n\n\n\nfrom __future__ import with_statement\nfrom passlib.utils.compat import PY3\nif PY3:\n from configparser import NoSectionError\nelse :\n from ConfigParser import NoSectionError\nimport datetime\nfrom functools import partial\nimport logging ;log=logging.getLogger(__name__)\nimport os\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.context import CryptContext,LazyCryptContext\nfrom passlib.exc import PasslibConfigWarning,PasslibHashWarning\nfrom passlib.utils import tick,to_unicode\nfrom passlib.utils.compat import irange,u,unicode,str_to_uascii,PY2,PY26\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import (TestCase,set_file,TICK_RESOLUTION,\nquicksleep,time_call,handler_derived_from)\nfrom passlib.registry import (register_crypt_handler_path,\n_has_crypt_handler as has_crypt_handler,\n_unload_handler_name as unload_handler_name,\nget_crypt_handler,\n)\n\n\n\n\nhere=os.path.abspath(os.path.dirname(__file__))\n\ndef merge_dicts(first,*args,**kwds):\n target=first.copy()\n for arg in args:\n  target.update(arg)\n if kwds:\n  target.update(kwds)\n return target\n \n \n \n \nclass CryptContextTest(TestCase):\n descriptionPrefix=\"CryptContext\"\n \n \n \n \n \n \n \n \n \n \n \n sample_1_schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"]\n sample_1_handlers=[get_crypt_handler(name)for name in sample_1_schemes]\n \n sample_1_dict=dict(\n schemes=sample_1_schemes,\n default=\"md5_crypt\",\n all__vary_rounds=0.1,\n bsdi_crypt__max_rounds=30001,\n bsdi_crypt__default_rounds=25001,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=40000,\n )\n \n sample_1_resolved_dict=merge_dicts(sample_1_dict,\n schemes=sample_1_handlers)\n \n sample_1_unnormalized=u(\"\"\"\\\n[passlib]\nschemes = des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\ndefault = md5_crypt\n; this is using %...\nall__vary_rounds = 10%%\nbsdi_crypt__default_rounds = 25001\nbsdi_crypt__max_rounds = 30001\nsha512_crypt__max_rounds = 50000\nsha512_crypt__min_rounds = 40000\n\"\"\")\n \n sample_1_unicode=u(\"\"\"\\\n[passlib]\nschemes = des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\ndefault = md5_crypt\nall__vary_rounds = 0.1\nbsdi_crypt__default_rounds = 25001\nbsdi_crypt__max_rounds = 30001\nsha512_crypt__max_rounds = 50000\nsha512_crypt__min_rounds = 40000\n\n\"\"\")\n \n \n \n \n \n \n sample_1_path=os.path.join(here,\"sample1.cfg\")\n \n \n sample_1b_unicode=sample_1_unicode.replace(u(\"\\n\"),u(\"\\r\\n\"))\n sample_1b_path=os.path.join(here,\"sample1b.cfg\")\n \n \n sample_1c_bytes=sample_1_unicode.replace(u(\"[passlib]\"),\n u(\"[mypolicy]\")).encode(\"utf-16\")\n sample_1c_path=os.path.join(here,\"sample1c.cfg\")\n \n \n if False :\n  set_file(sample_1_path,sample_1_unicode)\n  set_file(sample_1b_path,sample_1b_unicode)\n  set_file(sample_1c_path,sample_1c_bytes)\n  \n  \n  \n  \n sample_2_dict=dict(\n \n bsdi_crypt__min_rounds=29001,\n bsdi_crypt__max_rounds=35001,\n bsdi_crypt__default_rounds=31001,\n \n sha512_crypt__min_rounds=45000,\n )\n \n sample_2_unicode=\"\"\"\\\n[passlib]\nbsdi_crypt__min_rounds = 29001\nbsdi_crypt__max_rounds = 35001\nbsdi_crypt__default_rounds = 31001\nsha512_crypt__min_rounds = 45000\n\"\"\"\n \n \n sample_12_dict=merge_dicts(sample_1_dict,sample_2_dict)\n \n \n \n \n sample_3_dict=dict(\n default=\"sha512_crypt\",\n )\n \n \n sample_123_dict=merge_dicts(sample_12_dict,sample_3_dict)\n \n \n \n \n sample_4_dict=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"phpass\",\"bsdi_crypt\",\n \"sha256_crypt\"],\n deprecated=[\"des_crypt\",],\n default=\"sha256_crypt\",\n bsdi_crypt__max_rounds=31,\n bsdi_crypt__default_rounds=25,\n bsdi_crypt__vary_rounds=0,\n sha256_crypt__max_rounds=3000,\n sha256_crypt__min_rounds=2000,\n sha256_crypt__default_rounds=3000,\n phpass__ident=\"H\",\n phpass__default_rounds=7,\n )\n \n \n \n \n def setUp(self):\n  super(CryptContextTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\"The 'all' scheme is deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\".*'scheme' keyword is deprecated as of Passlib 1.7.*\")\n  \n  \n  \n  \n def test_01_constructor(self):\n  ''\n  \n  \n  ctx=CryptContext()\n  self.assertEqual(ctx.to_dict(),{})\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_resolved_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext(**self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_2_dict)\n  \n  \n  ctx=CryptContext(**self.sample_3_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_3_dict)\n  \n  \n  ctx=CryptContext(schemes=[u(\"sha256_crypt\")])\n  self.assertEqual(ctx.schemes(),(\"sha256_crypt\",))\n  \n def test_02_from_string(self):\n  ''\n  \n  ctx=CryptContext.from_string(self.sample_1_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1_unnormalized)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1_unicode.encode(\"utf-8\"))\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1b_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1c_bytes,section=\"mypolicy\",\n  encoding=\"utf-16\")\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  self.assertRaises(TypeError,CryptContext.from_string,None )\n  \n  \n  self.assertRaises(NoSectionError,CryptContext.from_string,\n  self.sample_1_unicode,section=\"fakesection\")\n  \n def test_03_from_path(self):\n  ''\n  \n  if not os.path.exists(self.sample_1_path):\n   raise RuntimeError(\"can't find data file: %r\"%self.sample_1_path)\n   \n   \n  ctx=CryptContext.from_path(self.sample_1_path)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_path(self.sample_1b_path)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_path(self.sample_1c_path,section=\"mypolicy\",\n  encoding=\"utf-16\")\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  self.assertRaises(EnvironmentError,CryptContext.from_path,\n  os.path.join(here,\"sample1xxx.cfg\"))\n  \n  \n  self.assertRaises(NoSectionError,CryptContext.from_path,\n  self.sample_1_path,section=\"fakesection\")\n  \n def test_04_copy(self):\n  ''\n  cc1=CryptContext(**self.sample_1_dict)\n  \n  \n  cc2=cc1.copy(**self.sample_2_dict)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc2.to_dict(),self.sample_12_dict)\n  \n  \n  cc2b=cc2.copy(**self.sample_2_dict)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc2b.to_dict(),self.sample_12_dict)\n  \n  \n  cc3=cc2.copy(**self.sample_3_dict)\n  self.assertEqual(cc3.to_dict(),self.sample_123_dict)\n  \n  \n  cc4=cc1.copy()\n  self.assertIsNot(cc4,cc1)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc4.to_dict(),self.sample_1_dict)\n  \n  \n  cc4.update(**self.sample_2_dict)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc4.to_dict(),self.sample_12_dict)\n  \n def test_09_repr(self):\n  ''\n  cc1=CryptContext(**self.sample_1_dict)\n  \n  self.assertRegex(repr(cc1),\"^<CryptContext at 0x-?[0-9a-f]+>$\")\n  \n  \n  \n  \n def test_10_load(self):\n  ''\n  \n  \n  \n  \n  \n  \n  ctx=CryptContext()\n  \n  \n  ctx.load(self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx.load(self.sample_1_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx.load(self.sample_1_unicode.encode(\"utf-8\"))\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  self.assertRaises(TypeError,ctx.load,None )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.load({},update=True )\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext()\n  ctx.load(self.sample_1_dict)\n  ctx.load(self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_2_dict)\n  \n def test_11_load_rollback(self):\n  ''\n  \n  cc=CryptContext([\"des_crypt\",\"sha256_crypt\"],\n  sha256_crypt__default_rounds=5000,\n  all__vary_rounds=0.1,\n  )\n  result=cc.to_string()\n  \n  \n  \n  self.assertRaises(TypeError,cc.update,too__many__key__parts=True )\n  self.assertEqual(cc.to_string(),result)\n  \n  \n  \n  \n  self.assertRaises(KeyError,cc.update,fake_context_option=True )\n  self.assertEqual(cc.to_string(),result)\n  \n  \n  self.assertRaises(ValueError,cc.update,sha256_crypt__min_rounds=10000)\n  self.assertEqual(cc.to_string(),result)\n  \n def test_12_update(self):\n  ''\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update()\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update(**self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_12_dict)\n  \n  \n  ctx.update(**self.sample_3_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_123_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update(self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_12_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update(self.sample_2_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_12_dict)\n  \n  \n  self.assertRaises(TypeError,ctx.update,{},{})\n  self.assertRaises(TypeError,ctx.update,{},schemes=['des_crypt'])\n  \n  \n  self.assertRaises(TypeError,ctx.update,None )\n  \n  \n  \n  \n def test_20_options(self):\n  ''\n  def parse(**kwds):\n   return CryptContext(**kwds).to_dict()\n   \n   \n   \n   \n   \n   \n   \n  self.assertRaises(TypeError,CryptContext,__=0.1)\n  self.assertRaises(TypeError,CryptContext,default__scheme__='x')\n  \n  \n  self.assertRaises(TypeError,CryptContext,__option='x')\n  self.assertRaises(TypeError,CryptContext,default____option='x')\n  \n  \n  self.assertRaises(TypeError,CryptContext,__scheme__option='x')\n  \n  \n  self.assertRaises(TypeError,CryptContext,\n  category__scheme__option__invalid=30000)\n  \n  \n  \n  self.assertRaises(KeyError,parse,\n  **{\"admin.context__schemes\":\"md5_crypt\"})\n  ctx=CryptContext(**{\"schemes\":\"md5_crypt,des_crypt\",\n  \"admin.context__default\":\"des_crypt\"})\n  self.assertEqual(ctx.default_scheme(\"admin\"),\"des_crypt\")\n  \n  \n  \n  \n  \n  \n  result=dict(default=\"md5_crypt\")\n  self.assertEqual(parse(default=\"md5_crypt\"),result)\n  self.assertEqual(parse(context__default=\"md5_crypt\"),result)\n  self.assertEqual(parse(default__context__default=\"md5_crypt\"),result)\n  self.assertEqual(parse(**{\"context.default\":\"md5_crypt\"}),result)\n  self.assertEqual(parse(**{\"default.context.default\":\"md5_crypt\"}),result)\n  \n  \n  result=dict(admin__context__default=\"md5_crypt\")\n  self.assertEqual(parse(admin__context__default=\"md5_crypt\"),result)\n  self.assertEqual(parse(**{\"admin.context.default\":\"md5_crypt\"}),result)\n  \n  \n  \n  \n  \n  \n  result=dict(all__vary_rounds=0.1)\n  self.assertEqual(parse(all__vary_rounds=0.1),result)\n  self.assertEqual(parse(default__all__vary_rounds=0.1),result)\n  self.assertEqual(parse(**{\"all.vary_rounds\":0.1}),result)\n  self.assertEqual(parse(**{\"default.all.vary_rounds\":0.1}),result)\n  \n  \n  result=dict(admin__all__vary_rounds=0.1)\n  self.assertEqual(parse(admin__all__vary_rounds=0.1),result)\n  self.assertEqual(parse(**{\"admin.all.vary_rounds\":0.1}),result)\n  \n  \n  ctx=CryptContext([\"phpass\",\"md5_crypt\"],phpass__ident=\"P\")\n  self.assertRaises(KeyError,ctx.copy,md5_crypt__ident=\"P\")\n  \n  \n  self.assertRaises(KeyError,CryptContext,schemes=[\"des_crypt\"],\n  des_crypt__salt=\"xx\")\n  self.assertRaises(KeyError,CryptContext,schemes=[\"des_crypt\"],\n  all__salt=\"xx\")\n  \n def test_21_schemes(self):\n  ''\n  \n  \n  cc=CryptContext(schemes=None )\n  self.assertEqual(cc.schemes(),())\n  \n  \n  cc=CryptContext(schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(cc.schemes(),(\"des_crypt\",\"md5_crypt\"))\n  \n  \n  cc=CryptContext(schemes=\" des_crypt, md5_crypt, \")\n  self.assertEqual(cc.schemes(),(\"des_crypt\",\"md5_crypt\"))\n  \n  \n  cc=CryptContext(schemes=[hash.des_crypt,hash.md5_crypt])\n  self.assertEqual(cc.schemes(),(\"des_crypt\",\"md5_crypt\"))\n  \n  \n  self.assertRaises(TypeError,CryptContext,schemes=[uh.StaticHandler])\n  \n  \n  class nameless(uh.StaticHandler):\n   name=None\n  self.assertRaises(ValueError,CryptContext,schemes=[nameless])\n  \n  \n  class dummy_1(uh.StaticHandler):\n   name='dummy_1'\n  self.assertRaises(KeyError,CryptContext,schemes=[dummy_1,dummy_1])\n  \n  \n  self.assertRaises(KeyError,CryptContext,\n  admin__context__schemes=[\"md5_crypt\"])\n  \n def test_22_deprecated(self):\n  ''\n  def getdep(ctx,category=None ):\n   return [name for name in ctx.schemes()\n   if ctx.handler(name,category).deprecated]\n   \n   \n  cc=CryptContext(deprecated=[\"md5_crypt\"])\n  cc.update(schemes=[\"md5_crypt\",\"des_crypt\"])\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  \n  \n  cc=CryptContext(deprecated=[\"md5_crypt\"],schemes=[\"md5_crypt\",\"des_crypt\"])\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  \n  \n  \n  self.assertRaises(TypeError,CryptContext,deprecated=[hash.md5_crypt],\n  schemes=[\"md5_crypt\",\"des_crypt\"])\n  \n  \n  \n  \n  cc=CryptContext(deprecated=\"md5_crypt,des_crypt\",schemes=[\"md5_crypt\",\"des_crypt\",\"sha256_crypt\"])\n  self.assertEqual(getdep(cc),[\"md5_crypt\",\"des_crypt\"])\n  \n  \n  self.assertRaises(KeyError,CryptContext,schemes=['des_crypt'],\n  deprecated=['md5_crypt'])\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt'],\n  deprecated=['des_crypt'])\n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  admin__context__deprecated=['des_crypt','md5_crypt'])\n  \n  \n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  default=\"md5_crypt\",\n  deprecated=\"md5_crypt\")\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  default=\"md5_crypt\",\n  admin__context__deprecated=\"md5_crypt\")\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  admin__context__default=\"md5_crypt\",\n  deprecated=\"md5_crypt\")\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  admin__context__default=\"md5_crypt\",\n  admin__context__deprecated=\"md5_crypt\")\n  \n  \n  CryptContext(\n  schemes=['des_crypt','md5_crypt'],\n  deprecated=\"md5_crypt\",\n  admin__context__default=\"md5_crypt\",\n  admin__context__deprecated=[])\n  \n  \n  self.assertRaises(TypeError,CryptContext,deprecated=123)\n  \n  \n  cc=CryptContext(deprecated=[\"md5_crypt\"],\n  schemes=[\"md5_crypt\",\"des_crypt\"],\n  admin__context__deprecated=[\"des_crypt\"],\n  )\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"user\"),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"admin\"),[\"des_crypt\"])\n  \n  \n  cc=CryptContext(deprecated=[\"md5_crypt\"],\n  schemes=[\"md5_crypt\",\"des_crypt\"],\n  admin__context__deprecated=[],\n  )\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"user\"),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"admin\"),[])\n  \n def test_23_default(self):\n  ''\n  \n  \n  self.assertEqual(CryptContext(default=\"md5_crypt\").to_dict(),\n  dict(default=\"md5_crypt\"))\n  \n  \n  ctx=CryptContext(default=\"md5_crypt\",schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  \n  \n  \n  ctx=CryptContext(default=hash.md5_crypt,schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  \n  \n  ctx=CryptContext(schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(ctx.default_scheme(),\"des_crypt\")\n  ctx.update(deprecated=\"des_crypt\")\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  \n  \n  self.assertRaises(KeyError,CryptContext,schemes=['des_crypt'],\n  default='md5_crypt')\n  \n  \n  self.assertRaises(TypeError,CryptContext,default=1)\n  \n  \n  ctx=CryptContext(default=\"des_crypt\",\n  schemes=[\"des_crypt\",\"md5_crypt\"],\n  admin__context__default=\"md5_crypt\")\n  self.assertEqual(ctx.default_scheme(),\"des_crypt\")\n  self.assertEqual(ctx.default_scheme(\"user\"),\"des_crypt\")\n  self.assertEqual(ctx.default_scheme(\"admin\"),\"md5_crypt\")\n  \n def test_24_vary_rounds(self):\n  ''\n  def parse(v):\n   return CryptContext(all__vary_rounds=v).to_dict()['all__vary_rounds']\n   \n   \n  self.assertEqual(parse(0.1),0.1)\n  self.assertEqual(parse('0.1'),0.1)\n  \n  \n  self.assertEqual(parse('10%'),0.1)\n  \n  \n  self.assertEqual(parse(1000),1000)\n  self.assertEqual(parse('1000'),1000)\n  \n  \n  \n  \n  \n def assertHandlerDerivedFrom(self,handler,base,msg=None ):\n  self.assertTrue(handler_derived_from(handler,base),msg=msg)\n  \n def test_30_schemes(self):\n  ''\n  \n  \n  \n  ctx=CryptContext()\n  self.assertEqual(ctx.schemes(),())\n  self.assertEqual(ctx.schemes(resolve=True ),())\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.schemes(),tuple(self.sample_1_schemes))\n  self.assertEqual(ctx.schemes(resolve=True ,unconfigured=True ),tuple(self.sample_1_handlers))\n  for result,correct in zip(ctx.schemes(resolve=True ),self.sample_1_handlers):\n   self.assertTrue(handler_derived_from(result,correct))\n   \n   \n  ctx=CryptContext(**self.sample_2_dict)\n  self.assertEqual(ctx.schemes(),())\n  \n def test_31_default_scheme(self):\n  ''\n  \n  \n  \n  ctx=CryptContext()\n  self.assertRaises(KeyError,ctx.default_scheme)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  self.assertEqual(ctx.default_scheme(resolve=True ,unconfigured=True ),hash.md5_crypt)\n  self.assertHandlerDerivedFrom(ctx.default_scheme(resolve=True ),hash.md5_crypt)\n  \n  \n  ctx=CryptContext(**self.sample_2_dict)\n  self.assertRaises(KeyError,ctx.default_scheme)\n  \n  \n  ctx=CryptContext(schemes=self.sample_1_schemes)\n  self.assertEqual(ctx.default_scheme(),\"des_crypt\")\n  \n  \n  \n def test_32_handler(self):\n  ''\n  \n  \n  ctx=CryptContext()\n  self.assertRaises(KeyError,ctx.handler)\n  self.assertRaises(KeyError,ctx.handler,\"md5_crypt\")\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.handler(unconfigured=True ),hash.md5_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(),hash.md5_crypt)\n  \n  \n  self.assertEqual(ctx.handler(\"des_crypt\",unconfigured=True ),hash.des_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(\"des_crypt\"),hash.des_crypt)\n  \n  \n  self.assertRaises(KeyError,ctx.handler,\"mysql323\")\n  \n  \n  ctx=CryptContext(\"sha256_crypt,md5_crypt\",admin__context__default=\"md5_crypt\")\n  self.assertEqual(ctx.handler(unconfigured=True ),hash.sha256_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(),hash.sha256_crypt)\n  \n  self.assertEqual(ctx.handler(category=\"staff\",unconfigured=True ),hash.sha256_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(category=\"staff\"),hash.sha256_crypt)\n  \n  self.assertEqual(ctx.handler(category=\"admin\",unconfigured=True ),hash.md5_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(category=\"staff\"),hash.sha256_crypt)\n  \n  \n  if PY2:\n   self.assertEqual(ctx.handler(category=u(\"staff\"),unconfigured=True ),hash.sha256_crypt)\n   self.assertEqual(ctx.handler(category=u(\"admin\"),unconfigured=True ),hash.md5_crypt)\n   \n def test_33_options(self):\n  ''\n  \n  def options(ctx,scheme,category=None ):\n   return ctx._config._get_record_options_with_flag(scheme,category)[0]\n   \n   \n   \n  cc4=CryptContext(\n  truncate_error=True ,\n  schemes=[\"sha512_crypt\",\"des_crypt\",\"bsdi_crypt\"],\n  deprecated=[\"sha512_crypt\",\"des_crypt\"],\n  all__vary_rounds=0.1,\n  bsdi_crypt__vary_rounds=0.2,\n  sha512_crypt__max_rounds=20000,\n  admin__context__deprecated=[\"des_crypt\",\"bsdi_crypt\"],\n  admin__all__vary_rounds=0.05,\n  admin__bsdi_crypt__vary_rounds=0.3,\n  admin__sha512_crypt__max_rounds=40000,\n  )\n  self.assertEqual(cc4._config.categories,(\"admin\",))\n  \n  \n  \n  \n  \n  self.assertEqual(options(cc4,\"sha512_crypt\"),dict(\n  deprecated=True ,\n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(options(cc4,\"sha512_crypt\",\"user\"),dict(\n  deprecated=True ,\n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(options(cc4,\"sha512_crypt\",\"admin\"),dict(\n  \n  vary_rounds=0.05,\n  max_rounds=40000,\n  ))\n  \n  \n  \n  \n  \n  self.assertEqual(options(cc4,\"des_crypt\"),dict(\n  deprecated=True ,\n  truncate_error=True ,\n  ))\n  \n  self.assertEqual(options(cc4,\"des_crypt\",\"user\"),dict(\n  deprecated=True ,\n  truncate_error=True ,\n  ))\n  \n  self.assertEqual(options(cc4,\"des_crypt\",\"admin\"),dict(\n  deprecated=True ,\n  truncate_error=True ,\n  ))\n  \n  \n  \n  \n  self.assertEqual(options(cc4,\"bsdi_crypt\"),dict(\n  vary_rounds=0.2,\n  ))\n  \n  self.assertEqual(options(cc4,\"bsdi_crypt\",\"user\"),dict(\n  vary_rounds=0.2,\n  ))\n  \n  self.assertEqual(options(cc4,\"bsdi_crypt\",\"admin\"),dict(\n  vary_rounds=0.3,\n  deprecated=True ,\n  ))\n  \n def test_34_to_dict(self):\n  ''\n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(resolve=True ),self.sample_1_resolved_dict)\n  \n def test_35_to_string(self):\n  ''\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  dump=ctx.to_string()\n  \n  \n  \n  \n  \n  if not PY26:\n   self.assertEqual(dump,self.sample_1_unicode)\n   \n   \n  ctx2=CryptContext.from_string(dump)\n  self.assertEqual(ctx2.to_dict(),self.sample_1_dict)\n  \n  \n  other=ctx.to_string(section=\"password-security\")\n  self.assertEqual(other,dump.replace(\"[passlib]\",\"[password-security]\"))\n  \n  \n  from passlib.tests.test_utils_handlers import UnsaltedHash\n  ctx3=CryptContext([UnsaltedHash,\"md5_crypt\"])\n  dump=ctx3.to_string()\n  self.assertRegex(dump,r\"# NOTE: the 'unsalted_test_hash' handler\\(s\\)\"\n  r\" are not registered with Passlib\")\n  \n  \n  \n  \n nonstring_vectors=[\n (None ,{}),\n (None ,{\"scheme\":\"des_crypt\"}),\n (1,{}),\n ((),{}),\n ]\n \n def test_40_basic(self):\n  ''\n  handlers=[hash.md5_crypt,hash.des_crypt,hash.bsdi_crypt]\n  cc=CryptContext(handlers,bsdi_crypt__default_rounds=5)\n  \n  \n  for crypt in handlers:\n   h=cc.hash(\"test\",scheme=crypt.name)\n   self.assertEqual(cc.identify(h),crypt.name)\n   self.assertEqual(cc.identify(h,resolve=True ,unconfigured=True ),crypt)\n   self.assertHandlerDerivedFrom(cc.identify(h,resolve=True ),crypt)\n   self.assertTrue(cc.verify('test',h))\n   self.assertFalse(cc.verify('notest',h))\n   \n   \n  h=cc.hash(\"test\")\n  self.assertEqual(cc.identify(h),\"md5_crypt\")\n  \n  \n  h=cc.genhash('secret',cc.genconfig())\n  self.assertEqual(cc.identify(h),'md5_crypt')\n  \n  h=cc.genhash('secret',cc.genconfig(),scheme='md5_crypt')\n  self.assertEqual(cc.identify(h),'md5_crypt')\n  \n  self.assertRaises(ValueError,cc.genhash,'secret',cc.genconfig(),scheme=\"des_crypt\")\n  \n def test_41_genconfig(self):\n  ''\n  cc=CryptContext(schemes=[\"md5_crypt\",\"phpass\"],\n  phpass__ident=\"H\",\n  phpass__default_rounds=7,\n  admin__phpass__ident=\"P\",\n  )\n  \n  \n  self.assertTrue(cc.genconfig().startswith(\"$1$\"))\n  \n  \n  self.assertTrue(cc.genconfig(scheme=\"phpass\").startswith(\"$H$5\"))\n  \n  \n  self.assertTrue(cc.genconfig(scheme=\"phpass\",category=\"admin\").startswith(\"$P$5\"))\n  self.assertTrue(cc.genconfig(scheme=\"phpass\",category=\"staff\").startswith(\"$H$5\"))\n  \n  \n  self.assertEqual(\n  cc.genconfig(scheme=\"phpass\",salt='.'*8,rounds=8,ident='P'),\n  '$P$6........22zGEuacuPOqEpYPDeR0R/',\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n  if PY2:\n   c2=cc.copy(default=\"phpass\")\n   self.assertTrue(c2.genconfig(category=u(\"admin\")).startswith(\"$P$5\"))\n   self.assertTrue(c2.genconfig(category=u(\"staff\")).startswith(\"$H$5\"))\n   \n   \n  self.assertRaises(KeyError,CryptContext().genconfig)\n  self.assertRaises(KeyError,CryptContext().genconfig,scheme='md5_crypt')\n  \n  \n  self.assertRaises(KeyError,cc.genconfig,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.genconfig,scheme=1,category='staff')\n  self.assertRaises(TypeError,cc.genconfig,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.genconfig,category=1)\n  \n  \n def test_42_genhash(self):\n  ''\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  hash=cc.hash('stub')\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.genhash,secret,hash,**kwds)\n   \n   \n  cc=CryptContext([\"des_crypt\"])\n  for config,kwds in self.nonstring_vectors:\n   if hash is None :\n   \n   \n    continue\n   self.assertRaises(TypeError,cc.genhash,'secret',config,**kwds)\n   \n   \n  cc=CryptContext([\"mysql323\"])\n  self.assertRaises(TypeError,cc.genhash,\"stub\",None )\n  \n  \n  self.assertRaises(KeyError,CryptContext().genhash,'secret','hash')\n  \n  \n  self.assertRaises(KeyError,cc.genhash,'secret',hash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.genhash,'secret',hash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.genconfig,'secret',hash,category=1)\n  \n def test_43_hash(self,):\n  ''\n  \n  \n  \n  \n  cc=CryptContext(**self.sample_4_dict)\n  hash=cc.hash(\"password\")\n  self.assertTrue(hash.startswith(\"$5$rounds=3000$\"))\n  self.assertTrue(cc.verify(\"password\",hash))\n  self.assertFalse(cc.verify(\"passwordx\",hash))\n  \n  \n  \n  self.assertRaises(ValueError,cc.copy,\n  sha256_crypt__default_rounds=4000)\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.hash,secret,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().hash,'secret')\n  \n  \n  self.assertRaises(TypeError,cc.hash,'secret',category=1)\n  \n def test_43_hash_legacy(self,use_16_legacy=False ):\n  ''\n  cc=CryptContext(**self.sample_4_dict)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",scheme=\"phpass\",salt='.'*8),\n   '$H$5........De04R5Egz0aq8Tf.1eVhY/',\n   )\n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",scheme=\"phpass\",salt='.'*8,ident=\"P\"),\n   '$P$5........De04R5Egz0aq8Tf.1eVhY/',\n   )\n   \n   \n   \n   \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",rounds=1999,salt=\"nacl\"),\n   '$5$rounds=1999$nacl$nmfwJIxqj0csloAAvSER0B8LU0ERCAbhmMug4Twl609',\n   )\n   \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",rounds=2001,salt=\"nacl\"),\n   '$5$rounds=2001$nacl$8PdeoPL4aXQnJ0woHhqgIw/efyfCKC2WHneOpnvF.31'\n   )\n   \n   \n   \n  self.assertRaises(KeyError,cc.hash,'secret',scheme=\"fake\")\n  self.assertRaises(TypeError,cc.hash,'secret',scheme=1)\n  \n def test_44_identify(self):\n  ''\n  handlers=[\"md5_crypt\",\"des_crypt\",\"bsdi_crypt\"]\n  cc=CryptContext(handlers,bsdi_crypt__default_rounds=5)\n  \n  \n  self.assertEqual(cc.identify('$9$232323123$1287319827'),None )\n  self.assertRaises(ValueError,cc.identify,'$9$232323123$1287319827',required=True )\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.identify,hash,**kwds)\n   \n   \n  cc=CryptContext()\n  self.assertIs(cc.identify('hash'),None )\n  self.assertRaises(KeyError,cc.identify,'hash',required=True )\n  \n  \n  self.assertRaises(TypeError,cc.identify,None ,category=1)\n  \n def test_45_verify(self):\n  ''\n  handlers=[\"md5_crypt\",\"des_crypt\",\"bsdi_crypt\"]\n  cc=CryptContext(handlers,bsdi_crypt__default_rounds=5)\n  \n  h=hash.md5_crypt.hash(\"test\")\n  \n  \n  self.assertTrue(cc.verify(\"test\",h))\n  self.assertTrue(not cc.verify(\"notest\",h))\n  \n  \n  self.assertTrue(cc.verify('test',h,scheme='md5_crypt'))\n  self.assertTrue(not cc.verify('notest',h,scheme='md5_crypt'))\n  \n  \n  self.assertRaises(ValueError,cc.verify,'test',h,scheme='bsdi_crypt')\n  \n  \n  \n  \n  \n  \n  self.assertRaises(ValueError,cc.verify,'stub','$6$232323123$1287319827')\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  h=refhash=cc.hash('stub')\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.verify,secret,h,**kwds)\n   \n   \n  self.assertFalse(cc.verify(secret,None ))\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for h,kwds in self.nonstring_vectors:\n   if h is None :\n    continue\n   self.assertRaises(TypeError,cc.verify,'secret',h,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().verify,'secret','hash')\n  \n  \n  self.assertRaises(KeyError,cc.verify,'secret',refhash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.verify,'secret',refhash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.verify,'secret',refhash,category=1)\n  \n def test_46_needs_update(self):\n  ''\n  cc=CryptContext(**self.sample_4_dict)\n  \n  \n  self.assertTrue(cc.needs_update('9XXD4trGYeGJA'))\n  self.assertFalse(cc.needs_update('$1$J8HC2RCr$HcmM.7NxB2weSvlw2FgzU0'))\n  \n  \n  self.assertTrue(cc.needs_update('$5$rounds=1999$jD81UCoo.zI.UETs$Y7qSTQ6mTiU9qZB4fRr43wRgQq4V.5AAf7F97Pzxey/'))\n  self.assertFalse(cc.needs_update('$5$rounds=2000$228SSRje04cnNCaQ$YGV4RYu.5sNiBvorQDlO0WWQjyJVGKBcJXz3OtyQ2u8'))\n  \n  \n  self.assertFalse(cc.needs_update('$5$rounds=3000$fS9iazEwTKi7QPW4$VasgBC8FqlOvD7x2HhABaMXCTh9jwHclPA9j5YQdns.'))\n  self.assertTrue(cc.needs_update('$5$rounds=3001$QlFHHifXvpFX4PLs$/0ekt7lSs/lOikSerQ0M/1porEHxYq7W/2hdFpxA3fA'))\n  \n  \n  \n  \n  check_state=[]\n  class dummy(uh.StaticHandler):\n   name='dummy'\n   _hash_prefix='@'\n   \n   @classmethod\n   def needs_update(cls,hash,secret=None ):\n    check_state.append((hash,secret))\n    return secret ==\"nu\"\n    \n   def _calc_checksum(self,secret):\n    from hashlib import md5\n    if isinstance(secret,unicode):\n     secret=secret.encode(\"utf-8\")\n    return str_to_uascii(md5(secret).hexdigest())\n    \n    \n  ctx=CryptContext([dummy])\n  hash=refhash=dummy.hash(\"test\")\n  self.assertFalse(ctx.needs_update(hash))\n  self.assertEqual(check_state,[(hash,None )])\n  del check_state[:]\n  \n  \n  self.assertFalse(ctx.needs_update(hash,secret='bob'))\n  self.assertEqual(check_state,[(hash,'bob')])\n  del check_state[:]\n  \n  \n  self.assertTrue(ctx.needs_update(hash,secret='nu'))\n  self.assertEqual(check_state,[(hash,'nu')])\n  del check_state[:]\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.needs_update,hash,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().needs_update,'hash')\n  \n  \n  self.assertRaises(KeyError,cc.needs_update,refhash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.needs_update,refhash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.needs_update,refhash,category=1)\n  \n def test_47_verify_and_update(self):\n  ''\n  cc=CryptContext(**self.sample_4_dict)\n  \n  \n  h1=cc.handler(\"des_crypt\").hash(\"password\")\n  h2=cc.handler(\"sha256_crypt\").hash(\"password\")\n  \n  \n  ok,new_hash=cc.verify_and_update(\"wrongpass\",h1)\n  self.assertFalse(ok)\n  self.assertIs(new_hash,None )\n  \n  \n  ok,new_hash=cc.verify_and_update(\"wrongpass\",h2)\n  self.assertFalse(ok)\n  self.assertIs(new_hash,None )\n  \n  \n  ok,new_hash=cc.verify_and_update(\"password\",h1)\n  self.assertTrue(ok)\n  self.assertTrue(cc.identify(new_hash),\"sha256_crypt\")\n  \n  \n  ok,new_hash=cc.verify_and_update(\"password\",h2)\n  self.assertTrue(ok)\n  self.assertIs(new_hash,None )\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  hash=refhash=cc.hash('stub')\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.verify_and_update,secret,hash,**kwds)\n   \n   \n  self.assertEqual(cc.verify_and_update(secret,None ),(False ,None ))\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in self.nonstring_vectors:\n   if hash is None :\n    continue\n   self.assertRaises(TypeError,cc.verify_and_update,'secret',hash,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().verify_and_update,'secret','hash')\n  \n  \n  self.assertRaises(KeyError,cc.verify_and_update,'secret',refhash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.verify_and_update,'secret',refhash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.verify_and_update,'secret',refhash,category=1)\n  \n def test_48_context_kwds(self):\n  ''\n  \n  \n  \n  from passlib.hash import des_crypt,md5_crypt,postgres_md5\n  des_hash=des_crypt.hash(\"stub\")\n  pg_root_hash=postgres_md5.hash(\"stub\",user=\"root\")\n  pg_admin_hash=postgres_md5.hash(\"stub\",user=\"admin\")\n  \n  \n  \n  \n  cc1=CryptContext([des_crypt,md5_crypt])\n  self.assertEqual(cc1.context_kwds,set())\n  \n  \n  self.assertTrue(des_crypt.identify(cc1.hash(\"stub\")),\"des_crypt\")\n  self.assertTrue(cc1.verify(\"stub\",des_hash))\n  self.assertEqual(cc1.verify_and_update(\"stub\",des_hash),(True ,None ))\n  \n  \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertRaises(TypeError,cc1.hash,\"stub\",user=\"root\")\n  self.assertRaises(TypeError,cc1.verify,\"stub\",des_hash,user=\"root\")\n  self.assertRaises(TypeError,cc1.verify_and_update,\"stub\",des_hash,user=\"root\")\n  \n  \n  \n  \n  cc2=CryptContext([des_crypt,postgres_md5])\n  self.assertEqual(cc2.context_kwds,set([\"user\"]))\n  \n  \n  self.assertTrue(des_crypt.identify(cc2.hash(\"stub\")),\"des_crypt\")\n  self.assertTrue(cc2.verify(\"stub\",des_hash))\n  self.assertEqual(cc2.verify_and_update(\"stub\",des_hash),(True ,None ))\n  \n  \n  self.assertTrue(des_crypt.identify(cc2.hash(\"stub\",user=\"root\")),\"des_crypt\")\n  self.assertTrue(cc2.verify(\"stub\",des_hash,user=\"root\"))\n  self.assertEqual(cc2.verify_and_update(\"stub\",des_hash,user=\"root\"),(True ,None ))\n  \n  \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertRaises(TypeError,cc2.hash,\"stub\",badkwd=\"root\")\n  self.assertRaises(TypeError,cc2.verify,\"stub\",des_hash,badkwd=\"root\")\n  self.assertRaises(TypeError,cc2.verify_and_update,\"stub\",des_hash,badkwd=\"root\")\n  \n  \n  \n  \n  cc3=CryptContext([postgres_md5,des_crypt],deprecated=\"auto\")\n  self.assertEqual(cc3.context_kwds,set([\"user\"]))\n  \n  \n  self.assertRaises(TypeError,cc3.hash,\"stub\")\n  self.assertRaises(TypeError,cc3.verify,\"stub\",pg_root_hash)\n  self.assertRaises(TypeError,cc3.verify_and_update,\"stub\",pg_root_hash)\n  \n  \n  self.assertEqual(cc3.hash(\"stub\",user=\"root\"),pg_root_hash)\n  self.assertTrue(cc3.verify(\"stub\",pg_root_hash,user=\"root\"))\n  self.assertEqual(cc3.verify_and_update(\"stub\",pg_root_hash,user=\"root\"),(True ,None ))\n  \n  \n  self.assertEqual(cc3.verify_and_update(\"stub\",pg_root_hash,user=\"admin\"),(False ,None ))\n  \n  \n  self.assertEqual(cc3.verify_and_update(\"stub\",des_hash,user=\"root\"),\n  (True ,pg_root_hash))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_50_rounds_limits(self):\n  ''\n  cc=CryptContext(schemes=[\"sha256_crypt\"],\n  sha256_crypt__min_rounds=2000,\n  sha256_crypt__max_rounds=3000,\n  sha256_crypt__default_rounds=2500,\n  )\n  \n  \n  STUB='...........................................'\n  \n  \n  \n  \n  \n  custom_handler=cc._get_record(\"sha256_crypt\",None )\n  self.assertEqual(custom_handler.min_desired_rounds,2000)\n  self.assertEqual(custom_handler.max_desired_rounds,3000)\n  self.assertEqual(custom_handler.default_rounds,2500)\n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([PasslibHashWarning]*2):\n   c2=cc.copy(sha256_crypt__min_rounds=500,sha256_crypt__max_rounds=None ,\n   sha256_crypt__default_rounds=500)\n  self.assertEqual(c2.genconfig(salt=\"nacl\"),\"$5$rounds=1000$nacl$\"+STUB)\n  \n  \n  \n  with self.assertWarningList([]):\n   self.assertEqual(\n   cc.genconfig(rounds=1999,salt=\"nacl\"),'$5$rounds=1999$nacl$'+STUB)\n   \n   \n  self.assertEqual(\n  cc.genconfig(rounds=2000,salt=\"nacl\"),'$5$rounds=2000$nacl$'+STUB)\n  \n  \n  self.assertEqual(\n  cc.genconfig(rounds=2001,salt=\"nacl\"),'$5$rounds=2001$nacl$'+STUB)\n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([PasslibHashWarning]*2):\n   c2=cc.copy(sha256_crypt__max_rounds=int(1e9)+500,sha256_crypt__min_rounds=None ,\n   sha256_crypt__default_rounds=int(1e9)+500)\n   \n  self.assertEqual(c2.genconfig(salt=\"nacl\"),\"$5$rounds=999999999$nacl$\"+STUB)\n  \n  \n  \n  with self.assertWarningList([]):\n   self.assertEqual(\n   cc.genconfig(rounds=3001,salt=\"nacl\"),'$5$rounds=3001$nacl$'+STUB)\n   \n   \n  self.assertEqual(\n  cc.genconfig(rounds=3000,salt=\"nacl\"),'$5$rounds=3000$nacl$'+STUB)\n  \n  \n  self.assertEqual(\n  cc.genconfig(rounds=2999,salt=\"nacl\"),'$5$rounds=2999$nacl$'+STUB)\n  \n  \n  \n  \n  \n  \n  self.assertEqual(cc.genconfig(salt=\"nacl\"),'$5$rounds=2500$nacl$'+STUB)\n  \n  \n  df=hash.sha256_crypt.default_rounds\n  c2=cc.copy(sha256_crypt__default_rounds=None ,sha256_crypt__max_rounds=df <<1)\n  self.assertEqual(c2.genconfig(salt=\"nacl\"),'$5$rounds=%d$nacl$%s'%(df,STUB))\n  \n  \n  c2=cc.copy(sha256_crypt__default_rounds=None ,sha256_crypt__max_rounds=3000)\n  self.assertEqual(c2.genconfig(salt=\"nacl\"),'$5$rounds=3000$nacl$'+STUB)\n  \n  \n  \n  \n  self.assertRaises(ValueError,cc.copy,sha256_crypt__default_rounds=1999)\n  cc.copy(sha256_crypt__default_rounds=2000)\n  cc.copy(sha256_crypt__default_rounds=3000)\n  self.assertRaises(ValueError,cc.copy,sha256_crypt__default_rounds=3001)\n  \n  \n  \n  \n  \n  \n  c2=CryptContext(schemes=[\"sha256_crypt\"])\n  \n  \n  \n  self.assertRaises(ValueError,c2.copy,sha256_crypt__min_rounds=2000,\n  sha256_crypt__max_rounds=1999)\n  \n  \n  self.assertRaises(ValueError,CryptContext,sha256_crypt__min_rounds='x')\n  self.assertRaises(ValueError,CryptContext,sha256_crypt__max_rounds='x')\n  self.assertRaises(ValueError,CryptContext,all__vary_rounds='x')\n  self.assertRaises(ValueError,CryptContext,sha256_crypt__default_rounds='x')\n  \n  \n  bad=datetime.datetime.now()\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",sha256_crypt__min_rounds=bad)\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",sha256_crypt__max_rounds=bad)\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",all__vary_rounds=bad)\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",sha256_crypt__default_rounds=bad)\n  \n def test_51_linear_vary_rounds(self):\n  ''\n  cc=CryptContext(schemes=[\"sha256_crypt\"],\n  sha256_crypt__min_rounds=1995,\n  sha256_crypt__max_rounds=2005,\n  sha256_crypt__default_rounds=2000,\n  )\n  \n  \n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=-1)\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"-1%\")\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"101%\")\n  \n  \n  c2=cc.copy(all__vary_rounds=0)\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"sha256_crypt\",2000,2000)\n  \n  c2=cc.copy(all__vary_rounds=\"0%\")\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"sha256_crypt\",2000,2000)\n  \n  \n  c2=cc.copy(all__vary_rounds=1)\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,1)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1999,2001)\n  c2=cc.copy(all__vary_rounds=100)\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,100)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1995,2005)\n  \n  \n  c2=cc.copy(all__vary_rounds=\"0.1%\")\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,0.001)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1998,2002)\n  c2=cc.copy(all__vary_rounds=\"100%\")\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,1.0)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1995,2005)\n  \n def test_52_log2_vary_rounds(self):\n  ''\n  cc=CryptContext(schemes=[\"bcrypt\"],\n  bcrypt__min_rounds=15,\n  bcrypt__max_rounds=25,\n  bcrypt__default_rounds=20,\n  )\n  \n  \n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=-1)\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"-1%\")\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"101%\")\n  \n  \n  c2=cc.copy(all__vary_rounds=0)\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  c2=cc.copy(all__vary_rounds=\"0%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  \n  c2=cc.copy(all__vary_rounds=1)\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,1)\n  self.assert_rounds_range(c2,\"bcrypt\",19,21)\n  c2=cc.copy(all__vary_rounds=100)\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,100)\n  self.assert_rounds_range(c2,\"bcrypt\",15,25)\n  \n  \n  c2=cc.copy(all__vary_rounds=\"1%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0.01)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  c2=cc.copy(all__vary_rounds=\"49%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0.49)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  c2=cc.copy(all__vary_rounds=\"50%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0.5)\n  self.assert_rounds_range(c2,\"bcrypt\",19,20)\n  \n  c2=cc.copy(all__vary_rounds=\"100%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,1.0)\n  self.assert_rounds_range(c2,\"bcrypt\",15,21)\n  \n def assert_rounds_range(self,context,scheme,lower,upper):\n  ''\n  \n  \n  handler=context.handler(scheme)\n  salt=handler.default_salt_chars[0:1]*handler.max_salt_size\n  seen=set()\n  for i in irange(300):\n   h=context.genconfig(scheme,salt=salt)\n   r=handler.from_string(h).rounds\n   seen.add(r)\n  self.assertEqual(min(seen),lower,\"vary_rounds had wrong lower limit:\")\n  self.assertEqual(max(seen),upper,\"vary_rounds had wrong upper limit:\")\n  \n  \n  \n  \n def test_harden_verify_parsing(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\".*harden_verify.*\",\n  category=DeprecationWarning)\n  \n  \n  ctx=CryptContext(schemes=[\"sha256_crypt\"])\n  self.assertEqual(ctx.harden_verify,None )\n  self.assertEqual(ctx.using(harden_verify=\"\").harden_verify,None )\n  self.assertEqual(ctx.using(harden_verify=\"true\").harden_verify,None )\n  self.assertEqual(ctx.using(harden_verify=\"false\").harden_verify,None )\n  \n def test_dummy_verify(self):\n  ''\n\n  \n  \n  expected=0.05\n  accuracy=0.2\n  handler=DelayHash.using()\n  handler.delay=expected\n  ctx=CryptContext(schemes=[handler])\n  ctx.dummy_verify()\n  elapsed,_=time_call(ctx.dummy_verify)\n  self.assertAlmostEqual(elapsed,expected,delta=expected *accuracy)\n  \n  \n  \n  \n  \n  \n  \n def test_61_autodeprecate(self):\n  ''\n  \n  def getstate(ctx,category=None ):\n   return [ctx.handler(scheme,category).deprecated for scheme in ctx.schemes()]\n   \n   \n  ctx=CryptContext(\"sha256_crypt,md5_crypt,des_crypt\",deprecated=\"auto\")\n  self.assertEqual(getstate(ctx,None ),[False ,True ,True ])\n  self.assertEqual(getstate(ctx,\"admin\"),[False ,True ,True ])\n  \n  \n  ctx.update(default=\"md5_crypt\")\n  self.assertEqual(getstate(ctx,None ),[True ,False ,True ])\n  self.assertEqual(getstate(ctx,\"admin\"),[True ,False ,True ])\n  \n  \n  ctx.update(admin__context__default=\"des_crypt\")\n  self.assertEqual(getstate(ctx,None ),[True ,False ,True ])\n  self.assertEqual(getstate(ctx,\"admin\"),[True ,True ,False ])\n  \n  \n  ctx=CryptContext([\"sha256_crypt\"],deprecated=\"auto\")\n  self.assertEqual(getstate(ctx,None ),[False ])\n  self.assertEqual(getstate(ctx,\"admin\"),[False ])\n  \n  \n  self.assertRaises(ValueError,CryptContext,\"sha256_crypt,md5_crypt\",\n  deprecated=\"auto,md5_crypt\")\n  self.assertRaises(ValueError,CryptContext,\"sha256_crypt,md5_crypt\",\n  deprecated=\"md5_crypt,auto\")\n  \n def test_disabled_hashes(self):\n  ''\n  \n  \n  \n  from passlib.exc import UnknownHashError\n  from passlib.hash import md5_crypt,unix_disabled\n  \n  ctx=CryptContext([\"des_crypt\"])\n  ctx2=CryptContext([\"des_crypt\",\"unix_disabled\"])\n  h_ref=ctx.hash(\"foo\")\n  h_other=md5_crypt.hash('foo')\n  \n  \n  \n  \n  \n  \n  self.assertRaisesRegex(RuntimeError,\"no disabled hasher present\",\n  ctx.disable)\n  self.assertRaisesRegex(RuntimeError,\"no disabled hasher present\",\n  ctx.disable,h_ref)\n  self.assertRaisesRegex(RuntimeError,\"no disabled hasher present\",\n  ctx.disable,h_other)\n  \n  \n  h_dis=ctx2.disable()\n  self.assertEqual(h_dis,unix_disabled.default_marker)\n  h_dis_ref=ctx2.disable(h_ref)\n  self.assertEqual(h_dis_ref,unix_disabled.default_marker+h_ref)\n  \n  h_dis_other=ctx2.disable(h_other)\n  self.assertEqual(h_dis_other,unix_disabled.default_marker+h_other)\n  \n  \n  self.assertEqual(ctx2.disable(h_dis_ref),h_dis_ref)\n  \n  \n  \n  \n  \n  \n  self.assertTrue(ctx.is_enabled(h_ref))\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_other)\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_dis)\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_dis_ref)\n  \n  \n  self.assertTrue(ctx2.is_enabled(h_ref))\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_other)\n  self.assertFalse(ctx2.is_enabled(h_dis))\n  self.assertFalse(ctx2.is_enabled(h_dis_ref))\n  \n  \n  \n  \n  \n  \n  self.assertRaises(UnknownHashError,ctx.enable,\"\")\n  self.assertRaises(TypeError,ctx.enable,None )\n  self.assertEqual(ctx.enable(h_ref),h_ref)\n  self.assertRaises(UnknownHashError,ctx.enable,h_other)\n  self.assertRaises(UnknownHashError,ctx.enable,h_dis)\n  self.assertRaises(UnknownHashError,ctx.enable,h_dis_ref)\n  \n  \n  self.assertRaises(UnknownHashError,ctx.enable,\"\")\n  self.assertRaises(TypeError,ctx2.enable,None )\n  self.assertEqual(ctx2.enable(h_ref),h_ref)\n  self.assertRaises(UnknownHashError,ctx2.enable,h_other)\n  self.assertRaisesRegex(ValueError,\"cannot restore original hash\",\n  ctx2.enable,h_dis)\n  self.assertEqual(ctx2.enable(h_dis_ref),h_ref)\n  \n  \n  \n  \n  \nimport hashlib,time\n\nclass DelayHash(uh.StaticHandler):\n ''\n name=\"delay_hash\"\n checksum_chars=uh.LOWER_HEX_CHARS\n checksum_size=40\n delay=0\n _hash_prefix=u(\"$x$\")\n \n def _calc_checksum(self,secret):\n  time.sleep(self.delay)\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(hashlib.sha1(b\"prefix\"+secret).hexdigest())\n  \n  \n  \n  \nclass dummy_2(uh.StaticHandler):\n name=\"dummy_2\"\n \nclass LazyCryptContextTest(TestCase):\n descriptionPrefix=\"LazyCryptContext\"\n \n def setUp(self):\n \n  unload_handler_name(\"dummy_2\")\n  self.addCleanup(unload_handler_name,\"dummy_2\")\n  \n def test_kwd_constructor(self):\n  ''\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  cc=LazyCryptContext(iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertEqual(cc.schemes(),(\"dummy_2\",\"des_crypt\"))\n  self.assertTrue(cc.handler(\"des_crypt\").deprecated)\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n def test_callable_constructor(self):\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  def onload(flag=False ):\n   self.assertTrue(flag)\n   return dict(schemes=iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n   \n  cc=LazyCryptContext(onload=onload,flag=True )\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertEqual(cc.schemes(),(\"dummy_2\",\"des_crypt\"))\n  self.assertTrue(cc.handler(\"des_crypt\").deprecated)\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n  \n  \n  \n", ["ConfigParser", "__future__", "configparser", "datetime", "functools", "hashlib", "logging", "os", "passlib", "passlib.context", "passlib.exc", "passlib.hash", "passlib.registry", "passlib.tests.test_utils_handlers", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "time", "warnings"]], "passlib.tests.test_context_deprecated": [".py", "''\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement\n\nfrom logging import getLogger\nimport os\nimport warnings\n\ntry :\n from pkg_resources import resource_filename\nexcept ImportError:\n resource_filename=None\n \nfrom passlib import hash\nfrom passlib.context import CryptContext,CryptPolicy,LazyCryptContext\nfrom passlib.utils import to_bytes,to_unicode\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import TestCase,set_file\nfrom passlib.registry import (register_crypt_handler_path,\n_has_crypt_handler as has_crypt_handler,\n_unload_handler_name as unload_handler_name,\n)\n\nlog=getLogger(__name__)\n\n\n\n\nclass CryptPolicyTest(TestCase):\n ''\n \n \n \n descriptionPrefix=\"CryptPolicy\"\n \n \n \n \n \n \n \n \n \n sample_config_1s=\"\"\"\\\n[passlib]\nschemes = des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\ndefault = md5_crypt\nall.vary_rounds = 10%%\nbsdi_crypt.max_rounds = 30000\nbsdi_crypt.default_rounds = 25000\nsha512_crypt.max_rounds = 50000\nsha512_crypt.min_rounds = 40000\n\"\"\"\n sample_config_1s_path=os.path.abspath(os.path.join(\n os.path.dirname(__file__),\"sample_config_1s.cfg\"))\n if not os.path.exists(sample_config_1s_path)and resource_filename:\n \n  sample_config_1s_path=resource_filename(\"passlib.tests\",\n  \"sample_config_1s.cfg\")\n  \n  \n assert sample_config_1s.startswith(\"[passlib]\\nschemes\")\n \n sample_config_1pd=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n default=\"md5_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__max_rounds=30000,\n bsdi_crypt__default_rounds=25000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=40000,\n )\n \n sample_config_1pid={\n \"schemes\":\"des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\",\n \"default\":\"md5_crypt\",\n \n \"all.vary_rounds\":0.1,\n \"bsdi_crypt.max_rounds\":30000,\n \"bsdi_crypt.default_rounds\":25000,\n \"sha512_crypt.max_rounds\":50000,\n \"sha512_crypt.min_rounds\":40000,\n }\n \n sample_config_1prd=dict(\n schemes=[hash.des_crypt,hash.md5_crypt,hash.bsdi_crypt,hash.sha512_crypt],\n default=\"md5_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__max_rounds=30000,\n bsdi_crypt__default_rounds=25000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=40000,\n )\n \n \n \n \n sample_config_2s=\"\"\"\\\n[passlib]\nbsdi_crypt.min_rounds = 29000\nbsdi_crypt.max_rounds = 35000\nbsdi_crypt.default_rounds = 31000\nsha512_crypt.min_rounds = 45000\n\"\"\"\n \n sample_config_2pd=dict(\n \n bsdi_crypt__min_rounds=29000,\n bsdi_crypt__max_rounds=35000,\n bsdi_crypt__default_rounds=31000,\n \n sha512_crypt__min_rounds=45000,\n )\n \n sample_config_12pd=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n default=\"md5_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__min_rounds=29000,\n bsdi_crypt__max_rounds=35000,\n bsdi_crypt__default_rounds=31000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=45000,\n )\n \n \n \n \n sample_config_3pd=dict(\n default=\"sha512_crypt\",\n )\n \n sample_config_123pd=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n default=\"sha512_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__min_rounds=29000,\n bsdi_crypt__max_rounds=35000,\n bsdi_crypt__default_rounds=31000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=45000,\n )\n \n \n \n \n sample_config_4s=\"\"\"\n[passlib]\nschemes = sha512_crypt\nall.vary_rounds = 10%%\ndefault.sha512_crypt.max_rounds = 20000\nadmin.all.vary_rounds = 5%%\nadmin.sha512_crypt.max_rounds = 40000\n\"\"\"\n \n sample_config_4pd=dict(\n schemes=[\"sha512_crypt\"],\n \n all__vary_rounds=0.1,\n sha512_crypt__max_rounds=20000,\n \n admin__all__vary_rounds=0.05,\n admin__sha512_crypt__max_rounds=40000,\n )\n \n \n \n \n sample_config_5s=sample_config_1s+\"\"\"\\\ndeprecated = des_crypt\nadmin__context__deprecated = des_crypt, bsdi_crypt\n\"\"\"\n \n sample_config_5pd=sample_config_1pd.copy()\n sample_config_5pd.update(\n deprecated=[\"des_crypt\"],\n admin__context__deprecated=[\"des_crypt\",\"bsdi_crypt\"],\n )\n \n sample_config_5pid=sample_config_1pid.copy()\n sample_config_5pid.update({\n \"deprecated\":\"des_crypt\",\n \"admin.context.deprecated\":\"des_crypt, bsdi_crypt\",\n })\n \n sample_config_5prd=sample_config_1prd.copy()\n sample_config_5prd.update({\n \n \n \"deprecated\":[\"des_crypt\"],\n \"admin__context__deprecated\":[\"des_crypt\",\"bsdi_crypt\"],\n })\n \n \n \n \n def setUp(self):\n  TestCase.setUp(self)\n  warnings.filterwarnings(\"ignore\",\n  r\"The CryptPolicy class has been deprecated\")\n  warnings.filterwarnings(\"ignore\",\n  r\"the method.*hash_needs_update.*is deprecated\")\n  warnings.filterwarnings(\"ignore\",\"The 'all' scheme is deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\"bsdi_crypt rounds should be odd\")\n  \n def test_00_constructor(self):\n  ''\n  policy=CryptPolicy(**self.sample_config_1pd)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  policy=CryptPolicy(self.sample_config_1pd)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  self.assertRaises(TypeError,CryptPolicy,{},{})\n  self.assertRaises(TypeError,CryptPolicy,{},dummy=1)\n  \n  \n  self.assertRaises(TypeError,CryptPolicy,\n  schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n  bad__key__bsdi_crypt__max_rounds=30000,\n  )\n  \n  \n  class nameless(uh.StaticHandler):\n   name=None\n  self.assertRaises(ValueError,CryptPolicy,schemes=[nameless])\n  \n  \n  self.assertRaises(TypeError,CryptPolicy,schemes=[uh.StaticHandler])\n  \n  \n  class dummy_1(uh.StaticHandler):\n   name='dummy_1'\n  self.assertRaises(KeyError,CryptPolicy,schemes=[dummy_1,dummy_1])\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=['des_crypt'],\n  deprecated=['md5_crypt'])\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=['des_crypt'],\n  default='md5_crypt')\n  \n def test_01_from_path_simple(self):\n  ''\n  \n  \n  \n  path=self.sample_config_1s_path\n  policy=CryptPolicy.from_path(path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  self.assertRaises(EnvironmentError,CryptPolicy.from_path,path+'xxx')\n  \n def test_01_from_path(self):\n  ''\n  path=self.mktemp()\n  \n  \n  set_file(path,self.sample_config_1s)\n  policy=CryptPolicy.from_path(path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  set_file(path,self.sample_config_1s.replace(\"\\n\",\"\\r\\n\"))\n  policy=CryptPolicy.from_path(path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  uc2=to_bytes(self.sample_config_1s,\"utf-16\",source_encoding=\"utf-8\")\n  set_file(path,uc2)\n  policy=CryptPolicy.from_path(path,encoding=\"utf-16\")\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n def test_02_from_string(self):\n  ''\n  \n  policy=CryptPolicy.from_string(self.sample_config_1s)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_string(\n  self.sample_config_1s.replace(\"\\n\",\"\\r\\n\"))\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  data=to_unicode(self.sample_config_1s)\n  policy=CryptPolicy.from_string(data)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  uc2=to_bytes(self.sample_config_1s,\"utf-16\",source_encoding=\"utf-8\")\n  policy=CryptPolicy.from_string(uc2,encoding=\"utf-16\")\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_string(self.sample_config_4s)\n  self.assertEqual(policy.to_dict(),self.sample_config_4pd)\n  \n def test_03_from_source(self):\n  ''\n  \n  policy=CryptPolicy.from_source(self.sample_config_1s_path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_source(self.sample_config_1s)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_source(self.sample_config_1pd.copy())\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  p2=CryptPolicy.from_source(policy)\n  self.assertIs(policy,p2)\n  \n  \n  self.assertRaises(TypeError,CryptPolicy.from_source,1)\n  self.assertRaises(TypeError,CryptPolicy.from_source,[])\n  \n def test_04_from_sources(self):\n  ''\n  \n  \n  self.assertRaises(ValueError,CryptPolicy.from_sources,[])\n  \n  \n  policy=CryptPolicy.from_sources([self.sample_config_1s])\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_sources(\n  [\n  self.sample_config_1s_path,\n  self.sample_config_2s,\n  self.sample_config_3pd,\n  ])\n  self.assertEqual(policy.to_dict(),self.sample_config_123pd)\n  \n def test_05_replace(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  \n  \n  p2=p1.replace(**self.sample_config_2pd)\n  self.assertEqual(p2.to_dict(),self.sample_config_12pd)\n  \n  \n  p2b=p2.replace(**self.sample_config_2pd)\n  self.assertEqual(p2b.to_dict(),self.sample_config_12pd)\n  \n  \n  p3=p2.replace(self.sample_config_3pd)\n  self.assertEqual(p3.to_dict(),self.sample_config_123pd)\n  \n def test_06_forbidden(self):\n  ''\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=[\"des_crypt\"],\n  des_crypt__salt=\"xx\",\n  )\n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=[\"des_crypt\"],\n  all__salt=\"xx\",\n  )\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=[\"des_crypt\"],\n  user__context__schemes=[\"md5_crypt\"],\n  )\n  \n  \n  \n  \n def test_10_has_schemes(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  self.assertTrue(p1.has_schemes())\n  \n  p3=CryptPolicy(**self.sample_config_3pd)\n  self.assertTrue(not p3.has_schemes())\n  \n def test_11_iter_handlers(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  s=self.sample_config_1prd['schemes']\n  self.assertEqual(list(p1.iter_handlers()),s)\n  \n  p3=CryptPolicy(**self.sample_config_3pd)\n  self.assertEqual(list(p3.iter_handlers()),[])\n  \n def test_12_get_handler(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  \n  \n  self.assertIs(p1.get_handler(\"bsdi_crypt\"),hash.bsdi_crypt)\n  \n  \n  self.assertIs(p1.get_handler(\"sha256_crypt\"),None )\n  self.assertRaises(KeyError,p1.get_handler,\"sha256_crypt\",required=True )\n  \n  \n  self.assertIs(p1.get_handler(),hash.md5_crypt)\n  \n def test_13_get_options(self):\n  ''\n  \n  p12=CryptPolicy(**self.sample_config_12pd)\n  \n  self.assertEqual(p12.get_options(\"bsdi_crypt\"),dict(\n  \n  vary_rounds=0.1,\n  min_rounds=29000,\n  max_rounds=35000,\n  default_rounds=31000,\n  ))\n  \n  self.assertEqual(p12.get_options(\"sha512_crypt\"),dict(\n  \n  vary_rounds=0.1,\n  min_rounds=45000,\n  max_rounds=50000,\n  ))\n  \n  p4=CryptPolicy.from_string(self.sample_config_4s)\n  self.assertEqual(p4.get_options(\"sha512_crypt\"),dict(\n  \n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(p4.get_options(\"sha512_crypt\",\"user\"),dict(\n  \n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(p4.get_options(\"sha512_crypt\",\"admin\"),dict(\n  \n  vary_rounds=0.05,\n  max_rounds=40000,\n  ))\n  \n def test_14_handler_is_deprecated(self):\n  ''\n  pa=CryptPolicy(**self.sample_config_1pd)\n  pb=CryptPolicy(**self.sample_config_5pd)\n  \n  self.assertFalse(pa.handler_is_deprecated(\"des_crypt\"))\n  self.assertFalse(pa.handler_is_deprecated(hash.bsdi_crypt))\n  self.assertFalse(pa.handler_is_deprecated(\"sha512_crypt\"))\n  \n  self.assertTrue(pb.handler_is_deprecated(\"des_crypt\"))\n  self.assertFalse(pb.handler_is_deprecated(hash.bsdi_crypt))\n  self.assertFalse(pb.handler_is_deprecated(\"sha512_crypt\"))\n  \n  \n  self.assertTrue(pb.handler_is_deprecated(\"des_crypt\",\"user\"))\n  self.assertFalse(pb.handler_is_deprecated(\"bsdi_crypt\",\"user\"))\n  self.assertTrue(pb.handler_is_deprecated(\"des_crypt\",\"admin\"))\n  self.assertTrue(pb.handler_is_deprecated(\"bsdi_crypt\",\"admin\"))\n  \n  \n  pc=CryptPolicy(\n  schemes=[\"md5_crypt\",\"des_crypt\"],\n  deprecated=[\"md5_crypt\"],\n  user__context__deprecated=[\"des_crypt\"],\n  )\n  self.assertTrue(pc.handler_is_deprecated(\"md5_crypt\"))\n  self.assertFalse(pc.handler_is_deprecated(\"des_crypt\"))\n  self.assertFalse(pc.handler_is_deprecated(\"md5_crypt\",\"user\"))\n  self.assertTrue(pc.handler_is_deprecated(\"des_crypt\",\"user\"))\n  \n def test_15_min_verify_time(self):\n  ''\n  \n  warnings.filterwarnings(\"ignore\",category=DeprecationWarning)\n  \n  pa=CryptPolicy()\n  self.assertEqual(pa.get_min_verify_time(),0)\n  self.assertEqual(pa.get_min_verify_time('admin'),0)\n  \n  pb=pa.replace(min_verify_time=.1)\n  self.assertEqual(pb.get_min_verify_time(),0)\n  self.assertEqual(pb.get_min_verify_time('admin'),0)\n  \n  \n  \n  \n def test_20_iter_config(self):\n  ''\n  p5=CryptPolicy(**self.sample_config_5pd)\n  self.assertEqual(dict(p5.iter_config()),self.sample_config_5pd)\n  self.assertEqual(dict(p5.iter_config(resolve=True )),self.sample_config_5prd)\n  self.assertEqual(dict(p5.iter_config(ini=True )),self.sample_config_5pid)\n  \n def test_21_to_dict(self):\n  ''\n  p5=CryptPolicy(**self.sample_config_5pd)\n  self.assertEqual(p5.to_dict(),self.sample_config_5pd)\n  self.assertEqual(p5.to_dict(resolve=True ),self.sample_config_5prd)\n  \n def test_22_to_string(self):\n  ''\n  pa=CryptPolicy(**self.sample_config_5pd)\n  s=pa.to_string()\n  pb=CryptPolicy.from_string(s)\n  self.assertEqual(pb.to_dict(),self.sample_config_5pd)\n  \n  s=pa.to_string(encoding=\"latin-1\")\n  self.assertIsInstance(s,bytes)\n  \n  \n  \n  \n  \n  \n  \n  \nclass CryptContextTest(TestCase):\n ''\n descriptionPrefix=\"CryptContext\"\n \n def setUp(self):\n  TestCase.setUp(self)\n  warnings.filterwarnings(\"ignore\",\n  r\"CryptContext\\(\\)\\.replace\\(\\) has been deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\n  r\"The CryptContext ``policy`` keyword has been deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\".*(CryptPolicy|context\\.policy).*(has|have) been deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\n  r\"the method.*hash_needs_update.*is deprecated\")\n  \n  \n  \n  \n def test_00_constructor(self):\n  ''\n  \n  cc=CryptContext([hash.md5_crypt,hash.bsdi_crypt,hash.des_crypt])\n  c,b,a=cc.policy.iter_handlers()\n  self.assertIs(a,hash.des_crypt)\n  self.assertIs(b,hash.bsdi_crypt)\n  self.assertIs(c,hash.md5_crypt)\n  \n  \n  cc=CryptContext([\"md5_crypt\",\"bsdi_crypt\",\"des_crypt\"])\n  c,b,a=cc.policy.iter_handlers()\n  self.assertIs(a,hash.des_crypt)\n  self.assertIs(b,hash.bsdi_crypt)\n  self.assertIs(c,hash.md5_crypt)\n  \n  \n  policy=cc.policy\n  cc=CryptContext(policy=policy)\n  self.assertEqual(cc.to_dict(),policy.to_dict())\n  \n  cc=CryptContext(policy=policy,default=\"bsdi_crypt\")\n  self.assertNotEqual(cc.to_dict(),policy.to_dict())\n  self.assertEqual(cc.to_dict(),dict(schemes=[\"md5_crypt\",\"bsdi_crypt\",\"des_crypt\"],\n  default=\"bsdi_crypt\"))\n  \n  self.assertRaises(TypeError,setattr,cc,'policy',None )\n  self.assertRaises(TypeError,CryptContext,policy='x')\n  \n def test_01_replace(self):\n  ''\n  \n  cc=CryptContext([\"md5_crypt\",\"bsdi_crypt\",\"des_crypt\"])\n  self.assertIs(cc.policy.get_handler(),hash.md5_crypt)\n  \n  cc2=cc.replace()\n  self.assertIsNot(cc2,cc)\n  \n  \n  \n  cc3=cc.replace(default=\"bsdi_crypt\")\n  self.assertIsNot(cc3,cc)\n  \n  \n  self.assertIs(cc3.policy.get_handler(),hash.bsdi_crypt)\n  \n def test_02_no_handlers(self):\n  ''\n  \n  \n  cc=CryptContext()\n  self.assertRaises(KeyError,cc.identify,'hash',required=True )\n  self.assertRaises(KeyError,cc.hash,'secret')\n  self.assertRaises(KeyError,cc.verify,'secret','hash')\n  \n  \n  cc=CryptContext(['md5_crypt'])\n  p=CryptPolicy(schemes=[])\n  cc.policy=p\n  \n  self.assertRaises(KeyError,cc.identify,'hash',required=True )\n  self.assertRaises(KeyError,cc.hash,'secret')\n  self.assertRaises(KeyError,cc.verify,'secret','hash')\n  \n  \n  \n  \n sample_policy_1=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"phpass\",\"bsdi_crypt\",\n \"sha256_crypt\"],\n deprecated=[\"des_crypt\",],\n default=\"sha256_crypt\",\n bsdi_crypt__max_rounds=30,\n bsdi_crypt__default_rounds=25,\n bsdi_crypt__vary_rounds=0,\n sha256_crypt__max_rounds=3000,\n sha256_crypt__min_rounds=2000,\n sha256_crypt__default_rounds=3000,\n phpass__ident=\"H\",\n phpass__default_rounds=7,\n )\n \n def test_12_hash_needs_update(self):\n  ''\n  cc=CryptContext(**self.sample_policy_1)\n  \n  \n  self.assertTrue(cc.hash_needs_update('9XXD4trGYeGJA'))\n  self.assertFalse(cc.hash_needs_update('$1$J8HC2RCr$HcmM.7NxB2weSvlw2FgzU0'))\n  \n  \n  self.assertTrue(cc.hash_needs_update('$5$rounds=1999$jD81UCoo.zI.UETs$Y7qSTQ6mTiU9qZB4fRr43wRgQq4V.5AAf7F97Pzxey/'))\n  self.assertFalse(cc.hash_needs_update('$5$rounds=2000$228SSRje04cnNCaQ$YGV4RYu.5sNiBvorQDlO0WWQjyJVGKBcJXz3OtyQ2u8'))\n  \n  \n  self.assertFalse(cc.hash_needs_update('$5$rounds=3000$fS9iazEwTKi7QPW4$VasgBC8FqlOvD7x2HhABaMXCTh9jwHclPA9j5YQdns.'))\n  self.assertTrue(cc.hash_needs_update('$5$rounds=3001$QlFHHifXvpFX4PLs$/0ekt7lSs/lOikSerQ0M/1porEHxYq7W/2hdFpxA3fA'))\n  \n  \n  \n  \n def test_30_nonstring_hash(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\".*needs_update.*'scheme' keyword is deprecated.*\")\n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in [\n  (None ,{}),\n  \n  (None ,{\"scheme\":\"des_crypt\"}),\n  (1,{}),\n  ((),{}),\n  ]:\n  \n   self.assertRaises(TypeError,cc.hash_needs_update,hash,**kwds)\n   \n  cc2=CryptContext([\"mysql323\"])\n  self.assertRaises(TypeError,cc2.hash_needs_update,None )\n  \n  \n  \n  \n  \n  \n  \n  \nclass dummy_2(uh.StaticHandler):\n name=\"dummy_2\"\n \nclass LazyCryptContextTest(TestCase):\n descriptionPrefix=\"LazyCryptContext\"\n \n def setUp(self):\n  TestCase.setUp(self)\n  \n  \n  unload_handler_name(\"dummy_2\")\n  self.addCleanup(unload_handler_name,\"dummy_2\")\n  \n  \n  warnings.filterwarnings(\"ignore\",\n  r\"CryptContext\\(\\)\\.replace\\(\\) has been deprecated\")\n  warnings.filterwarnings(\"ignore\",\".*(CryptPolicy|context\\.policy).*(has|have) been deprecated.*\")\n  \n def test_kwd_constructor(self):\n  ''\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  cc=LazyCryptContext(iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertTrue(cc.policy.handler_is_deprecated(\"des_crypt\"))\n  self.assertEqual(cc.policy.schemes(),[\"dummy_2\",\"des_crypt\"])\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n def test_callable_constructor(self):\n  ''\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  def create_policy(flag=False ):\n   self.assertTrue(flag)\n   return CryptPolicy(schemes=iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n   \n  cc=LazyCryptContext(create_policy=create_policy,flag=True )\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertTrue(cc.policy.handler_is_deprecated(\"des_crypt\"))\n  self.assertEqual(cc.policy.schemes(),[\"dummy_2\",\"des_crypt\"])\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n  \n  \n  \n", ["__future__", "logging", "os", "passlib", "passlib.context", "passlib.registry", "passlib.tests.utils", "passlib.utils", "passlib.utils.handlers", "pkg_resources", "warnings"]], "passlib.tests.test_crypto_scrypt": [".py", "''\n\n\n\n\nfrom binascii import hexlify\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\nimport struct\nimport warnings\nwarnings.filterwarnings(\"ignore\",\".*using builtin scrypt backend.*\")\n\n\nfrom passlib import exc\nfrom passlib.utils import getrandbytes\nfrom passlib.utils.compat import PYPY,u,bascii_to_str\nfrom passlib.utils.decor import classproperty\nfrom passlib.tests.utils import TestCase,skipUnless,TEST_MODE,hb\n\nfrom passlib.crypto import scrypt as scrypt_mod\n\n__all__=[\n\"ScryptEngineTest\",\n\"BuiltinScryptTest\",\n\"FastScryptTest\",\n]\n\n\n\n\ndef hexstr(data):\n ''\n return bascii_to_str(hexlify(data))\n \ndef unpack_uint32_list(data,check_count=None ):\n ''\n count=len(data)//4\n assert check_count is None or check_count ==count\n return struct.unpack(\"<%dI\"%count,data)\n \ndef seed_bytes(seed,count):\n ''\n\n\n \n if hasattr(seed,\"encode\"):\n  seed=seed.encode(\"ascii\")\n buf=b''\n i=0\n while len(buf)<count:\n  buf +=hashlib.sha256(seed+struct.pack(\"<I\",i)).digest()\n  i +=1\n return buf[:count]\n \n \n \n \nclass ScryptEngineTest(TestCase):\n descriptionPrefix=\"passlib.crypto.scrypt._builtin\"\n \n def test_smix(self):\n  ''\n  from passlib.crypto.scrypt._builtin import ScryptEngine\n  rng=self.getRandom()\n  \n  \n  \n  \n  \n  \n  input=hb(\"\"\"\n            f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd\n            77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad\n            89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29\n            09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7\n            89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb\n            cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0\n            67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b\n            7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89\n            \"\"\")\n  \n  output=hb(\"\"\"\n            79 cc c1 93 62 9d eb ca 04 7f 0b 70 60 4b f6 b6\n            2c e3 dd 4a 96 26 e3 55 fa fc 61 98 e6 ea 2b 46\n            d5 84 13 67 3b 99 b0 29 d6 65 c3 57 60 1f b4 26\n            a0 b2 f4 bb a2 00 ee 9f 0a 43 d1 9b 57 1a 9c 71\n            ef 11 42 e6 5d 5a 26 6f dd ca 83 2c e5 9f aa 7c\n            ac 0b 9c f1 be 2b ff ca 30 0d 01 ee 38 76 19 c4\n            ae 12 fd 44 38 f2 03 a0 e4 e1 c4 7e c3 14 86 1f\n            4e 90 87 cb 33 39 6a 68 73 e8 f9 d2 53 9a 4b 8e\n            \"\"\")\n  \n  \n  engine=ScryptEngine(n=16,r=1,p=rng.randint(1,1023))\n  self.assertEqual(engine.smix(input),output)\n  \n def test_bmix(self):\n  ''\n  from passlib.crypto.scrypt._builtin import ScryptEngine\n  rng=self.getRandom()\n  \n  \n  \n  \n  def check_bmix(r,input,output):\n   ''\n   \n   \n   engine=ScryptEngine(r=r,n=1 <<rng.randint(1,32),p=rng.randint(1,1023))\n   target=[rng.randint(0,1 <<32)for _ in range((2 *r)*16)]\n   engine.bmix(input,target)\n   self.assertEqual(target,list(output))\n   \n   \n   \n   if r ==1:\n    del engine.bmix\n    target=[rng.randint(0,1 <<32)for _ in range((2 *r)*16)]\n    engine.bmix(input,target)\n    self.assertEqual(target,list(output))\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  input=unpack_uint32_list(hb(\"\"\"\n                f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd\n                77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad\n                89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29\n                09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7\n\n                89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb\n                cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0\n                67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b\n                7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89\n            \"\"\"),32)\n  \n  output=unpack_uint32_list(hb(\"\"\"\n                a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05\n                04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29\n                b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba\n                e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81\n\n                20 ed c9 75 32 38 81 a8 05 40 f6 4c 16 2d cd 3c\n                21 07 7c fe 5f 8d 5f e2 b1 a4 16 8f 95 36 78 b7\n                7d 3b 3d 80 3b 60 e4 ab 92 09 96 e5 9b 4d 53 b6\n                5d 2a 22 58 77 d5 ed f5 84 2c b9 f1 4e ef e4 25\n            \"\"\"),32)\n  \n  \n  \n  \n  \n  \n  \n  \n  r=2\n  input=unpack_uint32_list(seed_bytes(\"bmix with r=2\",128 *r))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            ba240854954f4585f3d0573321f10beee96f12acdc1feb498131e40512934fd7\n            43e8139c17d0743c89d09ac8c3582c273c60ab85db63e410d049a9e17a42c6a1\n\n            6c7831b11bf370266afdaff997ae1286920dea1dedf0f4a1795ba710ba9017f1\n            a374400766f13ebd8969362de2d153965e9941bdde0768fa5b53e8522f116ce0\n\n            d14774afb88f46cd919cba4bc64af7fca0ecb8732d1fc2191e0d7d1b6475cb2e\n            e3db789ee478d056c4eb6c6e28b99043602dbb8dfb60c6e048bf90719da8d57d\n\n            3c42250e40ab79a1ada6aae9299b9790f767f54f388d024a1465b30cbbe9eb89\n            002d4f5c215c4259fac4d083bac5fb0b47463747d568f40bb7fa87c42f0a1dc1\n            \"\"\"),32 *r)\n  \n  check_bmix(r,input,output)\n  \n  \n  \n  \n  \n  \n  r=3\n  input=unpack_uint32_list(seed_bytes(\"bmix with r=3\",128 *r))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            11ddd8cf60c61f59a6e5b128239bdc77b464101312c88bd1ccf6be6e75461b29\n            7370d4770c904d0b09c402573cf409bf2db47b91ba87d5a3de469df8fb7a003c\n\n            95a66af96dbdd88beddc8df51a2f72a6f588d67e7926e9c2b676c875da13161e\n            b6262adac39e6b3003e9a6fbc8c1a6ecf1e227c03bc0af3e5f8736c339b14f84\n\n            c7ae5b89f5e16d0faf8983551165f4bb712d97e4f81426e6b78eb63892d3ff54\n            80bf406c98e479496d0f76d23d728e67d2a3d2cdbc4a932be6db36dc37c60209\n\n            a5ca76ca2d2979f995f73fe8182eefa1ce0ba0d4fc27d5b827cb8e67edd6552f\n            00a5b3ab6b371bd985a158e728011314eb77f32ade619b3162d7b5078a19886c\n\n            06f12bc8ae8afa46489e5b0239954d5216967c928982984101e4a88bae1f60ae\n            3f8a456e169a8a1c7450e7955b8a13a202382ae19d41ce8ef8b6a15eeef569a7\n\n            20f54c48e44cb5543dda032c1a50d5ddf2919030624978704eb8db0290052a1f\n            5d88989b0ef931b6befcc09e9d5162320e71e80b89862de7e2f0b6c67229b93f\n            \"\"\"),32 *r)\n  \n  check_bmix(r,input,output)\n  \n  \n  \n  \n  \n  \n  r=4\n  input=unpack_uint32_list(seed_bytes(\"bmix with r=4\",128 *r))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            803fcf7362702f30ef43250f20bc6b1b8925bf5c4a0f5a14bbfd90edce545997\n            3047bd81655f72588ca93f5c2f4128adaea805e0705a35e14417101fdb1c498c\n\n            33bec6f4e5950d66098da8469f3fe633f9a17617c0ea21275185697c0e4608f7\n            e6b38b7ec71704a810424637e2c296ca30d9cbf8172a71a266e0393deccf98eb\n\n            abc430d5f144eb0805308c38522f2973b7b6a48498851e4c762874497da76b88\n            b769b471fbfc144c0e8e859b2b3f5a11f51604d268c8fd28db55dff79832741a\n\n            1ac0dfdaff10f0ada0d93d3b1f13062e4107c640c51df05f4110bdda15f51b53\n            3a75bfe56489a6d8463440c78fb8c0794135e38591bdc5fa6cec96a124178a4a\n\n            d1a976e985bfe13d2b4af51bd0fc36dd4cfc3af08efe033b2323a235205dc43d\n            e57778a492153f9527338b3f6f5493a03d8015cd69737ee5096ad4cbe660b10f\n\n            b75b1595ddc96e3748f5c9f61fba1ef1f0c51b6ceef8bbfcc34b46088652e6f7\n            edab61521cbad6e69b77be30c9c97ea04a4af359dafc205c7878cc9a6c5d122f\n\n            8d77f3cbe65ab14c3c491ef94ecb3f5d2c2dd13027ea4c3606262bb3c9ce46e7\n            dc424729dc75f6e8f06096c0ad8ad4d549c42f0cad9b33cb95d10fb3cadba27c\n\n            5f4bf0c1ac677c23ba23b64f56afc3546e62d96f96b58d7afc5029f8168cbab4\n            533fd29fc83c8d2a32b81923992e4938281334e0c3694f0ee56f8ff7df7dc4ae\n            \"\"\"),32 *r)\n  \n  check_bmix(r,input,output)\n  \n def test_salsa(self):\n  ''\n  from passlib.crypto.scrypt._builtin import salsa20\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  input=unpack_uint32_list(hb(\"\"\"\n            7e 87 9a 21 4f 3e c9 86 7c a9 40 e6 41 71 8f 26\n            ba ee 55 5b 8c 61 c1 b5 0d f8 46 11 6d cd 3b 1d\n            ee 24 f3 19 df 9b 3d 85 14 12 1e 4b 5a c5 aa 32\n            76 02 1d 29 09 c7 48 29 ed eb c6 8d b8 b8 c2 5e\n            \"\"\"))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05\n            04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29\n            b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba\n            e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81\n            \"\"\"))\n  self.assertEqual(salsa20(input),output)\n  \n  \n  \n  \n  \n  input=list(range(16))\n  output=unpack_uint32_list(hb(\"\"\"\n            f518dd4fb98883e0a87954c05cab867083bb8808552810752285a05822f56c16\n            9d4a2a0fd2142523d758c60b36411b682d53860514b871d27659042a5afa475d\n            \"\"\"))\n  self.assertEqual(salsa20(input),output)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CommonScryptTest(TestCase):\n ''\n\n \n \n \n \n \n @classproperty\n def descriptionPrefix(cls):\n  return \"passlib.utils.scrypt.scrypt() <%s backend>\"%cls.backend\n backend=None\n \n \n \n \n def setUp(self):\n  assert self.backend\n  scrypt_mod._set_backend(self.backend)\n  super(_CommonScryptTest,self).setUp()\n  \n  \n  \n  \n  \n reference_vectors=[\n \n \n \n \n \n \n \n \n \n (\"\",\"\",16,1,1,64,hb(\"\"\"\n        77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97\n        f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42\n        fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17\n        e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06\n        \"\"\")),\n \n (\"password\",\"NaCl\",1024,8,16,64,hb(\"\"\"\n        fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe\n        7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62\n        2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da\n        c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40\n        \"\"\")),\n \n \n \n (\"pleaseletmein\",\"SodiumChloride\",16384,8,1,64,hb(\"\"\"\n        70 23 bd cb 3a fd 73 48 46 1c 06 cd 81 fd 38 eb\n        fd a8 fb ba 90 4f 8e 3e a9 b5 43 f6 54 5d a1 f2\n        d5 43 29 55 61 3f 0f cf 62 d4 97 05 24 2a 9a f9\n        e6 1e 85 dc 0d 65 1e 40 df cf 01 7b 45 57 58 87\n        \"\"\")),\n \n \n \n \n (\"pleaseletmein\",\"SodiumChloride\",1048576,8,1,64,hb(\"\"\"\n        21 01 cb 9b 6a 51 1a ae ad db be 09 cf 70 f8 81\n        ec 56 8d 57 4a 2f fd 4d ab e5 ee 98 20 ad aa 47\n        8e 56 fd 8f 4b a5 d0 9f fa 1c 6d 92 7c 40 f4 c3\n        37 30 40 49 e8 a9 52 fb cb f4 5c 6f a7 7a 41 a4\n        \"\"\")),\n ]\n \n def test_reference_vectors(self):\n  ''\n  for secret,salt,n,r,p,keylen,result in self.reference_vectors:\n   if n >=1024 and TEST_MODE(max=\"default\"):\n   \n    continue\n   if n >16384 and self.backend ==\"builtin\":\n   \n   \n    continue\n   log.debug(\"scrypt reference vector: %r %r n=%r r=%r p=%r\",secret,salt,n,r,p)\n   self.assertEqual(scrypt_mod.scrypt(secret,salt,n,r,p,keylen),result)\n   \n   \n   \n   \n   \n _already_tested_others=None\n \n def test_other_backends(self):\n  ''\n  \n  \n  if self._already_tested_others:\n   raise self.skipTest(\"already run under %r backend test\"%self._already_tested_others)\n  self._already_tested_others=self.backend\n  rng=self.getRandom()\n  \n  \n  orig=scrypt_mod.backend\n  available=set(name for name in scrypt_mod.backend_values\n  if scrypt_mod._has_backend(name))\n  scrypt_mod._set_backend(orig)\n  available.discard(self.backend)\n  if not available:\n   raise self.skipTest(\"no other backends found\")\n   \n  warnings.filterwarnings(\"ignore\",\"(?i)using builtin scrypt backend\",\n  category=exc.PasslibSecurityWarning)\n  \n  \n  for _ in range(10):\n  \n   secret=getrandbytes(rng,rng.randint(0,64))\n   salt=getrandbytes(rng,rng.randint(0,64))\n   n=1 <<rng.randint(1,10)\n   r=rng.randint(1,8)\n   p=rng.randint(1,3)\n   ks=rng.randint(1,64)\n   previous=None\n   backends=set()\n   for name in available:\n    scrypt_mod._set_backend(name)\n    self.assertNotIn(scrypt_mod._scrypt,backends)\n    backends.add(scrypt_mod._scrypt)\n    result=hexstr(scrypt_mod.scrypt(secret,salt,n,r,p,ks))\n    self.assertEqual(len(result),2 *ks)\n    if previous is not None :\n     self.assertEqual(result,previous,\n     msg=\"%r output differs from others %r: %r\"%\n     (name,available,[secret,salt,n,r,p,ks]))\n     \n     \n     \n     \n def test_backend(self):\n  ''\n  \n  scrypt_mod.backend=None\n  scrypt_mod._scrypt=None\n  self.assertRaises(TypeError,scrypt_mod.scrypt,'s','s',2,2,2,16)\n  \n  \n  scrypt_mod._set_backend(self.backend)\n  self.assertEqual(scrypt_mod.backend,self.backend)\n  scrypt_mod.scrypt('s','s',2,2,2,16)\n  \n  \n  self.assertRaises(ValueError,scrypt_mod._set_backend,'xxx')\n  self.assertEqual(scrypt_mod.backend,self.backend)\n  \n def test_secret_param(self):\n  ''\n  \n  def run_scrypt(secret):\n   return hexstr(scrypt_mod.scrypt(secret,\"salt\",2,2,2,16))\n   \n   \n  TEXT=u(\"abc\\u00defg\")\n  self.assertEqual(run_scrypt(TEXT),'05717106997bfe0da42cf4779a2f8bd8')\n  \n  \n  TEXT_UTF8=b'abc\\xc3\\x9efg'\n  self.assertEqual(run_scrypt(TEXT_UTF8),'05717106997bfe0da42cf4779a2f8bd8')\n  \n  \n  TEXT_LATIN1=b'abc\\xdefg'\n  self.assertEqual(run_scrypt(TEXT_LATIN1),'770825d10eeaaeaf98e8a3c40f9f441d')\n  \n  \n  self.assertEqual(run_scrypt(\"\"),'ca1399e5fae5d3b9578dcd2b1faff6e2')\n  \n  \n  self.assertRaises(TypeError,run_scrypt,None )\n  self.assertRaises(TypeError,run_scrypt,1)\n  \n def test_salt_param(self):\n  ''\n  \n  def run_scrypt(salt):\n   return hexstr(scrypt_mod.scrypt(\"secret\",salt,2,2,2,16))\n   \n   \n  TEXT=u(\"abc\\u00defg\")\n  self.assertEqual(run_scrypt(TEXT),'a748ec0f4613929e9e5f03d1ab741d88')\n  \n  \n  TEXT_UTF8=b'abc\\xc3\\x9efg'\n  self.assertEqual(run_scrypt(TEXT_UTF8),'a748ec0f4613929e9e5f03d1ab741d88')\n  \n  \n  TEXT_LATIN1=b'abc\\xdefg'\n  self.assertEqual(run_scrypt(TEXT_LATIN1),'91d056fb76fb6e9a7d1cdfffc0a16cd1')\n  \n  \n  self.assertRaises(TypeError,run_scrypt,None )\n  self.assertRaises(TypeError,run_scrypt,1)\n  \n def test_n_param(self):\n  ''\n  \n  def run_scrypt(n):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",n,2,2,16))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertRaises(ValueError,run_scrypt,1)\n  self.assertEqual(run_scrypt(2),'dacf2bca255e2870e6636fa8c8957a66')\n  self.assertRaises(ValueError,run_scrypt,3)\n  self.assertRaises(ValueError,run_scrypt,15)\n  self.assertEqual(run_scrypt(16),'0272b8fc72bc54b1159340ed99425233')\n  \n def test_r_param(self):\n  ''\n  def run_scrypt(r,n=2,p=2):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",n,r,p,16))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertEqual(run_scrypt(1),'3d630447d9f065363b8a79b0b3670251')\n  self.assertEqual(run_scrypt(2),'dacf2bca255e2870e6636fa8c8957a66')\n  self.assertEqual(run_scrypt(5),'114f05e985a903c27237b5578e763736')\n  \n  \n  self.assertRaises(ValueError,run_scrypt,(1 <<30),p=1)\n  self.assertRaises(ValueError,run_scrypt,(1 <<30)/2,p=2)\n  \n def test_p_param(self):\n  ''\n  def run_scrypt(p,n=2,r=2):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",n,r,p,16))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertEqual(run_scrypt(1),'f2960ea8b7d48231fcec1b89b784a6fa')\n  self.assertEqual(run_scrypt(2),'dacf2bca255e2870e6636fa8c8957a66')\n  self.assertEqual(run_scrypt(5),'848a0eeb2b3543e7f543844d6ca79782')\n  \n  \n  self.assertRaises(ValueError,run_scrypt,(1 <<30),r=1)\n  self.assertRaises(ValueError,run_scrypt,(1 <<30)/2,r=2)\n  \n def test_keylen_param(self):\n  ''\n  rng=self.getRandom()\n  \n  def run_scrypt(keylen):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",2,2,2,keylen))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertEqual(run_scrypt(1),'da')\n  \n  \n  ksize=rng.randint(1,1 <<10)\n  self.assertEqual(len(run_scrypt(ksize)),2 *ksize)\n  \n  \n  self.assertRaises(ValueError,run_scrypt,((2 **32)-1)*32+1)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef _can_import_cffi_scrypt():\n try :\n  import scrypt\n except ImportError as err:\n  if \"scrypt\"in str(err):\n   return False\n  raise\n return True\n \nhas_cffi_scrypt=_can_import_cffi_scrypt()\n\n\ndef _can_import_stdlib_scrypt():\n try :\n  from hashlib import scrypt\n  return True\n except ImportError:\n  return False\n  \nhas_stdlib_scrypt=_can_import_stdlib_scrypt()\n\n\n\n\n\n\n\n@skipUnless(PYPY or TEST_MODE(min=\"default\"),\"skipped under current test mode\")\nclass BuiltinScryptTest(_CommonScryptTest):\n backend=\"builtin\"\n \n def setUp(self):\n  super(BuiltinScryptTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\"(?i)using builtin scrypt backend\",\n  category=exc.PasslibSecurityWarning)\n  \n def test_missing_backend(self):\n  ''\n  if has_stdlib_scrypt or has_cffi_scrypt:\n   raise self.skipTest(\"non-builtin backend is present\")\n  self.assertRaises(exc.MissingBackendError,scrypt_mod._set_backend,'scrypt')\n  \n  \n@skipUnless(has_cffi_scrypt,\"'scrypt' package not found\")\nclass ScryptPackageTest(_CommonScryptTest):\n backend=\"scrypt\"\n \n def test_default_backend(self):\n  ''\n  if has_stdlib_scrypt:\n   raise self.skipTest(\"higher priority backend present\")\n  scrypt_mod._set_backend(\"default\")\n  self.assertEqual(scrypt_mod.backend,\"scrypt\")\n  \n  \n@skipUnless(has_stdlib_scrypt,\"'hashlib.scrypt()' not found\")\nclass StdlibScryptTest(_CommonScryptTest):\n backend=\"stdlib\"\n \n def test_default_backend(self):\n  ''\n  scrypt_mod._set_backend(\"default\")\n  self.assertEqual(scrypt_mod.backend,\"stdlib\")\n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib", "passlib.crypto", "passlib.crypto.scrypt._builtin", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "scrypt", "struct", "warnings"]], "passlib.tests.test_pwd": [".py", "''\n\n\n\n\nimport itertools\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.tests.utils import TestCase\n\n__all__=[\n\"UtilsTest\",\n\"GenerateTest\",\n\"StrengthTest\",\n]\n\n\n\n\nclass UtilsTest(TestCase):\n ''\n descriptionPrefix=\"passlib.pwd\"\n \n def test_self_info_rate(self):\n  ''\n  from passlib.pwd import _self_info_rate\n  \n  self.assertEqual(_self_info_rate(\"\"),0)\n  \n  self.assertEqual(_self_info_rate(\"a\"*8),0)\n  \n  self.assertEqual(_self_info_rate(\"ab\"),1)\n  self.assertEqual(_self_info_rate(\"ab\"*8),1)\n  \n  self.assertEqual(_self_info_rate(\"abcd\"),2)\n  self.assertEqual(_self_info_rate(\"abcd\"*8),2)\n  self.assertAlmostEqual(_self_info_rate(\"abcdaaaa\"),1.5488,places=4)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nfrom passlib.pwd import genword,default_charsets\nascii_62=default_charsets['ascii_62']\nhex=default_charsets['hex']\n\nclass WordGeneratorTest(TestCase):\n ''\n descriptionPrefix=\"passlib.pwd.genword()\"\n \n def setUp(self):\n  super(WordGeneratorTest,self).setUp()\n  \n  \n  from passlib.pwd import SequenceGenerator\n  self.patchAttr(SequenceGenerator,\"rng\",\n  self.getRandom(\"pwd generator\"))\n  \n def assertResultContents(self,results,count,chars,unique=True ):\n  ''\n  self.assertEqual(len(results),count)\n  if unique:\n   if unique is True :\n    unique=count\n   self.assertEqual(len(set(results)),unique)\n  self.assertEqual(set(\"\".join(results)),set(chars))\n  \n def test_general(self):\n  ''\n  \n  \n  result=genword()\n  self.assertEqual(len(result),9)\n  \n  \n  self.assertRaisesRegex(TypeError,\"(?i)unexpected keyword.*badkwd\",genword,badkwd=True )\n  \n def test_returns(self):\n  ''\n  \n  results=genword(returns=5000)\n  self.assertResultContents(results,5000,ascii_62)\n  \n  \n  gen=genword(returns=iter)\n  results=[next(gen)for _ in range(5000)]\n  self.assertResultContents(results,5000,ascii_62)\n  \n  \n  self.assertRaises(TypeError,genword,returns='invalid-type')\n  \n def test_charset(self):\n  ''\n  \n  results=genword(charset=\"hex\",returns=5000)\n  self.assertResultContents(results,5000,hex)\n  \n  \n  \n  results=genword(length=3,chars=\"abc\",returns=5000)\n  self.assertResultContents(results,5000,\"abc\",unique=27)\n  \n  \n  self.assertRaises(TypeError,genword,chars='abc',charset='hex')\n  \n  \n  \n  \n  \n  \n  \n  \nfrom passlib.pwd import genphrase\nsimple_words=[\"alpha\",\"beta\",\"gamma\"]\n\nclass PhraseGeneratorTest(TestCase):\n ''\n descriptionPrefix=\"passlib.pwd.genphrase()\"\n \n def assertResultContents(self,results,count,words,unique=True ,sep=\" \"):\n  ''\n  self.assertEqual(len(results),count)\n  if unique:\n   if unique is True :\n    unique=count\n   self.assertEqual(len(set(results)),unique)\n  out=set(itertools.chain.from_iterable(elem.split(sep)for elem in results))\n  self.assertEqual(out,set(words))\n  \n def test_general(self):\n  ''\n  \n  \n  result=genphrase()\n  self.assertEqual(len(result.split(\" \")),4)\n  \n  \n  self.assertRaisesRegex(TypeError,\"(?i)unexpected keyword.*badkwd\",genphrase,badkwd=True )\n  \n def test_entropy(self):\n  ''\n  \n  \n  result=genphrase(entropy=70)\n  self.assertEqual(len(result.split(\" \")),6)\n  \n  \n  result=genphrase(length=3)\n  self.assertEqual(len(result.split(\" \")),3)\n  \n  \n  result=genphrase(length=3,entropy=48)\n  self.assertEqual(len(result.split(\" \")),4)\n  \n  \n  result=genphrase(length=4,entropy=12)\n  self.assertEqual(len(result.split(\" \")),4)\n  \n def test_returns(self):\n  ''\n  \n  results=genphrase(returns=1000,words=simple_words)\n  self.assertResultContents(results,1000,simple_words)\n  \n  \n  gen=genphrase(returns=iter,words=simple_words)\n  results=[next(gen)for _ in range(1000)]\n  self.assertResultContents(results,1000,simple_words)\n  \n  \n  self.assertRaises(TypeError,genphrase,returns='invalid-type')\n  \n def test_wordset(self):\n  ''\n  \n  results=genphrase(words=simple_words,returns=5000)\n  self.assertResultContents(results,5000,simple_words)\n  \n  \n  results=genphrase(length=3,words=simple_words,returns=5000)\n  self.assertResultContents(results,5000,simple_words,unique=3 **3)\n  \n  \n  self.assertRaises(TypeError,genphrase,words=simple_words,wordset='bip39')\n  \n  \n  \n  \n", ["itertools", "logging", "passlib.pwd", "passlib.tests.utils"]], "passlib.tests.test_utils_md4": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport warnings\n\n\n\nfrom passlib.tests.test_crypto_builtin_md4 import _Common_MD4_Test\n\n__all__=[\n\"Legacy_MD4_Test\",\n]\n\n\n\nclass Legacy_MD4_Test(_Common_MD4_Test):\n descriptionPrefix=\"passlib.utils.md4.md4()\"\n \n def setUp(self):\n  super(Legacy_MD4_Test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.md4.*deprecated\",DeprecationWarning)\n  \n def get_md4_const(self):\n  from passlib.utils.md4 import md4\n  return md4\n  \n  \n  \n  \n", ["passlib.tests.test_crypto_builtin_md4", "passlib.utils.md4", "warnings"]], "passlib.tests.test_apache": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom logging import getLogger\nimport os\nimport subprocess\n\n\nfrom passlib import apache,registry\nfrom passlib.exc import MissingBackendError\nfrom passlib.utils.compat import irange\nfrom passlib.tests.backports import unittest\nfrom passlib.tests.utils import TestCase,get_file,set_file,ensure_mtime_changed\nfrom passlib.utils.compat import u\nfrom passlib.utils import to_bytes\nfrom passlib.utils.handlers import to_unicode_for_identify\n\nlog=getLogger(__name__)\n\n\n\n\n\ndef backdate_file_mtime(path,offset=10):\n ''\n \n \n atime=os.path.getatime(path)\n mtime=os.path.getmtime(path)-offset\n os.utime(path,(atime,mtime))\n \n \n \n \n \n \nhtpasswd_path=os.environ.get(\"PASSLIB_TEST_HTPASSWD_PATH\")or \"htpasswd\"\n\n\ndef _call_htpasswd(args,stdin=None ):\n ''\n\n \n if stdin is not None :\n  stdin=stdin.encode(\"utf-8\")\n proc=subprocess.Popen([htpasswd_path]+args,stdout=subprocess.PIPE,\n stderr=subprocess.STDOUT,stdin=subprocess.PIPE if stdin else None )\n out,err=proc.communicate(stdin)\n rc=proc.wait()\n out=to_unicode_for_identify(out or \"\")\n return out,rc\n \n \ndef _call_htpasswd_verify(path,user,password):\n ''\n\n \n out,rc=_call_htpasswd([\"-vi\",path,user],password)\n return not rc\n \n \ndef _detect_htpasswd():\n ''\n\n \n try :\n  out,rc=_call_htpasswd([])\n except OSError:\n \n \n  return False ,False\n  \n if not rc:\n  log.warning(\"htpasswd test returned with rc=0\")\n have_bcrypt=\" -B \"in out\n return True ,have_bcrypt\n \n \nHAVE_HTPASSWD,HAVE_HTPASSWD_BCRYPT=_detect_htpasswd()\n\nrequires_htpasswd_cmd=unittest.skipUnless(HAVE_HTPASSWD,\"requires `htpasswd` cmdline tool\")\n\n\n\n\n\nclass HtpasswdFileTest(TestCase):\n ''\n descriptionPrefix=\"HtpasswdFile\"\n \n \n sample_01=(b'user2:2CHkkwa2AtqGs\\n'\n b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\n'\n b'user4:pass4\\n'\n b'user1:$apr1$t4tc7jTh$GPIWVUo8sQKJlUdV8V5vu0\\n')\n \n \n sample_02=b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\nuser4:pass4\\n'\n \n \n sample_03=(b'user2:pass2x\\n'\n b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\n'\n b'user4:pass4\\n'\n b'user1:$apr1$t4tc7jTh$GPIWVUo8sQKJlUdV8V5vu0\\n'\n b'user5:pass5\\n')\n \n \n sample_04_utf8=b'user\\xc3\\xa6:2CHkkwa2AtqGs\\n'\n sample_04_latin1=b'user\\xe6:2CHkkwa2AtqGs\\n'\n \n sample_dup=b'user1:pass1\\nuser1:pass2\\n'\n \n \n sample_05=(b'user2:2CHkkwa2AtqGs\\n'\n b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\n'\n b'user4:pass4\\n'\n b'user1:$apr1$t4tc7jTh$GPIWVUo8sQKJlUdV8V5vu0\\n'\n b'user5:$2a$12$yktDxraxijBZ360orOyCOePFGhuis/umyPNJoL5EbsLk.s6SWdrRO\\n'\n b'user6:$5$rounds=110000$cCRp/xUUGVgwR4aP$'\n b'p0.QKFS5qLNRqw1/47lXYiAcgIjJK.WjCO8nrEKuUK.\\n')\n \n def test_00_constructor_autoload(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtpasswdFile(path)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  self.assertEqual(ht.path,path)\n  self.assertTrue(ht.mtime)\n  \n  \n  ht.path=path+\"x\"\n  self.assertEqual(ht.path,path+\"x\")\n  self.assertFalse(ht.mtime)\n  \n  \n  ht=apache.HtpasswdFile(path,new=True )\n  self.assertEqual(ht.to_string(),b\"\")\n  self.assertEqual(ht.path,path)\n  self.assertFalse(ht.mtime)\n  \n  \n  with self.assertWarningList(\"``autoload=False`` is deprecated\"):\n   ht=apache.HtpasswdFile(path,autoload=False )\n  self.assertEqual(ht.to_string(),b\"\")\n  self.assertEqual(ht.path,path)\n  self.assertFalse(ht.mtime)\n  \n  \n  os.remove(path)\n  self.assertRaises(IOError,apache.HtpasswdFile,path)\n  \n  \n  \n def test_00_from_path(self):\n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtpasswdFile.from_path(path)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  self.assertEqual(ht.path,None )\n  self.assertFalse(ht.mtime)\n  \n def test_01_delete(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  self.assertTrue(ht.delete(\"user1\"))\n  self.assertTrue(ht.delete(\"user2\"))\n  self.assertFalse(ht.delete(\"user5\"))\n  self.assertEqual(ht.to_string(),self.sample_02)\n  \n  \n  self.assertRaises(ValueError,ht.delete,\"user:\")\n  \n def test_01_delete_autosave(self):\n  path=self.mktemp()\n  sample=b'user1:pass1\\nuser2:pass2\\n'\n  set_file(path,sample)\n  \n  ht=apache.HtpasswdFile(path)\n  ht.delete(\"user1\")\n  self.assertEqual(get_file(path),sample)\n  \n  ht=apache.HtpasswdFile(path,autosave=True )\n  ht.delete(\"user1\")\n  self.assertEqual(get_file(path),b\"user2:pass2\\n\")\n  \n def test_02_set_password(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(\n  self.sample_01,default_scheme=\"plaintext\")\n  self.assertTrue(ht.set_password(\"user2\",\"pass2x\"))\n  self.assertFalse(ht.set_password(\"user5\",\"pass5\"))\n  self.assertEqual(ht.to_string(),self.sample_03)\n  \n  \n  with self.assertWarningList(\"``default`` is deprecated\"):\n   ht=apache.HtpasswdFile.from_string(self.sample_01,default=\"plaintext\")\n  self.assertTrue(ht.set_password(\"user2\",\"pass2x\"))\n  self.assertFalse(ht.set_password(\"user5\",\"pass5\"))\n  self.assertEqual(ht.to_string(),self.sample_03)\n  \n  \n  self.assertRaises(ValueError,ht.set_password,\"user:\",\"pass\")\n  \n  \n  with self.assertWarningList(\"update\\(\\) is deprecated\"):\n   ht.update(\"user2\",\"test\")\n  self.assertTrue(ht.check_password(\"user2\",\"test\"))\n  \n def test_02_set_password_autosave(self):\n  path=self.mktemp()\n  sample=b'user1:pass1\\n'\n  set_file(path,sample)\n  \n  ht=apache.HtpasswdFile(path)\n  ht.set_password(\"user1\",\"pass2\")\n  self.assertEqual(get_file(path),sample)\n  \n  ht=apache.HtpasswdFile(path,default_scheme=\"plaintext\",autosave=True )\n  ht.set_password(\"user1\",\"pass2\")\n  self.assertEqual(get_file(path),b\"user1:pass2\\n\")\n  \n def test_02_set_password_default_scheme(self):\n  ''\n  \n  def check(scheme):\n   ht=apache.HtpasswdFile(default_scheme=scheme)\n   ht.set_password(\"user1\",\"pass1\")\n   return ht.context.identify(ht.get_hash(\"user1\"))\n   \n   \n  self.assertEqual(check(\"sha256_crypt\"),\"sha256_crypt\")\n  self.assertEqual(check(\"des_crypt\"),\"des_crypt\")\n  \n  \n  self.assertRaises(KeyError,check,\"xxx\")\n  \n  \n  self.assertEqual(check(\"portable\"),apache.htpasswd_defaults[\"portable\"])\n  self.assertEqual(check(\"portable_apache_22\"),apache.htpasswd_defaults[\"portable_apache_22\"])\n  self.assertEqual(check(\"host_apache_22\"),apache.htpasswd_defaults[\"host_apache_22\"])\n  \n  \n  self.assertEqual(check(None ),apache.htpasswd_defaults[\"portable_apache_22\"])\n  \n def test_03_users(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  ht.set_password(\"user5\",\"pass5\")\n  ht.delete(\"user3\")\n  ht.set_password(\"user3\",\"pass3\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user3\",\"user4\",\"user5\"])\n  \n def test_04_check_password(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_05)\n  self.assertRaises(TypeError,ht.check_password,1,'pass9')\n  self.assertTrue(ht.check_password(\"user9\",\"pass9\")is None )\n  \n  \n  \n  for i in irange(1,7):\n   i=str(i)\n   try :\n    self.assertTrue(ht.check_password(\"user\"+i,\"pass\"+i))\n    self.assertTrue(ht.check_password(\"user\"+i,\"pass9\")is False )\n   except MissingBackendError:\n    if i ==\"5\":\n    \n     continue\n    raise\n    \n  self.assertRaises(ValueError,ht.check_password,\"user:\",\"pass\")\n  \n  \n  with self.assertWarningList([\"verify\\(\\) is deprecated\"]*2):\n   self.assertTrue(ht.verify(\"user1\",\"pass1\"))\n   self.assertFalse(ht.verify(\"user1\",\"pass2\"))\n   \n def test_05_load(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,\"\")\n  backdate_file_mtime(path,5)\n  ha=apache.HtpasswdFile(path,default_scheme=\"plaintext\")\n  self.assertEqual(ha.to_string(),b\"\")\n  \n  \n  ha.set_password(\"user1\",\"pass1\")\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),b\"user1:pass1\\n\")\n  \n  \n  set_file(path,self.sample_01)\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  ha.set_password(\"user5\",\"pass5\")\n  ha.load()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  hb=apache.HtpasswdFile()\n  self.assertRaises(RuntimeError,hb.load)\n  self.assertRaises(RuntimeError,hb.load_if_changed)\n  \n  \n  set_file(path,self.sample_dup)\n  hc=apache.HtpasswdFile()\n  hc.load(path)\n  self.assertTrue(hc.check_password('user1','pass1'))\n  \n  \n  \n def test_06_save(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtpasswdFile(path)\n  \n  \n  ht.delete(\"user1\")\n  ht.delete(\"user2\")\n  ht.save()\n  self.assertEqual(get_file(path),self.sample_02)\n  \n  \n  hb=apache.HtpasswdFile(default_scheme=\"plaintext\")\n  hb.set_password(\"user1\",\"pass1\")\n  self.assertRaises(RuntimeError,hb.save)\n  \n  \n  hb.save(path)\n  self.assertEqual(get_file(path),b\"user1:pass1\\n\")\n  \n def test_07_encodings(self):\n  ''\n  \n  self.assertRaises(ValueError,apache.HtpasswdFile,encoding=\"utf-16\")\n  \n  \n  ht=apache.HtpasswdFile.from_string(self.sample_04_utf8,encoding=\"utf-8\",\n  return_unicode=True )\n  self.assertEqual(ht.users(),[u(\"user\\u00e6\")])\n  \n  \n  with self.assertWarningList(\"``encoding=None`` is deprecated\"):\n   ht=apache.HtpasswdFile.from_string(self.sample_04_utf8,encoding=None )\n  self.assertEqual(ht.users(),[b'user\\xc3\\xa6'])\n  \n  \n  ht=apache.HtpasswdFile.from_string(self.sample_04_latin1,\n  encoding=\"latin-1\",return_unicode=True )\n  self.assertEqual(ht.users(),[u(\"user\\u00e6\")])\n  \n def test_08_get_hash(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  self.assertEqual(ht.get_hash(\"user3\"),b\"{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\")\n  self.assertEqual(ht.get_hash(\"user4\"),b\"pass4\")\n  self.assertEqual(ht.get_hash(\"user5\"),None )\n  \n  with self.assertWarningList(\"find\\(\\) is deprecated\"):\n   self.assertEqual(ht.find(\"user4\"),b\"pass4\")\n   \n def test_09_to_string(self):\n  ''\n  \n  \n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  \n  \n  ht=apache.HtpasswdFile()\n  self.assertEqual(ht.to_string(),b\"\")\n  \n def test_10_repr(self):\n  ht=apache.HtpasswdFile(\"fakepath\",autosave=True ,new=True ,encoding=\"latin-1\")\n  repr(ht)\n  \n def test_11_malformed(self):\n  self.assertRaises(ValueError,apache.HtpasswdFile.from_string,\n  b'realm:user1:pass1\\n')\n  self.assertRaises(ValueError,apache.HtpasswdFile.from_string,\n  b'pass1\\n')\n  \n def test_12_from_string(self):\n \n  self.assertRaises(TypeError,apache.HtpasswdFile.from_string,\n  b'',path=None )\n  \n def test_13_whitespace(self):\n  ''\n  \n  \n  \n  source=to_bytes(\n  '\\n'\n  'user2:pass2\\n'\n  'user4:pass4\\n'\n  'user7:pass7\\r\\n'\n  ' \\t \\n'\n  'user1:pass1\\n'\n  ' # legacy users\\n'\n  '#user6:pass6\\n'\n  'user5:pass5\\n\\n'\n  )\n  \n  \n  ht=apache.HtpasswdFile.from_string(source)\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user7\"])\n  \n  \n  ht.set_hash(\"user4\",\"althash4\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user7\"])\n  \n  \n  ht.set_hash(\"user6\",\"althash6\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user6\",\"user7\"])\n  \n  \n  ht.delete(\"user7\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user6\"])\n  \n  \n  target=to_bytes(\n  '\\n'\n  'user2:pass2\\n'\n  'user4:althash4\\n'\n  ' \\t \\n'\n  'user1:pass1\\n'\n  ' # legacy users\\n'\n  '#user6:pass6\\n'\n  'user5:pass5\\n'\n  'user6:althash6\\n'\n  )\n  self.assertEqual(ht.to_string(),target)\n  \n @requires_htpasswd_cmd\n def test_htpasswd_cmd_verify(self):\n  ''\n\n  \n  path=self.mktemp()\n  ht=apache.HtpasswdFile(path=path,new=True )\n  \n  def hash_scheme(pwd,scheme):\n   return ht.context.handler(scheme).hash(pwd)\n   \n   \n  ht.set_hash(\"user1\",hash_scheme(\"password\",\"apr_md5_crypt\"))\n  \n  \n  host_no_bcrypt=apache.htpasswd_defaults[\"host_apache_22\"]\n  ht.set_hash(\"user2\",hash_scheme(\"password\",host_no_bcrypt))\n  \n  \n  host_best=apache.htpasswd_defaults[\"host\"]\n  ht.set_hash(\"user3\",hash_scheme(\"password\",host_best))\n  \n  \n  ht.set_hash(\"user4\",\"$xxx$foo$bar$baz\")\n  \n  \n  ht.save()\n  \n  self.assertFalse(_call_htpasswd_verify(path,\"user1\",\"wrong\"))\n  self.assertFalse(_call_htpasswd_verify(path,\"user2\",\"wrong\"))\n  self.assertFalse(_call_htpasswd_verify(path,\"user3\",\"wrong\"))\n  self.assertFalse(_call_htpasswd_verify(path,\"user4\",\"wrong\"))\n  \n  self.assertTrue(_call_htpasswd_verify(path,\"user1\",\"password\"))\n  self.assertTrue(_call_htpasswd_verify(path,\"user2\",\"password\"))\n  self.assertTrue(_call_htpasswd_verify(path,\"user3\",\"password\"))\n  \n @requires_htpasswd_cmd\n @unittest.skipUnless(registry.has_backend(\"bcrypt\"),\"bcrypt support required\")\n def test_htpasswd_cmd_verify_bcrypt(self):\n  ''\n\n\n\n\n  \n  path=self.mktemp()\n  ht=apache.HtpasswdFile(path=path,new=True )\n  def hash_scheme(pwd,scheme):\n   return ht.context.handler(scheme).hash(pwd)\n  ht.set_hash(\"user1\",hash_scheme(\"password\",\"bcrypt\"))\n  ht.save()\n  self.assertFalse(_call_htpasswd_verify(path,\"user1\",\"wrong\"))\n  if HAVE_HTPASSWD_BCRYPT:\n   self.assertTrue(_call_htpasswd_verify(path,\"user1\",\"password\"))\n  else :\n  \n   self.assertFalse(_call_htpasswd_verify(path,\"user1\",\"password\"))\n   \n   \n   \n   \n   \n   \n   \n   \nclass HtdigestFileTest(TestCase):\n ''\n descriptionPrefix=\"HtdigestFile\"\n \n \n sample_01=(b'user2:realm:549d2a5f4659ab39a80dac99e159ab19\\n'\n b'user3:realm:a500bb8c02f6a9170ae46af10c898744\\n'\n b'user4:realm:ab7b5d5f28ccc7666315f508c7358519\\n'\n b'user1:realm:2a6cf53e7d8f8cf39d946dc880b14128\\n')\n \n \n sample_02=(b'user3:realm:a500bb8c02f6a9170ae46af10c898744\\n'\n b'user4:realm:ab7b5d5f28ccc7666315f508c7358519\\n')\n \n \n sample_03=(b'user2:realm:5ba6d8328943c23c64b50f8b29566059\\n'\n b'user3:realm:a500bb8c02f6a9170ae46af10c898744\\n'\n b'user4:realm:ab7b5d5f28ccc7666315f508c7358519\\n'\n b'user1:realm:2a6cf53e7d8f8cf39d946dc880b14128\\n'\n b'user5:realm:03c55fdc6bf71552356ad401bdb9af19\\n')\n \n \n sample_04_utf8=b'user\\xc3\\xa6:realm\\xc3\\xa6:549d2a5f4659ab39a80dac99e159ab19\\n'\n sample_04_latin1=b'user\\xe6:realm\\xe6:549d2a5f4659ab39a80dac99e159ab19\\n'\n \n def test_00_constructor_autoload(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtdigestFile(path)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  \n  \n  ht=apache.HtdigestFile(path,new=True )\n  self.assertEqual(ht.to_string(),b\"\")\n  \n  \n  os.remove(path)\n  self.assertRaises(IOError,apache.HtdigestFile,path)\n  \n  \n  \n def test_01_delete(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertTrue(ht.delete(\"user1\",\"realm\"))\n  self.assertTrue(ht.delete(\"user2\",\"realm\"))\n  self.assertFalse(ht.delete(\"user5\",\"realm\"))\n  self.assertFalse(ht.delete(\"user3\",\"realm5\"))\n  self.assertEqual(ht.to_string(),self.sample_02)\n  \n  \n  self.assertRaises(ValueError,ht.delete,\"user:\",\"realm\")\n  \n  \n  self.assertRaises(ValueError,ht.delete,\"user\",\"realm:\")\n  \n def test_01_delete_autosave(self):\n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  \n  ht=apache.HtdigestFile(path)\n  self.assertTrue(ht.delete(\"user1\",\"realm\"))\n  self.assertFalse(ht.delete(\"user3\",\"realm5\"))\n  self.assertFalse(ht.delete(\"user5\",\"realm\"))\n  self.assertEqual(get_file(path),self.sample_01)\n  \n  ht.autosave=True\n  self.assertTrue(ht.delete(\"user2\",\"realm\"))\n  self.assertEqual(get_file(path),self.sample_02)\n  \n def test_02_set_password(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertTrue(ht.set_password(\"user2\",\"realm\",\"pass2x\"))\n  self.assertFalse(ht.set_password(\"user5\",\"realm\",\"pass5\"))\n  self.assertEqual(ht.to_string(),self.sample_03)\n  \n  \n  self.assertRaises(TypeError,ht.set_password,\"user2\",\"pass3\")\n  ht.default_realm=\"realm2\"\n  ht.set_password(\"user2\",\"pass3\")\n  ht.check_password(\"user2\",\"realm2\",\"pass3\")\n  \n  \n  self.assertRaises(ValueError,ht.set_password,\"user:\",\"realm\",\"pass\")\n  self.assertRaises(ValueError,ht.set_password,\"u\"*256,\"realm\",\"pass\")\n  \n  \n  self.assertRaises(ValueError,ht.set_password,\"user\",\"realm:\",\"pass\")\n  self.assertRaises(ValueError,ht.set_password,\"user\",\"r\"*256,\"pass\")\n  \n  \n  with self.assertWarningList(\"update\\(\\) is deprecated\"):\n   ht.update(\"user2\",\"realm2\",\"test\")\n  self.assertTrue(ht.check_password(\"user2\",\"test\"))\n  \n  \n  \n def test_03_users(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  ht.set_password(\"user5\",\"realm\",\"pass5\")\n  ht.delete(\"user3\",\"realm\")\n  ht.set_password(\"user3\",\"realm\",\"pass3\")\n  self.assertEqual(sorted(ht.users(\"realm\")),[\"user1\",\"user2\",\"user3\",\"user4\",\"user5\"])\n  \n  self.assertRaises(TypeError,ht.users,1)\n  \n def test_04_check_password(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertRaises(TypeError,ht.check_password,1,'realm','pass5')\n  self.assertRaises(TypeError,ht.check_password,'user',1,'pass5')\n  self.assertIs(ht.check_password(\"user5\",\"realm\",\"pass5\"),None )\n  for i in irange(1,5):\n   i=str(i)\n   self.assertTrue(ht.check_password(\"user\"+i,\"realm\",\"pass\"+i))\n   self.assertIs(ht.check_password(\"user\"+i,\"realm\",\"pass5\"),False )\n   \n   \n  self.assertRaises(TypeError,ht.check_password,\"user5\",\"pass5\")\n  ht.default_realm=\"realm\"\n  self.assertTrue(ht.check_password(\"user1\",\"pass1\"))\n  self.assertIs(ht.check_password(\"user5\",\"pass5\"),None )\n  \n  \n  with self.assertWarningList([\"verify\\(\\) is deprecated\"]*2):\n   self.assertTrue(ht.verify(\"user1\",\"realm\",\"pass1\"))\n   self.assertFalse(ht.verify(\"user1\",\"realm\",\"pass2\"))\n   \n   \n  self.assertRaises(ValueError,ht.check_password,\"user:\",\"realm\",\"pass\")\n  \n def test_05_load(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,\"\")\n  backdate_file_mtime(path,5)\n  ha=apache.HtdigestFile(path)\n  self.assertEqual(ha.to_string(),b\"\")\n  \n  \n  ha.set_password(\"user1\",\"realm\",\"pass1\")\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),b'user1:realm:2a6cf53e7d8f8cf39d946dc880b14128\\n')\n  \n  \n  set_file(path,self.sample_01)\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  ha.set_password(\"user5\",\"realm\",\"pass5\")\n  ha.load()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  hb=apache.HtdigestFile()\n  self.assertRaises(RuntimeError,hb.load)\n  self.assertRaises(RuntimeError,hb.load_if_changed)\n  \n  \n  hc=apache.HtdigestFile()\n  hc.load(path)\n  self.assertEqual(hc.to_string(),self.sample_01)\n  \n  \n  ensure_mtime_changed(path)\n  set_file(path,\"\")\n  with self.assertWarningList(r\"load\\(force=False\\) is deprecated\"):\n   ha.load(force=False )\n  self.assertEqual(ha.to_string(),b\"\")\n  \n def test_06_save(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtdigestFile(path)\n  \n  \n  ht.delete(\"user1\",\"realm\")\n  ht.delete(\"user2\",\"realm\")\n  ht.save()\n  self.assertEqual(get_file(path),self.sample_02)\n  \n  \n  hb=apache.HtdigestFile()\n  hb.set_password(\"user1\",\"realm\",\"pass1\")\n  self.assertRaises(RuntimeError,hb.save)\n  \n  \n  hb.save(path)\n  self.assertEqual(get_file(path),hb.to_string())\n  \n def test_07_realms(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  \n  self.assertEqual(ht.delete_realm(\"x\"),0)\n  self.assertEqual(ht.realms(),['realm'])\n  \n  self.assertEqual(ht.delete_realm(\"realm\"),4)\n  self.assertEqual(ht.realms(),[])\n  self.assertEqual(ht.to_string(),b\"\")\n  \n def test_08_get_hash(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertEqual(ht.get_hash(\"user3\",\"realm\"),\"a500bb8c02f6a9170ae46af10c898744\")\n  self.assertEqual(ht.get_hash(\"user4\",\"realm\"),\"ab7b5d5f28ccc7666315f508c7358519\")\n  self.assertEqual(ht.get_hash(\"user5\",\"realm\"),None )\n  \n  with self.assertWarningList(\"find\\(\\) is deprecated\"):\n   self.assertEqual(ht.find(\"user4\",\"realm\"),\"ab7b5d5f28ccc7666315f508c7358519\")\n   \n def test_09_encodings(self):\n  ''\n  \n  self.assertRaises(ValueError,apache.HtdigestFile,encoding=\"utf-16\")\n  \n  \n  ht=apache.HtdigestFile.from_string(self.sample_04_utf8,encoding=\"utf-8\",return_unicode=True )\n  self.assertEqual(ht.realms(),[u(\"realm\\u00e6\")])\n  self.assertEqual(ht.users(u(\"realm\\u00e6\")),[u(\"user\\u00e6\")])\n  \n  \n  ht=apache.HtdigestFile.from_string(self.sample_04_latin1,encoding=\"latin-1\",return_unicode=True )\n  self.assertEqual(ht.realms(),[u(\"realm\\u00e6\")])\n  self.assertEqual(ht.users(u(\"realm\\u00e6\")),[u(\"user\\u00e6\")])\n  \n def test_10_to_string(self):\n  ''\n  \n  \n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  \n  \n  ht=apache.HtdigestFile()\n  self.assertEqual(ht.to_string(),b\"\")\n  \n def test_11_malformed(self):\n  self.assertRaises(ValueError,apache.HtdigestFile.from_string,\n  b'realm:user1:pass1:other\\n')\n  self.assertRaises(ValueError,apache.HtdigestFile.from_string,\n  b'user1:pass1\\n')\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "os", "passlib", "passlib.exc", "passlib.tests.backports", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "subprocess"]], "passlib.tests.test_handlers_cisco": [".py", "''\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\n\nimport logging\nlog=logging.getLogger(__name__)\n\n\nfrom passlib import hash,exc\nfrom passlib.utils.compat import u\nfrom .utils import UserHandlerMixin,HandlerCase,repeat_string\nfrom .test_handlers import UPASS_TABLE\n\n__all__=[\n\"cisco_pix_test\",\n\"cisco_asa_test\",\n\"cisco_type7_test\",\n]\n\n\n\n\nclass _PixAsaSharedTest(UserHandlerMixin,HandlerCase):\n ''\n\n \n __unittest_skip=True\n requires_user=False\n \n \n \n pix_asa_shared_hashes=[\n \n \n \n ((\"cisco\",\"\"),\"2KFQnbNIdI.2KYOU\"),\n \n \n \n \n ((\"hsc\",\"\"),\"YtT8/k6Np8F1yz2c\"),\n \n \n \n \n ((\"\",\"\"),\"8Ry2YjIyt7RRXU24\"),\n ((\"cisco\",\"john\"),\"hN7LzeyYjw12FSIU\"),\n ((\"cisco\",\"jack\"),\"7DrfeZ7cyOj/PslD\"),\n \n \n \n \n ((\"ripper\",\"alex\"),\"h3mJrcH0901pqX/m\"),\n ((\"cisco\",\"cisco\"),\"3USUcOPFUiMCO4Jk\"),\n ((\"cisco\",\"cisco1\"),\"3USUcOPFUiMCO4Jk\"),\n ((\"CscFw-ITC!\",\"admcom\"),\"lZt7HSIXw3.QP7.R\"),\n (\"cangetin\",\"TynyB./ftknE77QP\"),\n ((\"cangetin\",\"rramsey\"),\"jgBZqYtsWfGcUKDi\"),\n \n \n \n \n ((\"phonehome\",\"rharris\"),\"zyIIMSYjiPm0L7a6\"),\n \n \n \n \n ((\"cangetin\",\"\"),\"TynyB./ftknE77QP\"),\n ((\"cangetin\",\"rramsey\"),\"jgBZqYtsWfGcUKDi\"),\n \n \n \n \n (\"test1\",\"TRPEas6f/aa6JSPL\"),\n (\"test2\",\"OMT6mXmAvGyzrCtp\"),\n (\"test3\",\"gTC7RIy1XJzagmLm\"),\n (\"test4\",\"oWC1WRwqlBlbpf/O\"),\n (\"password\",\"NuLKvvWGg.x9HEKO\"),\n (\"0123456789abcdef\",\".7nfVBEIEu4KbF/1\"),\n \n \n \n \n ((\"1234567890123456\",\"\"),\"feCkwUGktTCAgIbD\"),\n ((\"watag00s1am\",\"\"),\"jMorNbK0514fadBh\"),\n \n \n \n \n ((\"cisco1\",\"cisco1\"),\"jmINXNH6p1BxUppp\"),\n \n \n (UPASS_TABLE,'CaiIvkLMu2TOHXGT'),\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n (('1234',''),'RLPMUQ26KL4blgFN'),\n \n \n (('01234567',''),'0T52THgnYdV1tlOF'),\n (('01234567','3'),'.z0dT9Alkdc7EIGS'),\n (('01234567','36'),'CC3Lam53t/mHhoE7'),\n (('01234567','365'),'8xPrWpNnBdD2DzdZ'),\n (('01234567','3333'),'.z0dT9Alkdc7EIGS'),\n (('01234567','3636'),'CC3Lam53t/mHhoE7'),\n (('01234567','3653'),'8xPrWpNnBdD2DzdZ'),\n (('01234567','adm'),'dfWs2qiao6KD/P2L'),\n (('01234567','adma'),'dfWs2qiao6KD/P2L'),\n (('01234567','admad'),'dfWs2qiao6KD/P2L'),\n (('01234567','user'),'PNZ4ycbbZ0jp1.j1'),\n (('01234567','user1234'),'PNZ4ycbbZ0jp1.j1'),\n \n \n (('0123456789ab',''),'S31BxZOGlAigndcJ'),\n (('0123456789ab','36'),'wFqSX91X5.YaRKsi'),\n (('0123456789ab','365'),'qjgo3kNgTVxExbno'),\n (('0123456789ab','3333'),'mcXPL/vIZcIxLUQs'),\n (('0123456789ab','3636'),'wFqSX91X5.YaRKsi'),\n (('0123456789ab','3653'),'qjgo3kNgTVxExbno'),\n (('0123456789ab','user'),'f.T4BKdzdNkjxQl7'),\n (('0123456789ab','user1234'),'f.T4BKdzdNkjxQl7'),\n \n \n \n \n \n \n \n \n \n \n ((u(\"t\\xe1ble\").encode(\"utf-8\"),'user'),'Og8fB4NyF0m5Ed9c'),\n ((u(\"t\\xe1ble\").encode(\"utf-8\").decode(\"latin-1\").encode(\"utf-8\"),\n 'user'),'cMvFC2XVBmK/68yB'),\n ]\n \n def test_calc_digest_spoiler(self):\n  ''\n\n\n\n\n\n  \n  def calc(secret,for_hash=False ):\n   return self.handler(use_defaults=for_hash)._calc_checksum(secret)\n   \n   \n  short_secret=repeat_string(\"1234\",self.handler.truncate_size)\n  short_hash=calc(short_secret)\n  \n  \n  \n  long_secret=short_secret+\"X\"\n  long_hash=calc(long_secret)\n  self.assertNotEqual(long_hash,short_hash)\n  \n  \n  \n  alt_long_secret=short_secret+\"Y\"\n  alt_long_hash=calc(alt_long_secret)\n  self.assertNotEqual(alt_long_hash,short_hash)\n  self.assertNotEqual(alt_long_hash,long_hash)\n  \n  \n  calc(short_secret,for_hash=True )\n  self.assertRaises(exc.PasswordSizeError,calc,long_secret,for_hash=True )\n  self.assertRaises(exc.PasswordSizeError,calc,alt_long_secret,for_hash=True )\n  \n  \n  \n  \nclass cisco_pix_test(_PixAsaSharedTest):\n handler=hash.cisco_pix\n \n \n known_correct_hashes=_PixAsaSharedTest.pix_asa_shared_hashes+[\n \n \n \n \n \n \n \n \n \n \n \n \n \n (('0123456789abc',''),'eacOpB7vE7ZDukSF'),\n (('0123456789abc','3'),'ylJTd/qei66WZe3w'),\n (('0123456789abc','36'),'hDx8QRlUhwd6bU8N'),\n (('0123456789abc','365'),'vYOOtnkh1HXcMrM7'),\n (('0123456789abc','3333'),'ylJTd/qei66WZe3w'),\n (('0123456789abc','3636'),'hDx8QRlUhwd6bU8N'),\n (('0123456789abc','3653'),'vYOOtnkh1HXcMrM7'),\n (('0123456789abc','user'),'f4/.SALxqDo59mfV'),\n (('0123456789abc','user1234'),'f4/.SALxqDo59mfV'),\n \n \n (('0123456789abcd',''),'6r8888iMxEoPdLp4'),\n (('0123456789abcd','3'),'f5lvmqWYj9gJqkIH'),\n (('0123456789abcd','36'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','365'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','3333'),'f5lvmqWYj9gJqkIH'),\n (('0123456789abcd','3636'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','3653'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','adm'),'DbPLCFIkHc2SiyDk'),\n (('0123456789abcd','adma'),'DbPLCFIkHc2SiyDk'),\n (('0123456789abcd','user'),'WfO2UiTapPkF/FSn'),\n (('0123456789abcd','user1234'),'WfO2UiTapPkF/FSn'),\n \n \n (('0123456789abcde',''),'al1e0XFIugTYLai3'),\n (('0123456789abcde','3'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','36'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','365'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','3333'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','3636'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','3653'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','adm'),'KgKx1UQvdR/09i9u'),\n (('0123456789abcde','adma'),'KgKx1UQvdR/09i9u'),\n (('0123456789abcde','user'),'qLopkenJ4WBqxaZN'),\n (('0123456789abcde','user1234'),'qLopkenJ4WBqxaZN'),\n \n \n (('0123456789abcdef',''),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','36'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','365'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','3333'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','3636'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','3653'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','user'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','user1234'),'.7nfVBEIEu4KbF/1'),\n ]\n \n \n \n \n \nclass cisco_asa_test(_PixAsaSharedTest):\n handler=hash.cisco_asa\n \n known_correct_hashes=_PixAsaSharedTest.pix_asa_shared_hashes+[\n \n \n \n \n \n \n \n \n \n \n \n \n (('0123456789abc',''),'eacOpB7vE7ZDukSF'),\n (('0123456789abc','36'),'FRV9JG18UBEgX0.O'),\n (('0123456789abc','365'),'NIwkusG9hmmMy6ZQ'),\n (('0123456789abc','3333'),'NmrkP98nT7RAeKZz'),\n (('0123456789abc','3636'),'FRV9JG18UBEgX0.O'),\n (('0123456789abc','3653'),'NIwkusG9hmmMy6ZQ'),\n (('0123456789abc','user'),'8Q/FZeam5ai1A47p'),\n (('0123456789abc','user1234'),'8Q/FZeam5ai1A47p'),\n \n \n (('0123456789abcd',''),'6r8888iMxEoPdLp4'),\n (('0123456789abcd','3'),'yxGoujXKPduTVaYB'),\n (('0123456789abcd','36'),'W0jckhnhjnr/DiT/'),\n (('0123456789abcd','365'),'HuVOxfMQNahaoF8u'),\n (('0123456789abcd','3333'),'yxGoujXKPduTVaYB'),\n (('0123456789abcd','3636'),'W0jckhnhjnr/DiT/'),\n (('0123456789abcd','3653'),'HuVOxfMQNahaoF8u'),\n (('0123456789abcd','adm'),'RtOmSeoCs4AUdZqZ'),\n (('0123456789abcd','adma'),'RtOmSeoCs4AUdZqZ'),\n (('0123456789abcd','user'),'rrucwrcM0h25pr.m'),\n (('0123456789abcd','user1234'),'rrucwrcM0h25pr.m'),\n \n \n (('0123456789abcde',''),'al1e0XFIugTYLai3'),\n (('0123456789abcde','3'),'nAZrQoHaL.fgrIqt'),\n (('0123456789abcde','36'),'2GxIQ6ICE795587X'),\n (('0123456789abcde','365'),'QmDsGwCRBbtGEKqM'),\n (('0123456789abcde','3333'),'nAZrQoHaL.fgrIqt'),\n (('0123456789abcde','3636'),'2GxIQ6ICE795587X'),\n (('0123456789abcde','3653'),'QmDsGwCRBbtGEKqM'),\n (('0123456789abcde','adm'),'Aj2aP0d.nk62wl4m'),\n (('0123456789abcde','adma'),'Aj2aP0d.nk62wl4m'),\n (('0123456789abcde','user'),'etxiXfo.bINJcXI7'),\n (('0123456789abcde','user1234'),'etxiXfo.bINJcXI7'),\n \n \n (('0123456789abcdef',''),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','36'),'GhI8.yFSC5lwoafg'),\n (('0123456789abcdef','365'),'KFBI6cNQauyY6h/G'),\n (('0123456789abcdef','3333'),'Ghdi1IlsswgYzzMH'),\n (('0123456789abcdef','3636'),'GhI8.yFSC5lwoafg'),\n (('0123456789abcdef','3653'),'KFBI6cNQauyY6h/G'),\n (('0123456789abcdef','user'),'IneB.wc9sfRzLPoh'),\n (('0123456789abcdef','user1234'),'IneB.wc9sfRzLPoh'),\n \n \n \n \n \n (('0123456789abcdefq',''),'bKshl.EN.X3CVFRQ'),\n (('0123456789abcdefq','36'),'JAeTXHs0n30svlaG'),\n (('0123456789abcdefq','365'),'4fKSSUBHT1ChGqHp'),\n (('0123456789abcdefq','3333'),'USEJbxI6.VY4ecBP'),\n (('0123456789abcdefq','3636'),'JAeTXHs0n30svlaG'),\n (('0123456789abcdefq','3653'),'4fKSSUBHT1ChGqHp'),\n (('0123456789abcdefq','user'),'/dwqyD7nGdwSrDwk'),\n (('0123456789abcdefq','user1234'),'/dwqyD7nGdwSrDwk'),\n \n \n (('0123456789abcdefqwertyuiopa',''),'4wp19zS3OCe.2jt5'),\n (('0123456789abcdefqwertyuiopa','36'),'PjUoGqWBKPyV9qOe'),\n (('0123456789abcdefqwertyuiopa','365'),'bfCy6xFAe5O/gzvM'),\n (('0123456789abcdefqwertyuiopa','3333'),'rd/ZMuGTJFIb2BNG'),\n (('0123456789abcdefqwertyuiopa','3636'),'PjUoGqWBKPyV9qOe'),\n (('0123456789abcdefqwertyuiopa','3653'),'bfCy6xFAe5O/gzvM'),\n (('0123456789abcdefqwertyuiopa','user'),'zynfWw3UtszxLMgL'),\n (('0123456789abcdefqwertyuiopa','user1234'),'zynfWw3UtszxLMgL'),\n \n \n \n \n (('0123456789abcdefqwertyuiopas',''),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','36'),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','365'),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','user'),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','user1234'),'W6nbOddI0SutTK7m'),\n \n \n \n (('0123456789abcdefqwertyuiopasdfgh',''),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','36'),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','365'),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','user'),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','user1234'),'5hPT/iC6DnoBxo6a'),\n ]\n \n \n \n \n \nclass cisco_type7_test(HandlerCase):\n handler=hash.cisco_type7\n salt_bits=4\n salt_type=int\n \n known_correct_hashes=[\n \n \n \n (\"secure \",\"04480E051A33490E\"),\n \n \n \n \n (\"Its time to go to lunch!\",\n \"153B1F1F443E22292D73212D5300194315591954465A0D0B59\"),\n \n \n \n \n (\"t35t:pa55w0rd\",\"08351F1B1D431516475E1B54382F\"),\n \n \n \n \n (\"hiImTesting:)\",\"020E0D7206320A325847071E5F5E\"),\n \n \n \n \n (\"cisco123\",\"060506324F41584B56\"),\n (\"cisco123\",\"1511021F07257A767B\"),\n \n \n \n \n ('Supe&8ZUbeRp4SS',\"06351A3149085123301517391C501918\"),\n \n \n \n \n \n \n (UPASS_TABLE,'0958EDC8A9F495F6F8A5FD'),\n ]\n \n known_unidentified_hashes=[\n \n \"0A480E051A33490E\",\n \n \n \n '99400E4812',\n ]\n \n def test_90_decode(self):\n  ''\n  from passlib.utils import to_unicode,to_bytes\n  \n  handler=self.handler\n  for secret,hash in self.known_correct_hashes:\n   usecret=to_unicode(secret)\n   bsecret=to_bytes(secret)\n   self.assertEqual(handler.decode(hash),usecret)\n   self.assertEqual(handler.decode(hash,None ),bsecret)\n   \n  self.assertRaises(UnicodeDecodeError,handler.decode,\n  '0958EDC8A9F495F6F8A5FD','ascii')\n  \n def test_91_salt(self):\n  ''\n  handler=self.handler\n  self.assertRaises(TypeError,handler,salt=None )\n  handler(salt=None ,use_defaults=True )\n  self.assertRaises(TypeError,handler,salt='abc')\n  self.assertRaises(ValueError,handler,salt=-10)\n  self.assertRaises(ValueError,handler,salt=100)\n  \n  self.assertRaises(TypeError,handler.using,salt='abc')\n  self.assertRaises(ValueError,handler.using,salt=-10)\n  self.assertRaises(ValueError,handler.using,salt=100)\n  with self.assertWarningList(\"salt/offset must be.*\"):\n   subcls=handler.using(salt=100,relaxed=True )\n  self.assertEqual(subcls(use_defaults=True ).salt,52)\n  \n  \n  \n  \n", ["__future__", "logging", "passlib", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat"]], "passlib.tests.test_utils_handlers": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport re\nimport hashlib\nfrom logging import getLogger\nimport warnings\n\n\nfrom passlib.hash import ldap_md5,sha256_crypt\nfrom passlib.exc import MissingBackendError,PasslibHashWarning\nfrom passlib.utils.compat import str_to_uascii,\\\nuascii_to_str,unicode\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import HandlerCase,TestCase\nfrom passlib.utils.compat import u\n\nlog=getLogger(__name__)\n\n\n\n\ndef _makelang(alphabet,size):\n ''\n def helper(size):\n  if size <2:\n   for char in alphabet:\n    yield char\n  else :\n   for char in alphabet:\n    for tail in helper(size -1):\n     yield char+tail\n return set(helper(size))\n \n \n \n \nclass SkeletonTest(TestCase):\n ''\n \n \n \n \n def test_00_static_handler(self):\n  ''\n  \n  class d1(uh.StaticHandler):\n   name=\"d1\"\n   context_kwds=(\"flag\",)\n   _hash_prefix=u(\"_\")\n   checksum_chars=u(\"ab\")\n   checksum_size=1\n   \n   def __init__(self,flag=False ,**kwds):\n    super(d1,self).__init__(**kwds)\n    self.flag=flag\n    \n   def _calc_checksum(self,secret):\n    return u('b')if self.flag else u('a')\n    \n    \n  self.assertTrue(d1.identify(u('_a')))\n  self.assertTrue(d1.identify(b'_a'))\n  self.assertTrue(d1.identify(u('_b')))\n  \n  self.assertFalse(d1.identify(u('_c')))\n  self.assertFalse(d1.identify(b'_c'))\n  self.assertFalse(d1.identify(u('a')))\n  self.assertFalse(d1.identify(u('b')))\n  self.assertFalse(d1.identify(u('c')))\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  \n  \n  self.assertEqual(d1.genconfig(),d1.hash(\"\"))\n  \n  \n  self.assertTrue(d1.verify('s',b'_a'))\n  self.assertTrue(d1.verify('s',u('_a')))\n  self.assertFalse(d1.verify('s',b'_b'))\n  self.assertFalse(d1.verify('s',u('_b')))\n  self.assertTrue(d1.verify('s',b'_b',flag=True ))\n  self.assertRaises(ValueError,d1.verify,'s',b'_c')\n  self.assertRaises(ValueError,d1.verify,'s',u('_c'))\n  \n  \n  self.assertEqual(d1.hash('s'),'_a')\n  self.assertEqual(d1.hash('s',flag=True ),'_b')\n  \n def test_01_calc_checksum_hack(self):\n  ''\n  \n  \n  \n  \n  class d1(uh.StaticHandler):\n   name=\"d1\"\n   \n   @classmethod\n   def identify(cls,hash):\n    if not hash or len(hash)!=40:\n     return False\n    try :\n     int(hash,16)\n    except ValueError:\n     return False\n    return True\n    \n   @classmethod\n   def genhash(cls,secret,hash):\n    if secret is None :\n     raise TypeError(\"no secret provided\")\n    if isinstance(secret,unicode):\n     secret=secret.encode(\"utf-8\")\n     \n    if hash is not None and not cls.identify(hash):\n     raise ValueError(\"invalid hash\")\n    return hashlib.sha1(b\"xyz\"+secret).hexdigest()\n    \n   @classmethod\n   def verify(cls,secret,hash):\n    if hash is None :\n     raise ValueError(\"no hash specified\")\n    return cls.genhash(secret,hash)==hash.lower()\n    \n    \n  with self.assertWarningList(\"d1.*should be updated.*_calc_checksum\"):\n   hash=d1.hash(\"test\")\n  self.assertEqual(hash,'7c622762588a0e5cc786ad0a143156f9fd38eea3')\n  \n  self.assertTrue(d1.verify(\"test\",hash))\n  self.assertFalse(d1.verify(\"xtest\",hash))\n  \n  \n  del d1.genhash\n  self.assertRaises(NotImplementedError,d1.hash,'test')\n  \n  \n  \n  \n def test_10_identify(self):\n  ''\n  class d1(uh.GenericHandler):\n   @classmethod\n   def from_string(cls,hash):\n    if isinstance(hash,bytes):\n     hash=hash.decode(\"ascii\")\n    if hash ==u('a'):\n     return cls(checksum=hash)\n    else :\n     raise ValueError\n     \n     \n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  self.assertFalse(d1.identify(''))\n  self.assertTrue(d1.identify('a'))\n  self.assertFalse(d1.identify('b'))\n  \n  \n  d1._hash_regex=re.compile(u('@.'))\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  self.assertTrue(d1.identify('@a'))\n  self.assertFalse(d1.identify('a'))\n  del d1._hash_regex\n  \n  \n  d1.ident=u('!')\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  self.assertTrue(d1.identify('!a'))\n  self.assertFalse(d1.identify('a'))\n  del d1.ident\n  \n def test_11_norm_checksum(self):\n  ''\n  \n  class d1(uh.GenericHandler):\n   name='d1'\n   checksum_size=4\n   checksum_chars=u('xz')\n   \n  def norm_checksum(checksum=None ,**k):\n   return d1(checksum=checksum,**k).checksum\n   \n   \n  self.assertRaises(ValueError,norm_checksum,u('xxx'))\n  \n  \n  self.assertEqual(norm_checksum(u('xxxx')),u('xxxx'))\n  self.assertEqual(norm_checksum(u('xzxz')),u('xzxz'))\n  \n  \n  self.assertRaises(ValueError,norm_checksum,u('xxxxx'))\n  \n  \n  self.assertRaises(ValueError,norm_checksum,u('xxyx'))\n  \n  \n  self.assertRaises(TypeError,norm_checksum,b'xxyx')\n  \n  \n  \n  \n  \n  \n  \n  \n  self.assertEqual(d1()._stub_checksum,u('xxxx'))\n  \n def test_12_norm_checksum_raw(self):\n  ''\n  class d1(uh.HasRawChecksum,uh.GenericHandler):\n   name='d1'\n   checksum_size=4\n   \n  def norm_checksum(*a,**k):\n   return d1(*a,**k).checksum\n   \n   \n  self.assertEqual(norm_checksum(b'1234'),b'1234')\n  \n  \n  self.assertRaises(TypeError,norm_checksum,u('xxyx'))\n  \n  \n  \n  \n  \n  self.assertEqual(d1()._stub_checksum,b'\\x00'*4)\n  \n def test_20_norm_salt(self):\n  ''\n  \n  class d1(uh.HasSalt,uh.GenericHandler):\n   name='d1'\n   setting_kwds=('salt',)\n   min_salt_size=2\n   max_salt_size=4\n   default_salt_size=3\n   salt_chars='ab'\n   \n  def norm_salt(**k):\n   return d1(**k).salt\n   \n  def gen_salt(sz,**k):\n   return d1.using(salt_size=sz,**k)(use_defaults=True ).salt\n   \n  salts2=_makelang('ab',2)\n  salts3=_makelang('ab',3)\n  salts4=_makelang('ab',4)\n  \n  \n  self.assertRaises(TypeError,norm_salt)\n  self.assertRaises(TypeError,norm_salt,salt=None )\n  self.assertIn(norm_salt(use_defaults=True ),salts3)\n  \n  \n  with warnings.catch_warnings(record=True )as wlog:\n  \n  \n   self.assertRaises(ValueError,norm_salt,salt='')\n   self.assertRaises(ValueError,norm_salt,salt='a')\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertEqual(norm_salt(salt='ab'),'ab')\n   self.assertEqual(norm_salt(salt='aba'),'aba')\n   self.assertEqual(norm_salt(salt='abba'),'abba')\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertRaises(ValueError,norm_salt,salt='aaaabb')\n   self.consumeWarningList(wlog)\n   \n   \n  with warnings.catch_warnings(record=True )as wlog:\n  \n  \n   self.assertRaises(ValueError,gen_salt,0)\n   self.assertRaises(ValueError,gen_salt,1)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertIn(gen_salt(2),salts2)\n   self.assertIn(gen_salt(3),salts3)\n   self.assertIn(gen_salt(4),salts4)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertRaises(ValueError,gen_salt,5)\n   self.consumeWarningList(wlog)\n   \n   self.assertIn(gen_salt(5,relaxed=True ),salts4)\n   self.consumeWarningList(wlog,[\"salt_size.*above max_salt_size\"])\n   \n   \n  del d1.max_salt_size\n  with self.assertWarningList([]):\n   self.assertEqual(len(gen_salt(None )),3)\n   self.assertEqual(len(gen_salt(5)),5)\n   \n   \n   \n def test_30_init_rounds(self):\n  ''\n  \n  class d1(uh.HasRounds,uh.GenericHandler):\n   name='d1'\n   setting_kwds=('rounds',)\n   min_rounds=1\n   max_rounds=3\n   default_rounds=2\n   \n   \n  def norm_rounds(**k):\n   return d1(**k).rounds\n   \n   \n  self.assertRaises(TypeError,norm_rounds)\n  self.assertRaises(TypeError,norm_rounds,rounds=None )\n  self.assertEqual(norm_rounds(use_defaults=True ),2)\n  \n  \n  self.assertRaises(TypeError,norm_rounds,rounds=1.5)\n  \n  \n  with warnings.catch_warnings(record=True )as wlog:\n  \n   self.assertRaises(ValueError,norm_rounds,rounds=0)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertEqual(norm_rounds(rounds=1),1)\n   self.assertEqual(norm_rounds(rounds=2),2)\n   self.assertEqual(norm_rounds(rounds=3),3)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertRaises(ValueError,norm_rounds,rounds=4)\n   self.consumeWarningList(wlog)\n   \n   \n  d1.default_rounds=None\n  self.assertRaises(TypeError,norm_rounds,use_defaults=True )\n  \n def test_40_backends(self):\n  ''\n  class d1(uh.HasManyBackends,uh.GenericHandler):\n   name='d1'\n   setting_kwds=()\n   \n   backends=(\"a\",\"b\")\n   \n   _enable_a=False\n   _enable_b=False\n   \n   @classmethod\n   def _load_backend_a(cls):\n    if cls._enable_a:\n     cls._set_calc_checksum_backend(cls._calc_checksum_a)\n     return True\n    else :\n     return False\n     \n   @classmethod\n   def _load_backend_b(cls):\n    if cls._enable_b:\n     cls._set_calc_checksum_backend(cls._calc_checksum_b)\n     return True\n    else :\n     return False\n     \n   def _calc_checksum_a(self,secret):\n    return 'a'\n    \n   def _calc_checksum_b(self,secret):\n    return 'b'\n    \n    \n  self.assertRaises(MissingBackendError,d1.get_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend,'any')\n  self.assertRaises(MissingBackendError,d1.set_backend,'default')\n  self.assertFalse(d1.has_backend())\n  \n  \n  d1._enable_b=True\n  \n  \n  obj=d1()\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  d1.set_backend('b')\n  d1.set_backend('any')\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  self.assertRaises(MissingBackendError,d1.set_backend,'a')\n  self.assertTrue(d1.has_backend('b'))\n  self.assertFalse(d1.has_backend('a'))\n  \n  \n  d1._enable_a=True\n  \n  \n  self.assertTrue(d1.has_backend())\n  d1.set_backend('a')\n  self.assertEqual(obj._calc_checksum('s'),'a')\n  \n  \n  self.assertRaises(ValueError,d1.set_backend,'c')\n  self.assertRaises(ValueError,d1.has_backend,'c')\n  \n  \n  d1.set_backend(\"b\")\n  class d2(d1):\n   _has_backend_a=True\n  self.assertRaises(AssertionError,d2.has_backend,\"a\")\n  \n def test_41_backends(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\n  category=DeprecationWarning,\n  message=r\".* support for \\._has_backend_.* is deprecated.*\",\n  )\n  \n  class d1(uh.HasManyBackends,uh.GenericHandler):\n   name='d1'\n   setting_kwds=()\n   \n   backends=(\"a\",\"b\")\n   \n   _has_backend_a=False\n   _has_backend_b=False\n   \n   def _calc_checksum_a(self,secret):\n    return 'a'\n    \n   def _calc_checksum_b(self,secret):\n    return 'b'\n    \n    \n  self.assertRaises(MissingBackendError,d1.get_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend,'any')\n  self.assertRaises(MissingBackendError,d1.set_backend,'default')\n  self.assertFalse(d1.has_backend())\n  \n  \n  d1._has_backend_b=True\n  \n  \n  obj=d1()\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  d1.set_backend('b')\n  d1.set_backend('any')\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  self.assertRaises(MissingBackendError,d1.set_backend,'a')\n  self.assertTrue(d1.has_backend('b'))\n  self.assertFalse(d1.has_backend('a'))\n  \n  \n  d1._has_backend_a=True\n  \n  \n  self.assertTrue(d1.has_backend())\n  d1.set_backend('a')\n  self.assertEqual(obj._calc_checksum('s'),'a')\n  \n  \n  self.assertRaises(ValueError,d1.set_backend,'c')\n  self.assertRaises(ValueError,d1.has_backend,'c')\n  \n def test_50_norm_ident(self):\n  ''\n  \n  class d1(uh.HasManyIdents,uh.GenericHandler):\n   name='d1'\n   setting_kwds=('ident',)\n   default_ident=u(\"!A\")\n   ident_values=(u(\"!A\"),u(\"!B\"))\n   ident_aliases={u(\"A\"):u(\"!A\")}\n   \n  def norm_ident(**k):\n   return d1(**k).ident\n   \n   \n  self.assertRaises(TypeError,norm_ident)\n  self.assertRaises(TypeError,norm_ident,ident=None )\n  self.assertEqual(norm_ident(use_defaults=True ),u('!A'))\n  \n  \n  self.assertEqual(norm_ident(ident=u('!A')),u('!A'))\n  self.assertEqual(norm_ident(ident=u('!B')),u('!B'))\n  self.assertRaises(ValueError,norm_ident,ident=u('!C'))\n  \n  \n  self.assertEqual(norm_ident(ident=u('A')),u('!A'))\n  \n  \n  self.assertRaises(ValueError,norm_ident,ident=u('B'))\n  \n  \n  self.assertTrue(d1.identify(u(\"!Axxx\")))\n  self.assertTrue(d1.identify(u(\"!Bxxx\")))\n  self.assertFalse(d1.identify(u(\"!Cxxx\")))\n  self.assertFalse(d1.identify(u(\"A\")))\n  self.assertFalse(d1.identify(u(\"\")))\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  \n  \n  d1.default_ident=None\n  self.assertRaises(AssertionError,norm_ident,use_defaults=True )\n  \n  \n  \n  \n  \n def test_91_parsehash(self):\n  ''\n  \n  from passlib import hash\n  \n  \n  \n  \n  \n  \n  result=hash.des_crypt.parsehash(\"OgAwTx2l6NADI\")\n  self.assertEqual(result,{'checksum':u('AwTx2l6NADI'),'salt':u('Og')})\n  \n  \n  h='$5$LKO/Ute40T3FNF95$U0prpBQd4PloSGU0pnpM4z9wKn4vZ1.jsrzQfPqxph9'\n  s=u('LKO/Ute40T3FNF95')\n  c=u('U0prpBQd4PloSGU0pnpM4z9wKn4vZ1.jsrzQfPqxph9')\n  result=hash.sha256_crypt.parsehash(h)\n  self.assertEqual(result,dict(salt=s,rounds=5000,\n  implicit_rounds=True ,checksum=c))\n  \n  \n  result=hash.sha256_crypt.parsehash(h,checksum=False )\n  self.assertEqual(result,dict(salt=s,rounds=5000,implicit_rounds=True ))\n  \n  \n  result=hash.sha256_crypt.parsehash(h,sanitize=True )\n  self.assertEqual(result,dict(rounds=5000,implicit_rounds=True ,\n  salt=u('LK**************'),\n  checksum=u('U0pr***************************************')))\n  \n  \n  result=hash.sha256_crypt.parsehash('$5$rounds=10428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3')\n  self.assertEqual(result,dict(\n  checksum=u('YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3'),\n  salt=u('uy/jIAhCetNCTtb0'),\n  rounds=10428,\n  ))\n  \n  \n  h1='$pbkdf2$60000$DoEwpvQeA8B4T.k951yLUQ$O26Y3/NJEiLCVaOVPxGXshyjW8k'\n  result=hash.pbkdf2_sha1.parsehash(h1)\n  self.assertEqual(result,dict(\n  checksum=b';n\\x98\\xdf\\xf3I\\x12\"\\xc2U\\xa3\\x95?\\x11\\x97\\xb2\\x1c\\xa3[\\xc9',\n  rounds=60000,\n  salt=b'\\x0e\\x810\\xa6\\xf4\\x1e\\x03\\xc0xO\\xe9=\\xe7\\\\\\x8bQ',\n  ))\n  \n  \n  result=hash.pbkdf2_sha1.parsehash(h1,sanitize=True )\n  self.assertEqual(result,dict(\n  checksum=u('O26************************'),\n  rounds=60000,\n  salt=u('Do********************'),\n  ))\n  \n def test_92_bitsize(self):\n  ''\n  \n  from passlib import hash\n  \n  \n  self.assertEqual(hash.des_crypt.bitsize(),\n  {'checksum':66,'salt':12})\n  \n  \n  self.assertEqual(hash.bcrypt.bitsize(),\n  {'checksum':186,'salt':132})\n  \n  \n  \n  \n  self.patchAttr(hash.sha256_crypt,\"default_rounds\",1 <<(14+3))\n  self.assertEqual(hash.sha256_crypt.bitsize(),\n  {'checksum':258,'rounds':14,'salt':96})\n  \n  \n  self.patchAttr(hash.pbkdf2_sha1,\"default_rounds\",1 <<(13+3))\n  self.assertEqual(hash.pbkdf2_sha1.bitsize(),\n  {'checksum':160,'rounds':13,'salt':128})\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass dummy_handler_in_registry(object):\n ''\n def __init__(self,name):\n  self.name=name\n  self.dummy=type('dummy_'+name,(uh.GenericHandler,),dict(\n  name=name,\n  setting_kwds=(),\n  ))\n  \n def __enter__(self):\n  from passlib import registry\n  registry._unload_handler_name(self.name,locations=False )\n  registry.register_crypt_handler(self.dummy)\n  assert registry.get_crypt_handler(self.name)is self.dummy\n  return self.dummy\n  \n def __exit__(self,*exc_info):\n  from passlib import registry\n  registry._unload_handler_name(self.name,locations=False )\n  \nclass PrefixWrapperTest(TestCase):\n ''\n \n def test_00_lazy_loading(self):\n  ''\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\",lazy=True )\n  \n  \n  self.assertEqual(d1._wrapped_name,\"ldap_md5\")\n  self.assertIs(d1._wrapped_handler,None )\n  \n  \n  self.assertIs(d1.wrapped,ldap_md5)\n  self.assertIs(d1._wrapped_handler,ldap_md5)\n  \n  \n  with dummy_handler_in_registry(\"ldap_md5\")as dummy:\n   self.assertIs(d1.wrapped,ldap_md5)\n   \n def test_01_active_loading(self):\n  ''\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  \n  \n  self.assertEqual(d1._wrapped_name,\"ldap_md5\")\n  self.assertIs(d1._wrapped_handler,ldap_md5)\n  self.assertIs(d1.wrapped,ldap_md5)\n  \n  \n  with dummy_handler_in_registry(\"ldap_md5\")as dummy:\n   self.assertIs(d1.wrapped,ldap_md5)\n   \n def test_02_explicit(self):\n  ''\n  \n  d1=uh.PrefixWrapper(\"d1\",ldap_md5,\"{XXX}\",\"{MD5}\")\n  \n  \n  self.assertEqual(d1._wrapped_name,None )\n  self.assertIs(d1._wrapped_handler,ldap_md5)\n  self.assertIs(d1.wrapped,ldap_md5)\n  \n  \n  with dummy_handler_in_registry(\"ldap_md5\")as dummy:\n   self.assertIs(d1.wrapped,ldap_md5)\n   \n def test_10_wrapped_attributes(self):\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  self.assertEqual(d1.name,\"d1\")\n  self.assertIs(d1.setting_kwds,ldap_md5.setting_kwds)\n  self.assertFalse('max_rounds'in dir(d1))\n  \n  d2=uh.PrefixWrapper(\"d2\",\"sha256_crypt\",\"{XXX}\")\n  self.assertIs(d2.setting_kwds,sha256_crypt.setting_kwds)\n  self.assertTrue('max_rounds'in dir(d2))\n  \n def test_11_wrapped_methods(self):\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  dph=\"{XXX}X03MO1qnZdYdgyfeuILPmQ==\"\n  lph=\"{MD5}X03MO1qnZdYdgyfeuILPmQ==\"\n  \n  \n  self.assertEqual(d1.genconfig(),'{XXX}1B2M2Y8AsgTpgAmY7PhCfg==')\n  \n  \n  self.assertRaises(TypeError,d1.genhash,\"password\",None )\n  self.assertEqual(d1.genhash(\"password\",dph),dph)\n  self.assertRaises(ValueError,d1.genhash,\"password\",lph)\n  \n  \n  self.assertEqual(d1.hash(\"password\"),dph)\n  \n  \n  self.assertTrue(d1.identify(dph))\n  self.assertFalse(d1.identify(lph))\n  \n  \n  self.assertRaises(ValueError,d1.verify,\"password\",lph)\n  self.assertTrue(d1.verify(\"password\",dph))\n  \n def test_12_ident(self):\n \n  h=uh.PrefixWrapper(\"h2\",\"ldap_md5\",\"{XXX}\")\n  self.assertEqual(h.ident,u(\"{XXX}{MD5}\"))\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h2\",\"des_crypt\",\"{XXX}\")\n  self.assertIs(h.ident,None )\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  self.assertIs(h.ident,None )\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h3\",\"ldap_md5\",\"{XXX}\",ident=\"{X\")\n  self.assertEqual(h.ident,u(\"{X\"))\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h3\",\"ldap_md5\",\"{XXX}\",ident=\"{XXX}A\")\n  self.assertRaises(ValueError,uh.PrefixWrapper,\"h3\",\"ldap_md5\",\n  \"{XXX}\",ident=\"{XY\")\n  self.assertRaises(ValueError,uh.PrefixWrapper,\"h3\",\"ldap_md5\",\n  \"{XXX}\",ident=\"{XXXX\")\n  \n  \n  h=uh.PrefixWrapper(\"h4\",\"phpass\",\"{XXX}\")\n  self.assertIs(h.ident,None )\n  self.assertEqual(h.ident_values,(u(\"{XXX}$P$\"),u(\"{XXX}$H$\")))\n  \n  \n  h=uh.PrefixWrapper(\"h5\",\"des_crypt\",\"{XXX}\",ident=True )\n  self.assertEqual(h.ident,u(\"{XXX}\"))\n  self.assertIs(h.ident_values,None )\n  \n  \n  self.assertRaises(ValueError,uh.PrefixWrapper,\"h6\",\"des_crypt\",ident=True )\n  \n  \n  with self.assertWarningList(\"orig_prefix.*may not work correctly\"):\n   h=uh.PrefixWrapper(\"h7\",\"phpass\",orig_prefix=\"$\",prefix=\"?\")\n  self.assertEqual(h.ident_values,None )\n  self.assertEqual(h.ident,None )\n  \n def test_13_repr(self):\n  ''\n  h=uh.PrefixWrapper(\"h2\",\"md5_crypt\",\"{XXX}\",orig_prefix=\"$1$\")\n  self.assertRegex(repr(h),\n  r\"\"\"(?x)^PrefixWrapper\\(\n                ['\"]h2['\"],\\s+\n                ['\"]md5_crypt['\"],\\s+\n                prefix=u?[\"']{XXX}['\"],\\s+\n                orig_prefix=u?[\"']\\$1\\$['\"]\n            \\)$\"\"\")\n  \n def test_14_bad_hash(self):\n  ''\n  \n  \n  h=uh.PrefixWrapper(\"h2\",\"md5_crypt\",orig_prefix=\"$6$\")\n  self.assertRaises(ValueError,h.hash,'test')\n  \n  \n  \n  \n  \n  \nclass UnsaltedHash(uh.StaticHandler):\n ''\n name=\"unsalted_test_hash\"\n checksum_chars=uh.LOWER_HEX_CHARS\n checksum_size=40\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  data=b\"boblious\"+secret\n  return str_to_uascii(hashlib.sha1(data).hexdigest())\n  \nclass SaltedHash(uh.HasSalt,uh.GenericHandler):\n ''\n name=\"salted_test_hash\"\n setting_kwds=(\"salt\",)\n \n min_salt_size=2\n max_salt_size=4\n checksum_size=40\n salt_chars=checksum_chars=uh.LOWER_HEX_CHARS\n \n _hash_regex=re.compile(u(\"^@salt[0-9a-f]{42,44}$\"))\n \n @classmethod\n def from_string(cls,hash):\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  return cls(salt=hash[5:-40],checksum=hash[-40:])\n  \n def to_string(self):\n  hash=u(\"@salt%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  data=self.salt.encode(\"ascii\")+secret+self.salt.encode(\"ascii\")\n  return str_to_uascii(hashlib.sha1(data).hexdigest())\n  \n  \n  \n  \n  \n  \n  \n  \nUPASS_TEMP=u('\\u0399\\u03c9\\u03b1\\u03bd\\u03bd\\u03b7\\u03c2')\n\nclass UnsaltedHashTest(HandlerCase):\n handler=UnsaltedHash\n \n known_correct_hashes=[\n (\"password\",\"61cfd32684c47de231f1f982c214e884133762c0\"),\n (UPASS_TEMP,'96b329d120b97ff81ada770042e44ba87343ad2b'),\n ]\n \n def test_bad_kwds(self):\n  self.assertRaises(TypeError,UnsaltedHash,salt='x')\n  self.assertRaises(TypeError,UnsaltedHash.genconfig,rounds=1)\n  \nclass SaltedHashTest(HandlerCase):\n handler=SaltedHash\n \n known_correct_hashes=[\n (\"password\",'@salt77d71f8fe74f314dac946766c1ac4a2a58365482c0'),\n (UPASS_TEMP,'@salt9f978a9bfe360d069b0c13f2afecd570447407fa7e48'),\n ]\n \n def test_bad_kwds(self):\n  stub=SaltedHash(use_defaults=True )._stub_checksum\n  self.assertRaises(TypeError,SaltedHash,checksum=stub,salt=None )\n  self.assertRaises(ValueError,SaltedHash,checksum=stub,salt='xxx')\n  \n  \n  \n  \n", ["__future__", "hashlib", "logging", "passlib", "passlib.exc", "passlib.hash", "passlib.tests.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.tests.test_hosts": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib import hosts,hash as hashmod\nfrom passlib.utils import unix_crypt_schemes\nfrom passlib.tests.utils import TestCase\n\n\n\n\n\nclass HostsTest(TestCase):\n ''\n \n \n \n \n \n \n \n def check_unix_disabled(self,ctx):\n  for hash in [\n  \"\",\n  \"!\",\n  \"*\",\n  \"!$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0\",\n  ]:\n   self.assertEqual(ctx.identify(hash),'unix_disabled')\n   self.assertFalse(ctx.verify('test',hash))\n   \n def test_linux_context(self):\n  ctx=hosts.linux_context\n  for hash in [\n  ('$6$rounds=41128$VoQLvDjkaZ6L6BIE$4pt.1Ll1XdDYduEwEYPCMOBiR6W6'\n  'znsyUEoNlcVXpv2gKKIbQolgmTGe6uEEVJ7azUxuc8Tf7zV9SD2z7Ij751'),\n  ('$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0itGny'\n  'xDGgMlDcOsfaI17'),\n  '$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0',\n  'kAJJz.Rwp0A/I',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n  self.check_unix_disabled(ctx)\n  \n def test_bsd_contexts(self):\n  for ctx in [\n  hosts.freebsd_context,\n  hosts.openbsd_context,\n  hosts.netbsd_context,\n  ]:\n   for hash in [\n   '$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0',\n   'kAJJz.Rwp0A/I',\n   ]:\n    self.assertTrue(ctx.verify(\"test\",hash))\n   h1=\"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n   if hashmod.bcrypt.has_backend():\n    self.assertTrue(ctx.verify(\"test\",h1))\n   else :\n    self.assertEqual(ctx.identify(h1),\"bcrypt\")\n   self.check_unix_disabled(ctx)\n   \n def test_host_context(self):\n  ctx=getattr(hosts,\"host_context\",None )\n  if not ctx:\n   return self.skipTest(\"host_context not available on this platform\")\n   \n   \n   \n  schemes=list(ctx.schemes())\n  self.assertTrue(schemes,\"appears to be unix system, but no known schemes supported by crypt\")\n  self.assertTrue('unix_disabled'in schemes)\n  schemes.remove(\"unix_disabled\")\n  self.assertTrue(schemes,\"should have schemes beside fallback scheme\")\n  self.assertTrue(set(unix_crypt_schemes).issuperset(schemes))\n  \n  \n  self.check_unix_disabled(ctx)\n  for scheme,hash in [\n  (\"sha512_crypt\",('$6$rounds=41128$VoQLvDjkaZ6L6BIE$4pt.1Ll1XdDYduEwEYPCMOBiR6W6'\n  'znsyUEoNlcVXpv2gKKIbQolgmTGe6uEEVJ7azUxuc8Tf7zV9SD2z7Ij751')),\n  (\"sha256_crypt\",('$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0itGny'\n  'xDGgMlDcOsfaI17')),\n  (\"md5_crypt\",'$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0'),\n  (\"des_crypt\",'kAJJz.Rwp0A/I'),\n  ]:\n   if scheme in schemes:\n    self.assertTrue(ctx.verify(\"test\",hash))\n    \n    \n    \n    \n", ["__future__", "logging", "passlib", "passlib.tests.utils", "passlib.utils"]], "passlib.tests.test_crypto_builtin_md4": [".py", "''\n\n\n\nfrom __future__ import with_statement,division\n\nfrom binascii import hexlify\nimport hashlib\n\n\n\nfrom passlib.utils.compat import bascii_to_str,PY3,u\nfrom passlib.crypto.digest import lookup_hash\nfrom passlib.tests.utils import TestCase,skipUnless\n\n__all__=[\n\"_Common_MD4_Test\",\n\"MD4_Builtin_Test\",\n\"MD4_SSL_Test\",\n]\n\n\n\nclass _Common_MD4_Test(TestCase):\n ''\n \n vectors=[\n \n \n (b\"\",\"31d6cfe0d16ae931b73c59d7e0c089c0\"),\n (b\"a\",\"bde52cb31de33e46245e05fbdbd6fb24\"),\n (b\"abc\",\"a448017aaf21d8525fc10ae87aa6729d\"),\n (b\"message digest\",\"d9130a8164549fe818874806e1c7014b\"),\n (b\"abcdefghijklmnopqrstuvwxyz\",\"d79e1c308aa5bbcdeea8ed63df412da9\"),\n (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\"043f8582f241db351ce627e153e7f0e4\"),\n (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\"e33b4ddc9c38f2199c3e7b164fcc0536\"),\n ]\n \n def get_md4_const(self):\n  ''\n\n\n  \n  return lookup_hash(\"md4\").const\n  \n def test_attrs(self):\n  ''\n  h=self.get_md4_const()()\n  self.assertEqual(h.name,\"md4\")\n  self.assertEqual(h.digest_size,16)\n  self.assertEqual(h.block_size,64)\n  \n def test_md4_update(self):\n  ''\n  md4=self.get_md4_const()\n  h=md4(b'')\n  self.assertEqual(h.hexdigest(),\"31d6cfe0d16ae931b73c59d7e0c089c0\")\n  \n  h.update(b'a')\n  self.assertEqual(h.hexdigest(),\"bde52cb31de33e46245e05fbdbd6fb24\")\n  \n  h.update(b'bcdefghijklmnopqrstuvwxyz')\n  self.assertEqual(h.hexdigest(),\"d79e1c308aa5bbcdeea8ed63df412da9\")\n  \n  if PY3:\n  \n   h=md4()\n   self.assertRaises(TypeError,h.update,u('a'))\n   self.assertEqual(h.hexdigest(),\"31d6cfe0d16ae931b73c59d7e0c089c0\")\n  else :\n  \n   h=md4()\n   h.update(u('a'))\n   self.assertEqual(h.hexdigest(),\"bde52cb31de33e46245e05fbdbd6fb24\")\n   \n def test_md4_hexdigest(self):\n  ''\n  md4=self.get_md4_const()\n  for input,hex in self.vectors:\n   out=md4(input).hexdigest()\n   self.assertEqual(out,hex)\n   \n def test_md4_digest(self):\n  ''\n  md4=self.get_md4_const()\n  for input,hex in self.vectors:\n   out=bascii_to_str(hexlify(md4(input).digest()))\n   self.assertEqual(out,hex)\n   \n def test_md4_copy(self):\n  ''\n  md4=self.get_md4_const()\n  h=md4(b'abc')\n  \n  h2=h.copy()\n  h2.update(b'def')\n  self.assertEqual(h2.hexdigest(),'804e7f1c2586e50b49ac65db5b645131')\n  \n  h.update(b'ghi')\n  self.assertEqual(h.hexdigest(),'c5225580bfe176f6deeee33dee98732c')\n  \n  \n  \n  \n  \n  \ndef has_native_md4():\n ''\n\n \n try :\n  hashlib.new(\"md4\")\n  return True\n except ValueError:\n \n  return False\n  \n  \n@skipUnless(has_native_md4(),\"hashlib lacks ssl/md4 support\")\nclass MD4_SSL_Test(_Common_MD4_Test):\n descriptionPrefix=\"hashlib.new('md4')\"\n \n \n \n \n def setUp(self):\n  super(MD4_SSL_Test,self).setUp()\n  \n  \n  self.assertEqual(self.get_md4_const().__module__,\"hashlib\")\n  \n  \nclass MD4_Builtin_Test(_Common_MD4_Test):\n descriptionPrefix=\"passlib.crypto._md4.md4()\"\n \n def setUp(self):\n  super(MD4_Builtin_Test,self).setUp()\n  \n  if has_native_md4():\n  \n  \n  \n   orig=hashlib.new\n   def wrapper(name,*args):\n    if name ==\"md4\":\n     raise ValueError(\"md4 disabled for testing\")\n    return orig(name,*args)\n   self.patchAttr(hashlib,\"new\",wrapper)\n   \n   \n   lookup_hash.clear_cache()\n   self.addCleanup(lookup_hash.clear_cache)\n   \n   \n  self.assertEqual(self.get_md4_const().__module__,\"passlib.crypto._md4\")\n  \n  \n  \n  \n  \n", ["__future__", "binascii", "hashlib", "passlib.crypto.digest", "passlib.tests.utils", "passlib.utils.compat"]], "passlib.tests.__main__": [".py", "import os\nfrom nose import run\nrun(\ndefaultTest=os.path.dirname(__file__),\n)\n\n", ["nose", "os"]], "passlib.tests.test_win32": [".py", "''\n\n\n\n\nimport warnings\n\n\nfrom passlib.tests.utils import TestCase\n\nfrom passlib.utils.compat import u\n\n\n\n\nclass UtilTest(TestCase):\n ''\n \n \n \n \n def setUp(self):\n  super(UtilTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\n  \"the 'passlib.win32' module is deprecated\")\n  \n def test_lmhash(self):\n  from passlib.win32 import raw_lmhash\n  for secret,hash in [\n  (\"OLDPASSWORD\",u(\"c9b81d939d6fd80cd408e6b105741864\")),\n  (\"NEWPASSWORD\",u('09eeab5aa415d6e4d408e6b105741864')),\n  (\"welcome\",u(\"c23413a8a1e7665faad3b435b51404ee\")),\n  ]:\n   result=raw_lmhash(secret,hex=True )\n   self.assertEqual(result,hash)\n   \n def test_nthash(self):\n  warnings.filterwarnings(\"ignore\",\n  r\"nthash\\.raw_nthash\\(\\) is deprecated\")\n  from passlib.win32 import raw_nthash\n  for secret,hash in [\n  (\"OLDPASSWORD\",u(\"6677b2c394311355b54f25eec5bfacf5\")),\n  (\"NEWPASSWORD\",u(\"256781a62031289d3c2c98c14f1efc8c\")),\n  ]:\n   result=raw_nthash(secret,hex=True )\n   self.assertEqual(result,hash)\n   \n   \n   \n   \n", ["passlib.tests.utils", "passlib.utils.compat", "passlib.win32", "warnings"]], "passlib.utils.binary": [".py", "''\n\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\nfrom base64 import (\nb64encode,\nb64decode,\nb32decode as _b32decode,\nb32encode as _b32encode,\n)\nfrom binascii import b2a_base64,a2b_base64,Error as _BinAsciiError\nimport logging\nlog=logging.getLogger(__name__)\n\n\nfrom passlib import exc\nfrom passlib.utils.compat import (\nPY3,bascii_to_str,\nirange,imap,iter_byte_chars,join_byte_values,join_byte_elems,\nnextgetter,suppress_cause,\nu,unicode,unicode_or_bytes_types,\n)\nfrom passlib.utils.decor import memoized_property\n\n\n__all__=[\n\n\"BASE64_CHARS\",\"PADDED_BASE64_CHARS\",\n\"AB64_CHARS\",\n\"HASH64_CHARS\",\n\"BCRYPT_CHARS\",\n\"HEX_CHARS\",\"LOWER_HEX_CHARS\",\"UPPER_HEX_CHARS\",\n\n\"ALL_BYTE_VALUES\",\n\n\n\"compile_byte_translation\",\n\n\n'ab64_encode','ab64_decode',\n'b64s_encode','b64s_decode',\n\n\n\"b32encode\",\"b32decode\",\n\n\n'Base64Engine',\n'LazyBase64Engine',\n'h64',\n'h64big',\n'bcrypt64',\n]\n\n\n\n\n\n\n\n\n\n\nBASE64_CHARS=u(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n\n\nAB64_CHARS=u(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./\")\n\n\nHASH64_CHARS=u(\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\")\n\n\nBCRYPT_CHARS=u(\"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n\n\nPADDED_BASE64_CHARS=BASE64_CHARS+u(\"=\")\n\n\nHEX_CHARS=u(\"0123456789abcdefABCDEF\")\n\n\nUPPER_HEX_CHARS=u(\"0123456789ABCDEF\")\n\n\nLOWER_HEX_CHARS=u(\"0123456789abcdef\")\n\n\n\n\n\n\n\nALL_BYTE_VALUES=join_byte_values(irange(256))\n\n\nB_EMPTY=b''\nB_NULL=b'\\x00'\nB_EQUAL=b'='\n\n\n\n\n\n\n_TRANSLATE_SOURCE=list(iter_byte_chars(ALL_BYTE_VALUES))\n\ndef compile_byte_translation(mapping,source=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n if source is None :\n  target=_TRANSLATE_SOURCE[:]\n else :\n  assert isinstance(source,bytes)and len(source)==255\n  target=list(iter_byte_chars(source))\n for k,v in mapping.items():\n  if isinstance(k,unicode_or_bytes_types):\n   k=ord(k)\n  assert isinstance(k,int)and 0 <=k <256\n  if isinstance(v,unicode):\n   v=v.encode(\"ascii\")\n  assert isinstance(v,bytes)and len(v)==1\n  target[k]=v\n return B_EMPTY.join(target)\n \n \n \n \ndef b64s_encode(data):\n ''\n\n\n \n return b2a_base64(data).rstrip(_BASE64_STRIP)\n \ndef b64s_decode(data):\n ''\n\n\n \n if isinstance(data,unicode):\n \n  try :\n   data=data.encode(\"ascii\")\n  except UnicodeEncodeError:\n   raise suppress_cause(ValueError(\"string argument should contain only ASCII characters\"))\n off=len(data)&3\n if off ==0:\n  pass\n elif off ==2:\n  data +=_BASE64_PAD2\n elif off ==3:\n  data +=_BASE64_PAD1\n else :\n  raise ValueError(\"invalid base64 input\")\n try :\n  return a2b_base64(data)\n except _BinAsciiError as err:\n  raise suppress_cause(TypeError(err))\n  \n  \n  \n  \n_BASE64_STRIP=b\"=\\n\"\n_BASE64_PAD1=b\"=\"\n_BASE64_PAD2=b\"==\"\n\n\n\n\ndef ab64_encode(data):\n ''\n\n\n\n\n \n return b64s_encode(data).replace(b\"+\",b\".\")\n \ndef ab64_decode(data):\n ''\n\n\n\n\n \n if isinstance(data,unicode):\n \n  try :\n   data=data.encode(\"ascii\")\n  except UnicodeEncodeError:\n   raise suppress_cause(ValueError(\"string argument should contain only ASCII characters\"))\n return b64s_decode(data.replace(b\".\",b\"+\"))\n \n \n \n \n \ndef b32encode(source):\n ''\n\n\n \n \n \n return bascii_to_str(_b32encode(source).rstrip(B_EQUAL))\n \n \n \n_b32_translate=compile_byte_translation({\"8\":\"B\",\"0\":\"O\"})\n\n\n_b32_decode_pad=B_EQUAL *8\n\ndef b32decode(source):\n ''\n\n\n\n \n \n if isinstance(source,unicode):\n  source=source.encode(\"ascii\")\n source=source.translate(_b32_translate)\n \n \n remainder=len(source)&0x7\n if remainder:\n  source +=_b32_decode_pad[:-remainder]\n  \n  \n  \n return _b32decode(source,True )\n \n \n \n \n \nclass Base64Engine(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n bytemap=None\n big=None\n \n \n \n _encode64=None\n _decode64=None\n \n \n _encode_bytes=None\n _decode_bytes=None\n \n \n \n \n def __init__(self,charmap,big=False ):\n \n  if isinstance(charmap,unicode):\n   charmap=charmap.encode(\"latin-1\")\n  elif not isinstance(charmap,bytes):\n   raise exc.ExpectedStringError(charmap,\"charmap\")\n  if len(charmap)!=64:\n   raise ValueError(\"charmap must be 64 characters in length\")\n  if len(set(charmap))!=64:\n   raise ValueError(\"charmap must not contain duplicate characters\")\n  self.bytemap=charmap\n  self._encode64=charmap.__getitem__\n  lookup=dict((value,idx)for idx,value in enumerate(charmap))\n  self._decode64=lookup.__getitem__\n  \n  \n  self.big=big\n  if big:\n   self._encode_bytes=self._encode_bytes_big\n   self._decode_bytes=self._decode_bytes_big\n  else :\n   self._encode_bytes=self._encode_bytes_little\n   self._decode_bytes=self._decode_bytes_little\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n @property\n def charmap(self):\n  ''\n  return self.bytemap.decode(\"latin-1\")\n  \n  \n  \n  \n def encode_bytes(self,source):\n  ''\n\n\n\n  \n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  chunks,tail=divmod(len(source),3)\n  if PY3:\n   next_value=nextgetter(iter(source))\n  else :\n   next_value=nextgetter(ord(elem)for elem in source)\n  gen=self._encode_bytes(next_value,chunks,tail)\n  out=join_byte_elems(imap(self._encode64,gen))\n  \n  \n  \n  \n  return out\n  \n def _encode_bytes_little(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   yield v1&0x3f\n   yield ((v2&0x0f)<<2)|(v1 >>6)\n   yield ((v3&0x03)<<4)|(v2 >>4)\n   yield v3 >>2\n   idx +=1\n  if tail:\n   v1=next_value()\n   if tail ==1:\n   \n    yield v1&0x3f\n    yield v1 >>6\n   else :\n    assert tail ==2\n    \n    v2=next_value()\n    yield v1&0x3f\n    yield ((v2&0x0f)<<2)|(v1 >>6)\n    yield v2 >>4\n    \n def _encode_bytes_big(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   yield v1 >>2\n   yield ((v1&0x03)<<4)|(v2 >>4)\n   yield ((v2&0x0f)<<2)|(v3 >>6)\n   yield v3&0x3f\n   idx +=1\n  if tail:\n   v1=next_value()\n   if tail ==1:\n   \n    yield v1 >>2\n    yield (v1&0x03)<<4\n   else :\n    assert tail ==2\n    \n    v2=next_value()\n    yield v1 >>2\n    yield ((v1&0x03)<<4)|(v2 >>4)\n    yield ((v2&0x0f)<<2)\n    \n    \n    \n    \n    \n def decode_bytes(self,source):\n  ''\n\n\n\n  \n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n   \n   \n   \n   \n  chunks,tail=divmod(len(source),4)\n  if tail ==1:\n  \n   raise ValueError(\"input string length cannot be == 1 mod 4\")\n  next_value=nextgetter(imap(self._decode64,source))\n  try :\n   return join_byte_values(self._decode_bytes(next_value,chunks,tail))\n  except KeyError as err:\n   raise ValueError(\"invalid character: %r\"%(err.args[0],))\n   \n def _decode_bytes_little(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   v4=next_value()\n   yield v1 |((v2&0x3)<<6)\n   yield (v2 >>2)|((v3&0xF)<<4)\n   yield (v3 >>4)|(v4 <<2)\n   idx +=1\n  if tail:\n  \n   v1=next_value()\n   v2=next_value()\n   yield v1 |((v2&0x3)<<6)\n   \n   if tail ==3:\n   \n    v3=next_value()\n    yield (v2 >>2)|((v3&0xF)<<4)\n    \n def _decode_bytes_big(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   v4=next_value()\n   yield (v1 <<2)|(v2 >>4)\n   yield ((v2&0xF)<<4)|(v3 >>2)\n   yield ((v3&0x3)<<6)|v4\n   idx +=1\n  if tail:\n  \n   v1=next_value()\n   v2=next_value()\n   yield (v1 <<2)|(v2 >>4)\n   \n   if tail ==3:\n   \n    v3=next_value()\n    yield ((v2&0xF)<<4)|(v3 >>2)\n    \n    \n    \n    \n    \n    \n    \n    \n def __make_padset(self,bits):\n  ''\n  pset=set(c for i,c in enumerate(self.bytemap)if not i&bits)\n  pset.update(c for i,c in enumerate(self.charmap)if not i&bits)\n  return frozenset(pset)\n  \n @memoized_property\n def _padinfo2(self):\n  ''\n  \n  bits=15 if self.big else (15 <<2)\n  return ~bits,self.__make_padset(bits)\n  \n @memoized_property\n def _padinfo3(self):\n  ''\n  \n  bits=3 if self.big else (3 <<4)\n  return ~bits,self.__make_padset(bits)\n  \n def check_repair_unused(self,source):\n  ''\n\n\n\n\n\n\n\n  \n  \n  tail=len(source)&3\n  if tail ==2:\n   mask,padset=self._padinfo2\n  elif tail ==3:\n   mask,padset=self._padinfo3\n  elif not tail:\n   return False ,source\n  else :\n   raise ValueError(\"source length must != 1 mod 4\")\n   \n   \n  last=source[-1]\n  if last in padset:\n   return False ,source\n   \n   \n   \n  if isinstance(source,unicode):\n   cm=self.charmap\n   last=cm[cm.index(last)&mask]\n   assert last in padset,\"failed to generate valid padding char\"\n  else :\n  \n  \n   last=self._encode64(self._decode64(last)&mask)\n   assert last in padset,\"failed to generate valid padding char\"\n   if PY3:\n    last=bytes([last])\n  return True ,source[:-1]+last\n  \n def repair_unused(self,source):\n  return self.check_repair_unused(source)[1]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def encode_transposed_bytes(self,source,offsets):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  tmp=join_byte_elems(source[off]for off in offsets)\n  return self.encode_bytes(tmp)\n  \n def decode_transposed_bytes(self,source,offsets):\n  ''\n  \n  \n  \n  tmp=self.decode_bytes(source)\n  buf=[None ]*len(offsets)\n  for off,char in zip(offsets,tmp):\n   buf[off]=char\n  return join_byte_elems(buf)\n  \n  \n  \n  \n def _decode_int(self,source,bits):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  big=self.big\n  pad=-bits %6\n  chars=(bits+pad)/6\n  if len(source)!=chars:\n   raise ValueError(\"source must be %d chars\"%(chars,))\n  decode=self._decode64\n  out=0\n  try :\n   for c in source if big else reversed(source):\n    out=(out <<6)+decode(c)\n  except KeyError:\n   raise ValueError(\"invalid character in string: %r\"%(c,))\n  if pad:\n  \n   if big:\n    out >>=pad\n   else :\n    out &=(1 <<bits)-1\n  return out\n  \n  \n  \n  \n  \n def decode_int6(self,source):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  if len(source)!=1:\n   raise ValueError(\"source must be exactly 1 byte\")\n  if PY3:\n  \n   source=source[0]\n  try :\n   return self._decode64(source)\n  except KeyError:\n   raise ValueError(\"invalid character\")\n   \n def decode_int12(self,source):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  if len(source)!=2:\n   raise ValueError(\"source must be exactly 2 bytes\")\n  decode=self._decode64\n  try :\n   if self.big:\n    return decode(source[1])+(decode(source[0])<<6)\n   else :\n    return decode(source[0])+(decode(source[1])<<6)\n  except KeyError:\n   raise ValueError(\"invalid character\")\n   \n def decode_int24(self,source):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  if len(source)!=4:\n   raise ValueError(\"source must be exactly 4 bytes\")\n  decode=self._decode64\n  try :\n   if self.big:\n    return decode(source[3])+(decode(source[2])<<6)+\\\n    (decode(source[1])<<12)+(decode(source[0])<<18)\n   else :\n    return decode(source[0])+(decode(source[1])<<6)+\\\n    (decode(source[2])<<12)+(decode(source[3])<<18)\n  except KeyError:\n   raise ValueError(\"invalid character\")\n   \n def decode_int30(self,source):\n  ''\n  return self._decode_int(source,30)\n  \n def decode_int64(self,source):\n  ''\n\n\n\n  \n  return self._decode_int(source,64)\n  \n  \n  \n  \n def _encode_int(self,value,bits):\n  ''\n\n\n\n\n\n\n  \n  assert value >=0,\"caller did not sanitize input\"\n  pad=-bits %6\n  bits +=pad\n  if self.big:\n   itr=irange(bits -6,-6,-6)\n   \n   value <<=pad\n  else :\n   itr=irange(0,bits,6)\n   \n  return join_byte_elems(imap(self._encode64,\n  ((value >>off)&0x3f for off in itr)))\n  \n  \n  \n  \n  \n def encode_int6(self,value):\n  ''\n  if value <0 or value >63:\n   raise ValueError(\"value out of range\")\n  if PY3:\n   return self.bytemap[value:value+1]\n  else :\n   return self._encode64(value)\n   \n def encode_int12(self,value):\n  ''\n  if value <0 or value >0xFFF:\n   raise ValueError(\"value out of range\")\n  raw=[value&0x3f,(value >>6)&0x3f]\n  if self.big:\n   raw=reversed(raw)\n  return join_byte_elems(imap(self._encode64,raw))\n  \n def encode_int24(self,value):\n  ''\n  if value <0 or value >0xFFFFFF:\n   raise ValueError(\"value out of range\")\n  raw=[value&0x3f,(value >>6)&0x3f,\n  (value >>12)&0x3f,(value >>18)&0x3f]\n  if self.big:\n   raw=reversed(raw)\n  return join_byte_elems(imap(self._encode64,raw))\n  \n def encode_int30(self,value):\n  ''\n  if value <0 or value >0x3fffffff:\n   raise ValueError(\"value out of range\")\n  return self._encode_int(value,30)\n  \n def encode_int64(self,value):\n  ''\n\n\n\n  \n  if value <0 or value >0xffffffffffffffff:\n   raise ValueError(\"value out of range\")\n  return self._encode_int(value,64)\n  \n  \n  \n  \n  \nclass LazyBase64Engine(Base64Engine):\n ''\n _lazy_opts=None\n \n def __init__(self,*args,**kwds):\n  self._lazy_opts=(args,kwds)\n  \n def _lazy_init(self):\n  args,kwds=self._lazy_opts\n  super(LazyBase64Engine,self).__init__(*args,**kwds)\n  del self._lazy_opts\n  self.__class__=Base64Engine\n  \n def __getattribute__(self,attr):\n  if not attr.startswith(\"_\"):\n   self._lazy_init()\n  return object.__getattribute__(self,attr)\n  \n  \n  \n  \n  \nh64=LazyBase64Engine(HASH64_CHARS)\nh64big=LazyBase64Engine(HASH64_CHARS,big=True )\nbcrypt64=LazyBase64Engine(BCRYPT_CHARS,big=True )\n\n\n\n\n", ["__future__", "base64", "binascii", "logging", "passlib", "passlib.utils.compat", "passlib.utils.decor"]], "passlib.utils.handlers": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport inspect\nimport logging ;log=logging.getLogger(__name__)\nimport math\nimport threading\nfrom warnings import warn\n\n\nimport passlib.exc as exc,passlib.ifc as ifc\nfrom passlib.exc import MissingBackendError,PasslibConfigWarning,\\\nPasslibHashWarning\nfrom passlib.ifc import PasswordHash\nfrom passlib.registry import get_crypt_handler\nfrom passlib.utils import (\nconsteq,getrandstr,getrandbytes,\nrng,to_native_str,\nis_crypt_handler,to_unicode,\nMAX_PASSWORD_SIZE,accepts_keyword,as_bool,\nupdate_mixin_classes)\nfrom passlib.utils.binary import (\nBASE64_CHARS,HASH64_CHARS,PADDED_BASE64_CHARS,\nHEX_CHARS,UPPER_HEX_CHARS,LOWER_HEX_CHARS,\nALL_BYTE_VALUES,\n)\nfrom passlib.utils.compat import join_byte_values,irange,u,native_string_types,\\\nuascii_to_str,join_unicode,unicode,str_to_uascii,\\\njoin_unicode,unicode_or_bytes_types,PY2,int_types\nfrom passlib.utils.decor import classproperty,deprecated_method\n\n__all__=[\n\n'parse_mc2',\n'parse_mc3',\n'render_mc2',\n'render_mc3',\n\n\n'GenericHandler',\n'StaticHandler',\n'HasUserContext',\n'HasRawChecksum',\n'HasManyIdents',\n'HasSalt',\n'HasRawSalt',\n'HasRounds',\n'HasManyBackends',\n\n\n'PrefixWrapper',\n\n\n\n]\n\n\n\n\n\n\nH64_CHARS=HASH64_CHARS\nB64_CHARS=BASE64_CHARS\nPADDED_B64_CHARS=PADDED_BASE64_CHARS\nUC_HEX_CHARS=UPPER_HEX_CHARS\nLC_HEX_CHARS=LOWER_HEX_CHARS\n\n\n\n\ndef _bitsize(count,chars):\n ''\n if chars and count:\n  import math\n  return int(count *math.log(len(chars),2))\n else :\n  return 0\n  \ndef guess_app_stacklevel(start=1):\n ''\n\n\n \n frame=inspect.currentframe()\n count=-start\n try :\n  while frame:\n   name=frame.f_globals.get('__name__',\"\")\n   if name.startswith(\"passlib.tests.\")or not name.startswith(\"passlib.\"):\n    return max(1,count)\n   count +=1\n   frame=frame.f_back\n  return start\n finally :\n  del frame\n  \ndef warn_hash_settings_deprecation(handler,kwds):\n warn(\"passing settings to %(handler)s.hash() is deprecated, and won't be supported in Passlib 2.0; \"\n \"use '%(handler)s.using(**settings).hash(secret)' instead\"%dict(handler=handler.name),\n DeprecationWarning,stacklevel=guess_app_stacklevel(2))\n \ndef extract_settings_kwds(handler,kwds):\n ''\n\n\n \n context_keys=set(handler.context_kwds)\n return dict((key,kwds.pop(key))for key in list(kwds)if key not in context_keys)\n \n \n \n \n_UDOLLAR=u(\"$\")\n_UZERO=u(\"0\")\n\ndef validate_secret(secret):\n ''\n if not isinstance(secret,unicode_or_bytes_types):\n  raise exc.ExpectedStringError(secret,\"secret\")\n if len(secret)>MAX_PASSWORD_SIZE:\n  raise exc.PasswordSizeError(MAX_PASSWORD_SIZE)\n  \ndef to_unicode_for_identify(hash):\n ''\n if isinstance(hash,unicode):\n  return hash\n elif isinstance(hash,bytes):\n \n \n \n  try :\n   return hash.decode(\"utf-8\")\n  except UnicodeDecodeError:\n   return hash.decode(\"latin-1\")\n else :\n  raise exc.ExpectedStringError(hash,\"hash\")\n  \ndef parse_mc2(hash,prefix,sep=_UDOLLAR,handler=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n hash=to_unicode(hash,\"ascii\",\"hash\")\n assert isinstance(prefix,unicode)\n if not hash.startswith(prefix):\n  raise exc.InvalidHashError(handler)\n  \n  \n assert isinstance(sep,unicode)\n parts=hash[len(prefix):].split(sep)\n if len(parts)==2:\n  salt,chk=parts\n  return salt,chk or None\n elif len(parts)==1:\n  return parts[0],None\n else :\n  raise exc.MalformedHashError(handler)\n  \ndef parse_mc3(hash,prefix,sep=_UDOLLAR,rounds_base=10,\ndefault_rounds=None ,handler=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n hash=to_unicode(hash,\"ascii\",\"hash\")\n assert isinstance(prefix,unicode)\n if not hash.startswith(prefix):\n  raise exc.InvalidHashError(handler)\n  \n  \n assert isinstance(sep,unicode)\n parts=hash[len(prefix):].split(sep)\n if len(parts)==3:\n  rounds,salt,chk=parts\n elif len(parts)==2:\n  rounds,salt=parts\n  chk=None\n else :\n  raise exc.MalformedHashError(handler)\n  \n  \n if rounds.startswith(_UZERO)and rounds !=_UZERO:\n  raise exc.ZeroPaddedRoundsError(handler)\n elif rounds:\n  rounds=int(rounds,rounds_base)\n elif default_rounds is None :\n  raise exc.MalformedHashError(handler,\"empty rounds field\")\n else :\n  rounds=default_rounds\n  \n  \n return rounds,salt,chk or None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef parse_int(source,base=10,default=None ,param=\"value\",handler=None ):\n ''\n\n\n\n\n\n\n\n \n if source.startswith(_UZERO)and source !=_UZERO:\n  raise exc.MalformedHashError(handler,\"zero-padded %s field\"%param)\n elif source:\n  return int(source,base)\n elif default is None :\n  raise exc.MalformedHashError(handler,\"empty %s field\"%param)\n else :\n  return default\n  \n  \n  \n  \ndef render_mc2(ident,salt,checksum,sep=u(\"$\")):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if checksum:\n  parts=[ident,salt,sep,checksum]\n else :\n  parts=[ident,salt]\n return uascii_to_str(join_unicode(parts))\n \ndef render_mc3(ident,rounds,salt,checksum,sep=u(\"$\"),rounds_base=10):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if rounds is None :\n  rounds=u('')\n elif rounds_base ==16:\n  rounds=u(\"%x\")%rounds\n else :\n  assert rounds_base ==10\n  rounds=unicode(rounds)\n if checksum:\n  parts=[ident,rounds,sep,salt,sep,checksum]\n else :\n  parts=[ident,rounds,sep,salt]\n return uascii_to_str(join_unicode(parts))\n \n \ndef mask_value(value,show=4,pct=0.125,char=u\"*\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if value is None :\n  return None\n if not isinstance(value,unicode):\n  if isinstance(value,bytes):\n   from passlib.utils.binary import ab64_encode\n   value=ab64_encode(value).decode(\"ascii\")\n  else :\n   value=unicode(value)\n size=len(value)\n show=min(show,int(size *pct))\n return value[:show]+char *(size -show)\n \n \n \n \n \ndef validate_default_value(handler,default,norm,param=\"value\"):\n ''\n\n\n \n assert default is not None ,\"%s lacks default %s\"%(handler.name,param)\n assert norm(default)==default,\"%s: invalid default %s: %r\"%(handler.name,param,default)\n return True\n \ndef norm_integer(handler,value,min=1,max=None ,\nparam=\"value\",relaxed=False ):\n ''\n\n\n\n\n\n\n\n\n \n \n if not isinstance(value,int_types):\n  raise exc.ExpectedTypeError(value,\"integer\",param)\n  \n  \n if value <min:\n  msg=\"%s: %s (%d) is too low, must be at least %d\"%(handler.name,param,value,min)\n  if relaxed:\n   warn(msg,exc.PasslibHashWarning)\n   value=min\n  else :\n   raise ValueError(msg)\n   \n   \n if max and value >max:\n  msg=\"%s: %s (%d) is too large, cannot be more than %d\"%(handler.name,param,value,max)\n  if relaxed:\n   warn(msg,exc.PasslibHashWarning)\n   value=max\n  else :\n   raise ValueError(msg)\n   \n return value\n \n \n \n \nclass MinimalHandler(PasswordHash):\n ''\n\n\n \n \n \n \n \n \n _configured=False\n \n \n \n \n \n @classmethod\n def using(cls,relaxed=False ):\n \n \n \n \n \n  name=cls.__name__\n  if not cls._configured:\n  \n   name=\"<customized %s hasher>\"%name\n  return type(name,(cls,),dict(__module__=cls.__module__,_configured=True ))\n  \n  \n  \n  \n  \nclass TruncateMixin(MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n truncate_error=False\n truncate_verify_reject=False\n \n @classmethod\n def using(cls,truncate_error=None ,**kwds):\n  subcls=super(TruncateMixin,cls).using(**kwds)\n  if truncate_error is not None :\n   truncate_error=as_bool(truncate_error,param=\"truncate_error\")\n   if truncate_error is not None :\n    subcls.truncate_error=truncate_error\n  return subcls\n  \n @classmethod\n def _check_truncate_policy(cls,secret):\n  ''\n\n\n\n  \n  assert cls.truncate_size is not None ,\"truncate_size must be set by subclass\"\n  if cls.truncate_error and len(secret)>cls.truncate_size:\n   raise exc.PasswordTruncateError(cls)\n   \n   \n   \n   \nclass GenericHandler(MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n setting_kwds=None\n \n \n context_kwds=()\n \n \n ident=None\n \n \n \n _hash_regex=None\n \n \n checksum_size=None\n \n \n checksum_chars=None\n \n \n _checksum_is_bytes=False\n \n \n \n \n checksum=None\n \n \n \n \n \n \n def __init__(self,checksum=None ,use_defaults=False ,**kwds):\n  self.use_defaults=use_defaults\n  super(GenericHandler,self).__init__(**kwds)\n  if checksum is not None :\n  \n   self.checksum=self._norm_checksum(checksum)\n   \n   \n   \n def _norm_checksum(self,checksum,relaxed=False ):\n  ''\n\n  \n  \n  \n  \n  \n  \n  raw=self._checksum_is_bytes\n  if raw:\n  \n  \n   if not isinstance(checksum,bytes):\n    raise exc.ExpectedTypeError(checksum,\"bytes\",\"checksum\")\n    \n  elif not isinstance(checksum,unicode):\n   if isinstance(checksum,bytes)and relaxed:\n    warn(\"checksum should be unicode, not bytes\",PasslibHashWarning)\n    checksum=checksum.decode(\"ascii\")\n   else :\n    raise exc.ExpectedTypeError(checksum,\"unicode\",\"checksum\")\n    \n    \n  cc=self.checksum_size\n  if cc and len(checksum)!=cc:\n   raise exc.ChecksumSizeError(self,raw=raw)\n   \n   \n  if not raw:\n   cs=self.checksum_chars\n   if cs and any(c not in cs for c in checksum):\n    raise ValueError(\"invalid characters in %s checksum\"%(self.name,))\n    \n  return checksum\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n \n \n \n  hash=to_unicode_for_identify(hash)\n  if not hash:\n   return False\n   \n   \n  ident=cls.ident\n  if ident is not None :\n   return hash.startswith(ident)\n   \n   \n  pat=cls._hash_regex\n  if pat is not None :\n   return pat.match(hash)is not None\n   \n   \n   \n  try :\n   cls.from_string(hash)\n   return True\n  except ValueError:\n   return False\n   \n @classmethod\n def from_string(cls,hash,**context):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"%s must implement from_string()\"%(cls,))\n  \n def to_string(self):\n  ''\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"%s must implement from_string()\"%(self.__class__,))\n  \n  \n  \n  \n  \n  \n @property\n def _stub_checksum(self):\n  ''\n\n  \n  \n  if self.checksum_size:\n   if self._checksum_is_bytes:\n    return b'\\x00'*self.checksum_size\n   if self.checksum_chars:\n    return self.checksum_chars[0]*self.checksum_size\n    \n    \n  if isinstance(self,HasRounds):\n   orig=self.rounds\n   self.rounds=self.min_rounds or 1\n   try :\n    return self._calc_checksum(\"\")\n   finally :\n    self.rounds=orig\n    \n    \n  return self._calc_checksum(\"\")\n  \n def _calc_checksum(self,secret):\n  ''\n\n\n\n\n  \n  raise NotImplementedError(\"%s must implement _calc_checksum()\"%\n  (self.__class__,))\n  \n  \n  \n  \n  \n @classmethod\n def hash(cls,secret,**kwds):\n  if kwds:\n  \n  \n  \n  \n  \n   settings=extract_settings_kwds(cls,kwds)\n   if settings:\n    warn_hash_settings_deprecation(cls,settings)\n    return cls.using(**settings).hash(secret,**kwds)\n    \n  validate_secret(secret)\n  self=cls(use_defaults=True ,**kwds)\n  self.checksum=self._calc_checksum(secret)\n  return self.to_string()\n  \n @classmethod\n def verify(cls,secret,hash,**context):\n \n \n \n  validate_secret(secret)\n  self=cls.from_string(hash,**context)\n  chk=self.checksum\n  if chk is None :\n   raise exc.MissingDigestError(cls)\n  return consteq(self._calc_checksum(secret),chk)\n  \n  \n  \n  \n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls,**kwds):\n \n  settings=extract_settings_kwds(cls,kwds)\n  if settings:\n   return cls.using(**settings).genconfig(**kwds)\n   \n   \n  self=cls(use_defaults=True ,**kwds)\n  self.checksum=self._stub_checksum\n  return self.to_string()\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,**context):\n  if config is None :\n   raise TypeError(\"config must be string\")\n  validate_secret(secret)\n  self=cls.from_string(config,**context)\n  self.checksum=self._calc_checksum(secret)\n  return self.to_string()\n  \n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,secret=None ,**kwds):\n \n \n  self=cls.from_string(hash)\n  assert isinstance(self,cls)\n  return self._calc_needs_update(secret=secret,**kwds)\n  \n def _calc_needs_update(self,secret=None ):\n  ''\n\n  \n  \n  \n  return False\n  \n  \n  \n  \n  \n  \n  \n _always_parse_settings=()\n \n \n _unparsed_settings=(\"salt_size\",\"relaxed\")\n \n \n _unsafe_settings=(\"salt\",\"checksum\")\n \n @classproperty\n def _parsed_settings(cls):\n  ''\n\n\n\n\n  \n  return tuple(key for key in cls.setting_kwds if key not in cls._unparsed_settings)\n  \n @classmethod\n def parsehash(cls,hash,checksum=True ,sanitize=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  self=cls.from_string(hash)\n  \n  \n  \n  \n  \n  UNSET=object()\n  always=self._always_parse_settings\n  kwds=dict((key,getattr(self,key))for key in self._parsed_settings\n  if key in always or getattr(self,key)!=getattr(cls,key,UNSET))\n  if checksum and self.checksum is not None :\n   kwds['checksum']=self.checksum\n  if sanitize:\n   if sanitize is True :\n    sanitize=mask_value\n   for key in cls._unsafe_settings:\n    if key in kwds:\n     kwds[key]=sanitize(kwds[key])\n  return kwds\n  \n @classmethod\n def bitsize(cls,**kwds):\n  ''\n  try :\n   info=super(GenericHandler,cls).bitsize(**kwds)\n  except AttributeError:\n   info={}\n  cc=ALL_BYTE_VALUES if cls._checksum_is_bytes else cls.checksum_chars\n  if cls.checksum_size and cc:\n  \n  \n   info['checksum']=_bitsize(cls.checksum_size,cc)\n  return info\n  \n  \n  \n  \n  \nclass StaticHandler(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n setting_kwds=()\n \n \n _hash_prefix=u(\"\")\n \n @classmethod\n def from_string(cls,hash,**context):\n \n \n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  hash=cls._norm_hash(hash)\n  \n  \n  \n  \n  prefix=cls._hash_prefix\n  if prefix:\n   if hash.startswith(prefix):\n    hash=hash[len(prefix):]\n   else :\n    raise exc.InvalidHashError(cls)\n  return cls(checksum=hash,**context)\n  \n @classmethod\n def _norm_hash(cls,hash):\n  ''\n  return hash\n  \n def to_string(self):\n  return uascii_to_str(self._hash_prefix+self.checksum)\n  \n  \n __cc_compat_hack=None\n \n def _calc_checksum(self,secret):\n  ''\n\n  \n  \n  \n  \n  \n  \n  \n  cls=self.__class__\n  assert cls.__module__ !=__name__\n  wrapper_cls=cls.__cc_compat_hack\n  if wrapper_cls is None :\n   def inner(self,secret):\n    raise NotImplementedError(\"%s must implement _calc_checksum()\"%\n    (cls,))\n   wrapper_cls=cls.__cc_compat_hack=type(cls.__name__+\"_wrapper\",\n   (cls,),dict(_calc_checksum=inner,__module__=cls.__module__))\n  context=dict((k,getattr(self,k))for k in self.context_kwds)\n  \n  \n  try :\n   hash=wrapper_cls.genhash(secret,None ,**context)\n  except TypeError as err:\n   if str(err)==\"config must be string\":\n    raise NotImplementedError(\"%s must implement _calc_checksum()\"%\n    (cls,))\n   else :\n    raise\n  warn(\"%r should be updated to implement StaticHandler._calc_checksum() \"\n  \"instead of StaticHandler.genhash(), support for the latter \"\n  \"style will be removed in Passlib 1.8\"%cls,\n  DeprecationWarning)\n  return str_to_uascii(hash)\n  \n  \n  \n  \nclass HasEncodingContext(GenericHandler):\n ''\n context_kwds=(\"encoding\",)\n default_encoding=\"utf-8\"\n \n def __init__(self,encoding=None ,**kwds):\n  super(HasEncodingContext,self).__init__(**kwds)\n  self.encoding=encoding or self.default_encoding\n  \nclass HasUserContext(GenericHandler):\n ''\n context_kwds=(\"user\",)\n \n def __init__(self,user=None ,**kwds):\n  super(HasUserContext,self).__init__(**kwds)\n  self.user=user\n  \n  \n  \n  \n  \n @classmethod\n def hash(cls,secret,user=None ,**context):\n  return super(HasUserContext,cls).hash(secret,user=user,**context)\n  \n @classmethod\n def verify(cls,secret,hash,user=None ,**context):\n  return super(HasUserContext,cls).verify(secret,hash,user=user,**context)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,user=None ,**context):\n  return super(HasUserContext,cls).genhash(secret,config,user=user,**context)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass HasRawChecksum(GenericHandler):\n ''\n\n\n\n\n \n \n \n \n \n \n _checksum_is_bytes=True\n \n \n \n \nclass HasManyIdents(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n default_ident=None\n ident_values=None\n ident_aliases=None\n \n \n \n \n \n \n \n \n \n \n ident=None\n \n \n \n \n @classmethod\n def using(cls,\n default_ident=None ,ident=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n  \n  \n  if ident is not None :\n   if default_ident is not None :\n    raise TypeError(\"'default_ident' and 'ident' are mutually exclusive\")\n   default_ident=ident\n   \n   \n  subcls=super(HasManyIdents,cls).using(**kwds)\n  \n  \n  \n  if default_ident is not None :\n   subcls.default_ident=cls(ident=default_ident,use_defaults=True ).ident\n  return subcls\n  \n  \n  \n  \n def __init__(self,ident=None ,**kwds):\n  super(HasManyIdents,self).__init__(**kwds)\n  \n  \n  if ident is not None :\n   ident=self._norm_ident(ident)\n  elif self.use_defaults:\n   ident=self.default_ident\n   assert validate_default_value(self,ident,self._norm_ident,param=\"default_ident\")\n  else :\n   raise TypeError(\"no ident specified\")\n  self.ident=ident\n  \n @classmethod\n def _norm_ident(cls,ident):\n  ''\n\n  \n  \n  assert ident is not None\n  if isinstance(ident,bytes):\n   ident=ident.decode('ascii')\n   \n   \n  iv=cls.ident_values\n  if ident in iv:\n   return ident\n   \n   \n  ia=cls.ident_aliases\n  if ia:\n   try :\n    value=ia[ident]\n   except KeyError:\n    pass\n   else :\n    if value in iv:\n     return value\n     \n     \n     \n  raise ValueError(\"invalid ident: %r\"%(ident,))\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n  hash=to_unicode_for_identify(hash)\n  return hash.startswith(cls.ident_values)\n  \n @classmethod\n def _parse_ident(cls,hash):\n  ''\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  for ident in cls.ident_values:\n   if hash.startswith(ident):\n    return ident,hash[len(ident):]\n  raise exc.InvalidHashError(cls)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass HasSalt(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n min_salt_size=0\n max_salt_size=None\n salt_chars=None\n \n @classproperty\n def default_salt_size(cls):\n  ''\n  return cls.max_salt_size\n  \n @classproperty\n def default_salt_chars(cls):\n  ''\n  return cls.salt_chars\n  \n  \n _salt_is_bytes=False\n _salt_unit=\"chars\"\n \n \n \n \n \n \n salt=None\n \n \n \n \n @classmethod\n def using(cls,\n default_salt_size=None ,\n salt_size=None ,\n salt=None ,\n **kwds):\n \n \n  if salt_size is not None :\n   if default_salt_size is not None :\n    raise TypeError(\"'salt_size' and 'default_salt_size' aliases are mutually exclusive\")\n   default_salt_size=salt_size\n   \n   \n  subcls=super(HasSalt,cls).using(**kwds)\n  \n  \n  relaxed=kwds.get(\"relaxed\")\n  if default_salt_size is not None :\n   if isinstance(default_salt_size,native_string_types):\n    default_salt_size=int(default_salt_size)\n   subcls.default_salt_size=subcls._clip_to_valid_salt_size(default_salt_size,\n   param=\"salt_size\",\n   relaxed=relaxed)\n   \n   \n   \n  if salt is not None :\n   salt=subcls._norm_salt(salt,relaxed=relaxed)\n   subcls._generate_salt=staticmethod(lambda :salt)\n   \n  return subcls\n  \n  \n @classmethod\n def _clip_to_valid_salt_size(cls,salt_size,param=\"salt_size\",relaxed=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  mn=cls.min_salt_size\n  mx=cls.max_salt_size\n  \n  \n  if mn ==mx:\n   if salt_size !=mn:\n    msg=\"%s: %s (%d) must be exactly %d\"%(cls.name,param,salt_size,mn)\n    if relaxed:\n     warn(msg,PasslibHashWarning)\n    else :\n     raise ValueError(msg)\n   return mn\n   \n   \n  if salt_size <mn:\n   msg=\"%s: %s (%r) below min_salt_size (%d)\"%(cls.name,param,salt_size,mn)\n   if relaxed:\n    warn(msg,PasslibHashWarning)\n    salt_size=mn\n   else :\n    raise ValueError(msg)\n    \n    \n  if mx and salt_size >mx:\n   msg=\"%s: %s (%r) above max_salt_size (%d)\"%(cls.name,param,salt_size,mx)\n   if relaxed:\n    warn(msg,PasslibHashWarning)\n    salt_size=mx\n   else :\n    raise ValueError(msg)\n    \n  return salt_size\n  \n  \n  \n  \n def __init__(self,salt=None ,**kwds):\n  super(HasSalt,self).__init__(**kwds)\n  if salt is not None :\n   salt=self._parse_salt(salt)\n  elif self.use_defaults:\n   salt=self._generate_salt()\n   assert self._norm_salt(salt)==salt,\"generated invalid salt: %r\"%(salt,)\n  else :\n   raise TypeError(\"no salt specified\")\n  self.salt=salt\n  \n  \n def _parse_salt(self,salt):\n  return self._norm_salt(salt)\n  \n @classmethod\n def _norm_salt(cls,salt,relaxed=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if cls._salt_is_bytes:\n   if not isinstance(salt,bytes):\n    raise exc.ExpectedTypeError(salt,\"bytes\",\"salt\")\n  else :\n   if not isinstance(salt,unicode):\n   \n    if isinstance(salt,bytes)and (PY2 or relaxed):\n     salt=salt.decode(\"ascii\")\n    else :\n     raise exc.ExpectedTypeError(salt,\"unicode\",\"salt\")\n     \n     \n   sc=cls.salt_chars\n   if sc is not None and any(c not in sc for c in salt):\n    raise ValueError(\"invalid characters in %s salt\"%cls.name)\n    \n    \n  mn=cls.min_salt_size\n  if mn and len(salt)<mn:\n   msg=\"salt too small (%s requires %s %d %s)\"%(cls.name,\n   \"exactly\"if mn ==cls.max_salt_size else \">=\",mn,cls._salt_unit)\n   raise ValueError(msg)\n   \n   \n  mx=cls.max_salt_size\n  if mx and len(salt)>mx:\n   msg=\"salt too large (%s requires %s %d %s)\"%(cls.name,\n   \"exactly\"if mx ==mn else \"<=\",mx,cls._salt_unit)\n   if relaxed:\n    warn(msg,PasslibHashWarning)\n    salt=cls._truncate_salt(salt,mx)\n   else :\n    raise ValueError(msg)\n    \n  return salt\n  \n @staticmethod\n def _truncate_salt(salt,mx):\n \n \n \n  return salt[:mx]\n  \n @classmethod\n def _generate_salt(cls):\n  ''\n\n  \n  return getrandstr(rng,cls.default_salt_chars,cls.default_salt_size)\n  \n @classmethod\n def bitsize(cls,salt_size=None ,**kwds):\n  ''\n  info=super(HasSalt,cls).bitsize(**kwds)\n  if salt_size is None :\n   salt_size=cls.default_salt_size\n   \n   \n  info['salt']=_bitsize(salt_size,cls.default_salt_chars)\n  return info\n  \n  \n  \n  \n  \nclass HasRawSalt(HasSalt):\n ''\n\n\n\n\n\n\n \n \n salt_chars=ALL_BYTE_VALUES\n \n \n \n _salt_is_bytes=True\n _salt_unit=\"bytes\"\n \n @classmethod\n def _generate_salt(cls):\n  assert cls.salt_chars in [None ,ALL_BYTE_VALUES]\n  return getrandbytes(rng,cls.default_salt_size)\n  \n  \n  \n  \nclass HasRounds(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n min_rounds=0\n max_rounds=None\n rounds_cost=\"linear\"\n \n \n using_rounds_kwds=(\"min_desired_rounds\",\"max_desired_rounds\",\n \"min_rounds\",\"max_rounds\",\n \"default_rounds\",\"vary_rounds\")\n \n \n \n \n min_desired_rounds=None\n max_desired_rounds=None\n default_rounds=None\n vary_rounds=None\n \n \n \n \n rounds=None\n \n \n \n \n @classmethod\n def using(cls,\n min_desired_rounds=None ,max_desired_rounds=None ,\n default_rounds=None ,vary_rounds=None ,\n min_rounds=None ,max_rounds=None ,rounds=None ,\n **kwds):\n \n \n  if min_rounds is not None :\n   if min_desired_rounds is not None :\n    raise TypeError(\"'min_rounds' and 'min_desired_rounds' aliases are mutually exclusive\")\n   min_desired_rounds=min_rounds\n   \n  if max_rounds is not None :\n   if max_desired_rounds is not None :\n    raise TypeError(\"'max_rounds' and 'max_desired_rounds' aliases are mutually exclusive\")\n   max_desired_rounds=max_rounds\n   \n   \n   \n   \n  if rounds is not None :\n   if min_desired_rounds is None :\n    min_desired_rounds=rounds\n   if max_desired_rounds is None :\n    max_desired_rounds=rounds\n   if default_rounds is None :\n    default_rounds=rounds\n    \n    \n  subcls=super(HasRounds,cls).using(**kwds)\n  \n  \n  relaxed=kwds.get(\"relaxed\")\n  if min_desired_rounds is None :\n   explicit_min_rounds=False\n   min_desired_rounds=cls.min_desired_rounds\n  else :\n   explicit_min_rounds=True\n   if isinstance(min_desired_rounds,native_string_types):\n    min_desired_rounds=int(min_desired_rounds)\n   subcls.min_desired_rounds=subcls._norm_rounds(min_desired_rounds,\n   param=\"min_desired_rounds\",\n   relaxed=relaxed)\n   \n   \n  if max_desired_rounds is None :\n   max_desired_rounds=cls.max_desired_rounds\n  else :\n   if isinstance(max_desired_rounds,native_string_types):\n    max_desired_rounds=int(max_desired_rounds)\n   if min_desired_rounds and max_desired_rounds <min_desired_rounds:\n    msg=\"%s: max_desired_rounds (%r) below min_desired_rounds (%r)\"%\\\n    (subcls.name,max_desired_rounds,min_desired_rounds)\n    if explicit_min_rounds:\n     raise ValueError(msg)\n    else :\n     warn(msg,PasslibConfigWarning)\n     max_desired_rounds=min_desired_rounds\n   subcls.max_desired_rounds=subcls._norm_rounds(max_desired_rounds,\n   param=\"max_desired_rounds\",\n   relaxed=relaxed)\n   \n   \n  if default_rounds is not None :\n   if isinstance(default_rounds,native_string_types):\n    default_rounds=int(default_rounds)\n   if min_desired_rounds and default_rounds <min_desired_rounds:\n    raise ValueError(\"%s: default_rounds (%r) below min_desired_rounds (%r)\"%\n    (subcls.name,default_rounds,min_desired_rounds))\n   elif max_desired_rounds and default_rounds >max_desired_rounds:\n    raise ValueError(\"%s: default_rounds (%r) above max_desired_rounds (%r)\"%\n    (subcls.name,default_rounds,max_desired_rounds))\n   subcls.default_rounds=subcls._norm_rounds(default_rounds,\n   param=\"default_rounds\",\n   relaxed=relaxed)\n   \n   \n  if subcls.default_rounds is not None :\n   subcls.default_rounds=subcls._clip_to_desired_rounds(subcls.default_rounds)\n   \n   \n  if vary_rounds is not None :\n   if isinstance(vary_rounds,native_string_types):\n    if vary_rounds.endswith(\"%\"):\n     vary_rounds=float(vary_rounds[:-1])*0.01\n    elif \".\"in vary_rounds:\n     vary_rounds=float(vary_rounds)\n    else :\n     vary_rounds=int(vary_rounds)\n   if vary_rounds <0:\n    raise ValueError(\"%s: vary_rounds (%r) below 0\"%\n    (subcls.name,vary_rounds))\n   elif isinstance(vary_rounds,float):\n   \n    if vary_rounds >1:\n     raise ValueError(\"%s: vary_rounds (%r) above 1.0\"%\n     (subcls.name,vary_rounds))\n   elif not isinstance(vary_rounds,int):\n    raise TypeError(\"vary_rounds must be int or float\")\n   if vary_rounds:\n    warn(\"The 'vary_rounds' option is deprecated as of Passlib 1.7, \"\n    \"and will be removed in Passlib 2.0\",PasslibConfigWarning)\n   subcls.vary_rounds=vary_rounds\n   \n   \n  return subcls\n  \n @classmethod\n def _clip_to_desired_rounds(cls,rounds):\n  ''\n\n\n  \n  \n  \n  mnd=cls.min_desired_rounds or 0\n  if rounds <mnd:\n   return mnd\n   \n   \n  mxd=cls.max_desired_rounds\n  if mxd and rounds >mxd:\n   return mxd\n   \n  return rounds\n  \n @classmethod\n def _calc_vary_rounds_range(cls,default_rounds):\n  ''\n\n\n\n\n\n  \n  \n  \n  assert default_rounds\n  vary_rounds=cls.vary_rounds\n  \n  \n  def linear_to_native(value,upper):\n   return value\n  if isinstance(vary_rounds,float):\n   assert 0 <=vary_rounds <=1\n   if cls.rounds_cost ==\"log2\":\n   \n   \n   \n    default_rounds=1 <<default_rounds\n    def linear_to_native(value,upper):\n     if value <=0:\n      return 0\n     elif upper:\n      return int(math.log(value,2))\n     else :\n      return int(math.ceil(math.log(value,2)))\n      \n   vary_rounds=int(default_rounds *vary_rounds)\n   \n   \n  assert vary_rounds >=0 and isinstance(vary_rounds,int_types)\n  lower=linear_to_native(default_rounds -vary_rounds,False )\n  upper=linear_to_native(default_rounds+vary_rounds,True )\n  return cls._clip_to_desired_rounds(lower),cls._clip_to_desired_rounds(upper)\n  \n  \n  \n  \n def __init__(self,rounds=None ,**kwds):\n  super(HasRounds,self).__init__(**kwds)\n  if rounds is not None :\n   rounds=self._parse_rounds(rounds)\n  elif self.use_defaults:\n   rounds=self._generate_rounds()\n   assert self._norm_rounds(rounds)==rounds,\"generated invalid rounds: %r\"%(rounds,)\n  else :\n   raise TypeError(\"no rounds specified\")\n  self.rounds=rounds\n  \n  \n def _parse_rounds(self,rounds):\n  return self._norm_rounds(rounds)\n  \n @classmethod\n def _norm_rounds(cls,rounds,relaxed=False ,param=\"rounds\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return norm_integer(cls,rounds,cls.min_rounds,cls.max_rounds,\n  param=param,relaxed=relaxed)\n  \n @classmethod\n def _generate_rounds(cls):\n  ''\n\n\n\n  \n  \n  rounds=cls.default_rounds\n  if rounds is None :\n   raise TypeError(\"%s rounds value must be specified explicitly\"%(cls.name,))\n   \n   \n   \n  if cls.vary_rounds:\n   lower,upper=cls._calc_vary_rounds_range(rounds)\n   assert lower <=rounds <=upper\n   if lower <upper:\n    rounds=rng.randint(lower,upper)\n    \n  return rounds\n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  min_desired_rounds=self.min_desired_rounds\n  if min_desired_rounds and self.rounds <min_desired_rounds:\n   return True\n  max_desired_rounds=self.max_desired_rounds\n  if max_desired_rounds and self.rounds >max_desired_rounds:\n   return True\n  return super(HasRounds,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n @classmethod\n def bitsize(cls,rounds=None ,vary_rounds=.1,**kwds):\n  ''\n  info=super(HasRounds,cls).bitsize(**kwds)\n  \n  \n  if cls.rounds_cost !=\"log2\":\n  \n  \n  \n  \n  \n  \n   import math\n   if rounds is None :\n    rounds=cls.default_rounds\n   info['rounds']=max(0,int(1+math.log(rounds *vary_rounds,2)))\n   \n   \n   \n  return info\n  \n  \n  \n  \n  \n  \n  \n  \nclass ParallelismMixin(GenericHandler):\n ''\n\n \n \n \n \n \n \n \n \n \n \n \n \n parallelism=1\n \n \n \n \n \n @classmethod\n def using(cls,parallelism=None ,**kwds):\n  subcls=super(ParallelismMixin,cls).using(**kwds)\n  if parallelism is not None :\n   if isinstance(parallelism,native_string_types):\n    parallelism=int(parallelism)\n   subcls.parallelism=subcls._norm_parallelism(parallelism,relaxed=kwds.get(\"relaxed\"))\n  return subcls\n  \n  \n  \n  \n def __init__(self,parallelism=None ,**kwds):\n  super(ParallelismMixin,self).__init__(**kwds)\n  \n  \n  if parallelism is None :\n   assert validate_default_value(self,self.parallelism,self._norm_parallelism,\n   param=\"parallelism\")\n  else :\n   self.parallelism=self._norm_parallelism(parallelism)\n   \n @classmethod\n def _norm_parallelism(cls,parallelism,relaxed=False ):\n  return norm_integer(cls,parallelism,min=1,param=\"parallelism\",relaxed=relaxed)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  \n  if self.parallelism !=type(self).parallelism:\n   return True\n  return super(ParallelismMixin,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_backend_lock=threading.RLock()\n\nclass BackendMixin(PasswordHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n backends=None\n \n \n __backend=None\n \n \n \n _no_backend_suggestion=None\n \n \n \n _pending_backend=None\n \n \n \n _pending_dry_run=False\n \n \n \n \n \n @classmethod\n def get_backend(cls):\n  ''\n\n\n\n\n\n\n\n\n  \n  if not cls.__backend:\n   cls.set_backend()\n   assert cls.__backend,\"set_backend() failed to load a default backend\"\n  return cls.__backend\n  \n @classmethod\n def has_backend(cls,name=\"any\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   cls.set_backend(name,dryrun=True )\n   return True\n  except (exc.MissingBackendError,exc.PasslibSecurityError):\n   return False\n   \n @classmethod\n def set_backend(cls,name=\"any\",dryrun=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if (name ==\"any\"and cls.__backend)or (name and name ==cls.__backend):\n   return cls.__backend\n   \n   \n   \n  owner=cls._get_backend_owner()\n  if owner is not cls:\n   return owner.set_backend(name,dryrun=dryrun)\n   \n   \n  if name ==\"any\"or name ==\"default\":\n   default_error=None\n   for name in cls.backends:\n    try :\n     return cls.set_backend(name,dryrun=dryrun)\n    except exc.MissingBackendError:\n     continue\n    except exc.PasslibSecurityError as err:\n    \n     if default_error is None :\n      default_error=err\n     continue\n   if default_error is None :\n    msg=\"%s: no backends available\"%cls.name\n    if cls._no_backend_suggestion:\n     msg +=cls._no_backend_suggestion\n    default_error=exc.MissingBackendError(msg)\n   raise default_error\n   \n   \n  if name not in cls.backends:\n   raise exc.UnknownBackendError(cls,name)\n   \n   \n  with _backend_lock:\n   orig=cls._pending_backend,cls._pending_dry_run\n   try :\n    cls._pending_backend=name\n    cls._pending_dry_run=dryrun\n    cls._set_backend(name,dryrun)\n   finally :\n    cls._pending_backend,cls._pending_dry_run=orig\n   if not dryrun:\n    cls.__backend=name\n   return name\n   \n   \n   \n   \n   \n @classmethod\n def _get_backend_owner(cls):\n  ''\n\n\n  \n  return cls\n  \n @classmethod\n def _set_backend(cls,name,dryrun):\n  ''\n\n\n\n\n\n\n\n  \n  loader=cls._get_backend_loader(name)\n  kwds={}\n  if accepts_keyword(loader,\"name\"):\n   kwds['name']=name\n  if accepts_keyword(loader,\"dryrun\"):\n   kwds['dryrun']=dryrun\n  ok=loader(**kwds)\n  if ok is False :\n   raise exc.MissingBackendError(\"%s: backend not available: %s\"%\n   (cls.name,name))\n  elif ok is not True :\n   raise AssertionError(\"backend loaders must return True or False\"\n   \": %r\"%(ok,))\n   \n @classmethod\n def _get_backend_loader(cls,name):\n  ''\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"implement in subclass\")\n  \n @classmethod\n def _stub_requires_backend(cls):\n  ''\n\n  \n  if cls.__backend:\n   raise AssertionError(\"%s: _finalize_backend(%r) failed to replace lazy loader\"%\n   (cls.name,cls.__backend))\n  cls.set_backend()\n  if not cls.__backend:\n   raise AssertionError(\"%s: set_backend() failed to load a default backend\"%\n   (cls.name))\n   \n   \n   \n   \n   \nclass SubclassBackendMixin(BackendMixin):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n _backend_mixin_target=False\n \n \n _backend_mixin_map=None\n \n \n \n \n \n @classmethod\n def _get_backend_owner(cls):\n  ''\n\n\n\n  \n  if not cls._backend_mixin_target:\n   raise AssertionError(\"_backend_mixin_target not set\")\n  for base in cls.__mro__:\n   if base.__dict__.get(\"_backend_mixin_target\"):\n    return base\n  raise AssertionError(\"expected to find class w/ '_backend_mixin_target' set\")\n  \n @classmethod\n def _set_backend(cls,name,dryrun):\n \n  super(SubclassBackendMixin,cls)._set_backend(name,dryrun)\n  \n  \n  \n  assert cls is cls._get_backend_owner(),\"_finalize_backend() not invoked on owner\"\n  \n  \n  mixin_map=cls._backend_mixin_map\n  assert mixin_map,\"_backend_mixin_map not specified\"\n  mixin_cls=mixin_map[name]\n  assert issubclass(mixin_cls,SubclassBackendMixin),\"invalid mixin class\"\n  \n  \n  update_mixin_classes(cls,\n  add=mixin_cls,\n  remove=mixin_map.values(),\n  append=True ,before=SubclassBackendMixin,\n  dryrun=dryrun,\n  )\n  \n @classmethod\n def _get_backend_loader(cls,name):\n  assert cls._backend_mixin_map,\"_backend_mixin_map not specified\"\n  return cls._backend_mixin_map[name]._load_backend_mixin\n  \n  \n  \n  \n  \n  \nclass HasManyBackends(BackendMixin,GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n def _calc_checksum(self,secret):\n  ''''\n  \n  \n  \n  return self._calc_checksum_backend(secret)\n  \n def _calc_checksum_backend(self,secret):\n  ''\n\n\n\n  \n  self._stub_requires_backend()\n  return self._calc_checksum_backend(secret)\n  \n  \n  \n  \n @classmethod\n def _get_backend_loader(cls,name):\n  ''\n\n\n  \n  \n  loader=getattr(cls,\"_load_backend_\"+name,None )\n  if loader is None :\n  \n   def loader():\n    return cls.__load_legacy_backend(name)\n  else :\n  \n   assert not hasattr(cls,\"_has_backend_\"+name),(\n   \"%s: can't specify both ._load_backend_%s() \"\n   \"and ._has_backend_%s\"%(cls.name,name,name)\n   )\n  return loader\n  \n @classmethod\n def __load_legacy_backend(cls,name):\n  value=getattr(cls,\"_has_backend_\"+name)\n  warn(\"%s: support for ._has_backend_%s is deprecated as of Passlib 1.7, \"\n  \"and will be removed in Passlib 1.9/2.0, please implement \"\n  \"._load_backend_%s() instead\"%(cls.name,name,name),\n  DeprecationWarning,\n  )\n  if value:\n   func=getattr(cls,\"_calc_checksum_\"+name)\n   cls._set_calc_checksum_backend(func)\n   return True\n  else :\n   return False\n   \n @classmethod\n def _set_calc_checksum_backend(cls,func):\n  ''\n\n\n  \n  backend=cls._pending_backend\n  assert backend,\"should only be called during set_backend()\"\n  if not callable(func):\n   raise RuntimeError(\"%s: backend %r returned invalid callable: %r\"%\n   (cls.name,backend,func))\n  if not cls._pending_dry_run:\n   cls._calc_checksum_backend=func\n   \n   \n   \n   \n   \n   \n   \n   \n   \nclass PrefixWrapper(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n _using_clone_attrs=()\n \n def __init__(self,name,wrapped,prefix=u(''),orig_prefix=u(''),lazy=False ,\n doc=None ,ident=None ):\n  self.name=name\n  if isinstance(prefix,bytes):\n   prefix=prefix.decode(\"ascii\")\n  self.prefix=prefix\n  if isinstance(orig_prefix,bytes):\n   orig_prefix=orig_prefix.decode(\"ascii\")\n  self.orig_prefix=orig_prefix\n  if doc:\n   self.__doc__=doc\n  if hasattr(wrapped,\"name\"):\n   self._set_wrapped(wrapped)\n  else :\n   self._wrapped_name=wrapped\n   if not lazy:\n    self._get_wrapped()\n    \n  if ident is not None :\n   if ident is True :\n   \n    if prefix:\n     ident=prefix\n    else :\n     raise ValueError(\"no prefix specified\")\n   if isinstance(ident,bytes):\n    ident=ident.decode(\"ascii\")\n    \n   if ident[:len(prefix)]!=prefix[:len(ident)]:\n    raise ValueError(\"ident must agree with prefix\")\n   self._ident=ident\n   \n _wrapped_name=None\n _wrapped_handler=None\n \n def _set_wrapped(self,handler):\n \n  if 'ident'in handler.setting_kwds and self.orig_prefix:\n  \n   warn(\"PrefixWrapper: 'orig_prefix' option may not work correctly \"\n   \"for handlers which have multiple identifiers: %r\"%\n   (handler.name,),exc.PasslibRuntimeWarning)\n   \n   \n  self._wrapped_handler=handler\n  \n def _get_wrapped(self):\n  handler=self._wrapped_handler\n  if handler is None :\n   handler=get_crypt_handler(self._wrapped_name)\n   self._set_wrapped(handler)\n  return handler\n  \n wrapped=property(_get_wrapped)\n \n _ident=False\n \n @property\n def ident(self):\n  value=self._ident\n  if value is False :\n   value=None\n   \n   \n   if not self.orig_prefix:\n    wrapped=self.wrapped\n    ident=getattr(wrapped,\"ident\",None )\n    if ident is not None :\n     value=self._wrap_hash(ident)\n   self._ident=value\n  return value\n  \n _ident_values=False\n \n @property\n def ident_values(self):\n  value=self._ident_values\n  if value is False :\n   value=None\n   \n   \n   if not self.orig_prefix:\n    wrapped=self.wrapped\n    idents=getattr(wrapped,\"ident_values\",None )\n    if idents:\n     value=tuple(self._wrap_hash(ident)for ident in idents)\n     \n     \n     \n     \n   self._ident_values=value\n  return value\n  \n  \n  \n _proxy_attrs=(\n \"setting_kwds\",\"context_kwds\",\n \"default_rounds\",\"min_rounds\",\"max_rounds\",\"rounds_cost\",\n \"min_desired_rounds\",\"max_desired_rounds\",\"vary_rounds\",\n \"default_salt_size\",\"min_salt_size\",\"max_salt_size\",\n \"salt_chars\",\"default_salt_chars\",\n \"backends\",\"has_backend\",\"get_backend\",\"set_backend\",\n \"is_disabled\",\"truncate_size\",\"truncate_error\",\n \"truncate_verify_reject\",\n \n \n \"_salt_is_bytes\",\n )\n \n def __repr__(self):\n  args=[repr(self._wrapped_name or self._wrapped_handler)]\n  if self.prefix:\n   args.append(\"prefix=%r\"%self.prefix)\n  if self.orig_prefix:\n   args.append(\"orig_prefix=%r\"%self.orig_prefix)\n  args=\", \".join(args)\n  return 'PrefixWrapper(%r, %s)'%(self.name,args)\n  \n def __dir__(self):\n  attrs=set(dir(self.__class__))\n  attrs.update(self.__dict__)\n  wrapped=self.wrapped\n  attrs.update(\n  attr for attr in self._proxy_attrs\n  if hasattr(wrapped,attr)\n  )\n  return list(attrs)\n  \n def __getattr__(self,attr):\n  ''\n  if attr in self._proxy_attrs:\n   return getattr(self.wrapped,attr)\n  raise AttributeError(\"missing attribute: %r\"%(attr,))\n  \n def __setattr__(self,attr,value):\n \n \n \n \n \n  if attr in self._proxy_attrs and self._derived_from:\n   wrapped=self.wrapped\n   if hasattr(wrapped,attr):\n    setattr(wrapped,attr,value)\n    return\n  return object.__setattr__(self,attr,value)\n  \n def _unwrap_hash(self,hash):\n  ''\n  \n  prefix=self.prefix\n  if not hash.startswith(prefix):\n   raise exc.InvalidHashError(self)\n   \n  return self.orig_prefix+hash[len(prefix):]\n  \n def _wrap_hash(self,hash):\n  ''\n  \n  \n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  orig_prefix=self.orig_prefix\n  if not hash.startswith(orig_prefix):\n   raise exc.InvalidHashError(self.wrapped)\n  wrapped=self.prefix+hash[len(orig_prefix):]\n  return uascii_to_str(wrapped)\n  \n  \n _derived_from=None\n \n def using(self,**kwds):\n \n  subcls=self.wrapped.using(**kwds)\n  assert subcls is not self.wrapped\n  \n  wrapper=PrefixWrapper(self.name,subcls,prefix=self.prefix,orig_prefix=self.orig_prefix)\n  wrapper._derived_from=self\n  for attr in self._using_clone_attrs:\n   setattr(wrapper,attr,getattr(self,attr))\n  return wrapper\n  \n def needs_update(self,hash,**kwds):\n  hash=self._unwrap_hash(hash)\n  return self.wrapped.needs_update(hash,**kwds)\n  \n def identify(self,hash):\n  hash=to_unicode_for_identify(hash)\n  if not hash.startswith(self.prefix):\n   return False\n  hash=self._unwrap_hash(hash)\n  return self.wrapped.identify(hash)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genconfig(self,**kwds):\n  config=self.wrapped.genconfig(**kwds)\n  if config is None :\n   raise RuntimeError(\".genconfig() must return a string, not None\")\n  return self._wrap_hash(config)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genhash(self,secret,config,**kwds):\n \n  if config is not None :\n   config=to_unicode(config,\"ascii\",\"config/hash\")\n   config=self._unwrap_hash(config)\n  return self._wrap_hash(self.wrapped.genhash(secret,config,**kwds))\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\",replacement=\".hash()\")\n def encrypt(self,secret,**kwds):\n  return self.hash(secret,**kwds)\n  \n def hash(self,secret,**kwds):\n  return self._wrap_hash(self.wrapped.hash(secret,**kwds))\n  \n def verify(self,secret,hash,**kwds):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  hash=self._unwrap_hash(hash)\n  return self.wrapped.verify(secret,hash,**kwds)\n  \n  \n  \n  \n", ["__future__", "inspect", "logging", "math", "passlib.exc", "passlib.ifc", "passlib.registry", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "threading", "warnings"]], "passlib.utils": [".py", "''\n\n\n\nfrom passlib.utils.compat import JYTHON\n\nfrom binascii import b2a_base64,a2b_base64,Error as _BinAsciiError\nfrom base64 import b64encode,b64decode\ntry :\n from collections.abc import Sequence\n from collections.abc import Iterable\nexcept ImportError:\n\n from collections import Sequence\n from collections import Iterable\nfrom codecs import lookup as _lookup_codec\nfrom functools import update_wrapper\nimport itertools\nimport inspect\nimport logging ;log=logging.getLogger(__name__)\nimport math\nimport os\nimport sys\nimport random\nimport re\nif JYTHON:\n\n\n try :\n  import stringprep\n except ImportError:\n  stringprep=None\n  _stringprep_missing_reason=\"not present under Jython\"\nelse :\n import stringprep\nimport time\nif stringprep:\n import unicodedata\ntry :\n import threading\nexcept ImportError:\n\n threading=None\nimport timeit\nimport types\nfrom warnings import warn\n\n\nfrom passlib.utils.binary import (\n\nBASE64_CHARS,AB64_CHARS,HASH64_CHARS,BCRYPT_CHARS,\nBase64Engine,LazyBase64Engine,h64,h64big,bcrypt64,\nab64_encode,ab64_decode,b64s_encode,b64s_decode\n)\nfrom passlib.utils.decor import (\n\ndeprecated_function,\ndeprecated_method,\nmemoized_property,\nclassproperty,\nhybrid_method,\n)\nfrom passlib.exc import ExpectedStringError,ExpectedTypeError\nfrom passlib.utils.compat import (add_doc,join_bytes,join_byte_values,\njoin_byte_elems,irange,imap,PY3,u,\njoin_unicode,unicode,byte_elem_value,nextgetter,\nunicode_or_str,unicode_or_bytes_types,\nget_method_function,suppress_cause,PYPY)\n\n__all__=[\n\n'JYTHON',\n'sys_bits',\n'unix_crypt_schemes',\n'rounds_cost_values',\n\n\n'consteq',\n'saslprep',\n\n\n\"xor_bytes\",\n\"render_bytes\",\n\n\n'is_same_codec',\n'is_ascii_safe',\n'to_bytes',\n'to_unicode',\n'to_native_str',\n\n\n'has_crypt',\n'test_crypt',\n'safe_crypt',\n'tick',\n\n\n'rng',\n'getrandbytes',\n'getrandstr',\n'generate_password',\n\n\n'is_crypt_handler',\n'is_crypt_context',\n'has_rounds_info',\n'has_salt_info',\n]\n\n\n\n\n\n\nsys_bits=int(math.log(sys.maxsize if PY3 else sys.maxint,2)+1.5)\n\n\n\nunix_crypt_schemes=[\n\"sha512_crypt\",\"sha256_crypt\",\n\"sha1_crypt\",\"bcrypt\",\n\"md5_crypt\",\n\n\"bsdi_crypt\",\"des_crypt\",\n]\n\n\nrounds_cost_values=[\"linear\",\"log2\"]\n\n\nfrom passlib.exc import MissingBackendError\n\n\n_BEMPTY=b''\n_UEMPTY=u(\"\")\n_USPACE=u(\" \")\n\n\nMAX_PASSWORD_SIZE=int(os.environ.get(\"PASSLIB_MAX_PASSWORD_SIZE\")or 4096)\n\n\n\n\n\nclass SequenceMixin(object):\n ''\n\n\n \n def _as_tuple(self):\n  raise NotImplementedError(\"implement in subclass\")\n  \n def __repr__(self):\n  return repr(self._as_tuple())\n  \n def __getitem__(self,idx):\n  return self._as_tuple()[idx]\n  \n def __iter__(self):\n  return iter(self._as_tuple())\n  \n def __len__(self):\n  return len(self._as_tuple())\n  \n def __eq__(self,other):\n  return self._as_tuple()==other\n  \n def __ne__(self,other):\n  return not self.__eq__(other)\n  \nif PY3:\n\n\n\n _VAR_KEYWORD=inspect.Parameter.VAR_KEYWORD\n _VAR_ANY_SET=set([_VAR_KEYWORD,inspect.Parameter.VAR_POSITIONAL])\n \n def accepts_keyword(func,key):\n  ''\n  params=inspect.signature(get_method_function(func)).parameters\n  if not params:\n   return False\n  arg=params.get(key)\n  if arg and arg.kind not in _VAR_ANY_SET:\n   return True\n   \n  return params[list(params)[-1]].kind ==_VAR_KEYWORD\n  \nelse :\n\n def accepts_keyword(func,key):\n  ''\n  spec=inspect.getargspec(get_method_function(func))\n  return key in spec.args or spec.keywords is not None\n  \ndef update_mixin_classes(target,add=None ,remove=None ,append=False ,\nbefore=None ,after=None ,dryrun=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(add,type):\n  add=[add]\n  \n bases=list(target.__bases__)\n \n \n if remove:\n  if isinstance(remove,type):\n   remove=[remove]\n  for mixin in remove:\n   if add and mixin in add:\n    continue\n   if mixin in bases:\n    bases.remove(mixin)\n    \n    \n if add:\n  for mixin in add:\n  \n   if any(issubclass(base,mixin)for base in bases):\n    continue\n    \n    \n   if append:\n    for idx,base in enumerate(bases):\n     if issubclass(mixin,base):\n     \n      break\n     if before and issubclass(base,before):\n     \n      break\n    else :\n    \n     idx=len(bases)\n   elif after:\n    for end_idx,base in enumerate(reversed(bases)):\n     if issubclass(base,after):\n     \n      idx=len(bases)-end_idx\n      assert bases[idx -1]==base\n      break\n    else :\n     idx=0\n   else :\n   \n    idx=0\n    \n    \n   bases.insert(idx,mixin)\n   \n   \n if not dryrun:\n  target.__bases__=tuple(bases)\n  \n  \n  \n  \ndef batch(source,size):\n ''\n\n \n if size <1:\n  raise ValueError(\"size must be positive integer\")\n if isinstance(source,Sequence):\n  end=len(source)\n  i=0\n  while i <end:\n   n=i+size\n   yield source[i:n]\n   i=n\n elif isinstance(source,Iterable):\n  itr=iter(source)\n  while True :\n   chunk_itr=itertools.islice(itr,size)\n   try :\n    first=next(chunk_itr)\n   except StopIteration:\n    break\n   yield itertools.chain((first,),chunk_itr)\n else :\n  raise TypeError(\"source must be iterable\")\n  \n  \n  \n  \n  \n  \n  \ndef consteq(left,right):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n if isinstance(left,unicode):\n  if not isinstance(right,unicode):\n   raise TypeError(\"inputs must be both unicode or both bytes\")\n  is_py3_bytes=False\n elif isinstance(left,bytes):\n  if not isinstance(right,bytes):\n   raise TypeError(\"inputs must be both unicode or both bytes\")\n  is_py3_bytes=PY3\n else :\n  raise TypeError(\"inputs must be both unicode or both bytes\")\n  \n  \n  \n  \n  \n same_size=(len(left)==len(right))\n if same_size:\n \n  tmp=left\n  result=0\n if not same_size:\n \n \n \n  tmp=right\n  result=1\n  \n  \n  \n if is_py3_bytes:\n  for l,r in zip(tmp,right):\n   result |=l ^r\n else :\n  for l,r in zip(tmp,right):\n   result |=ord(l)^ord(r)\n return result ==0\n \n \n \n \n \nstr_consteq=consteq\n\ntry :\n\n from hmac import compare_digest as consteq\nexcept ImportError:\n pass\n \n \n \n \n \n \ndef splitcomma(source,sep=\",\"):\n ''\n\n \n source=source.strip()\n if source.endswith(sep):\n  source=source[:-1]\n if not source:\n  return []\n return [elem.strip()for elem in source.split(sep)]\n \ndef saslprep(source,param=\"value\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n if not isinstance(source,unicode):\n  raise TypeError(\"input must be unicode string, not %s\"%\n  (type(source),))\n  \n  \n  \n  \n in_table_c12=stringprep.in_table_c12\n in_table_b1=stringprep.in_table_b1\n data=join_unicode(\n _USPACE if in_table_c12(c)else c\n for c in source\n if not in_table_b1(c)\n )\n \n \n data=unicodedata.normalize('NFKC',data)\n if not data:\n  return _UEMPTY\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n is_ral_char=stringprep.in_table_d1\n if is_ral_char(data[0]):\n  if not is_ral_char(data[-1]):\n   raise ValueError(\"malformed bidi sequence in \"+param)\n   \n  is_forbidden_bidi_char=stringprep.in_table_d2\n else :\n \n  is_forbidden_bidi_char=is_ral_char\n  \n  \n in_table_a1=stringprep.in_table_a1\n in_table_c21_c22=stringprep.in_table_c21_c22\n in_table_c3=stringprep.in_table_c3\n in_table_c4=stringprep.in_table_c4\n in_table_c5=stringprep.in_table_c5\n in_table_c6=stringprep.in_table_c6\n in_table_c7=stringprep.in_table_c7\n in_table_c8=stringprep.in_table_c8\n in_table_c9=stringprep.in_table_c9\n for c in data:\n \n  assert not in_table_b1(c),\"failed to strip B.1 in mapping stage\"\n  assert not in_table_c12(c),\"failed to replace C.1.2 in mapping stage\"\n  \n  \n  if in_table_a1(c):\n   raise ValueError(\"unassigned code points forbidden in \"+param)\n  if in_table_c21_c22(c):\n   raise ValueError(\"control characters forbidden in \"+param)\n  if in_table_c3(c):\n   raise ValueError(\"private use characters forbidden in \"+param)\n  if in_table_c4(c):\n   raise ValueError(\"non-char code points forbidden in \"+param)\n  if in_table_c5(c):\n   raise ValueError(\"surrogate codes forbidden in \"+param)\n  if in_table_c6(c):\n   raise ValueError(\"non-plaintext chars forbidden in \"+param)\n  if in_table_c7(c):\n  \n  \n   raise ValueError(\"non-canonical chars forbidden in \"+param)\n  if in_table_c8(c):\n   raise ValueError(\"display-modifying / deprecated chars \"\n   \"forbidden in\"+param)\n  if in_table_c9(c):\n   raise ValueError(\"tagged characters forbidden in \"+param)\n   \n   \n  if is_forbidden_bidi_char(c):\n   raise ValueError(\"forbidden bidi character in \"+param)\n   \n return data\n \n \nif stringprep is None :\n def saslprep(source,param=\"value\"):\n  ''\n  raise NotImplementedError(\"saslprep() support requires the 'stringprep' \"\n  \"module, which is \"+_stringprep_missing_reason)\n  \n  \n  \n  \ndef render_bytes(source,*args):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(source,bytes):\n  source=source.decode(\"latin-1\")\n result=source %tuple(arg.decode(\"latin-1\")if isinstance(arg,bytes)\n else arg for arg in args)\n return result.encode(\"latin-1\")\n \nif PY3:\n\n def bytes_to_int(value):\n  return int.from_bytes(value,'big')\n def int_to_bytes(value,count):\n  return value.to_bytes(count,'big')\nelse :\n\n from binascii import hexlify,unhexlify\n def bytes_to_int(value):\n  return int(hexlify(value),16)\n def int_to_bytes(value,count):\n  return unhexlify(('%%0%dx'%(count <<1))%value)\n  \nadd_doc(bytes_to_int,\"decode byte string as single big-endian integer\")\nadd_doc(int_to_bytes,\"encode integer as single big-endian byte string\")\n\ndef xor_bytes(left,right):\n ''\n return int_to_bytes(bytes_to_int(left)^bytes_to_int(right),len(left))\n \ndef repeat_string(source,size):\n ''\n\n \n mult=1+(size -1)//len(source)\n return (source *mult)[:size]\n \n \ndef utf8_repeat_string(source,size):\n ''\n\n \n mult=1+(size -1)//len(source)\n return utf8_truncate(source *mult,size)\n \n \n_BNULL=b\"\\x00\"\n_UNULL=u(\"\\x00\")\n\ndef right_pad_string(source,size,pad=None ):\n ''\n cur=len(source)\n if size >cur:\n  if pad is None :\n   pad=_UNULL if isinstance(source,unicode)else _BNULL\n  return source+pad *(size -cur)\n else :\n  return source[:size]\n  \n  \ndef utf8_truncate(source,index):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n if not isinstance(source,bytes):\n  raise ExpectedTypeError(source,bytes,\"source\")\n  \n  \n end=len(source)\n if index <0:\n  index=max(0,index+end)\n if index >=end:\n  return source\n  \n  \n end=min(index+3,end)\n \n \n while index <end:\n  if byte_elem_value(source[index])&0xC0 !=0x80:\n  \n   break\n   \n  index +=1\n else :\n  assert index ==end\n  \n  \n result=source[:index]\n \n def sanity_check():\n \n  try :\n   text=source.decode(\"utf-8\")\n  except UnicodeDecodeError:\n  \n   return True\n   \n   \n  assert text.startswith(result.decode(\"utf-8\"))\n  return True\n  \n assert sanity_check()\n \n return result\n \n \n \n \n_ASCII_TEST_BYTES=b\"\\x00\\n aA:#!\\x7f\"\n_ASCII_TEST_UNICODE=_ASCII_TEST_BYTES.decode(\"ascii\")\n\ndef is_ascii_codec(codec):\n ''\n return _ASCII_TEST_UNICODE.encode(codec)==_ASCII_TEST_BYTES\n \ndef is_same_codec(left,right):\n ''\n if left ==right:\n  return True\n if not (left and right):\n  return False\n return _lookup_codec(left).name ==_lookup_codec(right).name\n \n_B80=b'\\x80'[0]\n_U80=u('\\x80')\ndef is_ascii_safe(source):\n ''\n r=_B80 if isinstance(source,bytes)else _U80\n return all(c <r for c in source)\n \ndef to_bytes(source,encoding=\"utf-8\",param=\"value\",source_encoding=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n assert encoding\n if isinstance(source,bytes):\n  if source_encoding and not is_same_codec(source_encoding,encoding):\n   return source.decode(source_encoding).encode(encoding)\n  else :\n   return source\n elif isinstance(source,unicode):\n  return source.encode(encoding)\n else :\n  raise ExpectedStringError(source,param)\n  \ndef to_unicode(source,encoding=\"utf-8\",param=\"value\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n assert encoding\n if isinstance(source,unicode):\n  return source\n elif isinstance(source,bytes):\n  return source.decode(encoding)\n else :\n  raise ExpectedStringError(source,param)\n  \nif PY3:\n def to_native_str(source,encoding=\"utf-8\",param=\"value\"):\n  if isinstance(source,bytes):\n   return source.decode(encoding)\n  elif isinstance(source,unicode):\n   return source\n  else :\n   raise ExpectedStringError(source,param)\nelse :\n def to_native_str(source,encoding=\"utf-8\",param=\"value\"):\n  if isinstance(source,bytes):\n   return source\n  elif isinstance(source,unicode):\n   return source.encode(encoding)\n  else :\n   raise ExpectedStringError(source,param)\n   \nadd_doc(to_native_str,\n\"\"\"Take in unicode or bytes, return native string.\n\n    Python 2: encodes unicode using specified encoding, leaves bytes alone.\n    Python 3: leaves unicode alone, decodes bytes using specified encoding.\n\n    :raises TypeError: if source is not unicode or bytes.\n\n    :arg source:\n        source unicode or bytes string.\n\n    :arg encoding:\n        encoding to use when encoding unicode or decoding bytes.\n        this defaults to ``\"utf-8\"``.\n\n    :param param:\n        optional name of variable/noun to reference when raising errors.\n\n    :returns: :class:`str` instance\n    \"\"\")\n\n@deprecated_function(deprecated=\"1.6\",removed=\"1.7\")\ndef to_hash_str(source,encoding=\"ascii\"):\n ''\n return to_native_str(source,encoding,param=\"hash\")\n \n_true_set=set(\"true t yes y on 1 enable enabled\".split())\n_false_set=set(\"false f no n off 0 disable disabled\".split())\n_none_set=set([\"\",\"none\"])\n\ndef as_bool(value,none=None ,param=\"boolean\"):\n ''\n\n\n \n assert none in [True ,False ,None ]\n if isinstance(value,unicode_or_bytes_types):\n  clean=value.lower().strip()\n  if clean in _true_set:\n   return True\n  if clean in _false_set:\n   return False\n  if clean in _none_set:\n   return none\n  raise ValueError(\"unrecognized %s value: %r\"%(param,value))\n elif isinstance(value,bool):\n  return value\n elif value is None :\n  return none\n else :\n  return bool(value)\n  \n  \n  \n  \n  \ndef is_safe_crypt_input(value):\n ''\n\n\n\n \n if crypt_accepts_bytes or not isinstance(value,bytes):\n  return True\n try :\n  value.decode(\"utf-8\")\n  return True\n except UnicodeDecodeError:\n  return False\n  \ntry :\n from crypt import crypt as _crypt\nexcept ImportError:\n _crypt=None\n has_crypt=False\n crypt_accepts_bytes=False\n crypt_needs_lock=False\n _safe_crypt_lock=None\n def safe_crypt(secret,hash):\n  return None\nelse :\n has_crypt=True\n _NULL='\\x00'\n \n \n if threading and PYPY and (7,2,0)<=sys.pypy_version_info <=(7,3,3):\n \n \n  _safe_crypt_lock=threading.Lock()\n  \n  \n  crypt_needs_lock=True\n  \n else :\n  from passlib.utils.compat import nullcontext\n  _safe_crypt_lock=nullcontext()\n  crypt_needs_lock=False\n  \n  \n  \n  \n  \n  \n _invalid_prefixes=u(\"*:!\")\n \n if PY3:\n \n \n \n \n  crypt_accepts_bytes=True\n  try :\n   _crypt(b\"\\xEE\",\"xx\")\n  except TypeError:\n  \n   crypt_accepts_bytes=False\n  except :\n  \n  \n   pass\n   \n  def safe_crypt(secret,hash):\n   if crypt_accepts_bytes:\n   \n   \n    if isinstance(secret,unicode):\n     secret=secret.encode(\"utf-8\")\n    if _BNULL in secret:\n     raise ValueError(\"null character in secret\")\n    if isinstance(hash,unicode):\n     hash=hash.encode(\"ascii\")\n   else :\n   \n   \n   \n    if isinstance(secret,bytes):\n     orig=secret\n     try :\n      secret=secret.decode(\"utf-8\")\n     except UnicodeDecodeError:\n      return None\n      \n      \n     assert secret.encode(\"utf-8\")==orig,\\\n     \"utf-8 spec says this can't happen!\"\n    if _NULL in secret:\n     raise ValueError(\"null character in secret\")\n    if isinstance(hash,bytes):\n     hash=hash.decode(\"ascii\")\n   try :\n    with _safe_crypt_lock:\n     result=_crypt(secret,hash)\n   except OSError:\n   \n   \n   \n    return None\n    \n    \n    \n   if isinstance(result,bytes):\n    result=result.decode(\"ascii\")\n   if not result or result[0]in _invalid_prefixes:\n    return None\n   return result\n else :\n \n \n  crypt_accepts_bytes=True\n  \n  \n  def safe_crypt(secret,hash):\n   if isinstance(secret,unicode):\n    secret=secret.encode(\"utf-8\")\n   if _NULL in secret:\n    raise ValueError(\"null character in secret\")\n   if isinstance(hash,unicode):\n    hash=hash.encode(\"ascii\")\n   with _safe_crypt_lock:\n    result=_crypt(secret,hash)\n   if not result:\n    return None\n   result=result.decode(\"ascii\")\n   if result[0]in _invalid_prefixes:\n    return None\n   return result\n   \nadd_doc(safe_crypt,\"\"\"Wrapper around stdlib's crypt.\n\n    This is a wrapper around stdlib's :func:`!crypt.crypt`, which attempts\n    to provide uniform behavior across Python 2 and 3.\n\n    :arg secret:\n        password, as bytes or unicode (unicode will be encoded as ``utf-8``).\n\n    :arg hash:\n        hash or config string, as ascii bytes or unicode.\n\n    :returns:\n        resulting hash as ascii unicode; or ``None`` if the password\n        couldn't be hashed due to one of the issues:\n\n        * :func:`crypt()` not available on platform.\n\n        * Under Python 3, if *secret* is specified as bytes,\n          it must be use ``utf-8`` or it can't be passed\n          to :func:`crypt()`.\n\n        * Some OSes will return ``None`` if they don't recognize\n          the algorithm being used (though most will simply fall\n          back to des-crypt).\n\n        * Some OSes will return an error string if the input config\n          is recognized but malformed; current code converts these to ``None``\n          as well.\n    \"\"\")\n\ndef test_crypt(secret,hash):\n ''\n\n\n\n \n \n \n \n \n assert isinstance(hash,unicode_or_str),\\\n \"hash must be unicode_or_str, got %s\"%type(hash)\n assert hash,\"hash must be non-empty\"\n return safe_crypt(secret,hash)==hash\n \ntimer=timeit.default_timer\n\ntick=timer\n\ndef parse_version(source):\n ''\n m=re.search(r\"(\\d+(?:\\.\\d+)+)\",source)\n if m:\n  return tuple(int(elem)for elem in m.group(1).split(\".\"))\n return None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ntry :\n os.urandom(1)\n has_urandom=True\nexcept NotImplementedError:\n has_urandom=False\n \ndef genseed(value=None ):\n ''\n from hashlib import sha512\n if hasattr(value,\"getstate\")and hasattr(value,\"getrandbits\"):\n \n  try :\n   value=value.getstate()\n  except NotImplementedError:\n  \n  \n   value=value.getrandbits(1 <<15)\n text=u(\"%s %s %s %.15f %.15f %s\")%(\n \n value,\n \n \n \n os.getpid()if hasattr(os,\"getpid\")else None ,\n \n \n \n id(object()),\n \n \n time.time(),\n tick(),\n \n \n os.urandom(32).decode(\"latin-1\")if has_urandom else 0,\n )\n \n return int(sha512(text.encode(\"utf-8\")).hexdigest(),16)\n \nif has_urandom:\n rng=random.SystemRandom()\nelse :\n\n\n rng=random.Random(genseed())\n \n \n \n \ndef getrandbytes(rng,count):\n ''\n \n \n \n \n \n \n \n if not count:\n  return _BEMPTY\n def helper():\n \n  value=rng.getrandbits(count <<3)\n  i=0\n  while i <count:\n   yield value&0xff\n   value >>=3\n   i +=1\n return join_byte_values(helper())\n \ndef getrandstr(rng,charset,count):\n ''\n \n \n \n \n if count <0:\n  raise ValueError(\"count must be >= 0\")\n letters=len(charset)\n if letters ==0:\n  raise ValueError(\"alphabet must not be empty\")\n if letters ==1:\n  return charset *count\n  \n  \n def helper():\n \n  value=rng.randrange(0,letters **count)\n  i=0\n  while i <count:\n   yield charset[value %letters]\n   value //=letters\n   i +=1\n   \n if isinstance(charset,unicode):\n  return join_unicode(helper())\n else :\n  return join_byte_elems(helper())\n  \n_52charset='2346789ABCDEFGHJKMNPQRTUVWXYZabcdefghjkmnpqrstuvwxyz'\n\n@deprecated_function(deprecated=\"1.7\",removed=\"2.0\",\nreplacement=\"passlib.pwd.genword() / passlib.pwd.genphrase()\")\ndef generate_password(size=10,charset=_52charset):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return getrandstr(rng,charset,size)\n \n \n \n \n_handler_attrs=(\n\"name\",\n\"setting_kwds\",\"context_kwds\",\n\"verify\",\"hash\",\"identify\",\n)\n\ndef is_crypt_handler(obj):\n ''\n \n return all(hasattr(obj,name)for name in _handler_attrs)\n \n_context_attrs=(\n\"needs_update\",\n\"genconfig\",\"genhash\",\n\"verify\",\"encrypt\",\"identify\",\n)\n\ndef is_crypt_context(obj):\n ''\n \n return all(hasattr(obj,name)for name in _context_attrs)\n \n \n \n \n \n \ndef has_rounds_info(handler):\n ''\n return ('rounds'in handler.setting_kwds and\n getattr(handler,\"min_rounds\",None )is not None )\n \ndef has_salt_info(handler):\n ''\n return ('salt'in handler.setting_kwds and\n getattr(handler,\"min_salt_size\",None )is not None )\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", ["base64", "binascii", "codecs", "collections", "collections.abc", "crypt", "functools", "hashlib", "hmac", "inspect", "itertools", "logging", "math", "os", "passlib.exc", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "random", "re", "stringprep", "sys", "threading", "time", "timeit", "types", "unicodedata", "warnings"], 1], "passlib.utils.pbkdf2": [".py", "''\n\n\n\n\n\n\n\nfrom __future__ import division\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.exc import ExpectedTypeError\nfrom passlib.utils.decor import deprecated_function\nfrom passlib.utils.compat import native_string_types\nfrom passlib.crypto.digest import norm_hash_name,lookup_hash,pbkdf1 as _pbkdf1,pbkdf2_hmac,compile_hmac\n\n__all__=[\n\n\"norm_hash_name\",\n\n\n\"get_prf\",\n\n\n\"pbkdf1\",\n\"pbkdf2\",\n]\n\n\n\n\nfrom warnings import warn\n\nwarn(\"the module 'passlib.utils.pbkdf2' is deprecated as of Passlib 1.7, \"\n\"and will be removed in Passlib 2.0, please use 'passlib.crypto' instead\",\nDeprecationWarning)\n\n\n\n\n\nnorm_hash_name=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",func_module=__name__,\nreplacement=\"passlib.crypto.digest.norm_hash_name\")(norm_hash_name)\n\n\n\n\n\n\n_prf_cache={}\n\n\n_HMAC_PREFIXES=(\"hmac_\",\"hmac-\")\n\ndef get_prf(name):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _prf_cache\n if name in _prf_cache:\n  return _prf_cache[name]\n if isinstance(name,native_string_types):\n  if not name.startswith(_HMAC_PREFIXES):\n   raise ValueError(\"unknown prf algorithm: %r\"%(name,))\n  digest=lookup_hash(name[5:]).name\n  def hmac(key,msg):\n   return compile_hmac(digest,key)(msg)\n  record=(hmac,hmac.digest_info.digest_size)\n elif callable(name):\n \n  digest_size=len(name(b'x',b'y'))\n  record=(name,digest_size)\n else :\n  raise ExpectedTypeError(name,\"str or callable\",\"prf name\")\n _prf_cache[name]=record\n return record\n \n \n \n \ndef pbkdf1(secret,salt,rounds,keylen=None ,hash=\"sha1\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return _pbkdf1(hash,secret,salt,rounds,keylen)\n \n \n \n \ndef pbkdf2(secret,salt,rounds,keylen=None ,prf=\"hmac-sha1\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if callable(prf)or (isinstance(prf,native_string_types)and not prf.startswith(_HMAC_PREFIXES)):\n  raise NotImplementedError(\"non-HMAC prfs are not supported as of Passlib 1.7\")\n digest=prf[5:]\n return pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n \n \n \n \n", ["__future__", "logging", "passlib.crypto.digest", "passlib.exc", "passlib.utils.compat", "passlib.utils.decor", "warnings"]], "passlib.utils.md4": [".py", "''\n\n\n\n\n\n\n\n\nfrom warnings import warn\nwarn(\"the module 'passlib.utils.md4' is deprecated as of Passlib 1.7, \"\n\"and will be removed in Passlib 2.0, please use \"\n\"'lookup_hash(\\\"md4\\\").const()' from 'passlib.crypto' instead\",\nDeprecationWarning)\n\n\n\n\n__all__=[\"md4\"]\n\n\n\nfrom passlib.crypto.digest import lookup_hash\nmd4=lookup_hash(\"md4\").const\ndel lookup_hash\n\n\n\n\n", ["passlib.crypto.digest", "warnings"]], "passlib.utils.decor": [".py", "''\n\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\nimport logging\nlog=logging.getLogger(__name__)\nfrom functools import wraps,update_wrapper\nimport types\nfrom warnings import warn\n\n\nfrom passlib.utils.compat import PY3\n\n__all__=[\n\"classproperty\",\n\"hybrid_method\",\n\n\"memoize_single_value\",\n\"memoized_property\",\n\n\"deprecated_function\",\n\"deprecated_method\",\n]\n\n\n\n\nclass classproperty(object):\n ''\n \n def __init__(self,func):\n  self.im_func=func\n  \n def __get__(self,obj,cls):\n  return self.im_func(cls)\n  \n @property\n def __func__(self):\n  ''\n  return self.im_func\n  \nclass hybrid_method(object):\n ''\n\n\n \n \n def __init__(self,func):\n  self.func=func\n  update_wrapper(self,func)\n  \n def __get__(self,obj,cls):\n  if obj is None :\n   obj=cls\n  if PY3:\n   return types.MethodType(self.func,obj)\n  else :\n   return types.MethodType(self.func,obj,cls)\n   \n   \n   \n   \n   \ndef memoize_single_value(func):\n ''\n\n\n\n \n cache={}\n \n @wraps(func)\n def wrapper():\n  try :\n   return cache[True ]\n  except KeyError:\n   pass\n  value=cache[True ]=func()\n  return value\n  \n def clear_cache():\n  cache.pop(True ,None )\n wrapper.clear_cache=clear_cache\n \n return wrapper\n \nclass memoized_property(object):\n ''\n\n \n def __init__(self,func):\n  self.__func__=func\n  self.__name__=func.__name__\n  self.__doc__=func.__doc__\n  \n def __get__(self,obj,cls):\n  if obj is None :\n   return self\n  value=self.__func__(obj)\n  setattr(obj,self.__name__,value)\n  return value\n  \n if not PY3:\n \n  @property\n  def im_func(self):\n   ''\n   return self.__func__\n   \n def clear_cache(self,obj):\n  ''\n\n\n\n  \n  obj.__dict__.pop(self.__name__,None )\n  \n def peek_cache(self,obj,default=None ):\n  ''\n\n\n\n  \n  return obj.__dict__.get(self.__name__,default)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef deprecated_function(msg=None ,deprecated=None ,removed=None ,updoc=True ,\nreplacement=None ,_is_method=False ,\nfunc_module=None ):\n ''\n\n\n\n\n\n\n \n if msg is None :\n  if _is_method:\n   msg=\"the method %(mod)s.%(klass)s.%(name)s() is deprecated\"\n  else :\n   msg=\"the function %(mod)s.%(name)s() is deprecated\"\n  if deprecated:\n   msg +=\" as of Passlib %(deprecated)s\"\n  if removed:\n   msg +=\", and will be removed in Passlib %(removed)s\"\n  if replacement:\n   msg +=\", use %s instead\"%replacement\n  msg +=\".\"\n def build(func):\n  is_classmethod=_is_method and isinstance(func,classmethod)\n  if is_classmethod:\n  \n   func=func.__get__(None ,type).__func__\n  opts=dict(\n  mod=func_module or func.__module__,\n  name=func.__name__,\n  deprecated=deprecated,\n  removed=removed,\n  )\n  if _is_method:\n   def wrapper(*args,**kwds):\n    tmp=opts.copy()\n    klass=args[0]if is_classmethod else args[0].__class__\n    tmp.update(klass=klass.__name__,mod=klass.__module__)\n    warn(msg %tmp,DeprecationWarning,stacklevel=2)\n    return func(*args,**kwds)\n  else :\n   text=msg %opts\n   def wrapper(*args,**kwds):\n    warn(text,DeprecationWarning,stacklevel=2)\n    return func(*args,**kwds)\n  update_wrapper(wrapper,func)\n  if updoc and (deprecated or removed)and\\\n  wrapper.__doc__ and \".. deprecated::\"not in wrapper.__doc__:\n   txt=deprecated or ''\n   if removed or replacement:\n    txt +=\"\\n    \"\n    if removed:\n     txt +=\"and will be removed in version %s\"%(removed,)\n    if replacement:\n     if removed:\n      txt +=\", \"\n     txt +=\"use %s instead\"%replacement\n    txt +=\".\"\n   if not wrapper.__doc__.strip(\" \").endswith(\"\\n\"):\n    wrapper.__doc__ +=\"\\n\"\n   wrapper.__doc__ +=\"\\n.. deprecated:: %s\\n\"%(txt,)\n  if is_classmethod:\n   wrapper=classmethod(wrapper)\n  return wrapper\n return build\n \ndef deprecated_method(msg=None ,deprecated=None ,removed=None ,updoc=True ,\nreplacement=None ):\n ''\n\n\n\n\n\n\n \n return deprecated_function(msg,deprecated,removed,updoc,replacement,\n _is_method=True )\n \n \n \n \n", ["__future__", "functools", "logging", "passlib.utils.compat", "types", "warnings"]], "passlib.utils.des": [".py", "''\n\n\n\n\n\n\n\nfrom warnings import warn\nwarn(\"the 'passlib.utils.des' module has been relocated to 'passlib.crypto.des' \"\n\"as of passlib 1.7, and the old location will be removed in passlib 2.0\",\nDeprecationWarning)\n\n\n\n\nfrom passlib.utils.decor import deprecated_function\nfrom passlib.crypto.des import expand_des_key,des_encrypt_block,des_encrypt_int_block\n\nexpand_des_key=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.expand_des_key\")(expand_des_key)\n\ndes_encrypt_block=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.des_encrypt_block\")(des_encrypt_block)\n\ndes_encrypt_int_block=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.des_encrypt_int_block\")(des_encrypt_int_block)\n\n\n\n\nimport struct\n_unpack_uint64=struct.Struct(\">Q\").unpack\n\n@deprecated_function(deprecated=\"1.6\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.des_encrypt_int_block()\")\ndef mdes_encrypt_int_block(key,input,salt=0,rounds=1):\n if isinstance(key,bytes):\n  if len(key)==7:\n   key=expand_des_key(key)\n  key=_unpack_uint64(key)[0]\n return des_encrypt_int_block(key,input,salt,rounds)\n \n \n \n \n", ["passlib.crypto.des", "passlib.utils.decor", "struct", "warnings"]], "passlib.utils.compat._ordered_dict": [".py", "''\n\n\n\n\n\n\ntry :\n from thread import get_ident as _get_ident\nexcept ImportError:\n from dummy_thread import get_ident as _get_ident\n \nclass OrderedDict(dict):\n ''\n \n \n \n \n \n \n \n \n \n \n def __init__(self,*args,**kwds):\n  ''\n\n\n\n  \n  if len(args)>1:\n   raise TypeError('expected at most 1 arguments, got %d'%len(args))\n  try :\n   self.__root\n  except AttributeError:\n   self.__root=root=[]\n   root[:]=[root,root,None ]\n   self.__map={}\n  self.__update(*args,**kwds)\n  \n def __setitem__(self,key,value,dict_setitem=dict.__setitem__):\n  ''\n  \n  \n  if key not in self:\n   root=self.__root\n   last=root[0]\n   last[1]=root[0]=self.__map[key]=[last,root,key]\n  dict_setitem(self,key,value)\n  \n def __delitem__(self,key,dict_delitem=dict.__delitem__):\n  ''\n  \n  \n  dict_delitem(self,key)\n  link_prev,link_next,key=self.__map.pop(key)\n  link_prev[1]=link_next\n  link_next[0]=link_prev\n  \n def __iter__(self):\n  ''\n  root=self.__root\n  curr=root[1]\n  while curr is not root:\n   yield curr[2]\n   curr=curr[1]\n   \n def __reversed__(self):\n  ''\n  root=self.__root\n  curr=root[0]\n  while curr is not root:\n   yield curr[2]\n   curr=curr[0]\n   \n def clear(self):\n  ''\n  try :\n   for node in self.__map.itervalues():\n    del node[:]\n   root=self.__root\n   root[:]=[root,root,None ]\n   self.__map.clear()\n  except AttributeError:\n   pass\n  dict.clear(self)\n  \n def popitem(self,last=True ):\n  ''\n\n\n  \n  if not self:\n   raise KeyError('dictionary is empty')\n  root=self.__root\n  if last:\n   link=root[0]\n   link_prev=link[0]\n   link_prev[1]=root\n   root[0]=link_prev\n  else :\n   link=root[1]\n   link_next=link[1]\n   root[1]=link_next\n   link_next[0]=root\n  key=link[2]\n  del self.__map[key]\n  value=dict.pop(self,key)\n  return key,value\n  \n  \n  \n def keys(self):\n  ''\n  return list(self)\n  \n def values(self):\n  ''\n  return [self[key]for key in self]\n  \n def items(self):\n  ''\n  return [(key,self[key])for key in self]\n  \n def iterkeys(self):\n  ''\n  return iter(self)\n  \n def itervalues(self):\n  ''\n  for k in self:\n   yield self[k]\n   \n def iteritems(self):\n  ''\n  for k in self:\n   yield (k,self[k])\n   \n def update(*args,**kwds):\n  ''\n\n\n\n\n\n\n  \n  if len(args)>2:\n   raise TypeError('update() takes at most 2 positional '\n   'arguments (%d given)'%(len(args),))\n  elif not args:\n   raise TypeError('update() takes at least 1 argument (0 given)')\n  self=args[0]\n  \n  other=()\n  if len(args)==2:\n   other=args[1]\n  if isinstance(other,dict):\n   for key in other:\n    self[key]=other[key]\n  elif hasattr(other,'keys'):\n   for key in other.keys():\n    self[key]=other[key]\n  else :\n   for key,value in other:\n    self[key]=value\n  for key,value in kwds.items():\n   self[key]=value\n   \n __update=update\n \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n\n  \n  if key in self:\n   result=self[key]\n   del self[key]\n   return result\n  if default is self.__marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self,key,default=None ):\n  ''\n  if key in self:\n   return self[key]\n  self[key]=default\n  return default\n  \n def __repr__(self,_repr_running={}):\n  ''\n  call_key=id(self),_get_ident()\n  if call_key in _repr_running:\n   return '...'\n  _repr_running[call_key]=1\n  try :\n   if not self:\n    return '%s()'%(self.__class__.__name__,)\n   return '%s(%r)'%(self.__class__.__name__,self.items())\n  finally :\n   del _repr_running[call_key]\n   \n def __reduce__(self):\n  ''\n  items=[[k,self[k]]for k in self]\n  inst_dict=vars(self).copy()\n  for k in vars(OrderedDict()):\n   inst_dict.pop(k,None )\n  if inst_dict:\n   return (self.__class__,(items,),inst_dict)\n  return self.__class__,(items,)\n  \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  ''\n\n\n  \n  d=cls()\n  for key in iterable:\n   d[key]=value\n  return d\n  \n def __eq__(self,other):\n  ''\n\n\n  \n  if isinstance(other,OrderedDict):\n   return len(self)==len(other)and self.items()==other.items()\n  return dict.__eq__(self,other)\n  \n def __ne__(self,other):\n  return not self ==other\n", ["dummy_thread", "thread"]], "passlib.utils.compat": [".py", "''\n\n\n\n\n\n\n\nimport sys\nPY2=sys.version_info <(3,0)\nPY3=sys.version_info >=(3,0)\n\n\nif sys.version_info <(2,6)or (3,0)<=sys.version_info <(3,2):\n raise RuntimeError(\"Passlib requires Python 2.6, 2.7, or >= 3.2 (as of passlib 1.7)\")\n \nPY26=sys.version_info <(2,7)\n\n\n\n\nJYTHON=sys.platform.startswith('java')\n\nPYPY=hasattr(sys,\"pypy_version_info\")\n\nif PYPY and sys.pypy_version_info <(2,0):\n raise RuntimeError(\"passlib requires pypy >= 2.0 (as of passlib 1.7)\")\n \n \n \nPYSTON=\"Pyston\"in sys.version\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nif PY3:\n import builtins\nelse :\n import __builtin__ as builtins\n \ndef add_doc(obj,doc):\n ''\n obj.__doc__=doc\n \n \n \n \n__all__=[\n\n'PY2','PY3','PY26',\n\n\n'BytesIO','StringIO','NativeStringIO','SafeConfigParser',\n'print_',\n\n\n\n'int_types',\n'num_types',\n'unicode_or_bytes_types',\n'native_string_types',\n\n\n'u',\n'unicode',\n'uascii_to_str','bascii_to_str',\n'str_to_uascii','str_to_bascii',\n'join_unicode','join_bytes',\n'join_byte_values','join_byte_elems',\n'byte_elem_value',\n'iter_byte_values',\n\n\n'irange',\n'imap','lmap',\n'iteritems','itervalues',\n'next',\n\n\n'OrderedDict',\n\n\n'nullcontext',\n\n\n'get_method_function','add_doc',\n]\n\n\n\n_lazy_attrs=dict()\n\n\n\n\nif PY3:\n unicode=str\n \n \n def u(s):\n  assert isinstance(s,str)\n  return s\n  \n unicode_or_bytes_types=(str,bytes)\n native_string_types=(unicode,)\n \nelse :\n unicode=builtins.unicode\n \n def u(s):\n  assert isinstance(s,str)\n  return s.decode(\"unicode_escape\")\n  \n unicode_or_bytes_types=(basestring,)\n native_string_types=(basestring,)\n \n \nunicode_or_bytes=unicode_or_bytes_types\nunicode_or_str=native_string_types\n\n\n\n\n\n\n\n\n\n\njoin_unicode=u('').join\n\n\njoin_bytes=b''.join\n\nif PY3:\n def uascii_to_str(s):\n  assert isinstance(s,unicode)\n  return s\n  \n def bascii_to_str(s):\n  assert isinstance(s,bytes)\n  return s.decode(\"ascii\")\n  \n def str_to_uascii(s):\n  assert isinstance(s,str)\n  return s\n  \n def str_to_bascii(s):\n  assert isinstance(s,str)\n  return s.encode(\"ascii\")\n  \n join_byte_values=join_byte_elems=bytes\n \n def byte_elem_value(elem):\n  assert isinstance(elem,int)\n  return elem\n  \n def iter_byte_values(s):\n  assert isinstance(s,bytes)\n  return s\n  \n def iter_byte_chars(s):\n  assert isinstance(s,bytes)\n  \n  return (bytes([c])for c in s)\n  \nelse :\n def uascii_to_str(s):\n  assert isinstance(s,unicode)\n  return s.encode(\"ascii\")\n  \n def bascii_to_str(s):\n  assert isinstance(s,bytes)\n  return s\n  \n def str_to_uascii(s):\n  assert isinstance(s,str)\n  return s.decode(\"ascii\")\n  \n def str_to_bascii(s):\n  assert isinstance(s,str)\n  return s\n  \n def join_byte_values(values):\n  return join_bytes(chr(v)for v in values)\n  \n join_byte_elems=join_bytes\n \n byte_elem_value=ord\n \n def iter_byte_values(s):\n  assert isinstance(s,bytes)\n  return (ord(c)for c in s)\n  \n def iter_byte_chars(s):\n  assert isinstance(s,bytes)\n  return s\n  \nadd_doc(uascii_to_str,\"helper to convert ascii unicode -> native str\")\nadd_doc(bascii_to_str,\"helper to convert ascii bytes -> native str\")\nadd_doc(str_to_uascii,\"helper to convert ascii native str -> unicode\")\nadd_doc(str_to_bascii,\"helper to convert ascii native str -> bytes\")\n\n\n\n\n\n\n\n\n\nadd_doc(iter_byte_values,\"iterate over byte string as sequence of ints 0-255\")\nadd_doc(iter_byte_chars,\"iterate over byte string as sequence of 1-byte strings\")\n\n\n\n\nif PY3:\n int_types=(int,)\n num_types=(int,float)\nelse :\n int_types=(int,long)\n num_types=(int,long,float)\n \n \n \n \n \n \n \n \n \n \nif PY3:\n irange=range\n \n \n \n def lmap(*a,**k):\n  return list(map(*a,**k))\n imap=map\n \n def iteritems(d):\n  return d.items()\n def itervalues(d):\n  return d.values()\n  \n def nextgetter(obj):\n  return obj.__next__\n  \n izip=zip\n \nelse :\n irange=xrange\n \n \n lmap=map\n from itertools import imap,izip\n \n def iteritems(d):\n  return d.iteritems()\n def itervalues(d):\n  return d.itervalues()\n  \n def nextgetter(obj):\n  return obj.next\n  \nadd_doc(nextgetter,\"return function that yields successive values from iterable\")\n\n\n\n\n\n\n\n\n\n\n\nif PY3:\n method_function_attr=\"__func__\"\nelse :\n method_function_attr=\"im_func\"\n \ndef get_method_function(func):\n ''\n return getattr(func,method_function_attr,func)\n \ndef get_unbound_method_function(func):\n ''\n return func if PY3 else func.__func__\n \ndef error_from(exc,\ncause=None ):\n ''\n\n\n\n \n exc.__cause__=cause\n exc.__suppress_context__=True\n return exc\n \n \nsuppress_cause=error_from\n\n\n\n\nif PY3:\n _lazy_attrs=dict(\n BytesIO=\"io.BytesIO\",\n UnicodeIO=\"io.StringIO\",\n NativeStringIO=\"io.StringIO\",\n SafeConfigParser=\"configparser.ConfigParser\",\n )\n \n print_=getattr(builtins,\"print\")\n \nelse :\n _lazy_attrs=dict(\n BytesIO=\"cStringIO.StringIO\",\n UnicodeIO=\"StringIO.StringIO\",\n NativeStringIO=\"cStringIO.StringIO\",\n SafeConfigParser=\"ConfigParser.SafeConfigParser\",\n )\n \n def print_(*args,**kwds):\n  ''\n  \n  fp=kwds.pop(\"file\",sys.stdout)\n  sep=kwds.pop(\"sep\",None )\n  end=kwds.pop(\"end\",None )\n  if kwds:\n   raise TypeError(\"invalid keyword arguments\")\n   \n   \n  if fp is None :\n   return\n   \n   \n  want_unicode=isinstance(sep,unicode)or isinstance(end,unicode)or\\\n  any(isinstance(arg,unicode)for arg in args)\n  \n  \n  if end is None :\n   end=u(\"\\n\")if want_unicode else \"\\n\"\n  elif not isinstance(end,unicode_or_bytes_types):\n   raise TypeError(\"end must be None or a string\")\n   \n   \n  if sep is None :\n   sep=u(\" \")if want_unicode else \" \"\n  elif not isinstance(sep,unicode_or_bytes_types):\n   raise TypeError(\"sep must be None or a string\")\n   \n   \n  first=True\n  write=fp.write\n  for arg in args:\n   if first:\n    first=False\n   else :\n    write(sep)\n   if not isinstance(arg,basestring):\n    arg=str(arg)\n   write(arg)\n  write(end)\n  \n  \n  \n  \nif PY26:\n _lazy_attrs['OrderedDict']='passlib.utils.compat._ordered_dict.OrderedDict'\nelse :\n _lazy_attrs['OrderedDict']='collections.OrderedDict'\n \n \n \n \n \ntry :\n\n from contextlib import nullcontext\nexcept ImportError:\n\n class nullcontext(object):\n  ''\n\n  \n  def __init__(self,enter_result=None ):\n   self.enter_result=enter_result\n   \n  def __enter__(self):\n   return self.enter_result\n   \n  def __exit__(self,*exc_info):\n   pass\n   \n   \n   \n   \nfrom types import ModuleType\n\ndef _import_object(source):\n ''\n modname,modattr=source.rsplit(\".\",1)\n mod=__import__(modname,fromlist=[modattr],level=0)\n return getattr(mod,modattr)\n \nclass _LazyOverlayModule(ModuleType):\n ''\n\n\n\n\n\n\n\n\n \n \n @classmethod\n def replace_module(cls,name,attrmap):\n  orig=sys.modules[name]\n  self=cls(name,attrmap,orig)\n  sys.modules[name]=self\n  return self\n  \n def __init__(self,name,attrmap,proxy=None ):\n  ModuleType.__init__(self,name)\n  self.__attrmap=attrmap\n  self.__proxy=proxy\n  self.__log=logging.getLogger(name)\n  \n def __getattr__(self,attr):\n  proxy=self.__proxy\n  if proxy and hasattr(proxy,attr):\n   return getattr(proxy,attr)\n  attrmap=self.__attrmap\n  if attr in attrmap:\n   source=attrmap[attr]\n   if callable(source):\n    value=source()\n   else :\n    value=_import_object(source)\n   setattr(self,attr,value)\n   self.__log.debug(\"loaded lazy attr %r: %r\",attr,value)\n   return value\n  raise AttributeError(\"'module' object has no attribute '%s'\"%(attr,))\n  \n def __repr__(self):\n  proxy=self.__proxy\n  if proxy:\n   return repr(proxy)\n  else :\n   return ModuleType.__repr__(self)\n   \n def __dir__(self):\n  attrs=set(dir(self.__class__))\n  attrs.update(self.__dict__)\n  attrs.update(self.__attrmap)\n  proxy=self.__proxy\n  if proxy is not None :\n   attrs.update(dir(proxy))\n  return list(attrs)\n  \n  \n_LazyOverlayModule.replace_module(__name__,_lazy_attrs)\n\n\n\n\n", ["__builtin__", "builtins", "contextlib", "itertools", "logging", "sys", "types"], 1], "passlib.Lib.site-packages.passlib.totp": [".py", "''\n\n\n\nfrom __future__ import absolute_import,division,print_function\nfrom passlib.utils.compat import PY3\n\nimport base64\nimport calendar\nimport json\nimport logging ;log=logging.getLogger(__name__)\nimport math\nimport struct\nimport sys\nimport time as _time\nimport re\nif PY3:\n from urllib.parse import urlparse,parse_qsl,quote,unquote\nelse :\n from urllib import quote,unquote\n from urlparse import urlparse,parse_qsl\nfrom warnings import warn\n\ntry :\n\n from cryptography.hazmat.backends import default_backend as _cg_default_backend\n import cryptography.hazmat.primitives.ciphers.algorithms\n import cryptography.hazmat.primitives.ciphers.modes\n from cryptography.hazmat.primitives import ciphers as _cg_ciphers\n del cryptography\nexcept ImportError:\n log.debug(\"can't import 'cryptography' package, totp encryption disabled\")\n _cg_ciphers=_cg_default_backend=None\n \nfrom passlib import exc\nfrom passlib.exc import TokenError,MalformedTokenError,InvalidTokenError,UsedTokenError\nfrom passlib.utils import (to_unicode,to_bytes,consteq,\ngetrandbytes,rng,SequenceMixin,xor_bytes,getrandstr)\nfrom passlib.utils.binary import BASE64_CHARS,b32encode,b32decode\nfrom passlib.utils.compat import (u,unicode,native_string_types,bascii_to_str,int_types,num_types,\nirange,byte_elem_value,UnicodeIO,suppress_cause)\nfrom passlib.utils.decor import hybrid_method,memoized_property\nfrom passlib.crypto.digest import lookup_hash,compile_hmac,pbkdf2_hmac\nfrom passlib.hash import pbkdf2_sha256\n\n__all__=[\n\n\"AppWallet\",\n\"TOTP\",\n\n\n\"TokenError\",\n\"MalformedTokenError\",\n\"InvalidTokenError\",\n\"UsedTokenError\",\n\n\n\"TotpToken\",\n\"TotpMatch\",\n]\n\n\n\n\n\n\n\n\nif sys.version_info <(2,7,4):\n from urlparse import uses_query\n if \"otpauth\"not in uses_query:\n  uses_query.append(\"otpauth\")\n  log.debug(\"registered 'otpauth' scheme with urlparse.uses_query\")\n del uses_query\n \n \n \n \n \n \n \n \n \n \n_clean_re=re.compile(u(r\"\\s|[-=]\"),re.U)\n\n_chunk_sizes=[4,6,5]\n\ndef _get_group_size(klen):\n ''\n\n\n \n \n for size in _chunk_sizes:\n  if not klen %size:\n   return size\n   \n   \n best=_chunk_sizes[0]\n rem=0\n for size in _chunk_sizes:\n  if klen %size >rem:\n   best=size\n   rem=klen %size\n return best\n \ndef group_string(value,sep=\"-\"):\n ''\n\n\n \n klen=len(value)\n size=_get_group_size(klen)\n return sep.join(value[o:o+size]for o in irange(0,klen,size))\n \n \n \n \n \ndef _decode_bytes(key,format):\n ''\n\n\n \n if format ==\"raw\":\n  if not isinstance(key,bytes):\n   raise exc.ExpectedTypeError(key,\"bytes\",\"key\")\n  return key\n  \n  \n key=to_unicode(key,param=\"key\")\n key=_clean_re.sub(\"\",key).encode(\"utf-8\")\n if format ==\"hex\"or format ==\"base16\":\n  return base64.b16decode(key.upper())\n elif format ==\"base32\":\n  return b32decode(key)\n  \n else :\n  raise ValueError(\"unknown byte-encoding format: %r\"%(format,))\n  \n  \n  \n  \n  \n  \nAES_SUPPORT=bool(_cg_ciphers)\n\n\n_tag_re=re.compile(\"(?i)^[a-z0-9][a-z0-9_.-]*$\")\n\nclass AppWallet(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n salt_size=12\n \n \n \n \n encrypt_cost=14\n \n \n _secrets=None\n \n \n default_tag=None\n \n \n \n \n def __init__(self,secrets=None ,default_tag=None ,encrypt_cost=None ,\n secrets_path=None ):\n \n \n \n \n \n \n \n  if encrypt_cost is not None :\n   if isinstance(encrypt_cost,native_string_types):\n    encrypt_cost=int(encrypt_cost)\n   assert encrypt_cost >=0\n   self.encrypt_cost=encrypt_cost\n   \n   \n   \n   \n   \n   \n  if secrets_path is not None :\n   if secrets is not None :\n    raise TypeError(\"'secrets' and 'secrets_path' are mutually exclusive\")\n   secrets=open(secrets_path,\"rt\").read()\n   \n   \n  secrets=self._secrets=self._parse_secrets(secrets)\n  \n  \n  \n  \n  if secrets:\n   if default_tag is not None :\n   \n    self.get_secret(default_tag)\n   elif all(tag.isdigit()for tag in secrets):\n    default_tag=max(secrets,key=int)\n   else :\n    default_tag=max(secrets)\n   self.default_tag=default_tag\n   \n def _parse_secrets(self,source):\n  ''\n\n\n\n\n  \n  \n  \n  \n  check_type=True\n  if isinstance(source,native_string_types):\n   if source.lstrip().startswith((\"[\",\"{\")):\n   \n    source=json.loads(source)\n   elif \"\\n\"in source and \":\"in source:\n   \n   \n    def iter_pairs(source):\n     for line in source.splitlines():\n      line=line.strip()\n      if line and not line.startswith(\"#\"):\n       tag,secret=line.split(\":\",1)\n       yield tag.strip(),secret.strip()\n    source=iter_pairs(source)\n    check_type=False\n   else :\n    raise ValueError(\"unrecognized secrets string format\")\n    \n    \n  if source is None :\n   return {}\n  elif isinstance(source,dict):\n   source=source.items()\n   \n   \n  elif check_type:\n   raise TypeError(\"'secrets' must be mapping, or list of items\")\n   \n   \n  return dict(self._parse_secret_pair(tag,value)\n  for tag,value in source)\n  \n def _parse_secret_pair(self,tag,value):\n  if isinstance(tag,native_string_types):\n   pass\n  elif isinstance(tag,int):\n   tag=str(tag)\n  else :\n   raise TypeError(\"tag must be unicode/string: %r\"%(tag,))\n  if not _tag_re.match(tag):\n   raise ValueError(\"tag contains invalid characters: %r\"%(tag,))\n  if not isinstance(value,bytes):\n   value=to_bytes(value,param=\"secret %r\"%(tag,))\n  if not value:\n   raise ValueError(\"tag contains empty secret: %r\"%(tag,))\n  return tag,value\n  \n  \n  \n  \n  \n @property\n def has_secrets(self):\n  ''\n  return self.default_tag is not None\n  \n def get_secret(self,tag):\n  ''\n\n\n  \n  secrets=self._secrets\n  if not secrets:\n   raise KeyError(\"no application secrets configured\")\n  try :\n   return secrets[tag]\n  except KeyError:\n   raise suppress_cause(KeyError(\"unknown secret tag: %r\"%(tag,)))\n   \n   \n   \n   \n   \n @staticmethod\n def _cipher_aes_key(value,secret,salt,cost,decrypt=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if _cg_ciphers is None :\n   raise RuntimeError(\"TOTP encryption requires 'cryptography' package \"\n   \"(https://cryptography.io)\")\n   \n   \n   \n  keyiv=pbkdf2_hmac(\"sha256\",secret,salt=salt,rounds=(1 <<cost),keylen=48)\n  \n  \n  cipher=_cg_ciphers.Cipher(_cg_ciphers.algorithms.AES(keyiv[:32]),\n  _cg_ciphers.modes.CTR(keyiv[32:]),\n  _cg_default_backend())\n  ctx=cipher.decryptor()if decrypt else cipher.encryptor()\n  return ctx.update(value)+ctx.finalize()\n  \n def encrypt_key(self,key):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not key:\n   raise ValueError(\"no key provided\")\n  salt=getrandbytes(rng,self.salt_size)\n  cost=self.encrypt_cost\n  tag=self.default_tag\n  if not tag:\n   raise TypeError(\"no application secrets configured, can't encrypt OTP key\")\n  ckey=self._cipher_aes_key(key,self.get_secret(tag),salt,cost)\n  \n  return dict(v=1,c=cost,t=tag,s=b32encode(salt),k=b32encode(ckey))\n  \n def decrypt_key(self,enckey):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(enckey,dict):\n   raise TypeError(\"'enckey' must be dictionary\")\n  version=enckey.get(\"v\",None )\n  needs_recrypt=False\n  if version ==1:\n   _cipher_key=self._cipher_aes_key\n  else :\n   raise ValueError(\"missing / unrecognized 'enckey' version: %r\"%(version,))\n  tag=enckey['t']\n  cost=enckey['c']\n  key=_cipher_key(\n  value=b32decode(enckey['k']),\n  secret=self.get_secret(tag),\n  salt=b32decode(enckey['s']),\n  cost=cost,\n  )\n  if cost !=self.encrypt_cost or tag !=self.default_tag:\n   needs_recrypt=True\n  return key,needs_recrypt\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_pack_uint64=struct.Struct(\">Q\").pack\n\n\n_unpack_uint32=struct.Struct(\">I\").unpack\n\n\n_DUMMY_KEY=b\"\\x00\"*16\n\nclass TOTP(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n _min_key_size=10\n \n \n min_json_version=json_version=1\n \n \n \n wallet=None\n \n \n \n now=_time.time\n \n \n \n \n \n \n \n \n \n \n \n _key=None\n \n \n \n _encrypted_key=None\n \n \n \n \n _keyed_hmac=None\n \n \n digits=6\n \n \n alg=\"sha1\"\n \n \n label=None\n \n \n issuer=None\n \n \n \n \n period=30\n \n \n \n \n \n \n \n \n changed=False\n \n \n \n \n @classmethod\n def using(cls,digits=None ,alg=None ,period=None ,\n issuer=None ,wallet=None ,now=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  subcls=type(\"TOTP\",(cls,),{})\n  \n  def norm_param(attr,value):\n   ''\n\n\n   \n   \n   \n   \n   kwds=dict(key=_DUMMY_KEY,format=\"raw\")\n   kwds[attr]=value\n   obj=subcls(**kwds)\n   return getattr(obj,attr)\n   \n  if digits is not None :\n   subcls.digits=norm_param(\"digits\",digits)\n   \n  if alg is not None :\n   subcls.alg=norm_param(\"alg\",alg)\n   \n  if period is not None :\n   subcls.period=norm_param(\"period\",period)\n   \n   \n   \n  if issuer is not None :\n   subcls.issuer=norm_param(\"issuer\",issuer)\n   \n  if kwds:\n   subcls.wallet=AppWallet(**kwds)\n   if wallet:\n    raise TypeError(\"'wallet' and 'secrets' keywords are mutually exclusive\")\n  elif wallet is not None :\n   if not isinstance(wallet,AppWallet):\n    raise exc.ExpectedTypeError(wallet,AppWallet,\"wallet\")\n   subcls.wallet=wallet\n   \n  if now is not None :\n   assert isinstance(now(),num_types)and now()>=0,\\\n   \"now() function must return non-negative int/float\"\n   subcls.now=staticmethod(now)\n   \n  return subcls\n  \n  \n  \n  \n  \n @classmethod\n def new(cls,**kwds):\n  ''\n\n  \n  return cls(new=True ,**kwds)\n  \n def __init__(self,key=None ,format=\"base32\",\n \n new=False ,digits=None ,alg=None ,size=None ,period=None ,\n label=None ,issuer=None ,changed=False ,\n **kwds):\n  super(TOTP,self).__init__(**kwds)\n  if changed:\n   self.changed=changed\n   \n   \n  info=lookup_hash(alg or self.alg)\n  self.alg=info.name\n  digest_size=info.digest_size\n  if digest_size <4:\n   raise RuntimeError(\"%r hash digest too small\"%alg)\n   \n   \n  if new:\n  \n   if key:\n    raise TypeError(\"'key' and 'new=True' are mutually exclusive\")\n   if size is None :\n   \n    size=digest_size\n   elif size >digest_size:\n   \n   \n    raise ValueError(\"'size' should be less than digest size \"\n    \"(%d)\"%digest_size)\n   self.key=getrandbytes(rng,size)\n  elif not key:\n   raise TypeError(\"must specify either an existing 'key', or 'new=True'\")\n  elif format ==\"encrypted\":\n  \n   self.encrypted_key=key\n  elif key:\n  \n   self.key=_decode_bytes(key,format)\n   \n   \n  if len(self.key)<self._min_key_size:\n  \n  \n   msg=\"for security purposes, secret key must be >= %d bytes\"%self._min_key_size\n   if new:\n    raise ValueError(msg)\n   else :\n    warn(msg,exc.PasslibSecurityWarning,stacklevel=1)\n    \n    \n  if digits is None :\n   digits=self.digits\n  if not isinstance(digits,int_types):\n   raise TypeError(\"digits must be an integer, not a %r\"%type(digits))\n  if digits <6 or digits >10:\n   raise ValueError(\"digits must in range(6,11)\")\n  self.digits=digits\n  \n  \n  if label:\n   self._check_label(label)\n   self.label=label\n   \n   \n  if issuer:\n   self._check_issuer(issuer)\n   self.issuer=issuer\n   \n   \n  if period is not None :\n   self._check_serial(period,\"period\",minval=1)\n   self.period=period\n   \n   \n   \n   \n   \n @staticmethod\n def _check_serial(value,param,minval=0):\n  ''\n\n  \n  if not isinstance(value,int_types):\n   raise exc.ExpectedTypeError(value,\"int\",param)\n  if value <minval:\n   raise ValueError(\"%s must be >= %d\"%(param,minval))\n   \n @staticmethod\n def _check_label(label):\n  ''\n\n  \n  if label and \":\"in label:\n   raise ValueError(\"label may not contain ':'\")\n   \n @staticmethod\n def _check_issuer(issuer):\n  ''\n\n  \n  if issuer and \":\"in issuer:\n   raise ValueError(\"issuer may not contain ':'\")\n   \n   \n   \n   \n   \n   \n   \n   \n @property\n def key(self):\n  ''\n\n  \n  return self._key\n  \n @key.setter\n def key(self,value):\n \n  if not isinstance(value,bytes):\n   raise exc.ExpectedTypeError(value,bytes,\"key\")\n  self._key=value\n  \n  \n  self._encrypted_key=self._keyed_hmac=None\n  \n  \n  \n  \n @property\n def encrypted_key(self):\n  ''\n\n\n\n  \n  enckey=self._encrypted_key\n  if enckey is None :\n   wallet=self.wallet\n   if not wallet:\n    raise TypeError(\"no application secrets present, can't encrypt TOTP key\")\n   enckey=self._encrypted_key=wallet.encrypt_key(self.key)\n  return enckey\n  \n @encrypted_key.setter\n def encrypted_key(self,value):\n  wallet=self.wallet\n  if not wallet:\n   raise TypeError(\"no application secrets present, can't decrypt TOTP key\")\n  self.key,needs_recrypt=wallet.decrypt_key(value)\n  if needs_recrypt:\n  \n   self.changed=True\n  else :\n  \n   self._encrypted_key=value\n   \n   \n   \n   \n   \n @property\n def hex_key(self):\n  ''\n\n  \n  return bascii_to_str(base64.b16encode(self.key)).lower()\n  \n @property\n def base32_key(self):\n  ''\n\n  \n  return b32encode(self.key)\n  \n def pretty_key(self,format=\"base32\",sep=\"-\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if format ==\"hex\"or format ==\"base16\":\n   key=self.hex_key\n  elif format ==\"base32\":\n   key=self.base32_key\n  else :\n   raise ValueError(\"unknown byte-encoding format: %r\"%(format,))\n  if sep:\n   key=group_string(key,sep)\n  return key\n  \n  \n  \n  \n  \n @classmethod\n def normalize_time(cls,time):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(time,int_types):\n   return time\n  elif isinstance(time,float):\n   return int(time)\n  elif time is None :\n   return int(cls.now())\n  elif hasattr(time,\"utctimetuple\"):\n  \n  \n  \n   return calendar.timegm(time.utctimetuple())\n  else :\n   raise exc.ExpectedTypeError(time,\"int, float, or datetime\",\"time\")\n   \n def _time_to_counter(self,time):\n  ''\n\n  \n  return time //self.period\n  \n def _counter_to_time(self,counter):\n  ''\n\n  \n  return counter *self.period\n  \n @hybrid_method\n def normalize_token(self_or_cls,token):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  digits=self_or_cls.digits\n  if isinstance(token,int_types):\n   token=u(\"%0*d\")%(digits,token)\n  else :\n   token=to_unicode(token,param=\"token\")\n   token=_clean_re.sub(u(\"\"),token)\n   if not token.isdigit():\n    raise MalformedTokenError(\"Token must contain only the digits 0-9\")\n  if len(token)!=digits:\n   raise MalformedTokenError(\"Token must have exactly %d digits\"%digits)\n  return token\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def generate(self,time=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  time=self.normalize_time(time)\n  counter=self._time_to_counter(time)\n  if counter <0:\n   raise ValueError(\"timestamp must be >= 0\")\n  token=self._generate(counter)\n  return TotpToken(self,token,counter)\n  \n def _generate(self,counter):\n  ''\n\n\n\n\n  \n  \n  assert isinstance(counter,int_types),\"counter must be integer\"\n  assert counter >=0,\"counter must be non-negative\"\n  keyed_hmac=self._keyed_hmac\n  if keyed_hmac is None :\n   keyed_hmac=self._keyed_hmac=compile_hmac(self.alg,self.key)\n  digest=keyed_hmac(_pack_uint64(counter))\n  digest_size=keyed_hmac.digest_info.digest_size\n  assert len(digest)==digest_size,\"digest_size: sanity check failed\"\n  \n  \n  assert digest_size >=20,\"digest_size: sanity check 2 failed\"\n  offset=byte_elem_value(digest[-1])&0xF\n  value=_unpack_uint32(digest[offset:offset+4])[0]&0x7fffffff\n  \n  \n  \n  \n  \n  digits=self.digits\n  assert 0 <digits <11,\"digits: sanity check failed\"\n  return (u(\"%0*d\")%(digits,value))[-digits:]\n  \n  \n  \n  \n  \n @classmethod\n def verify(cls,token,source,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return cls.from_source(source).match(token,**kwds)\n  \n def match(self,token,time=None ,window=30,skew=0,last_counter=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  time=self.normalize_time(time)\n  self._check_serial(window,\"window\")\n  \n  client_time=time+skew\n  if last_counter is None :\n   last_counter=-1\n  start=max(last_counter,self._time_to_counter(client_time -window))\n  end=self._time_to_counter(client_time+window)+1\n  \n  \n  \n  counter=self._find_match(token,start,end)\n  assert counter >=last_counter,\"sanity check failed: counter went backward\"\n  \n  if counter ==last_counter:\n   raise UsedTokenError(expire_time=(last_counter+1)*self.period)\n   \n   \n   \n   \n   \n  return TotpMatch(self,counter,time,window)\n  \n def _find_match(self,token,start,end,expected=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  token=self.normalize_token(token)\n  if start <0:\n   start=0\n  if end <=start:\n   raise InvalidTokenError()\n  generate=self._generate\n  if not (expected is None or expected <start)and consteq(token,generate(expected)):\n   return expected\n   \n   \n   \n   \n   \n  counter=start\n  while counter <end:\n   if consteq(token,generate(counter)):\n    return counter\n   counter +=1\n  raise InvalidTokenError()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def from_source(cls,source):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(source,TOTP):\n  \n  \n   if cls.wallet ==source.wallet:\n    return source\n   source=source.to_dict(encrypt=False )\n  if isinstance(source,dict):\n   return cls.from_dict(source)\n   \n  source=to_unicode(source,param=\"totp source\")\n  if source.startswith(\"otpauth://\"):\n   return cls.from_uri(source)\n  else :\n   return cls.from_json(source)\n   \n   \n   \n   \n @classmethod\n def from_uri(cls,uri):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  uri=to_unicode(uri,param=\"uri\").strip()\n  result=urlparse(uri)\n  if result.scheme !=\"otpauth\":\n   raise cls._uri_parse_error(\"wrong uri scheme\")\n   \n   \n  cls._check_otp_type(result.netloc)\n  return cls._from_parsed_uri(result)\n  \n @classmethod\n def _check_otp_type(cls,type):\n  ''\n\n\n  \n  if type ==\"totp\":\n   return True\n  if type ==\"hotp\":\n   raise NotImplementedError(\"HOTP not supported\")\n  raise ValueError(\"unknown otp type: %r\"%type)\n  \n @classmethod\n def _from_parsed_uri(cls,result):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  \n  label=result.path\n  if label.startswith(\"/\")and len(label)>1:\n   label=unquote(label[1:])\n  else :\n   raise cls._uri_parse_error(\"missing label\")\n   \n   \n  if \":\"in label:\n   try :\n    issuer,label=label.split(\":\")\n   except ValueError:\n    raise cls._uri_parse_error(\"malformed label\")\n  else :\n   issuer=None\n  if label:\n  \n   label=label.strip()or None\n   \n   \n  params=dict(label=label)\n  for k,v in parse_qsl(result.query):\n   if k in params:\n    raise cls._uri_parse_error(\"duplicate parameter (%r)\"%k)\n   params[k]=v\n   \n   \n  if issuer:\n   if \"issuer\"not in params:\n    params['issuer']=issuer\n   elif params['issuer']!=issuer:\n    raise cls._uri_parse_error(\"conflicting issuer identifiers\")\n    \n    \n  return cls(**cls._adapt_uri_params(**params))\n  \n @classmethod\n def _adapt_uri_params(cls,label=None ,secret=None ,issuer=None ,\n digits=None ,algorithm=None ,period=None ,\n **extra):\n  ''\n\n\n  \n  assert label,\"from_uri() failed to provide label\"\n  if not secret:\n   raise cls._uri_parse_error(\"missing 'secret' parameter\")\n  kwds=dict(label=label,issuer=issuer,key=secret,format=\"base32\")\n  if digits:\n   kwds['digits']=cls._uri_parse_int(digits,\"digits\")\n  if algorithm:\n   kwds['alg']=algorithm\n  if period:\n   kwds['period']=cls._uri_parse_int(period,\"period\")\n  if extra:\n  \n  \n   warn(\"%s: unexpected parameters encountered in otp uri: %r\"%\n   (cls,extra),exc.PasslibRuntimeWarning)\n  return kwds\n  \n @staticmethod\n def _uri_parse_error(reason):\n  ''\n  return ValueError(\"Invalid otpauth uri: %s\"%(reason,))\n  \n @classmethod\n def _uri_parse_int(cls,source,param):\n  ''\n  try :\n   return int(source)\n  except ValueError:\n   raise cls._uri_parse_error(\"Malformed %r parameter\"%param)\n   \n   \n   \n   \n def to_uri(self,label=None ,issuer=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if label is None :\n   label=self.label\n  if not label:\n   raise ValueError(\"a label must be specified as argument, or in the constructor\")\n  self._check_label(label)\n  \n  \n  \n  label=quote(label,'@')\n  \n  \n  params=self._to_uri_params()\n  if issuer is None :\n   issuer=self.issuer\n  if issuer:\n   self._check_issuer(issuer)\n   \n   \n   \n   \n   label=\"%s:%s\"%(quote(issuer,'@'),label)\n   params.append((\"issuer\",issuer))\n   \n   \n   \n  param_str=u(\"&\").join(u(\"%s=%s\")%(key,quote(value,''))for key,value in params)\n  assert param_str,\"param_str should never be empty\"\n  \n  \n  return u(\"otpauth://totp/%s?%s\")%(label,param_str)\n  \n def _to_uri_params(self):\n  ''\n  args=[(\"secret\",self.base32_key)]\n  if self.alg !=\"sha1\":\n   args.append((\"algorithm\",self.alg.upper()))\n  if self.digits !=6:\n   args.append((\"digits\",str(self.digits)))\n  if self.period !=30:\n   args.append((\"period\",str(self.period)))\n  return args\n  \n  \n  \n  \n  \n @classmethod\n def from_json(cls,source):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  source=to_unicode(source,param=\"json source\")\n  return cls.from_dict(json.loads(source))\n  \n def to_json(self,encrypt=None ):\n  ''\n\n\n\n\n\n\n  \n  state=self.to_dict(encrypt=encrypt)\n  return json.dumps(state,sort_keys=True ,separators=(\",\",\":\"))\n  \n  \n  \n  \n  \n @classmethod\n def from_dict(cls,source):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(source,dict)or \"type\"not in source:\n   raise cls._dict_parse_error(\"unrecognized format\")\n  return cls(**cls._adapt_dict_kwds(**source))\n  \n @classmethod\n def _adapt_dict_kwds(cls,type,**kwds):\n  ''\n\n\n  \n  \n  \n  \n  assert cls._check_otp_type(type)\n  ver=kwds.pop(\"v\",None )\n  if not ver or ver <cls.min_json_version or ver >cls.json_version:\n   raise cls._dict_parse_error(\"missing/unsupported version (%r)\"%(ver,))\n  elif ver !=cls.json_version:\n  \n   kwds['changed']=True\n  if 'enckey'in kwds:\n  \n  \n  \n  \n  \n   assert 'key'not in kwds\n   kwds.update(key=kwds.pop(\"enckey\"),format=\"encrypted\")\n  elif 'key'not in kwds:\n   raise cls._dict_parse_error(\"missing 'enckey' / 'key'\")\n   \n   \n  kwds.pop(\"last_counter\",None )\n  return kwds\n  \n @staticmethod\n def _dict_parse_error(reason):\n  ''\n  return ValueError(\"Invalid totp data: %s\"%(reason,))\n  \n def to_dict(self,encrypt=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  state=dict(v=self.json_version,type=\"totp\")\n  if self.alg !=\"sha1\":\n   state['alg']=self.alg\n  if self.digits !=6:\n   state['digits']=self.digits\n  if self.period !=30:\n   state['period']=self.period\n   \n  if self.label:\n   state['label']=self.label\n  issuer=self.issuer\n  if issuer and issuer !=type(self).issuer:\n  \n   state['issuer']=issuer\n  if encrypt is None :\n   wallet=self.wallet\n   encrypt=wallet and wallet.has_secrets\n  if encrypt:\n   state['enckey']=self.encrypted_key\n  else :\n   state['key']=self.base32_key\n   \n   \n   \n   \n  return state\n  \n  \n  \n  \n  \n  \n  \n  \nclass TotpToken(SequenceMixin):\n ''\n\n\n\n\n\n\n\n\n\n \n \n totp=None\n \n \n token=None\n \n \n counter=None\n \n def __init__(self,totp,token,counter):\n  ''\n\n\n  \n  self.totp=totp\n  self.token=token\n  self.counter=counter\n  \n @memoized_property\n def start_time(self):\n  ''\n  return self.totp._counter_to_time(self.counter)\n  \n @memoized_property\n def expire_time(self):\n  ''\n  return self.totp._counter_to_time(self.counter+1)\n  \n @property\n def remaining(self):\n  ''\n  return max(0,self.expire_time -self.totp.now())\n  \n @property\n def valid(self):\n  ''\n  return bool(self.remaining)\n  \n def _as_tuple(self):\n  return self.token,self.expire_time\n  \n def __repr__(self):\n  expired=\"\"if self.remaining else \" expired\"\n  return \"<TotpToken token='%s' expire_time=%d%s>\"%\\\n  (self.token,self.expire_time,expired)\n  \n  \nclass TotpMatch(SequenceMixin):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n totp=None\n \n \n \n \n counter=0\n \n \n time=0\n \n \n window=30\n \n def __init__(self,totp,counter,time,window=30):\n  ''\n\n\n  \n  self.totp=totp\n  self.counter=counter\n  self.time=time\n  self.window=window\n  \n @memoized_property\n def expected_counter(self):\n  ''\n\n  \n  return self.totp._time_to_counter(self.time)\n  \n @memoized_property\n def skipped(self):\n  ''\n\n\n  \n  return self.counter -self.expected_counter\n  \n  \n  \n  \n  \n  \n @memoized_property\n def expire_time(self):\n  ''\n  return self.totp._counter_to_time(self.counter+1)\n  \n @memoized_property\n def cache_seconds(self):\n  ''\n\n\n  \n  \n  \n  return self.totp.period+self.window\n  \n @memoized_property\n def cache_time(self):\n  ''\n\n  \n  return self.expire_time+self.window\n  \n def _as_tuple(self):\n  return self.counter,self.time\n  \n def __repr__(self):\n  args=(self.counter,self.time,self.cache_seconds)\n  return \"<TotpMatch counter=%d time=%d cache_seconds=%d>\"%args\n  \n  \n  \n  \n  \ndef generate_secret(entropy=256,charset=BASE64_CHARS[:-2]):\n ''\n\n\n\n\n\n \n assert entropy >0\n assert len(charset)>1\n count=int(math.ceil(entropy *math.log(2,len(charset))))\n return getrandstr(rng,charset,count)\n \n \n \n \n", ["__future__", "base64", "calendar", "cryptography.hazmat.backends", "cryptography.hazmat.primitives", "cryptography.hazmat.primitives.ciphers.algorithms", "cryptography.hazmat.primitives.ciphers.modes", "json", "logging", "math", "passlib", "passlib.crypto.digest", "passlib.exc", "passlib.hash", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "re", "struct", "sys", "time", "urllib", "urllib.parse", "urlparse", "warnings"]], "passlib.Lib.site-packages.passlib.registry": [".py", "''\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\nfrom passlib import exc\nfrom passlib.exc import ExpectedTypeError,PasslibWarning\nfrom passlib.ifc import PasswordHash\nfrom passlib.utils import (\nis_crypt_handler,has_crypt as os_crypt_present,\nunix_crypt_schemes as os_crypt_schemes,\n)\nfrom passlib.utils.compat import unicode_or_str\nfrom passlib.utils.decor import memoize_single_value\n\n__all__=[\n\"register_crypt_handler_path\",\n\"register_crypt_handler\",\n\"get_crypt_handler\",\n\"list_crypt_handlers\",\n]\n\n\n\n\nclass _PasslibRegistryProxy(object):\n ''\n\n\n\n\n \n __name__=\"passlib.hash\"\n __package__=None\n \n def __getattr__(self,attr):\n  if attr.startswith(\"_\"):\n   raise AttributeError(\"missing attribute: %r\"%(attr,))\n  handler=get_crypt_handler(attr,None )\n  if handler:\n   return handler\n  else :\n   raise AttributeError(\"unknown password hash: %r\"%(attr,))\n   \n def __setattr__(self,attr,value):\n  if attr.startswith(\"_\"):\n  \n  \n   object.__setattr__(self,attr,value)\n  else :\n  \n  \n   register_crypt_handler(value,_attr=attr)\n   \n def __repr__(self):\n  return \"<proxy module 'passlib.hash'>\"\n  \n def __dir__(self):\n \n \n  attrs=set(dir(self.__class__))\n  attrs.update(self.__dict__)\n  attrs.update(_locations)\n  return sorted(attrs)\n  \n  \n_proxy=_PasslibRegistryProxy()\n\n\n\n\n\n\n_UNSET=object()\n\n\n_handlers=_proxy.__dict__\n\n\n\n\n_locations=dict(\n\n\napr_md5_crypt=\"passlib.handlers.md5_crypt\",\nargon2=\"passlib.handlers.argon2\",\natlassian_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\nbcrypt=\"passlib.handlers.bcrypt\",\nbcrypt_sha256=\"passlib.handlers.bcrypt\",\nbigcrypt=\"passlib.handlers.des_crypt\",\nbsd_nthash=\"passlib.handlers.windows\",\nbsdi_crypt=\"passlib.handlers.des_crypt\",\ncisco_pix=\"passlib.handlers.cisco\",\ncisco_asa=\"passlib.handlers.cisco\",\ncisco_type7=\"passlib.handlers.cisco\",\ncta_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\ncrypt16=\"passlib.handlers.des_crypt\",\ndes_crypt=\"passlib.handlers.des_crypt\",\ndjango_argon2=\"passlib.handlers.django\",\ndjango_bcrypt=\"passlib.handlers.django\",\ndjango_bcrypt_sha256=\"passlib.handlers.django\",\ndjango_pbkdf2_sha256=\"passlib.handlers.django\",\ndjango_pbkdf2_sha1=\"passlib.handlers.django\",\ndjango_salted_sha1=\"passlib.handlers.django\",\ndjango_salted_md5=\"passlib.handlers.django\",\ndjango_des_crypt=\"passlib.handlers.django\",\ndjango_disabled=\"passlib.handlers.django\",\ndlitz_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\nfshp=\"passlib.handlers.fshp\",\ngrub_pbkdf2_sha512=\"passlib.handlers.pbkdf2\",\nhex_md4=\"passlib.handlers.digests\",\nhex_md5=\"passlib.handlers.digests\",\nhex_sha1=\"passlib.handlers.digests\",\nhex_sha256=\"passlib.handlers.digests\",\nhex_sha512=\"passlib.handlers.digests\",\nhtdigest=\"passlib.handlers.digests\",\nldap_plaintext=\"passlib.handlers.ldap_digests\",\nldap_md5=\"passlib.handlers.ldap_digests\",\nldap_sha1=\"passlib.handlers.ldap_digests\",\nldap_hex_md5=\"passlib.handlers.roundup\",\nldap_hex_sha1=\"passlib.handlers.roundup\",\nldap_salted_md5=\"passlib.handlers.ldap_digests\",\nldap_salted_sha1=\"passlib.handlers.ldap_digests\",\nldap_salted_sha256=\"passlib.handlers.ldap_digests\",\nldap_salted_sha512=\"passlib.handlers.ldap_digests\",\nldap_des_crypt=\"passlib.handlers.ldap_digests\",\nldap_bsdi_crypt=\"passlib.handlers.ldap_digests\",\nldap_md5_crypt=\"passlib.handlers.ldap_digests\",\nldap_bcrypt=\"passlib.handlers.ldap_digests\",\nldap_sha1_crypt=\"passlib.handlers.ldap_digests\",\nldap_sha256_crypt=\"passlib.handlers.ldap_digests\",\nldap_sha512_crypt=\"passlib.handlers.ldap_digests\",\nldap_pbkdf2_sha1=\"passlib.handlers.pbkdf2\",\nldap_pbkdf2_sha256=\"passlib.handlers.pbkdf2\",\nldap_pbkdf2_sha512=\"passlib.handlers.pbkdf2\",\nlmhash=\"passlib.handlers.windows\",\nmd5_crypt=\"passlib.handlers.md5_crypt\",\nmsdcc=\"passlib.handlers.windows\",\nmsdcc2=\"passlib.handlers.windows\",\nmssql2000=\"passlib.handlers.mssql\",\nmssql2005=\"passlib.handlers.mssql\",\nmysql323=\"passlib.handlers.mysql\",\nmysql41=\"passlib.handlers.mysql\",\nnthash=\"passlib.handlers.windows\",\noracle10=\"passlib.handlers.oracle\",\noracle11=\"passlib.handlers.oracle\",\npbkdf2_sha1=\"passlib.handlers.pbkdf2\",\npbkdf2_sha256=\"passlib.handlers.pbkdf2\",\npbkdf2_sha512=\"passlib.handlers.pbkdf2\",\nphpass=\"passlib.handlers.phpass\",\nplaintext=\"passlib.handlers.misc\",\npostgres_md5=\"passlib.handlers.postgres\",\nroundup_plaintext=\"passlib.handlers.roundup\",\nscram=\"passlib.handlers.scram\",\nscrypt=\"passlib.handlers.scrypt\",\nsha1_crypt=\"passlib.handlers.sha1_crypt\",\nsha256_crypt=\"passlib.handlers.sha2_crypt\",\nsha512_crypt=\"passlib.handlers.sha2_crypt\",\nsun_md5_crypt=\"passlib.handlers.sun_md5_crypt\",\nunix_disabled=\"passlib.handlers.misc\",\nunix_fallback=\"passlib.handlers.misc\",\n)\n\n\n_name_re=re.compile(\"^[a-z][a-z0-9_]+[a-z0-9]$\")\n\n\n\n_forbidden_names=frozenset([\"onload\",\"policy\",\"context\",\"all\",\n\"default\",\"none\",\"auto\"])\n\n\n\n\ndef _validate_handler_name(name):\n ''\n\n\n\n\n\n\n \n if not name:\n  raise ValueError(\"handler name cannot be empty: %r\"%(name,))\n if name.lower()!=name:\n  raise ValueError(\"name must be lower-case: %r\"%(name,))\n if not _name_re.match(name):\n  raise ValueError(\"invalid name (must be 3+ characters, \"\n  \" begin with a-z, and contain only underscore, a-z, \"\n  \"0-9): %r\"%(name,))\n if '__'in name:\n  raise ValueError(\"name may not contain double-underscores: %r\"%\n  (name,))\n if name in _forbidden_names:\n  raise ValueError(\"that name is not allowed: %r\"%(name,))\n return True\n \ndef register_crypt_handler_path(name,path):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _validate_handler_name(name)\n \n \n if path.startswith(\".\"):\n  raise ValueError(\"path cannot start with '.'\")\n if ':'in path:\n  if path.count(':')>1:\n   raise ValueError(\"path cannot have more than one ':'\")\n  if path.find('.',path.index(':'))>-1:\n   raise ValueError(\"path cannot have '.' to right of ':'\")\n   \n   \n _locations[name]=path\n log.debug(\"registered path to %r handler: %r\",name,path)\n \ndef register_crypt_handler(handler,force=False ,_attr=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not is_crypt_handler(handler):\n  raise ExpectedTypeError(handler,\"password hash handler\",\"handler\")\n if not handler:\n  raise AssertionError(\"``bool(handler)`` must be True\")\n  \n  \n name=handler.name\n _validate_handler_name(name)\n if _attr and _attr !=name:\n  raise ValueError(\"handlers must be stored only under their own name (%r != %r)\"%\n  (_attr,name))\n  \n  \n other=_handlers.get(name)\n if other:\n  if other is handler:\n   log.debug(\"same %r handler already registered: %r\",name,handler)\n   return\n  elif force:\n   log.warning(\"overriding previously registered %r handler: %r\",\n   name,other)\n  else :\n   raise KeyError(\"another %r handler has already been registered: %r\"%\n   (name,other))\n   \n   \n _handlers[name]=handler\n log.debug(\"registered %r handler: %r\",name,handler)\n \ndef get_crypt_handler(name,default=_UNSET):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n if name.startswith(\"_\"):\n  if default is _UNSET:\n   raise KeyError(\"invalid handler name: %r\"%(name,))\n  else :\n   return default\n   \n   \n try :\n  return _handlers[name]\n except KeyError:\n  pass\n  \n  \n assert isinstance(name,unicode_or_str),\"name must be string instance\"\n alt=name.replace(\"-\",\"_\").lower()\n if alt !=name:\n  warn(\"handler names should be lower-case, and use underscores instead \"\n  \"of hyphens: %r => %r\"%(name,alt),PasslibWarning,\n  stacklevel=2)\n  name=alt\n  \n  \n  try :\n   return _handlers[name]\n  except KeyError:\n   pass\n   \n   \n path=_locations.get(name)\n if path:\n  if ':'in path:\n   modname,modattr=path.split(\":\")\n  else :\n   modname,modattr=path,name\n   \n   \n   \n   \n  mod=__import__(modname,fromlist=[modattr],level=0)\n  \n  \n  \n  handler=_handlers.get(name)\n  if handler:\n  \n   assert is_crypt_handler(handler),\"unexpected object: name=%r object=%r\"%(name,handler)\n   return handler\n   \n   \n  handler=getattr(mod,modattr)\n  register_crypt_handler(handler,_attr=name)\n  return handler\n  \n  \n if default is _UNSET:\n  raise KeyError(\"no crypt handler found for algorithm: %r\"%(name,))\n else :\n  return default\n  \ndef list_crypt_handlers(loaded_only=False ):\n ''\n\n\n\n\n \n names=set(_handlers)\n if not loaded_only:\n  names.update(_locations)\n  \n  \n return sorted(name for name in names if not name.startswith(\"_\"))\n \n \n \ndef _has_crypt_handler(name,loaded_only=False ):\n ''\n\n\n\n\n\n\n\n\n \n return (name in _handlers)or (not loaded_only and name in _locations)\n \ndef _unload_handler_name(name,locations=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if name in _handlers:\n  del _handlers[name]\n if locations and name in _locations:\n  del _locations[name]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef _resolve(hasher,param=\"value\"):\n ''\n\n \n if is_crypt_handler(hasher):\n  return hasher\n elif isinstance(hasher,unicode_or_str):\n  return get_crypt_handler(hasher)\n else :\n  raise exc.ExpectedTypeError(hasher,unicode_or_str,param)\n  \n  \n  \nANY=\"any\"\nBUILTIN=\"builtin\"\nOS_CRYPT=\"os_crypt\"\n\n\ndef has_backend(hasher,backend=ANY,safe=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n hasher=_resolve(hasher)\n \n if backend ==ANY:\n  if not hasattr(hasher,\"get_backend\"):\n  \n   return True\n   \n   \n  try :\n   hasher.get_backend()\n   return True\n  except exc.MissingBackendError:\n   return False\n   \n   \n if hasattr(hasher,\"has_backend\"):\n \n  if safe and backend not in hasher.backends:\n   return None\n  return hasher.has_backend(backend)\n  \n  \n if backend ==BUILTIN:\n  return True\n elif safe:\n  return None\n else :\n  raise exc.UnknownBackendError(hasher,backend)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n@memoize_single_value\ndef get_supported_os_crypt_schemes():\n ''\n\n \n if not os_crypt_present:\n  return ()\n cache=tuple(name for name in os_crypt_schemes\n if get_crypt_handler(name).has_backend(OS_CRYPT))\n if not cache:\n \n  import platform\n  warn(\"crypt.crypt() function is present, but doesn't support any \"\n  \"formats known to passlib! (system=%r release=%r)\"%\n  (platform.system(),platform.release()),\n  exc.PasslibRuntimeWarning)\n return cache\n \n \n \ndef has_os_crypt_support(hasher):\n ''\n\n\n\n\n\n\n\n\n \n return os_crypt_present and has_backend(hasher,OS_CRYPT,safe=True )\n \n \n \n \n", ["logging", "passlib", "passlib.exc", "passlib.ifc", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "platform", "re", "warnings"]], "passlib.Lib.site-packages.passlib.apache": [".py", "''\n\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport os\nfrom warnings import warn\n\n\nfrom passlib import exc,registry\nfrom passlib.context import CryptContext\nfrom passlib.exc import ExpectedStringError\nfrom passlib.hash import htdigest\nfrom passlib.utils import render_bytes,to_bytes,is_ascii_codec\nfrom passlib.utils.decor import deprecated_method\nfrom passlib.utils.compat import join_bytes,unicode,BytesIO,PY3\n\n__all__=[\n'HtpasswdFile',\n'HtdigestFile',\n]\n\n\n\n\n_UNSET=object()\n\n_BCOLON=b\":\"\n_BHASH=b\"#\"\n\n\n_INVALID_FIELD_CHARS=b\":\\n\\r\\t\\x00\"\n\n\n_SKIPPED=\"skipped\"\n_RECORD=\"record\"\n\n\n\n\nclass _CommonFile(object):\n ''\n \n \n \n \n \n encoding=None\n \n \n \n return_unicode=None\n \n \n _path=None\n _mtime=None\n \n \n autosave=False\n \n \n \n _records=None\n \n \n \n _source=None\n \n \n \n \n @classmethod\n def from_string(cls,data,**kwds):\n  ''\n\n\n\n\n\n\n\n  \n  if 'path'in kwds:\n   raise TypeError(\"'path' not accepted by from_string()\")\n  self=cls(**kwds)\n  self.load_string(data)\n  return self\n  \n @classmethod\n def from_path(cls,path,**kwds):\n  ''\n\n\n\n\n\n\n\n  \n  self=cls(**kwds)\n  self.load(path)\n  return self\n  \n  \n  \n  \n def __init__(self,path=None ,new=False ,autoload=True ,autosave=False ,\n encoding=\"utf-8\",return_unicode=PY3,\n ):\n \n  if not encoding:\n   warn(\"``encoding=None`` is deprecated as of Passlib 1.6, \"\n   \"and will cause a ValueError in Passlib 1.8, \"\n   \"use ``return_unicode=False`` instead.\",\n   DeprecationWarning,stacklevel=2)\n   encoding=\"utf-8\"\n   return_unicode=False\n  elif not is_ascii_codec(encoding):\n  \n  \n   raise ValueError(\"encoding must be 7-bit ascii compatible\")\n  self.encoding=encoding\n  \n  \n  self.return_unicode=return_unicode\n  self.autosave=autosave\n  self._path=path\n  self._mtime=0\n  \n  \n  if not autoload:\n   warn(\"``autoload=False`` is deprecated as of Passlib 1.6, \"\n   \"and will be removed in Passlib 1.8, use ``new=True`` instead\",\n   DeprecationWarning,stacklevel=2)\n   new=True\n  if path and not new:\n   self.load()\n  else :\n   self._records={}\n   self._source=[]\n   \n def __repr__(self):\n  tail=''\n  if self.autosave:\n   tail +=' autosave=True'\n  if self._path:\n   tail +=' path=%r'%self._path\n  if self.encoding !=\"utf-8\":\n   tail +=' encoding=%r'%self.encoding\n  return \"<%s 0x%0x%s>\"%(self.__class__.__name__,id(self),tail)\n  \n  \n  \n @property\n def path(self):\n  return self._path\n  \n @path.setter\n def path(self,value):\n  if value !=self._path:\n   self._mtime=0\n  self._path=value\n  \n @property\n def mtime(self):\n  ''\n  return self._mtime\n  \n  \n  \n  \n def load_if_changed(self):\n  ''\n  if not self._path:\n   raise RuntimeError(\"%r is not bound to a local file\"%self)\n  if self._mtime and self._mtime ==os.path.getmtime(self._path):\n   return False\n  self.load()\n  return True\n  \n def load(self,path=None ,force=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if path is not None :\n   with open(path,\"rb\")as fh:\n    self._mtime=0\n    self._load_lines(fh)\n  elif not force:\n   warn(\"%(name)s.load(force=False) is deprecated as of Passlib 1.6,\"\n   \"and will be removed in Passlib 1.8; \"\n   \"use %(name)s.load_if_changed() instead.\"%\n   dict(name=self.__class__.__name__),\n   DeprecationWarning,stacklevel=2)\n   return self.load_if_changed()\n  elif self._path:\n   with open(self._path,\"rb\")as fh:\n    self._mtime=os.path.getmtime(self._path)\n    self._load_lines(fh)\n  else :\n   raise RuntimeError(\"%s().path is not set, an explicit path is required\"%\n   self.__class__.__name__)\n  return True\n  \n def load_string(self,data):\n  ''\n  data=to_bytes(data,self.encoding,\"data\")\n  self._mtime=0\n  self._load_lines(BytesIO(data))\n  \n def _load_lines(self,lines):\n  ''\n  parse=self._parse_record\n  records={}\n  source=[]\n  skipped=b''\n  for idx,line in enumerate(lines):\n  \n  \n  \n   tmp=line.lstrip()\n   if not tmp or tmp.startswith(_BHASH):\n    skipped +=line\n    continue\n    \n    \n   key,value=parse(line,idx+1)\n   \n   \n   \n   if key in records:\n    log.warning(\"username occurs multiple times in source file: %r\"%key)\n    skipped +=line\n    continue\n    \n    \n   if skipped:\n    source.append((_SKIPPED,skipped))\n    skipped=b''\n    \n    \n   records[key]=value\n   source.append((_RECORD,key))\n   \n   \n  if skipped.rstrip():\n   source.append((_SKIPPED,skipped))\n   \n   \n  self._records=records\n  self._source=source\n  \n def _parse_record(self,record,lineno):\n  ''\n  raise NotImplementedError(\"should be implemented in subclass\")\n  \n def _set_record(self,key,value):\n  ''\n\n\n\n\n  \n  records=self._records\n  existing=(key in records)\n  records[key]=value\n  if not existing:\n   self._source.append((_RECORD,key))\n  return existing\n  \n  \n  \n  \n def _autosave(self):\n  ''\n  if self.autosave and self._path:\n   self.save()\n   \n def save(self,path=None ):\n  ''\n\n  \n  if path is not None :\n   with open(path,\"wb\")as fh:\n    fh.writelines(self._iter_lines())\n  elif self._path:\n   self.save(self._path)\n   self._mtime=os.path.getmtime(self._path)\n  else :\n   raise RuntimeError(\"%s().path is not set, cannot autosave\"%\n   self.__class__.__name__)\n   \n def to_string(self):\n  ''\n  return join_bytes(self._iter_lines())\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _iter_lines(self):\n  ''\n  \n  \n  records=self._records\n  if __debug__:\n   pending=set(records)\n  for action,content in self._source:\n   if action ==_SKIPPED:\n   \n    yield content\n   else :\n    assert action ==_RECORD\n    \n    if content not in records:\n    \n    \n    \n     continue\n    yield self._render_record(content,records[content])\n    if __debug__:\n     pending.remove(content)\n  if __debug__:\n  \n  \n   assert not pending,\"failed to write all records: missing=%r\"%(pending,)\n   \n def _render_record(self,key,value):\n  ''\n  raise NotImplementedError(\"should be implemented in subclass\")\n  \n  \n  \n  \n def _encode_user(self,user):\n  ''\n  return self._encode_field(user,\"user\")\n  \n def _encode_realm(self,realm):\n  ''\n  return self._encode_field(realm,\"realm\")\n  \n def _encode_field(self,value,param=\"field\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(value,unicode):\n   value=value.encode(self.encoding)\n  elif not isinstance(value,bytes):\n   raise ExpectedStringError(value,param)\n  if len(value)>255:\n   raise ValueError(\"%s must be at most 255 characters: %r\"%\n   (param,value))\n  if any(c in _INVALID_FIELD_CHARS for c in value):\n   raise ValueError(\"%s contains invalid characters: %r\"%\n   (param,value,))\n  return value\n  \n def _decode_field(self,value):\n  ''\n\n\n\n\n\n\n\n\n  \n  assert isinstance(value,bytes),\"expected value to be bytes\"\n  if self.return_unicode:\n   return value.decode(self.encoding)\n  else :\n   return value\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n_warn_no_bcrypt=set()\n\ndef _init_default_schemes():\n\n\n host_best=None\n for name in [\"bcrypt\",\"sha256_crypt\"]:\n  if registry.has_os_crypt_support(name):\n   host_best=name\n   break\n   \n   \n   \n bcrypt=\"bcrypt\"if registry.has_backend(\"bcrypt\")else None\n _warn_no_bcrypt.clear()\n if not bcrypt:\n  _warn_no_bcrypt.update([\"portable_apache_24\",\"host_apache_24\",\n  \"linux_apache_24\",\"portable\",\"host\"])\n  \n defaults=dict(\n \n portable_apache_24=bcrypt or \"apr_md5_crypt\",\n portable_apache_22=\"apr_md5_crypt\",\n \n \n host_apache_24=bcrypt or host_best or \"apr_md5_crypt\",\n host_apache_22=host_best or \"apr_md5_crypt\",\n \n \n linux_apache_24=bcrypt or \"sha256_crypt\",\n linux_apache_22=\"sha256_crypt\",\n )\n \n \n \n \n defaults.update(\n portable=defaults['portable_apache_24'],\n host=defaults['host_apache_24'],\n )\n return defaults\n \n \nhtpasswd_defaults=_init_default_schemes()\n\ndef _init_htpasswd_context():\n\n\n schemes=[\n \n \n \"bcrypt\",\n \n \n \n \"sha256_crypt\",\n \"sha512_crypt\",\n \"des_crypt\",\n \n \n \"apr_md5_crypt\",\n \n \n \"ldap_sha1\",\n \n \n \"plaintext\"\n ]\n \n \n \n \n schemes.extend(registry.get_supported_os_crypt_schemes())\n \n \n preferred=schemes[:3]+[\"apr_md5_crypt\"]+schemes\n schemes=sorted(set(schemes),key=preferred.index)\n \n \n return CryptContext(\n schemes=schemes,\n \n \n default=htpasswd_defaults['portable_apache_22'],\n \n \n bcrypt__ident=\"2y\",\n )\n \n \nhtpasswd_context=_init_htpasswd_context()\n\n\n\n\n\nclass HtpasswdFile(_CommonFile):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n def __init__(self,path=None ,default_scheme=None ,context=htpasswd_context,\n **kwds):\n  if 'default'in kwds:\n   warn(\"``default`` is deprecated as of Passlib 1.6, \"\n   \"and will be removed in Passlib 1.8, it has been renamed \"\n   \"to ``default_scheem``.\",\n   DeprecationWarning,stacklevel=2)\n   default_scheme=kwds.pop(\"default\")\n  if default_scheme:\n   if default_scheme in _warn_no_bcrypt:\n    warn(\"HtpasswdFile: no bcrypt backends available, \"\n    \"using fallback for default scheme %r\"%default_scheme,\n    exc.PasslibSecurityWarning)\n   default_scheme=htpasswd_defaults.get(default_scheme,default_scheme)\n   context=context.copy(default=default_scheme)\n  self.context=context\n  super(HtpasswdFile,self).__init__(path,**kwds)\n  \n def _parse_record(self,record,lineno):\n \n  result=record.rstrip().split(_BCOLON)\n  if len(result)!=2:\n   raise ValueError(\"malformed htpasswd file (error reading line %d)\"\n   %lineno)\n  return result\n  \n def _render_record(self,user,hash):\n  return render_bytes(\"%s:%s\\n\",user,hash)\n  \n  \n  \n  \n  \n def users(self):\n  ''\n\n  \n  return [self._decode_field(user)for user in self._records]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def set_password(self,user,password):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  hash=self.context.hash(password)\n  return self.set_hash(user,hash)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"set_password\")\n def update(self,user,password):\n  ''\n  return self.set_password(user,password)\n  \n def get_hash(self,user):\n  ''\n\n\n\n\n\n  \n  try :\n   return self._records[self._encode_user(user)]\n  except KeyError:\n   return None\n   \n def set_hash(self,user,hash):\n  ''\n\n\n\n\n\n\n\n  \n  \n  if PY3 and isinstance(hash,str):\n   hash=hash.encode(self.encoding)\n  user=self._encode_user(user)\n  existing=self._set_record(user,hash)\n  self._autosave()\n  return existing\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"get_hash\")\n def find(self,user):\n  ''\n  return self.get_hash(user)\n  \n  \n def delete(self,user):\n  ''\n\n\n\n\n  \n  try :\n   del self._records[self._encode_user(user)]\n  except KeyError:\n   return False\n  self._autosave()\n  return True\n  \n def check_password(self,user,password):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  user=self._encode_user(user)\n  hash=self._records.get(user)\n  if hash is None :\n   return None\n  if isinstance(password,unicode):\n  \n  \n   password=password.encode(self.encoding)\n  ok,new_hash=self.context.verify_and_update(password,hash)\n  if ok and new_hash is not None :\n  \n   assert user in self._records\n   self._records[user]=new_hash\n   self._autosave()\n  return ok\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"check_password\")\n def verify(self,user,password):\n  ''\n  return self.check_password(user,password)\n  \n  \n  \n  \n  \n  \n  \n  \nclass HtdigestFile(_CommonFile):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n default_realm=None\n \n \n \n \n def __init__(self,path=None ,default_realm=None ,**kwds):\n  self.default_realm=default_realm\n  super(HtdigestFile,self).__init__(path,**kwds)\n  \n def _parse_record(self,record,lineno):\n  result=record.rstrip().split(_BCOLON)\n  if len(result)!=3:\n   raise ValueError(\"malformed htdigest file (error reading line %d)\"\n   %lineno)\n  user,realm,hash=result\n  return (user,realm),hash\n  \n def _render_record(self,key,hash):\n  user,realm=key\n  return render_bytes(\"%s:%s:%s\\n\",user,realm,hash)\n  \n def _require_realm(self,realm):\n  if realm is None :\n   realm=self.default_realm\n   if realm is None :\n    raise TypeError(\"you must specify a realm explicitly, \"\n    \"or set the default_realm attribute\")\n  return realm\n  \n def _encode_realm(self,realm):\n  realm=self._require_realm(realm)\n  return self._encode_field(realm,\"realm\")\n  \n def _encode_key(self,user,realm):\n  return self._encode_user(user),self._encode_realm(realm)\n  \n  \n  \n  \n  \n def realms(self):\n  ''\n  realms=set(key[1]for key in self._records)\n  return [self._decode_field(realm)for realm in realms]\n  \n def users(self,realm=None ):\n  ''\n\n\n\n  \n  realm=self._encode_realm(realm)\n  return [self._decode_field(key[0])for key in self._records\n  if key[1]==realm]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def set_password(self,user,realm=None ,password=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if password is _UNSET:\n  \n   realm,password=None ,realm\n  realm=self._require_realm(realm)\n  hash=htdigest.hash(password,user,realm,encoding=self.encoding)\n  return self.set_hash(user,realm,hash)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"set_password\")\n def update(self,user,realm,password):\n  ''\n  return self.set_password(user,realm,password)\n  \n def get_hash(self,user,realm=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  key=self._encode_key(user,realm)\n  hash=self._records.get(key)\n  if hash is None :\n   return None\n  if PY3:\n   hash=hash.decode(self.encoding)\n  return hash\n  \n def set_hash(self,user,realm=None ,hash=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if hash is _UNSET:\n  \n   realm,hash=None ,realm\n   \n  if PY3 and isinstance(hash,str):\n   hash=hash.encode(self.encoding)\n  key=self._encode_key(user,realm)\n  existing=self._set_record(key,hash)\n  self._autosave()\n  return existing\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"get_hash\")\n def find(self,user,realm):\n  ''\n  return self.get_hash(user,realm)\n  \n  \n def delete(self,user,realm=None ):\n  ''\n\n\n\n\n\n\n  \n  key=self._encode_key(user,realm)\n  try :\n   del self._records[key]\n  except KeyError:\n   return False\n  self._autosave()\n  return True\n  \n def delete_realm(self,realm):\n  ''\n\n\n\n\n  \n  realm=self._encode_realm(realm)\n  records=self._records\n  keys=[key for key in records if key[1]==realm]\n  for key in keys:\n   del records[key]\n  self._autosave()\n  return len(keys)\n  \n def check_password(self,user,realm=None ,password=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if password is _UNSET:\n  \n   realm,password=None ,realm\n  user=self._encode_user(user)\n  realm=self._encode_realm(realm)\n  hash=self._records.get((user,realm))\n  if hash is None :\n   return None\n  return htdigest.verify(password,hash,user,realm,\n  encoding=self.encoding)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"1.8\",\n replacement=\"check_password\")\n def verify(self,user,realm,password):\n  ''\n  return self.check_password(user,realm,password)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "os", "passlib", "passlib.context", "passlib.exc", "passlib.hash", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "warnings"]], "passlib.Lib.site-packages.passlib.ifc": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nimport sys\n\n\nfrom passlib.utils.decor import deprecated_method\n\n__all__=[\n\"PasswordHash\",\n]\n\n\n\n\ndef recreate_with_metaclass(meta):\n ''\n def builder(cls):\n  if meta is type(cls):\n   return cls\n  return meta(cls.__name__,cls.__bases__,cls.__dict__.copy())\n return builder\n \n \n \n \nfrom abc import ABCMeta,abstractmethod,abstractproperty\n\n\n\n\n\n\n@recreate_with_metaclass(ABCMeta)\nclass PasswordHash(object):\n ''\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n is_disabled=False\n \n \n \n \n \n \n \n \n truncate_size=None\n \n \n \n \n \n \n \n \n \n \n \n \n truncate_error=True\n \n \n \n \n \n truncate_verify_reject=True\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n @abstractmethod\n def hash(cls,secret,\n **setting_and_context_kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\",replacement=\".hash()\")\n @classmethod\n def encrypt(cls,*args,**kwds):\n  ''\n\n\n\n\n\n\n  \n  return cls.hash(*args,**kwds)\n  \n  \n  \n  \n @classmethod\n @abstractmethod\n def verify(cls,secret,hash,**context_kwds):\n  ''\n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n  \n  \n  \n @classmethod\n @abstractmethod\n def using(cls,relaxed=False ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,secret=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return False\n  \n  \n  \n  \n @classmethod\n @abstractmethod\n def identify(cls,hash):\n  ''\n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls,**setting_kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  if cls.context_kwds:\n   raise NotImplementedError(\"must be implemented by subclass\")\n  return cls.using(**setting_kwds).hash(\"\")\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,**context):\n  ''\n\n\n\n\n\n\n\n  \n  \n  raise NotImplementedError(\"must be implemented by subclass\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n deprecated=False\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nclass DisabledHash(PasswordHash):\n ''\n\n \n \n is_disabled=True\n \n @classmethod\n def disable(cls,hash=None ):\n  ''\n\n\n\n  \n  \n  return cls.hash(\"\")\n  \n @classmethod\n def enable(cls,hash):\n  ''\n\n\n\n  \n  \n  raise ValueError(\"cannot restore original hash\")\n  \n  \n  \n  \n", ["abc", "logging", "passlib.utils.decor", "sys"]], "passlib.Lib.site-packages.passlib": [".py", "''\n\n__version__='1.7.4'\n", [], 1], "passlib.Lib.site-packages.passlib.hosts": [".py", "''\n\n\n\n\nfrom warnings import warn\n\nfrom passlib.context import LazyCryptContext\nfrom passlib.exc import PasslibRuntimeWarning\nfrom passlib import registry\nfrom passlib.utils import has_crypt,unix_crypt_schemes\n\n__all__=[\n\"linux_context\",\"linux2_context\",\n\"openbsd_context\",\n\"netbsd_context\",\n\"freebsd_context\",\n\"host_context\",\n]\n\n\n\n\n\n\n\nlinux_context=linux2_context=LazyCryptContext(\nschemes=[\"sha512_crypt\",\"sha256_crypt\",\"md5_crypt\",\n\"des_crypt\",\"unix_disabled\"],\ndeprecated=[\"des_crypt\"],\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfreebsd_context=LazyCryptContext([\"bcrypt\",\"md5_crypt\",\"bsd_nthash\",\n\"des_crypt\",\"unix_disabled\"])\n\nopenbsd_context=LazyCryptContext([\"bcrypt\",\"md5_crypt\",\"bsdi_crypt\",\n\"des_crypt\",\"unix_disabled\"])\n\nnetbsd_context=LazyCryptContext([\"bcrypt\",\"sha1_crypt\",\"md5_crypt\",\n\"bsdi_crypt\",\"des_crypt\",\"unix_disabled\"])\n\n\n\n\n\n\n\nif registry.os_crypt_present:\n\n\n\n\n def _iter_os_crypt_schemes():\n  ''\n  out=registry.get_supported_os_crypt_schemes()\n  if out:\n  \n  \n   out +=(\"unix_disabled\",)\n  return out\n  \n host_context=LazyCryptContext(_iter_os_crypt_schemes())\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", ["passlib", "passlib.context", "passlib.exc", "passlib.utils", "warnings"]], "passlib.Lib.site-packages.passlib.win32": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom warnings import warn\nwarn(\"the 'passlib.win32' module is deprecated, and will be removed in \"\n\"passlib 1.8; please use the 'passlib.hash.nthash' and \"\n\"'passlib.hash.lmhash' classes instead.\",\nDeprecationWarning)\n\n\n\n\n\nfrom binascii import hexlify\n\n\nfrom passlib.utils.compat import unicode\nfrom passlib.crypto.des import des_encrypt_block\nfrom passlib.hash import nthash\n\n__all__=[\n\"nthash\",\n\"raw_lmhash\",\n\"raw_nthash\",\n]\n\n\n\nLM_MAGIC=b\"KGS!@#$%\"\n\nraw_nthash=nthash.raw_nthash\n\ndef raw_lmhash(secret,encoding=\"ascii\",hex=False ):\n ''\n \n \n \n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(encoding)\n ns=secret.upper()[:14]+b\"\\x00\"*(14 -len(secret))\n out=des_encrypt_block(ns[:7],LM_MAGIC)+des_encrypt_block(ns[7:],LM_MAGIC)\n return hexlify(out).decode(\"ascii\")if hex else out\n \n \n \n \n", ["binascii", "passlib.crypto.des", "passlib.hash", "passlib.utils.compat", "warnings"]], "passlib.Lib.site-packages.passlib.apps": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nfrom itertools import chain\n\n\nfrom passlib import hash\nfrom passlib.context import LazyCryptContext\nfrom passlib.utils import sys_bits\n\n__all__=[\n'custom_app_context',\n'django_context',\n'ldap_context','ldap_nocrypt_context',\n'mysql_context','mysql4_context','mysql3_context',\n'phpass_context',\n'phpbb3_context',\n'postgres_context',\n]\n\n\n\n\ndef _load_master_config():\n from passlib.registry import list_crypt_handlers\n \n \n schemes=list_crypt_handlers()\n \n \n excluded=[\n \n 'bigcrypt',\n 'crypt16',\n \n \n 'cisco_pix',\n 'cisco_type7',\n 'htdigest',\n 'mysql323',\n 'oracle10',\n \n \n 'lmhash',\n 'msdcc',\n 'msdcc2',\n 'nthash',\n \n \n 'plaintext',\n 'ldap_plaintext',\n \n \n 'django_disabled',\n 'unix_disabled',\n 'unix_fallback',\n ]\n for name in excluded:\n  schemes.remove(name)\n  \n  \n return dict(schemes=schemes,default=\"sha256_crypt\")\nmaster_context=LazyCryptContext(onload=_load_master_config)\n\n\n\n\ncustom_app_context=LazyCryptContext(\n\nschemes=[\"sha512_crypt\",\"sha256_crypt\"],\n\n\ndefault=\"sha256_crypt\"if sys_bits <64 else \"sha512_crypt\",\n\n\nsha512_crypt__min_rounds=535000,\nsha256_crypt__min_rounds=535000,\n\n\nadmin__sha512_crypt__min_rounds=1024000,\nadmin__sha256_crypt__min_rounds=1024000,\n)\n\n\n\n\n\n\n\n\n\n_django10_schemes=[\n\"django_salted_sha1\",\n\"django_salted_md5\",\n\"django_des_crypt\",\n\"hex_md5\",\n\"django_disabled\",\n]\n\ndjango10_context=LazyCryptContext(\nschemes=_django10_schemes,\ndefault=\"django_salted_sha1\",\ndeprecated=[\"hex_md5\"],\n)\n\n\n\n\n\n_django14_schemes=[\n\"django_pbkdf2_sha256\",\n\"django_pbkdf2_sha1\",\n\"django_bcrypt\"\n]+_django10_schemes\n\ndjango14_context=LazyCryptContext(\nschemes=_django14_schemes,\ndeprecated=_django10_schemes,\n)\n\n\n\n\n\n_django16_schemes=list(_django14_schemes)\n_django16_schemes.insert(1,\"django_bcrypt_sha256\")\ndjango16_context=LazyCryptContext(\nschemes=_django16_schemes,\ndeprecated=_django10_schemes,\n)\n\n\n\n\n\n_django_110_schemes=[\n\"django_pbkdf2_sha256\",\n\"django_pbkdf2_sha1\",\n\"django_argon2\",\n\"django_bcrypt\",\n\"django_bcrypt_sha256\",\n\"django_disabled\",\n]\ndjango110_context=LazyCryptContext(schemes=_django_110_schemes)\n\n\n\n\n\n_django21_schemes=list(_django_110_schemes)\n_django21_schemes.remove(\"django_bcrypt\")\ndjango21_context=LazyCryptContext(schemes=_django21_schemes)\n\n\n\n\n\n\ndjango_context=django21_context\n\n\n\n\n\n\nstd_ldap_schemes=[\n\"ldap_salted_sha512\",\n\"ldap_salted_sha256\",\n\"ldap_salted_sha1\",\n\"ldap_salted_md5\",\n\"ldap_sha1\",\n\"ldap_md5\",\n\"ldap_plaintext\",\n]\n\n\nldap_nocrypt_context=LazyCryptContext(std_ldap_schemes)\n\n\ndef _iter_ldap_crypt_schemes():\n from passlib.utils import unix_crypt_schemes\n return ('ldap_'+name for name in unix_crypt_schemes)\n \ndef _iter_ldap_schemes():\n ''\n return chain(std_ldap_schemes,_iter_ldap_crypt_schemes())\nldap_context=LazyCryptContext(_iter_ldap_schemes())\n\n\n\n\n\n\n\n\n\n\n\nmysql3_context=LazyCryptContext([\"mysql323\"])\nmysql4_context=LazyCryptContext([\"mysql41\",\"mysql323\"],deprecated=\"mysql323\")\nmysql_context=mysql4_context\n\n\n\n\npostgres_context=LazyCryptContext([\"postgres_md5\"])\n\n\n\n\ndef _create_phpass_policy(**kwds):\n ''\n kwds['default']='bcrypt'if hash.bcrypt.has_backend()else 'phpass'\n return kwds\n \nphpass_context=LazyCryptContext(\nschemes=[\"bcrypt\",\"phpass\",\"bsdi_crypt\"],\nonload=_create_phpass_policy,\n)\n\nphpbb3_context=LazyCryptContext([\"phpass\"],phpass__ident=\"H\")\n\n\n\n\n\n\n\n_std_roundup_schemes=[\"ldap_hex_sha1\",\"ldap_hex_md5\",\"ldap_des_crypt\",\"roundup_plaintext\"]\nroundup10_context=LazyCryptContext(_std_roundup_schemes)\n\n\nroundup_context=roundup15_context=LazyCryptContext(\nschemes=_std_roundup_schemes+[\"ldap_pbkdf2_sha1\"],\ndeprecated=_std_roundup_schemes,\ndefault=\"ldap_pbkdf2_sha1\",\nldap_pbkdf2_sha1__default_rounds=10000,\n)\n\n\n\n\n", ["itertools", "logging", "passlib", "passlib.context", "passlib.registry", "passlib.utils"]], "passlib.Lib.site-packages.passlib.pwd": [".py", "''\n\n\n\nfrom __future__ import absolute_import,division,print_function,unicode_literals\n\nimport codecs\nfrom collections import defaultdict\ntry :\n from collections.abc import MutableMapping\nexcept ImportError:\n\n from collections import MutableMapping\nfrom math import ceil,log as logf\nimport logging ;log=logging.getLogger(__name__)\nimport pkg_resources\nimport os\n\n\nfrom passlib import exc\nfrom passlib.utils.compat import PY2,irange,itervalues,int_types\nfrom passlib.utils import rng,getrandstr,to_unicode\nfrom passlib.utils.decor import memoized_property\n\n__all__=[\n\"genword\",\"default_charsets\",\n\"genphrase\",\"default_wordsets\",\n]\n\n\n\n\n\n\nentropy_aliases=dict(\n\nunsafe=12,\n\n\nweak=24,\n\n\nfair=36,\n\n\nstrong=48,\n\n\nsecure=60,\n)\n\n\n\n\n\ndef _superclasses(obj,cls):\n ''\n mro=type(obj).__mro__\n return mro[mro.index(cls)+1:]\n \n \ndef _self_info_rate(source):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  size=len(source)\n except TypeError:\n \n  size=None\n counts=defaultdict(int)\n for char in source:\n  counts[char]+=1\n if size is None :\n  values=counts.values()\n  size=sum(values)\n else :\n  values=itervalues(counts)\n if not size:\n  return 0\n  \n  \n return logf(size,2)-sum(value *logf(value,2)for value in values)/size\n \n \n \n \n \n \n \n \n \n \ndef _open_asset_path(path,encoding=None ):\n ''\n\n\n\n\n\n\n\n\n \n if encoding:\n  return codecs.getreader(encoding)(_open_asset_path(path))\n if os.path.isabs(path):\n  return open(path,\"rb\")\n package,sep,subpath=path.partition(\":\")\n if not sep:\n  raise ValueError(\"asset path must be absolute file path \"\n  \"or use 'pkg.name:sub/path' format: %r\"%(path,))\n return pkg_resources.resource_stream(package,subpath)\n \n \n \n_sequence_types=(list,tuple)\n_set_types=(set,frozenset)\n\n\n_ensure_unique_cache=set()\n\n\ndef _ensure_unique(source,param=\"source\"):\n ''\n\n\n\n \n \n cache=_ensure_unique_cache\n hashable=True\n try :\n  if source in cache:\n   return True\n except TypeError:\n  hashable=False\n  \n  \n if isinstance(source,_set_types)or len(set(source))==len(source):\n  if hashable:\n   try :\n    cache.add(source)\n   except TypeError:\n   \n   \n    pass\n  return True\n  \n  \n seen=set()\n dups=set()\n for elem in source:\n  (dups if elem in seen else seen).add(elem)\n dups=sorted(dups)\n trunc=8\n if len(dups)>trunc:\n  trunc=5\n dup_repr=\", \".join(repr(str(word))for word in dups[:trunc])\n if len(dups)>trunc:\n  dup_repr +=\", ... plus %d others\"%(len(dups)-trunc)\n  \n  \n raise ValueError(\"`%s` cannot contain duplicate elements: %s\"%\n (param,dup_repr))\n \n \n \n \nclass SequenceGenerator(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n length=None\n \n \n requested_entropy=\"strong\"\n \n \n rng=rng\n \n \n symbol_count=None\n \n \n \n \n def __init__(self,entropy=None ,length=None ,rng=None ,**kwds):\n \n \n  assert self.symbol_count is not None ,\"subclass must set .symbol_count\"\n  \n  \n  if entropy is not None or length is None :\n   if entropy is None :\n    entropy=self.requested_entropy\n   entropy=entropy_aliases.get(entropy,entropy)\n   if entropy <=0:\n    raise ValueError(\"`entropy` must be positive number\")\n   min_length=int(ceil(entropy /self.entropy_per_symbol))\n   if length is None or length <min_length:\n    length=min_length\n    \n  self.requested_entropy=entropy\n  \n  if length <1:\n   raise ValueError(\"`length` must be positive integer\")\n  self.length=length\n  \n  \n  if rng is not None :\n   self.rng=rng\n   \n   \n  if kwds and _superclasses(self,SequenceGenerator)==(object,):\n   raise TypeError(\"Unexpected keyword(s): %s\"%\", \".join(kwds.keys()))\n  super(SequenceGenerator,self).__init__(**kwds)\n  \n  \n  \n  \n  \n @memoized_property\n def entropy_per_symbol(self):\n  ''\n\n  \n  return logf(self.symbol_count,2)\n  \n @memoized_property\n def entropy(self):\n  ''\n\n\n\n\n\n  \n  return self.length *self.entropy_per_symbol\n  \n  \n  \n  \n def __next__(self):\n  ''\n  raise NotImplementedError(\"implement in subclass\")\n  \n def __call__(self,returns=None ):\n  ''\n\n  \n  if returns is None :\n   return next(self)\n  elif isinstance(returns,int_types):\n   return [next(self)for _ in irange(returns)]\n  elif returns is iter:\n   return self\n  else :\n   raise exc.ExpectedTypeError(returns,\"<None>, int, or <iter>\",\"returns\")\n   \n def __iter__(self):\n  return self\n  \n if PY2:\n  def next(self):\n   return self.__next__()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \ndefault_charsets=dict(\n\nascii_72='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*?/',\n\n\nascii_62='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n\n\nascii_50='234679abcdefghjkmnpqrstuvwxyzACDEFGHJKMNPQRTUVWXYZ',\n\n\nhex='0123456789abcdef',\n)\n\n\n\n\n\nclass WordGenerator(SequenceGenerator):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n charset=\"ascii_62\"\n \n \n chars=None\n \n \n \n \n def __init__(self,chars=None ,charset=None ,**kwds):\n \n \n  if chars:\n   if charset:\n    raise TypeError(\"`chars` and `charset` are mutually exclusive\")\n  else :\n   if not charset:\n    charset=self.charset\n    assert charset\n   chars=default_charsets[charset]\n  self.charset=charset\n  chars=to_unicode(chars,param=\"chars\")\n  _ensure_unique(chars,param=\"chars\")\n  self.chars=chars\n  \n  \n  super(WordGenerator,self).__init__(**kwds)\n  \n  \n  \n  \n  \n  \n @memoized_property\n def symbol_count(self):\n  return len(self.chars)\n  \n  \n  \n  \n  \n def __next__(self):\n \n \n  return getrandstr(self.rng,self.chars,self.length)\n  \n  \n  \n  \n  \n  \ndef genword(entropy=None ,length=None ,returns=None ,**kwds):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n gen=WordGenerator(length=length,entropy=entropy,**kwds)\n return gen(returns)\n \n \n \n \n \ndef _load_wordset(asset_path):\n ''\n\n\n\n\n\n\n\n\n\n \n \n with _open_asset_path(asset_path,\"utf-8\")as fh:\n  gen=(word.strip()for word in fh)\n  words=tuple(word for word in gen if word)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n log.debug(\"loaded %d-element wordset from %r\",len(words),asset_path)\n return words\n \n \nclass WordsetDict(MutableMapping):\n ''\n\n\n\n \n \n \n paths=None\n \n \n _loaded=None\n \n def __init__(self,*args,**kwds):\n  self.paths={}\n  self._loaded={}\n  super(WordsetDict,self).__init__(*args,**kwds)\n  \n def __getitem__(self,key):\n  try :\n   return self._loaded[key]\n  except KeyError:\n   pass\n  path=self.paths[key]\n  value=self._loaded[key]=_load_wordset(path)\n  return value\n  \n def set_path(self,key,path):\n  ''\n\n  \n  self.paths[key]=path\n  \n def __setitem__(self,key,value):\n  self._loaded[key]=value\n  \n def __delitem__(self,key):\n  if key in self:\n   del self._loaded[key]\n   self.paths.pop(key,None )\n  else :\n   del self.paths[key]\n   \n @property\n def _keyset(self):\n  keys=set(self._loaded)\n  keys.update(self.paths)\n  return keys\n  \n def __iter__(self):\n  return iter(self._keyset)\n  \n def __len__(self):\n  return len(self._keyset)\n  \n  \n def __contains__(self,key):\n  return key in self._loaded or key in self.paths\n  \n  \n  \n  \ndefault_wordsets=WordsetDict()\n\n\nfor name in \"eff_long eff_short eff_prefixed bip39\".split():\n default_wordsets.set_path(name,\"passlib:_data/wordsets/%s.txt\"%name)\n \n \n \n \nclass PhraseGenerator(SequenceGenerator):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n wordset=\"eff_long\"\n \n \n words=None\n \n \n sep=\" \"\n \n \n \n \n def __init__(self,wordset=None ,words=None ,sep=None ,**kwds):\n \n \n  if words is not None :\n   if wordset is not None :\n    raise TypeError(\"`words` and `wordset` are mutually exclusive\")\n  else :\n   if wordset is None :\n    wordset=self.wordset\n    assert wordset\n   words=default_wordsets[wordset]\n  self.wordset=wordset\n  \n  \n  if not isinstance(words,_sequence_types):\n   words=tuple(words)\n  _ensure_unique(words,param=\"words\")\n  self.words=words\n  \n  \n  if sep is None :\n   sep=self.sep\n  sep=to_unicode(sep,param=\"sep\")\n  self.sep=sep\n  \n  \n  super(PhraseGenerator,self).__init__(**kwds)\n  \n  \n  \n  \n  \n  \n  \n @memoized_property\n def symbol_count(self):\n  return len(self.words)\n  \n  \n  \n  \n  \n def __next__(self):\n  words=(self.rng.choice(self.words)for _ in irange(self.length))\n  return self.sep.join(words)\n  \n  \n  \n  \n  \n  \ndef genphrase(entropy=None ,length=None ,returns=None ,**kwds):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n gen=PhraseGenerator(entropy=entropy,length=length,**kwds)\n return gen(returns)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", ["__future__", "codecs", "collections", "collections.abc", "logging", "math", "os", "passlib", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "pkg_resources"]], "passlib.Lib.site-packages.passlib.hash": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom passlib.registry import _proxy\nimport sys\nsys.modules[__name__]=_proxy\n\n\n\n\n\n\n\n\n\n\nif False :\n from passlib.handlers.argon2 import argon2\n from passlib.handlers.bcrypt import bcrypt,bcrypt_sha256\n from passlib.handlers.cisco import cisco_asa,cisco_pix,cisco_type7\n from passlib.handlers.des_crypt import bigcrypt,bsdi_crypt,crypt16,des_crypt\n from passlib.handlers.digests import hex_md4,hex_md5,hex_sha1,hex_sha256,hex_sha512,htdigest\n from passlib.handlers.django import django_bcrypt,django_bcrypt_sha256,django_des_crypt,django_disabled,django_pbkdf2_sha1,django_pbkdf2_sha256,django_salted_md5,django_salted_sha1\n from passlib.handlers.fshp import fshp\n from passlib.handlers.ldap_digests import ldap_bcrypt,ldap_bsdi_crypt,ldap_des_crypt,ldap_md5,ldap_md5_crypt,ldap_plaintext,ldap_salted_md5,ldap_salted_sha1,ldap_salted_sha256,ldap_salted_sha512,ldap_sha1,ldap_sha1_crypt,ldap_sha256_crypt,ldap_sha512_crypt\n from passlib.handlers.md5_crypt import apr_md5_crypt,md5_crypt\n from passlib.handlers.misc import plaintext,unix_disabled,unix_fallback\n from passlib.handlers.mssql import mssql2000,mssql2005\n from passlib.handlers.mysql import mysql323,mysql41\n from passlib.handlers.oracle import oracle10,oracle11\n from passlib.handlers.pbkdf2 import atlassian_pbkdf2_sha1,cta_pbkdf2_sha1,dlitz_pbkdf2_sha1,grub_pbkdf2_sha512,ldap_pbkdf2_sha1,ldap_pbkdf2_sha256,ldap_pbkdf2_sha512,pbkdf2_sha1,pbkdf2_sha256,pbkdf2_sha512\n from passlib.handlers.phpass import phpass\n from passlib.handlers.postgres import postgres_md5\n from passlib.handlers.roundup import ldap_hex_md5,ldap_hex_sha1,roundup_plaintext\n from passlib.handlers.scram import scram\n from passlib.handlers.scrypt import scrypt\n from passlib.handlers.sha1_crypt import sha1_crypt\n from passlib.handlers.sha2_crypt import sha256_crypt,sha512_crypt\n from passlib.handlers.sun_md5_crypt import sun_md5_crypt\n from passlib.handlers.windows import bsd_nthash,lmhash,msdcc,msdcc2,nthash\n \n \n \n \n \n \n \n", ["passlib.handlers.argon2", "passlib.handlers.bcrypt", "passlib.handlers.cisco", "passlib.handlers.des_crypt", "passlib.handlers.digests", "passlib.handlers.django", "passlib.handlers.fshp", "passlib.handlers.ldap_digests", "passlib.handlers.md5_crypt", "passlib.handlers.misc", "passlib.handlers.mssql", "passlib.handlers.mysql", "passlib.handlers.oracle", "passlib.handlers.pbkdf2", "passlib.handlers.phpass", "passlib.handlers.postgres", "passlib.handlers.roundup", "passlib.handlers.scram", "passlib.handlers.scrypt", "passlib.handlers.sha1_crypt", "passlib.handlers.sha2_crypt", "passlib.handlers.sun_md5_crypt", "passlib.handlers.windows", "passlib.registry", "sys"]], "passlib.Lib.site-packages.passlib.context": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nimport threading\nimport time\nfrom warnings import warn\n\n\nfrom passlib import exc\nfrom passlib.exc import ExpectedStringError,ExpectedTypeError,PasslibConfigWarning\nfrom passlib.registry import get_crypt_handler,_validate_handler_name\nfrom passlib.utils import (handlers as uh,to_bytes,\nto_unicode,splitcomma,\nas_bool,timer,rng,getrandstr,\n)\nfrom passlib.utils.binary import BASE64_CHARS\nfrom passlib.utils.compat import (iteritems,num_types,irange,\nPY2,PY3,unicode,SafeConfigParser,\nNativeStringIO,BytesIO,\nunicode_or_bytes_types,native_string_types,\n)\nfrom passlib.utils.decor import deprecated_method,memoized_property\n\n__all__=[\n'CryptContext',\n'LazyCryptContext',\n'CryptPolicy',\n]\n\n\n\n\n\n\n_UNSET=object()\n\ndef _coerce_vary_rounds(value):\n ''\n if value.endswith(\"%\"):\n \n  return float(value.rstrip(\"%\"))*.01\n try :\n  return int(value)\n except ValueError:\n  return float(value)\n  \n  \n_forbidden_scheme_options=set([\"salt\"])\n\n\n\n\n\n_coerce_scheme_options=dict(\nmin_rounds=int,\nmax_rounds=int,\ndefault_rounds=int,\nvary_rounds=_coerce_vary_rounds,\nsalt_size=int,\n)\n\ndef _is_handler_registered(handler):\n ''\n return get_crypt_handler(handler.name,None )is handler\n \n@staticmethod\ndef _always_needs_update(hash,secret=None ):\n ''\n\n\n \n return True\n \n \n_global_settings=set([\"truncate_error\",\"vary_rounds\"])\n\n\n\n\n_preamble=(\"The CryptPolicy class has been deprecated as of \"\n\"Passlib 1.6, and will be removed in Passlib 1.8. \")\n\nclass CryptPolicy(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n @classmethod\n def from_path(cls,path,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  warn(_preamble+\n  \"Instead of ``CryptPolicy.from_path(path)``, \"\n  \"use ``CryptContext.from_path(path)`` \"\n  \" or ``context.load_path(path)`` for an existing CryptContext.\",\n  DeprecationWarning,stacklevel=2)\n  return cls(_internal_context=CryptContext.from_path(path,section,\n  encoding))\n  \n @classmethod\n def from_string(cls,source,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  warn(_preamble+\n  \"Instead of ``CryptPolicy.from_string(source)``, \"\n  \"use ``CryptContext.from_string(source)`` or \"\n  \"``context.load(source)`` for an existing CryptContext.\",\n  DeprecationWarning,stacklevel=2)\n  return cls(_internal_context=CryptContext.from_string(source,section,\n  encoding))\n  \n @classmethod\n def from_source(cls,source,_warn=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if _warn:\n   warn(_preamble+\n   \"Instead of ``CryptPolicy.from_source()``, \"\n   \"use ``CryptContext.from_string(path)`` \"\n   \" or ``CryptContext.from_path(source)``, as appropriate.\",\n   DeprecationWarning,stacklevel=2)\n  if isinstance(source,CryptPolicy):\n   return source\n  elif isinstance(source,dict):\n   return cls(_internal_context=CryptContext(**source))\n  elif not isinstance(source,(bytes,unicode)):\n   raise TypeError(\"source must be CryptPolicy, dict, config string, \"\n   \"or file path: %r\"%(type(source),))\n  elif any(c in source for c in \"\\n\\r\\t\")or not source.strip(\" \\t./;:\"):\n   return cls(_internal_context=CryptContext.from_string(source))\n  else :\n   return cls(_internal_context=CryptContext.from_path(source))\n   \n @classmethod\n def from_sources(cls,sources,_warn=True ):\n  ''\n\n\n\n\n\n\n\n\n  \n  if _warn:\n   warn(_preamble+\n   \"Instead of ``CryptPolicy.from_sources()``, \"\n   \"use the various CryptContext constructors \"\n   \" followed by ``context.update()``.\",\n   DeprecationWarning,stacklevel=2)\n  if len(sources)==0:\n   raise ValueError(\"no sources specified\")\n  if len(sources)==1:\n   return cls.from_source(sources[0],_warn=False )\n  kwds={}\n  for source in sources:\n   kwds.update(cls.from_source(source,_warn=False )._context.to_dict(resolve=True ))\n  return cls(_internal_context=CryptContext(**kwds))\n  \n def replace(self,*args,**kwds):\n  ''\n\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.replace()``, \"\n   \"use ``context.update()`` or ``context.copy()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().replace()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.update()`` or ``context.copy()``.\",\n   DeprecationWarning,stacklevel=2)\n  sources=[self]\n  if args:\n   sources.extend(args)\n  if kwds:\n   sources.append(kwds)\n  return CryptPolicy.from_sources(sources,_warn=False )\n  \n  \n  \n  \n  \n  \n  \n _context=None\n \n \n \n _stub_policy=False\n \n \n \n \n def __init__(self,*args,**kwds):\n  context=kwds.pop(\"_internal_context\",None )\n  if context:\n   assert isinstance(context,CryptContext)\n   self._context=context\n   self._stub_policy=kwds.pop(\"_stub_policy\",False )\n   assert not (args or kwds),\"unexpected args: %r %r\"%(args,kwds)\n  else :\n   if args:\n    if len(args)!=1:\n     raise TypeError(\"only one positional argument accepted\")\n    if kwds:\n     raise TypeError(\"cannot specify positional arg and kwds\")\n    kwds=args[0]\n   warn(_preamble+\n   \"Instead of constructing a CryptPolicy instance, \"\n   \"create a CryptContext directly, or use ``context.update()`` \"\n   \"and ``context.load()`` to reconfigure existing CryptContext \"\n   \"instances.\",\n   DeprecationWarning,stacklevel=2)\n   self._context=CryptContext(**kwds)\n   \n   \n   \n   \n def has_schemes(self):\n  ''\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.has_schemes()``, \"\n   \"use ``bool(context.schemes())``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().has_schemes()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``bool(context.schemes())``.\",\n   DeprecationWarning,stacklevel=2)\n  return bool(self._context.schemes())\n  \n def iter_handlers(self):\n  ''\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.iter_handlers()``, \"\n   \"use ``context.schemes(resolve=True)``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().iter_handlers()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.schemes(resolve=True)``.\",\n   DeprecationWarning,stacklevel=2)\n  return self._context.schemes(resolve=True ,unconfigured=True )\n  \n def schemes(self,resolve=False ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.schemes()``, \"\n   \"use ``context.schemes()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().schemes()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.schemes()``.\",\n   DeprecationWarning,stacklevel=2)\n  return list(self._context.schemes(resolve=resolve,unconfigured=True ))\n  \n def get_handler(self,name=None ,category=None ,required=False ):\n  ''\n\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.get_handler()``, \"\n   \"use ``context.handler()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().get_handler()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.handler()``.\",\n   DeprecationWarning,stacklevel=2)\n   \n   \n  try :\n   return self._context.handler(name,category,unconfigured=True )\n  except KeyError:\n   if required:\n    raise\n   else :\n    return None\n    \n def get_min_verify_time(self,category=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  warn(\"get_min_verify_time() and min_verify_time option is deprecated and ignored, \"\n  \"and will be removed in Passlib 1.8\",DeprecationWarning,\n  stacklevel=2)\n  return 0\n  \n def get_options(self,name,category=None ):\n  ''\n\n\n\n\n\n  \n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"``context.policy.get_options()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"``CryptPolicy().get_options()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  if hasattr(name,\"name\"):\n   name=name.name\n  return self._context._config._get_record_options_with_flag(name,category)[0]\n  \n def handler_is_deprecated(self,name,category=None ):\n  ''\n\n\n\n\n\n  \n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"``context.policy.handler_is_deprecated()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"``CryptPolicy().handler_is_deprecated()`` will no longer be available.\",\n   DeprecationWarning,stacklevel=2)\n  if hasattr(name,\"name\"):\n   name=name.name\n  return self._context.handler(name,category).deprecated\n  \n  \n  \n  \n  \n def iter_config(self,ini=False ,resolve=False ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.iter_config()``, \"\n   \"use ``context.to_dict().items()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().iter_config()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.to_dict().items()``.\",\n   DeprecationWarning,stacklevel=2)\n   \n   \n  context=self._context\n  if ini:\n   def render_key(key):\n    return context._render_config_key(key).replace(\"__\",\".\")\n   def render_value(value):\n    if isinstance(value,(list,tuple)):\n     value=\", \".join(value)\n    return value\n   resolve=False\n  else :\n   render_key=context._render_config_key\n   render_value=lambda value:value\n  return (\n  (render_key(key),render_value(value))\n  for key,value in context._config.iter_config(resolve)\n  )\n  \n def to_dict(self,resolve=False ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.to_dict()``, \"\n   \"use ``context.to_dict()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().to_dict()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.to_dict()``.\",\n   DeprecationWarning,stacklevel=2)\n  return self._context.to_dict(resolve)\n  \n def to_file(self,stream,section=\"passlib\"):\n  ''\n\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.to_file(stream)``, \"\n   \"use ``stream.write(context.to_string())``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().to_file(stream)``, \"\n   \"create a CryptContext instance and \"\n   \"use ``stream.write(context.to_string())``.\",\n   DeprecationWarning,stacklevel=2)\n  out=self._context.to_string(section=section)\n  if PY2:\n   out=out.encode(\"utf-8\")\n  stream.write(out)\n  \n def to_string(self,section=\"passlib\",encoding=None ):\n  ''\n\n\n\n  \n  if self._stub_policy:\n   warn(_preamble+\n   \"Instead of ``context.policy.to_string()``, \"\n   \"use ``context.to_string()``.\",\n   DeprecationWarning,stacklevel=2)\n  else :\n   warn(_preamble+\n   \"Instead of ``CryptPolicy().to_string()``, \"\n   \"create a CryptContext instance and \"\n   \"use ``context.to_string()``.\",\n   DeprecationWarning,stacklevel=2)\n  out=self._context.to_string(section=section)\n  if encoding:\n   out=out.encode(encoding)\n  return out\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CryptConfig(object):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n _scheme_options=None\n \n \n \n _context_options=None\n \n \n handlers=None\n \n \n schemes=None\n \n \n categories=None\n \n \n context_kwds=None\n \n \n _default_schemes=None\n \n \n _records=None\n \n \n \n _record_lists=None\n \n \n \n \n def __init__(self,source):\n  self._init_scheme_list(source.get((None ,None ,\"schemes\")))\n  self._init_options(source)\n  self._init_default_schemes()\n  self._init_records()\n  \n def _init_scheme_list(self,data):\n  ''\n  handlers=[]\n  schemes=[]\n  if isinstance(data,native_string_types):\n   data=splitcomma(data)\n  for elem in data or ():\n  \n   if hasattr(elem,\"name\"):\n    handler=elem\n    scheme=handler.name\n    _validate_handler_name(scheme)\n   elif isinstance(elem,native_string_types):\n    handler=get_crypt_handler(elem)\n    scheme=handler.name\n   else :\n    raise TypeError(\"scheme must be name or CryptHandler, \"\n    \"not %r\"%type(elem))\n    \n    \n   if scheme in schemes:\n    raise KeyError(\"multiple handlers with same name: %r\"%\n    (scheme,))\n    \n    \n   handlers.append(handler)\n   schemes.append(scheme)\n   \n  self.handlers=tuple(handlers)\n  self.schemes=tuple(schemes)\n  \n  \n  \n  \n  \n  \n  \n  \n def _init_options(self,source):\n  ''\n\n  \n  \n  norm_scheme_option=self._norm_scheme_option\n  norm_context_option=self._norm_context_option\n  self._scheme_options=scheme_options={}\n  self._context_options=context_options={}\n  categories=set()\n  \n  \n  for (cat,scheme,key),value in iteritems(source):\n   categories.add(cat)\n   explicit_scheme=scheme\n   if not cat and not scheme and key in _global_settings:\n   \n   \n   \n    scheme=\"all\"\n   if scheme:\n   \n    key,value=norm_scheme_option(key,value)\n    \n    \n    \n    if scheme ==\"all\"and key not in _global_settings:\n     warn(\"The '%s' option should be configured per-algorithm, and not set \"\n     \"globally in the context; This will be an error in Passlib 2.0\"%\n     (key,),PasslibConfigWarning)\n     \n     \n     \n    if explicit_scheme ==\"all\":\n     warn(\"The 'all' scheme is deprecated as of Passlib 1.7, \"\n     \"and will be removed in Passlib 2.0; Please configure \"\n     \"options on a per-algorithm basis.\",DeprecationWarning)\n     \n     \n     \n    try :\n     category_map=scheme_options[scheme]\n    except KeyError:\n     scheme_options[scheme]={cat:{key:value}}\n    else :\n     try :\n      option_map=category_map[cat]\n     except KeyError:\n      category_map[cat]={key:value}\n     else :\n      option_map[key]=value\n   else :\n   \n    if cat and key ==\"schemes\":\n     raise KeyError(\"'schemes' context option is not allowed \"\n     \"per category\")\n    key,value=norm_context_option(cat,key,value)\n    if key ==\"min_verify_time\":\n     continue\n     \n     \n     \n    try :\n     category_map=context_options[key]\n    except KeyError:\n     context_options[key]={cat:value}\n    else :\n     category_map[cat]=value\n     \n     \n  categories.discard(None )\n  self.categories=tuple(sorted(categories))\n  \n def _norm_scheme_option(self,key,value):\n \n  if key in _forbidden_scheme_options:\n   raise KeyError(\"%r option not allowed in CryptContext \"\n   \"configuration\"%(key,))\n   \n  if isinstance(value,native_string_types):\n   func=_coerce_scheme_options.get(key)\n   if func:\n    value=func(value)\n  return key,value\n  \n def _norm_context_option(self,cat,key,value):\n  schemes=self.schemes\n  if key ==\"default\":\n   if hasattr(value,\"name\"):\n    value=value.name\n   elif not isinstance(value,native_string_types):\n    raise ExpectedTypeError(value,\"str\",\"default\")\n   if schemes and value not in schemes:\n    raise KeyError(\"default scheme not found in policy\")\n  elif key ==\"deprecated\":\n   if isinstance(value,native_string_types):\n    value=splitcomma(value)\n   elif not isinstance(value,(list,tuple)):\n    raise ExpectedTypeError(value,\"str or seq\",\"deprecated\")\n   if 'auto'in value:\n   \n   \n    if len(value)>1:\n     raise ValueError(\"cannot list other schemes if \"\n     \"``deprecated=['auto']`` is used\")\n   elif schemes:\n   \n    for scheme in value:\n     if not isinstance(scheme,native_string_types):\n      raise ExpectedTypeError(value,\"str\",\"deprecated element\")\n     if scheme not in schemes:\n      raise KeyError(\"deprecated scheme not found \"\n      \"in policy: %r\"%(scheme,))\n  elif key ==\"min_verify_time\":\n   warn(\"'min_verify_time' was deprecated in Passlib 1.6, is \"\n   \"ignored in 1.7, and will be removed in 1.8\",\n   DeprecationWarning)\n  elif key ==\"harden_verify\":\n   warn(\"'harden_verify' is deprecated & ignored as of Passlib 1.7.1, \"\n   \" and will be removed in 1.8\",\n   DeprecationWarning)\n  elif key !=\"schemes\":\n   raise KeyError(\"unknown CryptContext keyword: %r\"%(key,))\n  return key,value\n  \n  \n  \n  \n def get_context_optionmap(self,key,_default={}):\n  ''\n\n\n  \n  return self._context_options.get(key,_default)\n  \n def get_context_option_with_flag(self,category,key):\n  ''\n\n  \n  try :\n   category_map=self._context_options[key]\n  except KeyError:\n   return None ,False\n  value=category_map.get(None )\n  if category:\n   try :\n    alt=category_map[category]\n   except KeyError:\n    pass\n   else :\n    if value is None or alt !=value:\n     return alt,True\n  return value,False\n  \n  \n  \n  \n def _get_scheme_optionmap(self,scheme,category,default={}):\n  ''\n\n\n  \n  try :\n   return self._scheme_options[scheme][category]\n  except KeyError:\n   return default\n   \n def get_base_handler(self,scheme):\n  return self.handlers[self.schemes.index(scheme)]\n  \n @staticmethod\n def expand_settings(handler):\n  setting_kwds=handler.setting_kwds\n  if 'rounds'in handler.setting_kwds:\n  \n   setting_kwds +=uh.HasRounds.using_rounds_kwds\n  return setting_kwds\n  \n  \n def get_scheme_options_with_flag(self,scheme,category):\n  ''\n\n\n\n  \n  \n  get_optionmap=self._get_scheme_optionmap\n  kwds=get_optionmap(\"all\",None ).copy()\n  has_cat_options=False\n  \n  \n  if category:\n   defkwds=kwds.copy()\n   kwds.update(get_optionmap(\"all\",category))\n   \n   \n  allowed_settings=self.expand_settings(self.get_base_handler(scheme))\n  for key in set(kwds).difference(allowed_settings):\n   kwds.pop(key)\n  if category:\n   for key in set(defkwds).difference(allowed_settings):\n    defkwds.pop(key)\n    \n    \n  other=get_optionmap(scheme,None )\n  kwds.update(other)\n  \n  \n  if category:\n   defkwds.update(other)\n   kwds.update(get_optionmap(scheme,category))\n   \n   \n   \n   if kwds !=defkwds:\n    has_cat_options=True\n    \n  return kwds,has_cat_options\n  \n  \n  \n  \n def _init_default_schemes(self):\n  ''\n\n\n\n  \n  \n  get_optionmap=self.get_context_optionmap\n  default_map=self._default_schemes=get_optionmap(\"default\").copy()\n  dep_map=get_optionmap(\"deprecated\")\n  schemes=self.schemes\n  if not schemes:\n   return\n   \n   \n  deps=dep_map.get(None )or ()\n  default=default_map.get(None )\n  if not default:\n   for scheme in schemes:\n    if scheme not in deps:\n     default_map[None ]=scheme\n     break\n   else :\n    raise ValueError(\"must have at least one non-deprecated scheme\")\n  elif default in deps:\n   raise ValueError(\"default scheme cannot be deprecated\")\n   \n   \n  for cat in self.categories:\n   cdeps=dep_map.get(cat,deps)\n   cdefault=default_map.get(cat,default)\n   if not cdefault:\n    for scheme in schemes:\n     if scheme not in cdeps:\n      default_map[cat]=scheme\n      break\n    else :\n     raise ValueError(\"must have at least one non-deprecated \"\n     \"scheme for %r category\"%cat)\n   elif cdefault in cdeps:\n    raise ValueError(\"default scheme for %r category \"\n    \"cannot be deprecated\"%cat)\n    \n def default_scheme(self,category):\n  ''\n  defaults=self._default_schemes\n  try :\n   return defaults[category]\n  except KeyError:\n   pass\n  if not self.schemes:\n   raise KeyError(\"no hash schemes configured for this \"\n   \"CryptContext instance\")\n  return defaults[None ]\n  \n def is_deprecated_with_flag(self,scheme,category):\n  ''\n  depmap=self.get_context_optionmap(\"deprecated\")\n  def test(cat):\n   source=depmap.get(cat,depmap.get(None ))\n   if source is None :\n    return None\n   elif 'auto'in source:\n    return scheme !=self.default_scheme(cat)\n   else :\n    return scheme in source\n  value=test(None )or False\n  if category:\n   alt=test(category)\n   if alt is not None and value !=alt:\n    return alt,True\n  return value,False\n  \n  \n  \n  \n def _init_records(self):\n \n \n \n \n  self._record_lists={}\n  records=self._records={}\n  all_context_kwds=self.context_kwds=set()\n  get_options=self._get_record_options_with_flag\n  categories=(None ,)+self.categories\n  for handler in self.handlers:\n   scheme=handler.name\n   all_context_kwds.update(handler.context_kwds)\n   for cat in categories:\n    kwds,has_cat_options=get_options(scheme,cat)\n    if cat is None or has_cat_options:\n     records[scheme,cat]=self._create_record(handler,cat,**kwds)\n     \n     \n     \n     \n     \n @staticmethod\n def _create_record(handler,category=None ,deprecated=False ,**settings):\n \n  try :\n  \n  \n   subcls=handler.using(relaxed=True ,**settings)\n  except TypeError as err:\n   m=re.match(r\".* unexpected keyword argument '(.*)'$\",str(err))\n   if m and m.group(1)in settings:\n   \n   \n    key=m.group(1)\n    raise KeyError(\"keyword not supported by %s handler: %r\"%\n    (handler.name,key))\n   raise\n   \n   \n  assert subcls is not handler,\"expected unique variant of handler\"\n  \n  subcls._Context__orig_handler=handler\n  subcls.deprecated=deprecated\n  return subcls\n  \n def _get_record_options_with_flag(self,scheme,category):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  kwds,has_cat_options=self.get_scheme_options_with_flag(scheme,category)\n  \n  \n  value,not_inherited=self.is_deprecated_with_flag(scheme,category)\n  if value:\n   kwds['deprecated']=True\n  if not_inherited:\n   has_cat_options=True\n   \n  return kwds,has_cat_options\n  \n def get_record(self,scheme,category):\n  ''\n  \n  \n  \n  \n  \n  try :\n   return self._records[scheme,category]\n  except KeyError:\n   pass\n   \n   \n  if category is not None and not isinstance(category,native_string_types):\n   if PY2 and isinstance(category,unicode):\n   \n    return self.get_record(scheme,category.encode(\"utf-8\"))\n   raise ExpectedTypeError(category,\"str or None\",\"category\")\n  if scheme is not None and not isinstance(scheme,native_string_types):\n   raise ExpectedTypeError(scheme,\"str or None\",\"scheme\")\n   \n   \n   \n  if not scheme:\n   default=self.default_scheme(category)\n   assert default\n   record=self._records[None ,category]=self.get_record(default,\n   category)\n   return record\n   \n   \n   \n  if category:\n   try :\n    cache=self._records\n    record=cache[scheme,category]=cache[scheme,None ]\n    return record\n   except KeyError:\n    pass\n    \n    \n  raise KeyError(\"crypt algorithm not found in policy: %r\"%(scheme,))\n  \n def _get_record_list(self,category=None ):\n  ''\n\n\n  \n  \n  \n  try :\n   return self._record_lists[category]\n  except KeyError:\n   pass\n   \n  value=self._record_lists[category]=[\n  self.get_record(scheme,category)\n  for scheme in self.schemes\n  ]\n  return value\n  \n def identify_record(self,hash,category,required=True ):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if not isinstance(hash,unicode_or_bytes_types):\n   raise ExpectedStringError(hash,\"hash\")\n   \n  for record in self._get_record_list(category):\n   if record.identify(hash):\n    return record\n  if not required:\n   return None\n  elif not self.schemes:\n   raise KeyError(\"no crypt algorithms supported\")\n  else :\n   raise exc.UnknownHashError(\"hash could not be identified\")\n   \n @memoized_property\n def disabled_record(self):\n  for record in self._get_record_list(None ):\n   if record.is_disabled:\n    return record\n  raise RuntimeError(\"no disabled hasher present \"\n  \"(perhaps add 'unix_disabled' to list of schemes?)\")\n  \n  \n  \n  \n def iter_config(self,resolve=False ):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  scheme_options=self._scheme_options\n  context_options=self._context_options\n  scheme_keys=sorted(scheme_options)\n  context_keys=sorted(context_options)\n  \n  \n  if 'schemes'in context_keys:\n   context_keys.remove(\"schemes\")\n  value=self.handlers if resolve else self.schemes\n  if value:\n   yield (None ,None ,\"schemes\"),list(value)\n   \n   \n  for cat in (None ,)+self.categories:\n  \n  \n   for key in context_keys:\n    try :\n     value=context_options[key][cat]\n    except KeyError:\n     pass\n    else :\n     if isinstance(value,list):\n      value=list(value)\n     yield (cat,None ,key),value\n     \n     \n   for scheme in scheme_keys:\n    try :\n     kwds=scheme_options[scheme][cat]\n    except KeyError:\n     pass\n    else :\n     for key in sorted(kwds):\n      yield (cat,scheme,key),kwds[key]\n      \n      \n      \n      \n      \n      \n      \n      \nclass CryptContext(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n _config=None\n \n \n _get_record=None\n _identify_record=None\n \n \n \n \n @classmethod\n def _norm_source(cls,source):\n  ''\n  if isinstance(source,dict):\n   return cls(**source)\n  elif isinstance(source,cls):\n   return source\n  else :\n   self=cls()\n   self.load(source)\n   return self\n   \n @classmethod\n def from_string(cls,source,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(source,unicode_or_bytes_types):\n   raise ExpectedTypeError(source,\"unicode or bytes\",\"source\")\n  self=cls(_autoload=False )\n  self.load(source,section=section,encoding=encoding)\n  return self\n  \n @classmethod\n def from_path(cls,path,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self=cls(_autoload=False )\n  self.load_path(path,section=section,encoding=encoding)\n  return self\n  \n def copy(self,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  other=CryptContext(_autoload=False )\n  other.load(self)\n  if kwds:\n   other.load(kwds,update=True )\n  return other\n  \n def using(self,**kwds):\n  ''\n\n  \n  return self.copy(**kwds)\n  \n def replace(self,**kwds):\n  ''\n  warn(\"CryptContext().replace() has been deprecated in Passlib 1.6, \"\n  \"and will be removed in Passlib 1.8, \"\n  \"it has been renamed to CryptContext().copy()\",\n  DeprecationWarning,stacklevel=2)\n  return self.copy(**kwds)\n  \n  \n  \n  \n def __init__(self,schemes=None ,\n \n policy=_UNSET,\n _autoload=True ,**kwds):\n \n \n \n  if schemes is not None :\n   kwds['schemes']=schemes\n  if policy is not _UNSET:\n   warn(\"The CryptContext ``policy`` keyword has been deprecated as of Passlib 1.6, \"\n   \"and will be removed in Passlib 1.8; please use \"\n   \"``CryptContext.from_string()` or \"\n   \"``CryptContext.from_path()`` instead.\",\n   DeprecationWarning)\n   if policy is None :\n    self.load(kwds)\n   elif isinstance(policy,CryptPolicy):\n    self.load(policy._context)\n    self.update(kwds)\n   else :\n    raise TypeError(\"policy must be a CryptPolicy instance\")\n  elif _autoload:\n   self.load(kwds)\n  else :\n   assert not kwds,\"_autoload=False and kwds are mutually exclusive\"\n   \n   \n   \n   \n   \n   \n   \n   \n def __repr__(self):\n  return \"<CryptContext at 0x%0x>\"%id(self)\n  \n  \n  \n  \n def _get_policy(self):\n \n \n \n \n \n \n \n \n \n \n  return CryptPolicy(_internal_context=self.copy(),_stub_policy=True )\n  \n def _set_policy(self,policy):\n  warn(\"The CryptPolicy class and the ``context.policy`` attribute have \"\n  \"been deprecated as of Passlib 1.6, and will be removed in \"\n  \"Passlib 1.8; please use the ``context.load()`` and \"\n  \"``context.update()`` methods instead.\",\n  DeprecationWarning,stacklevel=2)\n  if isinstance(policy,CryptPolicy):\n   self.load(policy._context)\n  else :\n   raise TypeError(\"expected CryptPolicy instance\")\n   \n policy=property(_get_policy,_set_policy,\n doc=\"[deprecated] returns CryptPolicy instance \"\n \"tied to this CryptContext\")\n \n \n \n \n @staticmethod\n def _parse_ini_stream(stream,section,filename):\n  ''\n  \n  \n  \n  p=SafeConfigParser()\n  if PY3:\n  \n   p.read_file(stream,filename)\n  else :\n   p.readfp(stream,filename)\n   \n   \n  return dict(p.items(section))\n  \n def load_path(self,path,update=False ,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n  \n  def helper(stream):\n   kwds=self._parse_ini_stream(stream,section,path)\n   return self.load(kwds,update=update)\n  if PY3:\n  \n   with open(path,\"rt\",encoding=encoding)as stream:\n    return helper(stream)\n  elif encoding in [\"utf-8\",\"ascii\"]:\n  \n   with open(path,\"rb\")as stream:\n    return helper(stream)\n  else :\n  \n   with open(path,\"rb\")as fh:\n    tmp=fh.read().decode(encoding).encode(\"utf-8\")\n    return helper(BytesIO(tmp))\n    \n def load(self,source,update=False ,section=\"passlib\",encoding=\"utf-8\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  parse_keys=True\n  if isinstance(source,unicode_or_bytes_types):\n   if PY3:\n    source=to_unicode(source,encoding,param=\"source\")\n   else :\n    source=to_bytes(source,\"utf-8\",source_encoding=encoding,\n    param=\"source\")\n   source=self._parse_ini_stream(NativeStringIO(source),section,\n   \"<string passed to CryptContext.load()>\")\n  elif isinstance(source,CryptContext):\n  \n   source=dict(source._config.iter_config(resolve=True ))\n   parse_keys=False\n  elif not hasattr(source,\"items\"):\n  \n   raise ExpectedTypeError(source,\"string or dict\",\"source\")\n   \n   \n   \n   \n   \n   \n   \n  if parse_keys:\n   parse=self._parse_config_key\n   source=dict((parse(key),value)\n   for key,value in iteritems(source))\n  if update and self._config is not None :\n  \n   if not source:\n    return\n    \n   tmp=source\n   source=dict(self._config.iter_config(resolve=True ))\n   source.update(tmp)\n   \n   \n   \n   \n  config=_CryptConfig(source)\n  self._config=config\n  self._reset_dummy_verify()\n  self._get_record=config.get_record\n  self._identify_record=config.identify_record\n  if config.context_kwds:\n  \n   self.__dict__.pop(\"_strip_unused_context_kwds\",None )\n  else :\n  \n   self._strip_unused_context_kwds=None\n   \n @staticmethod\n def _parse_config_key(ckey):\n  ''\n  \n  assert isinstance(ckey,native_string_types)\n  parts=ckey.replace(\".\",\"__\").split(\"__\")\n  count=len(parts)\n  if count ==1:\n   cat,scheme,key=None ,None ,parts[0]\n  elif count ==2:\n   cat=None\n   scheme,key=parts\n  elif count ==3:\n   cat,scheme,key=parts\n  else :\n   raise TypeError(\"keys must have less than 3 separators: %r\"%\n   (ckey,))\n   \n  if cat ==\"default\":\n   cat=None\n  elif not cat and cat is not None :\n   raise TypeError(\"empty category: %r\"%ckey)\n  if scheme ==\"context\":\n   scheme=None\n  elif not scheme and scheme is not None :\n   raise TypeError(\"empty scheme: %r\"%ckey)\n  if not key:\n   raise TypeError(\"empty option: %r\"%ckey)\n  return cat,scheme,key\n  \n def update(self,*args,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if args:\n   if len(args)>1:\n    raise TypeError(\"expected at most one positional argument\")\n   if kwds:\n    raise TypeError(\"positional arg and keywords mutually exclusive\")\n   self.load(args[0],update=True )\n  elif kwds:\n   self.load(kwds,update=True )\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def schemes(self,resolve=False ,category=None ,unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  schemes=self._config.schemes\n  if resolve:\n   return tuple(self.handler(scheme,category,unconfigured=unconfigured)\n   for scheme in schemes)\n  else :\n   return schemes\n   \n def default_scheme(self,category=None ,resolve=False ,unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  hasher=self.handler(None ,category,unconfigured=unconfigured)\n  return hasher if resolve else hasher.name\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def handler(self,scheme=None ,category=None ,unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   hasher=self._get_record(scheme,category)\n   if unconfigured:\n    return hasher._Context__orig_handler\n   else :\n    return hasher\n  except KeyError:\n   pass\n  if self._config.handlers:\n   raise KeyError(\"crypt algorithm not found in this \"\n   \"CryptContext instance: %r\"%(scheme,))\n  else :\n   raise KeyError(\"no crypt algorithms loaded in this \"\n   \"CryptContext instance\")\n   \n def _get_unregistered_handlers(self):\n  ''\n  return tuple(handler for handler in self._config.handlers\n  if not _is_handler_registered(handler))\n  \n @property\n def context_kwds(self):\n  ''\n\n\n\n\n  \n  return self._config.context_kwds\n  \n  \n  \n  \n @staticmethod\n def _render_config_key(key):\n  ''\n  cat,scheme,option=key\n  if cat:\n   return \"%s__%s__%s\"%(cat,scheme or \"context\",option)\n  elif scheme:\n   return \"%s__%s\"%(scheme,option)\n  else :\n   return option\n   \n @staticmethod\n def _render_ini_value(key,value):\n  ''\n  \n  \n  if isinstance(value,(list,tuple)):\n   value=\", \".join(value)\n   \n   \n  elif isinstance(value,num_types):\n   if isinstance(value,float)and key[2]==\"vary_rounds\":\n    value=(\"%.2f\"%value).rstrip(\"0\")if value else \"0\"\n   else :\n    value=str(value)\n    \n  assert isinstance(value,native_string_types),\\\n  \"expected string for key: %r %r\"%(key,value)\n  \n  \n  return value.replace(\"%\",\"%%\")\n  \n def to_dict(self,resolve=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  render_key=self._render_config_key\n  return dict((render_key(key),value)\n  for key,value in self._config.iter_config(resolve))\n  \n def _write_to_parser(self,parser,section):\n  ''\n  render_key=self._render_config_key\n  render_value=self._render_ini_value\n  parser.add_section(section)\n  for k,v in self._config.iter_config():\n   v=render_value(k,v)\n   k=render_key(k)\n   parser.set(section,k,v)\n   \n def to_string(self,section=\"passlib\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  parser=SafeConfigParser()\n  self._write_to_parser(parser,section)\n  buf=NativeStringIO()\n  parser.write(buf)\n  unregistered=self._get_unregistered_handlers()\n  if unregistered:\n   buf.write((\n   \"# NOTE: the %s handler(s) are not registered with Passlib,\\n\"\n   \"# this string may not correctly reproduce the current configuration.\\n\\n\"\n   )%\", \".join(repr(handler.name)for handler in unregistered))\n  out=buf.getvalue()\n  if not PY3:\n   out=out.decode(\"utf-8\")\n  return out\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n mvt_estimate_max_samples=20\n mvt_estimate_min_samples=10\n mvt_estimate_max_time=2\n mvt_estimate_resolution=0.01\n harden_verify=None\n min_verify_time=0\n \n def reset_min_verify_time(self):\n  self._reset_dummy_verify()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _get_or_identify_record(self,hash,scheme=None ,category=None ):\n  ''\n  if scheme:\n   if not isinstance(hash,unicode_or_bytes_types):\n    raise ExpectedStringError(hash,\"hash\")\n   return self._get_record(scheme,category)\n  else :\n  \n   return self._identify_record(hash,category)\n   \n def _strip_unused_context_kwds(self,kwds,record):\n  ''\n\n\n\n\n\n\n\n  \n  if not kwds:\n   return\n  unused_kwds=self._config.context_kwds.difference(record.context_kwds)\n  for key in unused_kwds:\n   kwds.pop(key,None )\n   \n def needs_update(self,hash,scheme=None ,category=None ,secret=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if scheme is not None :\n  \n  \n  \n   warn(\"CryptContext.needs_update(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  record=self._get_or_identify_record(hash,scheme,category)\n  return record.deprecated or record.needs_update(hash,secret=secret)\n  \n @deprecated_method(deprecated=\"1.6\",removed=\"2.0\",replacement=\"CryptContext.needs_update()\")\n def hash_needs_update(self,hash,scheme=None ,category=None ):\n  ''\n\n\n\n\n\n  \n  return self.needs_update(hash,scheme,category)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genconfig(self,scheme=None ,category=None ,**settings):\n  ''\n\n\n\n\n\n  \n  record=self._get_record(scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(settings,record)\n  return record.genconfig(**settings)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genhash(self,secret,config,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n  \n  record=self._get_or_identify_record(config,scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(kwds,record)\n  return record.genhash(secret,config,**kwds)\n  \n def identify(self,hash,category=None ,resolve=False ,required=False ,\n unconfigured=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  record=self._identify_record(hash,category,required)\n  if record is None :\n   return None\n  elif resolve:\n   if unconfigured:\n    return record._Context__orig_handler\n   else :\n    return record\n  else :\n   return record.name\n   \n def hash(self,secret,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if scheme is not None :\n  \n  \n  \n   warn(\"CryptContext.hash(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  record=self._get_record(scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(kwds,record)\n  return record.hash(secret,**kwds)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\",replacement=\"CryptContext.hash()\")\n def encrypt(self,*args,**kwds):\n  ''\n\n\n\n\n\n\n  \n  return self.hash(*args,**kwds)\n  \n def verify(self,secret,hash,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  if scheme is not None :\n  \n  \n  \n   warn(\"CryptContext.verify(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  if hash is None :\n  \n  \n   self.dummy_verify()\n   return False\n  record=self._get_or_identify_record(hash,scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused:\n   strip_unused(kwds,record)\n  return record.verify(secret,hash,**kwds)\n  \n def verify_and_update(self,secret,hash,scheme=None ,category=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if scheme is not None :\n   warn(\"CryptContext.verify(): 'scheme' keyword is deprecated as of \"\n   \"Passlib 1.7, and will be removed in Passlib 2.0\",\n   DeprecationWarning)\n  if hash is None :\n  \n  \n   self.dummy_verify()\n   return False ,None\n  record=self._get_or_identify_record(hash,scheme,category)\n  strip_unused=self._strip_unused_context_kwds\n  if strip_unused and kwds:\n   clean_kwds=kwds.copy()\n   strip_unused(clean_kwds,record)\n  else :\n   clean_kwds=kwds\n   \n   \n   \n   \n  if not record.verify(secret,hash,**clean_kwds):\n   return False ,None\n  elif record.deprecated or record.needs_update(hash,secret=secret):\n  \n   return True ,self.hash(secret,category=category,**kwds)\n  else :\n   return True ,None\n   \n   \n   \n   \n   \n   \n _dummy_secret=\"too many secrets\"\n \n @memoized_property\n def _dummy_hash(self):\n  ''\n\n  \n  return self.hash(self._dummy_secret)\n  \n def _reset_dummy_verify(self):\n  ''\n\n  \n  type(self)._dummy_hash.clear_cache(self)\n  \n def dummy_verify(self,elapsed=0):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.verify(self._dummy_secret,self._dummy_hash)\n  return False\n  \n  \n  \n  \n  \n def is_enabled(self,hash):\n  ''\n\n\n\n\n\n\n\n  \n  return not self._identify_record(hash,None ).is_disabled\n  \n def disable(self,hash=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  record=self._config.disabled_record\n  assert record.is_disabled\n  return record.disable(hash)\n  \n def enable(self,hash):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  record=self._identify_record(hash,None )\n  if record.is_disabled:\n  \n   return record.enable(hash)\n  else :\n  \n   return hash\n   \n   \n   \n   \n   \nclass LazyCryptContext(CryptContext):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n _lazy_kwds=None\n \n \n \n \n \n \n \n def __init__(self,schemes=None ,**kwds):\n  if schemes is not None :\n   kwds['schemes']=schemes\n  self._lazy_kwds=kwds\n  \n def _lazy_init(self):\n  kwds=self._lazy_kwds\n  if 'create_policy'in kwds:\n   warn(\"The CryptPolicy class, and LazyCryptContext's \"\n   \"``create_policy`` keyword have been deprecated as of \"\n   \"Passlib 1.6, and will be removed in Passlib 1.8; \"\n   \"please use the ``onload`` keyword instead.\",\n   DeprecationWarning)\n   create_policy=kwds.pop(\"create_policy\")\n   result=create_policy(**kwds)\n   policy=CryptPolicy.from_source(result,_warn=False )\n   kwds=policy._context.to_dict()\n  elif 'onload'in kwds:\n   onload=kwds.pop(\"onload\")\n   kwds=onload(**kwds)\n  del self._lazy_kwds\n  super(LazyCryptContext,self).__init__(**kwds)\n  self.__class__=CryptContext\n  \n def __getattribute__(self,attr):\n  if (not attr.startswith(\"_\")or attr.startswith(\"__\"))and\\\n  self._lazy_kwds is not None :\n   self._lazy_init()\n  return object.__getattribute__(self,attr)\n  \n  \n  \n  \n", ["__future__", "logging", "passlib", "passlib.exc", "passlib.registry", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "re", "threading", "time", "warnings"]], "passlib.Lib.site-packages.passlib.exc": [".py", "''\n\n\n\nclass UnknownBackendError(ValueError):\n ''\n\n\n\n\n \n def __init__(self,hasher,backend):\n  self.hasher=hasher\n  self.backend=backend\n  message=\"%s: unknown backend: %r\"%(hasher.name,backend)\n  ValueError.__init__(self,message)\n  \n  \n  \n  \n  \nclass MissingBackendError(RuntimeError):\n ''\n\n\n\n\n\n\n\n\n \n \n \nclass InternalBackendError(RuntimeError):\n ''\n\n\n\n\n \n \n \nclass PasswordValueError(ValueError):\n ''\n\n\n\n\n\n\n\n\n \n pass\n \n \nclass PasswordSizeError(PasswordValueError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n max_size=None\n \n def __init__(self,max_size,msg=None ):\n  self.max_size=max_size\n  if msg is None :\n   msg=\"password exceeds maximum allowed size\"\n  PasswordValueError.__init__(self,msg)\n  \n  \n  \n  \nclass PasswordTruncateError(PasswordSizeError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,cls,msg=None ):\n  if msg is None :\n   msg=(\"Password too long (%s truncates to %d characters)\"%\n   (cls.name,cls.truncate_size))\n  PasswordSizeError.__init__(self,cls.truncate_size,msg)\n  \n  \nclass PasslibSecurityError(RuntimeError):\n ''\n\n\n\n\n \n \n \nclass TokenError(ValueError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n _default_message='Token not acceptable'\n \n def __init__(self,msg=None ,*args,**kwds):\n  if msg is None :\n   msg=self._default_message\n  ValueError.__init__(self,msg,*args,**kwds)\n  \n  \nclass MalformedTokenError(TokenError):\n ''\n\n\n \n _default_message=\"Unrecognized token\"\n \n \nclass InvalidTokenError(TokenError):\n ''\n\n\n \n _default_message=\"Token did not match\"\n \n \nclass UsedTokenError(TokenError):\n ''\n\n\n\n\n\n\n \n _default_message=\"Token has already been used, please wait for another.\"\n \n \n \n expire_time=None\n \n def __init__(self,*args,**kwds):\n  self.expire_time=kwds.pop(\"expire_time\",None )\n  TokenError.__init__(self,*args,**kwds)\n  \n  \nclass UnknownHashError(ValueError):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,message=None ,value=None ):\n  self.value=value\n  if message is None :\n   message=\"unknown hash algorithm: %r\"%value\n  self.message=message\n  ValueError.__init__(self,message,value)\n  \n def __str__(self):\n  return self.message\n  \n  \n  \n  \n  \nclass PasslibWarning(UserWarning):\n ''\n\n\n\n \n \n \n \nclass PasslibConfigWarning(PasslibWarning):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \nclass PasslibHashWarning(PasslibWarning):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \nclass PasslibRuntimeWarning(PasslibWarning):\n ''\n\n\n\n\n\n\n \n \nclass PasslibSecurityWarning(PasslibWarning):\n ''\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \ndef _get_name(handler):\n return handler.name if handler else \"<unnamed>\"\n \n \n \n \ndef type_name(value):\n ''\n cls=value.__class__\n if cls.__module__ and cls.__module__ not in [\"__builtin__\",\"builtins\"]:\n  return \"%s.%s\"%(cls.__module__,cls.__name__)\n elif value is None :\n  return 'None'\n else :\n  return cls.__name__\n  \ndef ExpectedTypeError(value,expected,param):\n ''\n \n name=type_name(value)\n return TypeError(\"%s must be %s, not %s\"%(param,expected,name))\n \ndef ExpectedStringError(value,param):\n ''\n return ExpectedTypeError(value,\"unicode or bytes\",param)\n \n \n \n \ndef MissingDigestError(handler=None ):\n ''\n name=_get_name(handler)\n return ValueError(\"expected %s hash, got %s config string instead\"%\n (name,name))\n \ndef NullPasswordError(handler=None ):\n ''\n name=_get_name(handler)\n return PasswordValueError(\"%s does not allow NULL bytes in password\"%name)\n \n \n \n \ndef InvalidHashError(handler=None ):\n ''\n return ValueError(\"not a valid %s hash\"%_get_name(handler))\n \ndef MalformedHashError(handler=None ,reason=None ):\n ''\n text=\"malformed %s hash\"%_get_name(handler)\n if reason:\n  text=\"%s (%s)\"%(text,reason)\n return ValueError(text)\n \ndef ZeroPaddedRoundsError(handler=None ):\n ''\n return MalformedHashError(handler,\"zero-padded rounds\")\n \n \n \n \ndef ChecksumSizeError(handler,raw=False ):\n ''\n \n \n checksum_size=handler.checksum_size\n unit=\"bytes\"if raw else \"chars\"\n reason=\"checksum must be exactly %d %s\"%(checksum_size,unit)\n return MalformedHashError(handler,reason)\n \n \n \n \n \n \nENABLE_DEBUG_ONLY_REPR=False\n\n\ndef debug_only_repr(value,param=\"hash\"):\n ''\n\n\n\n\n\n\n\n\n \n if ENABLE_DEBUG_ONLY_REPR or value is None or isinstance(value,bool):\n  return repr(value)\n return \"<%s %s value omitted>\"%(param,type(value))\n \n \ndef CryptBackendError(handler,config,hash,\nsource=\"crypt.crypt()\"):\n ''\n\n\n \n name=_get_name(handler)\n msg=\"%s returned invalid %s hash: config=%s hash=%s\"%\\\n (source,name,debug_only_repr(config),debug_only_repr(hash))\n raise InternalBackendError(msg)\n \n \n \n \n", []], "passlib.Lib.site-packages.passlib.crypto.digest": [".py", "''\n\n\n\n\n\n\nfrom __future__ import division\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\ntry :\n\n from hashlib import pbkdf2_hmac as _stdlib_pbkdf2_hmac\n if _stdlib_pbkdf2_hmac.__module__ ==\"hashlib\":\n \n \n  log.debug(\"ignoring pure-python hashlib.pbkdf2_hmac()\")\n  _stdlib_pbkdf2_hmac=None\nexcept ImportError:\n _stdlib_pbkdf2_hmac=None\nimport re\nimport os\nfrom struct import Struct\nfrom warnings import warn\n\ntry :\n\n from fastpbkdf2 import pbkdf2_hmac as _fast_pbkdf2_hmac\nexcept ImportError:\n _fast_pbkdf2_hmac=None\n \nfrom passlib import exc\nfrom passlib.utils import join_bytes,to_native_str,join_byte_values,to_bytes,\\\nSequenceMixin,as_bool\nfrom passlib.utils.compat import irange,int_types,unicode_or_bytes_types,PY3,error_from\nfrom passlib.utils.decor import memoized_property\n\n__all__=[\n\n\"lookup_hash\",\n\"HashInfo\",\n\"norm_hash_name\",\n\n\n\"compile_hmac\",\n\n\n\"pbkdf1\",\n\"pbkdf2_hmac\",\n]\n\n\n\n\n\n\nMAX_UINT32=(1 <<32)-1\n\n\nMAX_UINT64=(1 <<64)-1\n\n\n\n\n\n\n_known_hash_names=[\n\n\n\n\n\n\n(\"md2\",\"md2\"),\n(\"md5\",\"md5\"),\n(\"sha1\",\"sha-1\"),\n(\"sha224\",\"sha-224\",\"sha2-224\"),\n(\"sha256\",\"sha-256\",\"sha2-256\"),\n(\"sha384\",\"sha-384\",\"sha2-384\"),\n(\"sha512\",\"sha-512\",\"sha2-512\"),\n\n\n\n\n\n\n\n\n(\"blake2b\",\"blake-2b\"),\n(\"blake2s\",\"blake-2s\"),\n(\"md4\",\"md4\"),\n\n\n\n(\"ripemd160\",\"ripemd-160\",\"ripemd\"),\n]\n\n\n\n\n_fallback_info={\n\n'blake2b':(64,128),\n'blake2s':(32,64),\n'md4':(16,64),\n'md5':(16,64),\n'sha1':(20,64),\n'sha224':(28,64),\n'sha256':(32,64),\n'sha384':(48,128),\n'sha3_224':(28,144),\n'sha3_256':(32,136),\n'sha3_384':(48,104),\n'sha3_512':(64,72),\n'sha512':(64,128),\n'shake128':(16,168),\n'shake256':(32,136),\n}\n\n\ndef _gen_fallback_info():\n ''\n\n\n\n \n out={}\n for alg in sorted(hashlib.algorithms_available |set([\"md4\"])):\n  info=lookup_hash(alg)\n  out[info.name]=(info.digest_size,info.block_size)\n return out\n \n \n \n_hash_info_cache={}\n\ndef _get_hash_aliases(name):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n orig=name\n if not isinstance(name,str):\n  name=to_native_str(name,'utf-8','hash name')\n name=re.sub(\"[_ /]\",\"-\",name.strip().lower())\n if name.startswith(\"scram-\"):\n  name=name[6:]\n  if name.endswith(\"-plus\"):\n   name=name[:-5]\n   \n   \n def check_table(name):\n  for row in _known_hash_names:\n   if name in row:\n    return row\n result=check_table(name)\n if result:\n  return result\n  \n  \n m=re.match(r\"(?i)^(?P<name>[a-z]+)-?(?P<rev>\\d)?-?(?P<size>\\d{3,4})?$\",name)\n if m:\n \n \n  iana_name,rev,size=m.group(\"name\",\"rev\",\"size\")\n  if rev:\n   iana_name +=rev\n  hashlib_name=iana_name\n  if size:\n   iana_name +=\"-\"+size\n   if rev:\n    hashlib_name +=\"_\"\n   hashlib_name +=size\n  result=check_table(iana_name)\n  if result:\n   return result\n   \n   \n  log.info(\"normalizing unrecognized hash name %r => %r / %r\",\n  orig,hashlib_name,iana_name)\n  \n else :\n \n  iana_name=name\n  hashlib_name=name.replace(\"-\",\"_\")\n  log.warning(\"normalizing unrecognized hash name and format %r => %r / %r\",\n  orig,hashlib_name,iana_name)\n  \n return hashlib_name,iana_name\n \n \ndef _get_hash_const(name):\n ''\n\n\n\n\n\n\n\n\n\n \n \n if not name.startswith(\"_\")and name not in (\"new\",\"algorithms\"):\n  try :\n   return getattr(hashlib,name)\n  except AttributeError:\n   pass\n   \n   \n new_ssl_hash=hashlib.new\n try :\n \n  new_ssl_hash(name,b\"\")\n except ValueError:\n  pass\n else :\n \n \n  def const(msg=b\"\"):\n   return new_ssl_hash(name,msg)\n  const.__name__=name\n  const.__module__=\"hashlib\"\n  const.__doc__=(\"wrapper for hashlib.new(%r),\\n\"\n  \"generated by passlib.crypto.digest.lookup_hash()\")%name\n  return const\n  \n  \n if name ==\"md4\":\n  from passlib.crypto._md4 import md4\n  return md4\n  \n  \n  \n  \n return None\n \n \ndef lookup_hash(digest,\nreturn_unknown=False ,required=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n cache=_hash_info_cache\n try :\n  return cache[digest]\n except (KeyError,TypeError):\n \n  pass\n  \n  \n if return_unknown:\n  required=False\n  \n  \n cache_by_name=True\n if isinstance(digest,unicode_or_bytes_types):\n \n  name_list=_get_hash_aliases(digest)\n  name=name_list[0]\n  assert name\n  \n  \n  \n  if name !=digest:\n   info=lookup_hash(name,required=required)\n   cache[digest]=info\n   return info\n   \n   \n   \n  const=_get_hash_const(name)\n  \n  \n  \n  if const and mock_fips_mode and name not in _fips_algorithms:\n   def const(source=b\"\"):\n    raise ValueError(\"%r disabled for fips by passlib set_mock_fips_mode()\"%name)\n    \n elif isinstance(digest,HashInfo):\n \n  return digest\n  \n elif callable(digest):\n \n \n  const=digest\n  name_list=_get_hash_aliases(const().name)\n  name=name_list[0]\n  other_const=_get_hash_const(name)\n  if other_const is None :\n  \n  \n   pass\n   \n  elif other_const is const:\n  \n  \n   pass\n   \n  else :\n  \n  \n  \n   cache_by_name=False\n   \n else :\n  raise exc.ExpectedTypeError(digest,\"digest name or constructor\",\"digest\")\n  \n  \n info=HashInfo(const=const,names=name_list,required=required)\n \n \n if const is not None :\n  cache[const]=info\n if cache_by_name:\n  for name in name_list:\n   if name:\n    assert cache.get(name)in [None ,info],\"%r already in cache\"%name\n    cache[name]=info\n return info\n \n \nlookup_hash.clear_cache=_hash_info_cache.clear\n\n\ndef norm_hash_name(name,format=\"hashlib\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n info=lookup_hash(name,required=False )\n if info.unknown:\n  warn(\"norm_hash_name(): \"+info.error_text,exc.PasslibRuntimeWarning)\n if format ==\"hashlib\":\n  return info.name\n elif format ==\"iana\":\n  return info.iana_name\n else :\n  raise ValueError(\"unknown format: %r\"%(format,))\n  \n  \nclass HashInfo(SequenceMixin):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=None\n \n \n iana_name=None\n \n \n aliases=()\n \n \n const=None\n \n \n digest_size=None\n \n \n block_size=None\n \n \n \n error_text=None\n \n \n \n unknown=False\n \n \n \n \n \n def __init__(self,\n const,names,required=True ):\n  ''\n\n\n\n\n\n\n  \n  \n  name=self.name=names[0]\n  self.iana_name=names[1]\n  self.aliases=names[2:]\n  \n  def use_stub_const(msg):\n   ''\n\n   \n   def const(source=b\"\"):\n    raise exc.UnknownHashError(msg,name)\n   if required:\n   \n   \n    const()\n    assert \"shouldn't get here\"\n   self.error_text=msg\n   self.const=const\n   try :\n    self.digest_size,self.block_size=_fallback_info[name]\n   except KeyError:\n    pass\n    \n    \n  if const is None :\n   if names in _known_hash_names:\n    msg=\"unsupported hash: %r\"%name\n   else :\n    msg=\"unknown hash: %r\"%name\n    self.unknown=True\n   use_stub_const(msg)\n   \n   return\n   \n   \n  try :\n   hash=const()\n  except ValueError as err:\n  \n  \n  \n  \n   if \"disabled for fips\"in str(err).lower():\n    msg=\"%r hash disabled for fips\"%name\n   else :\n    msg=\"internal error in %r constructor\\n(%s: %s)\"%(name,type(err).__name__,err)\n   use_stub_const(msg)\n   return\n   \n   \n  self.const=const\n  self.digest_size=hash.digest_size\n  self.block_size=hash.block_size\n  \n  \n  if len(hash.digest())!=hash.digest_size:\n   raise RuntimeError(\"%r constructor failed sanity check\"%self.name)\n   \n   \n  if hash.name !=self.name:\n   warn(\"inconsistent digest name: %r resolved to %r, which reports name as %r\"%\n   (self.name,const,hash.name),exc.PasslibRuntimeWarning)\n   \n   \n   \n   \n def __repr__(self):\n  return \"<lookup_hash(%r): digest_size=%r block_size=%r)\"%\\\n  (self.name,self.digest_size,self.block_size)\n  \n def _as_tuple(self):\n  return self.const,self.digest_size,self.block_size\n  \n @memoized_property\n def supported(self):\n  ''\n\n\n  \n  return self.error_text is None\n  \n @memoized_property\n def supported_by_fastpbkdf2(self):\n  ''\n  if not _fast_pbkdf2_hmac:\n   return None\n  try :\n   _fast_pbkdf2_hmac(self.name,b\"p\",b\"s\",1)\n   return True\n  except ValueError:\n  \n   return False\n   \n @memoized_property\n def supported_by_hashlib_pbkdf2(self):\n  ''\n  if not _stdlib_pbkdf2_hmac:\n   return None\n  try :\n   _stdlib_pbkdf2_hmac(self.name,b\"p\",b\"s\",1)\n   return True\n  except ValueError:\n  \n   return False\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nmock_fips_mode=False\n\n\n\n\n_fips_algorithms=set([\n\n'sha1',\n'sha224',\n'sha256',\n'sha384',\n'sha512',\n\n\n\n\n'sha3_224',\n'sha3_256',\n'sha3_384',\n'sha3_512',\n'shake_128',\n'shake_256',\n])\n\n\ndef _set_mock_fips_mode(enable=True ):\n ''\n\n \n global mock_fips_mode\n mock_fips_mode=enable\n lookup_hash.clear_cache()\n \n \n \nif as_bool(os.environ.get(\"PASSLIB_MOCK_FIPS_MODE\")):\n _set_mock_fips_mode()\n \n \n \n \n \n \n_TRANS_5C=join_byte_values((x ^0x5C)for x in irange(256))\n_TRANS_36=join_byte_values((x ^0x36)for x in irange(256))\n\ndef compile_hmac(digest,key,multipart=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n digest_info=lookup_hash(digest)\n const,digest_size,block_size=digest_info\n assert block_size >=16,\"block size too small\"\n \n \n if not isinstance(key,bytes):\n  key=to_bytes(key,param=\"key\")\n klen=len(key)\n if klen >block_size:\n  key=const(key).digest()\n  klen=digest_size\n if klen <block_size:\n  key +=b'\\x00'*(block_size -klen)\n  \n  \n _inner_copy=const(key.translate(_TRANS_36)).copy\n _outer_copy=const(key.translate(_TRANS_5C)).copy\n \n if multipart:\n \n \n \n  def hmac():\n   ''\n   inner=_inner_copy()\n   def finalize():\n    outer=_outer_copy()\n    outer.update(inner.digest())\n    return outer.digest()\n   return inner.update,finalize\n else :\n \n \n  def hmac(msg):\n   ''\n   inner=_inner_copy()\n   inner.update(msg)\n   outer=_outer_copy()\n   outer.update(inner.digest())\n   return outer.digest()\n   \n   \n hmac.digest_info=digest_info\n return hmac\n \n \n \n \ndef pbkdf1(digest,secret,salt,rounds,keylen=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n const,digest_size,block_size=lookup_hash(digest)\n \n \n secret=to_bytes(secret,param=\"secret\")\n salt=to_bytes(salt,param=\"salt\")\n \n \n if not isinstance(rounds,int_types):\n  raise exc.ExpectedTypeError(rounds,\"int\",\"rounds\")\n if rounds <1:\n  raise ValueError(\"rounds must be at least 1\")\n  \n  \n if keylen is None :\n  keylen=digest_size\n elif not isinstance(keylen,int_types):\n  raise exc.ExpectedTypeError(keylen,\"int or None\",\"keylen\")\n elif keylen <0:\n  raise ValueError(\"keylen must be at least 0\")\n elif keylen >digest_size:\n  raise ValueError(\"keylength too large for digest: %r > %r\"%\n  (keylen,digest_size))\n  \n  \n block=secret+salt\n for _ in irange(rounds):\n  block=const(block).digest()\n return block[:keylen]\n \n \n \n \n \n_pack_uint32=Struct(\">L\").pack\n\ndef pbkdf2_hmac(digest,secret,salt,rounds,keylen=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n secret=to_bytes(secret,param=\"secret\")\n salt=to_bytes(salt,param=\"salt\")\n \n \n digest_info=lookup_hash(digest)\n digest_size=digest_info.digest_size\n \n \n if not isinstance(rounds,int_types):\n  raise exc.ExpectedTypeError(rounds,\"int\",\"rounds\")\n if rounds <1:\n  raise ValueError(\"rounds must be at least 1\")\n  \n  \n if keylen is None :\n  keylen=digest_size\n elif not isinstance(keylen,int_types):\n  raise exc.ExpectedTypeError(keylen,\"int or None\",\"keylen\")\n elif keylen <1:\n \n  raise ValueError(\"keylen must be at least 1\")\n  \n  \n  \n  \n  \n  \n  \n block_count=(keylen+digest_size -1)//digest_size\n if block_count >MAX_UINT32:\n  raise OverflowError(\"keylen too long for digest\")\n  \n  \n  \n  \n  \n  \n  \n if digest_info.supported_by_fastpbkdf2:\n  return _fast_pbkdf2_hmac(digest_info.name,secret,salt,rounds,keylen)\n  \n  \n  \n  \n if digest_info.supported_by_hashlib_pbkdf2:\n  return _stdlib_pbkdf2_hmac(digest_info.name,secret,salt,rounds,keylen)\n  \n  \n  \n  \n  \n  \n keyed_hmac=compile_hmac(digest,secret)\n \n \n calc_block=_get_pbkdf2_looper(digest_size)\n \n \n return join_bytes(\n calc_block(keyed_hmac,keyed_hmac(salt+_pack_uint32(i)),rounds)\n for i in irange(1,block_count+1)\n )[:keylen]\n \n \n \n \n \n \n_force_backend=os.environ.get(\"PASSLIB_PBKDF2_BACKEND\")or \"any\"\n\nif PY3 and _force_backend in [\"any\",\"from-bytes\"]:\n from functools import partial\n \n def _get_pbkdf2_looper(digest_size):\n  return partial(_pbkdf2_looper,digest_size)\n  \n def _pbkdf2_looper(digest_size,keyed_hmac,digest,rounds):\n  ''\n\n\n  \n  from_bytes=int.from_bytes\n  BIG=\"big\"\n  accum=from_bytes(digest,BIG)\n  for _ in irange(rounds -1):\n   digest=keyed_hmac(digest)\n   accum ^=from_bytes(digest,BIG)\n  return accum.to_bytes(digest_size,BIG)\n  \n _builtin_backend=\"from-bytes\"\n \nelif _force_backend in [\"any\",\"unpack\",\"from-bytes\"]:\n from struct import Struct\n from passlib.utils import sys_bits\n \n _have_64_bit=(sys_bits >=64)\n \n \n _looper_cache={}\n \n def _get_pbkdf2_looper(digest_size):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  try :\n   return _looper_cache[digest_size]\n  except KeyError:\n   pass\n   \n   \n   \n   \n  if _have_64_bit and not digest_size&0x7:\n  \n   count=(digest_size >>3)\n   fmt=\"=%dQ\"%count\n  elif not digest_size&0x3:\n   if _have_64_bit:\n   \n    count=(digest_size >>3)\n    fmt=\"=%dQI\"%count\n    count +=1\n   else :\n   \n    count=(digest_size >>2)\n    fmt=\"=%dI\"%count\n  else :\n  \n  \n   raise NotImplementedError(\"unsupported digest size: %d\"%digest_size)\n  struct=Struct(fmt)\n  \n  \n  \n  \n  tdict=dict(\n  digest_size=digest_size,\n  accum_vars=\", \".join(\"acc_%d\"%i for i in irange(count)),\n  digest_vars=\", \".join(\"dig_%d\"%i for i in irange(count)),\n  )\n  \n  \n  source=(\n  \"def helper(keyed_hmac, digest, rounds):\\n\"\n  \"    '''pbkdf2 loop helper for digest_size={digest_size}'''\\n\"\n  \"    unpack_digest = struct.unpack\\n\"\n  \"    {accum_vars} = unpack_digest(digest)\\n\"\n  \"    for _ in irange(1, rounds):\\n\"\n  \"        digest = keyed_hmac(digest)\\n\"\n  \"        {digest_vars} = unpack_digest(digest)\\n\"\n  ).format(**tdict)\n  \n  \n  for i in irange(count):\n   source +=\"        acc_%d ^= dig_%d\\n\"%(i,i)\n   \n   \n  source +=\"    return struct.pack({accum_vars})\\n\".format(**tdict)\n  \n  \n  \n  \n  code=compile(source,\"<generated by passlib.crypto.digest._get_pbkdf2_looper()>\",\"exec\")\n  gdict=dict(irange=irange,struct=struct)\n  ldict=dict()\n  eval(code,gdict,ldict)\n  helper=ldict['helper']\n  if __debug__:\n   helper.__source__=source\n   \n   \n   \n   \n  _looper_cache[digest_size]=helper\n  return helper\n  \n _builtin_backend=\"unpack\"\n \nelse :\n assert _force_backend in [\"any\",\"hexlify\"]\n \n \n \n \n from binascii import hexlify as _hexlify\n from passlib.utils import int_to_bytes\n \n def _get_pbkdf2_looper(digest_size):\n  return _pbkdf2_looper\n  \n def _pbkdf2_looper(keyed_hmac,digest,rounds):\n  hexlify=_hexlify\n  accum=int(hexlify(digest),16)\n  for _ in irange(rounds -1):\n   digest=keyed_hmac(digest)\n   accum ^=int(hexlify(digest),16)\n  return int_to_bytes(accum,len(digest))\n  \n _builtin_backend=\"hexlify\"\n \n \nif _force_backend ==_builtin_backend:\n _fast_pbkdf2_hmac=_stdlib_pbkdf2_hmac=None\n \n \nPBKDF2_BACKENDS=[b for b in [\n\"fastpbkdf2\"if _fast_pbkdf2_hmac else None ,\n\"hashlib-ssl\"if _stdlib_pbkdf2_hmac else None ,\n\"builtin-\"+_builtin_backend\n]if b]\n\n\nif \"fastpbkdf2\"in PBKDF2_BACKENDS:\n PBKDF2_SPEED_FACTOR=3\nelif \"hashlib-ssl\"in PBKDF2_BACKENDS:\n PBKDF2_SPEED_FACTOR=1.4\nelse :\n\n PBKDF2_SPEED_FACTOR=1\n \n \n \n \n", ["__future__", "binascii", "fastpbkdf2", "functools", "hashlib", "logging", "os", "passlib", "passlib.crypto._md4", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "re", "struct", "warnings"]], "passlib.Lib.site-packages.passlib.crypto._md4": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom binascii import hexlify\nimport struct\n\nfrom passlib.utils.compat import bascii_to_str,irange,PY3\n\n__all__=[\"md4\"]\n\n\n\n\ndef F(x,y,z):\n return (x&y)|((~x)&z)\n \ndef G(x,y,z):\n return (x&y)|(x&z)|(y&z)\n \n \n \n \nMASK_32=2 **32 -1\n\n\n\n\nclass md4(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"md4\"\n digest_size=digestsize=16\n block_size=64\n \n _count=0\n _state=None\n _buf=None\n \n def __init__(self,content=None ):\n  self._count=0\n  self._state=[0x67452301,0xefcdab89,0x98badcfe,0x10325476]\n  self._buf=b''\n  if content:\n   self.update(content)\n   \n   \n _round1=[\n [0,1,2,3,0,3],\n [3,0,1,2,1,7],\n [2,3,0,1,2,11],\n [1,2,3,0,3,19],\n \n [0,1,2,3,4,3],\n [3,0,1,2,5,7],\n [2,3,0,1,6,11],\n [1,2,3,0,7,19],\n \n [0,1,2,3,8,3],\n [3,0,1,2,9,7],\n [2,3,0,1,10,11],\n [1,2,3,0,11,19],\n \n [0,1,2,3,12,3],\n [3,0,1,2,13,7],\n [2,3,0,1,14,11],\n [1,2,3,0,15,19],\n ]\n \n \n _round2=[\n [0,1,2,3,0,3],\n [3,0,1,2,4,5],\n [2,3,0,1,8,9],\n [1,2,3,0,12,13],\n \n [0,1,2,3,1,3],\n [3,0,1,2,5,5],\n [2,3,0,1,9,9],\n [1,2,3,0,13,13],\n \n [0,1,2,3,2,3],\n [3,0,1,2,6,5],\n [2,3,0,1,10,9],\n [1,2,3,0,14,13],\n \n [0,1,2,3,3,3],\n [3,0,1,2,7,5],\n [2,3,0,1,11,9],\n [1,2,3,0,15,13],\n ]\n \n \n _round3=[\n [0,1,2,3,0,3],\n [3,0,1,2,8,9],\n [2,3,0,1,4,11],\n [1,2,3,0,12,15],\n \n [0,1,2,3,2,3],\n [3,0,1,2,10,9],\n [2,3,0,1,6,11],\n [1,2,3,0,14,15],\n \n [0,1,2,3,1,3],\n [3,0,1,2,9,9],\n [2,3,0,1,5,11],\n [1,2,3,0,13,15],\n \n [0,1,2,3,3,3],\n [3,0,1,2,11,9],\n [2,3,0,1,7,11],\n [1,2,3,0,15,15],\n ]\n \n def _process(self,block):\n  ''\n  \n  X=struct.unpack(\"<16I\",block)\n  \n  \n  orig=self._state\n  state=list(orig)\n  \n  \n  for a,b,c,d,k,s in self._round1:\n   t=(state[a]+F(state[b],state[c],state[d])+X[k])&MASK_32\n   state[a]=((t <<s)&MASK_32)+(t >>(32 -s))\n   \n   \n  for a,b,c,d,k,s in self._round2:\n   t=(state[a]+G(state[b],state[c],state[d])+X[k]+0x5a827999)&MASK_32\n   state[a]=((t <<s)&MASK_32)+(t >>(32 -s))\n   \n   \n  for a,b,c,d,k,s in self._round3:\n   t=(state[a]+(state[b]^state[c]^state[d])+X[k]+0x6ed9eba1)&MASK_32\n   state[a]=((t <<s)&MASK_32)+(t >>(32 -s))\n   \n   \n  for i in irange(4):\n   orig[i]=(orig[i]+state[i])&MASK_32\n   \n def update(self,content):\n  if not isinstance(content,bytes):\n   if PY3:\n    raise TypeError(\"expected bytes\")\n   else :\n   \n    content=content.encode(\"ascii\")\n  buf=self._buf\n  if buf:\n   content=buf+content\n  idx=0\n  end=len(content)\n  while True :\n   next=idx+64\n   if next <=end:\n    self._process(content[idx:next])\n    self._count +=1\n    idx=next\n   else :\n    self._buf=content[idx:]\n    return\n    \n def copy(self):\n  other=md4()\n  other._count=self._count\n  other._state=list(self._state)\n  other._buf=self._buf\n  return other\n  \n def digest(self):\n \n \n  orig=list(self._state)\n  \n  \n  \n  \n  buf=self._buf\n  msglen=self._count *512+len(buf)*8\n  block=buf+b'\\x80'+b'\\x00'*((119 -len(buf))%64)+\\\n  struct.pack(\"<2I\",msglen&MASK_32,(msglen >>32)&MASK_32)\n  if len(block)==128:\n   self._process(block[:64])\n   self._process(block[64:])\n  else :\n   assert len(block)==64\n   self._process(block)\n   \n   \n  out=struct.pack(\"<4I\",*self._state)\n  self._state=orig\n  return out\n  \n def hexdigest(self):\n  return bascii_to_str(hexlify(self.digest()))\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "passlib.utils.compat", "struct"]], "passlib.Lib.site-packages.passlib.crypto": [".py", "''\n", [], 1], "passlib.Lib.site-packages.passlib.crypto.des": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport struct\n\nfrom passlib import exc\nfrom passlib.utils.compat import join_byte_values,byte_elem_value,\\\nirange,irange,int_types\n\n__all__=[\n\"expand_des_key\",\n\"des_encrypt_block\",\n]\n\n\n\n\n\n\nINT_24_MASK=0xffffff\nINT_56_MASK=0xffffffffffffff\nINT_64_MASK=0xffffffffffffffff\n\n\n_KDATA_MASK=0xfefefefefefefefe\n_KPARITY_MASK=0x0101010101010101\n\n\n_KS_MASK=0xfcfcfcfcffffffff\n\n\n\n\n\n\nPCXROT=IE3264=SPE=CF6464=None\n\ndef _load_tables():\n ''\n global PCXROT,IE3264,SPE,CF6464\n \n \n \n \n \n \n PC1ROT=(\n (0x0000000000000000,0x0000000000000000,0x0000000000002000,0x0000000000002000,\n 0x0000000000000020,0x0000000000000020,0x0000000000002020,0x0000000000002020,\n 0x0000000000000400,0x0000000000000400,0x0000000000002400,0x0000000000002400,\n 0x0000000000000420,0x0000000000000420,0x0000000000002420,0x0000000000002420,),\n (0x0000000000000000,0x2000000000000000,0x0000000400000000,0x2000000400000000,\n 0x0000800000000000,0x2000800000000000,0x0000800400000000,0x2000800400000000,\n 0x0008000000000000,0x2008000000000000,0x0008000400000000,0x2008000400000000,\n 0x0008800000000000,0x2008800000000000,0x0008800400000000,0x2008800400000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000040,0x0000000000000040,\n 0x0000000020000000,0x0000000020000000,0x0000000020000040,0x0000000020000040,\n 0x0000000000200000,0x0000000000200000,0x0000000000200040,0x0000000000200040,\n 0x0000000020200000,0x0000000020200000,0x0000000020200040,0x0000000020200040,),\n (0x0000000000000000,0x0002000000000000,0x0800000000000000,0x0802000000000000,\n 0x0100000000000000,0x0102000000000000,0x0900000000000000,0x0902000000000000,\n 0x4000000000000000,0x4002000000000000,0x4800000000000000,0x4802000000000000,\n 0x4100000000000000,0x4102000000000000,0x4900000000000000,0x4902000000000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000040000,0x0000000000040000,\n 0x0000020000000000,0x0000020000000000,0x0000020000040000,0x0000020000040000,\n 0x0000000000000004,0x0000000000000004,0x0000000000040004,0x0000000000040004,\n 0x0000020000000004,0x0000020000000004,0x0000020000040004,0x0000020000040004,),\n (0x0000000000000000,0x0000400000000000,0x0200000000000000,0x0200400000000000,\n 0x0080000000000000,0x0080400000000000,0x0280000000000000,0x0280400000000000,\n 0x0000008000000000,0x0000408000000000,0x0200008000000000,0x0200408000000000,\n 0x0080008000000000,0x0080408000000000,0x0280008000000000,0x0280408000000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000010000000,0x0000000010000000,\n 0x0000000000001000,0x0000000000001000,0x0000000010001000,0x0000000010001000,\n 0x0000000040000000,0x0000000040000000,0x0000000050000000,0x0000000050000000,\n 0x0000000040001000,0x0000000040001000,0x0000000050001000,0x0000000050001000,),\n (0x0000000000000000,0x0000001000000000,0x0000080000000000,0x0000081000000000,\n 0x1000000000000000,0x1000001000000000,0x1000080000000000,0x1000081000000000,\n 0x0004000000000000,0x0004001000000000,0x0004080000000000,0x0004081000000000,\n 0x1004000000000000,0x1004001000000000,0x1004080000000000,0x1004081000000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000080,0x0000000000000080,\n 0x0000000000080000,0x0000000000080000,0x0000000000080080,0x0000000000080080,\n 0x0000000000800000,0x0000000000800000,0x0000000000800080,0x0000000000800080,\n 0x0000000000880000,0x0000000000880000,0x0000000000880080,0x0000000000880080,),\n (0x0000000000000000,0x0000000008000000,0x0000002000000000,0x0000002008000000,\n 0x0000100000000000,0x0000100008000000,0x0000102000000000,0x0000102008000000,\n 0x0000200000000000,0x0000200008000000,0x0000202000000000,0x0000202008000000,\n 0x0000300000000000,0x0000300008000000,0x0000302000000000,0x0000302008000000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000400000,0x0000000000400000,\n 0x0000000004000000,0x0000000004000000,0x0000000004400000,0x0000000004400000,\n 0x0000000000000800,0x0000000000000800,0x0000000000400800,0x0000000000400800,\n 0x0000000004000800,0x0000000004000800,0x0000000004400800,0x0000000004400800,),\n (0x0000000000000000,0x0000000000008000,0x0040000000000000,0x0040000000008000,\n 0x0000004000000000,0x0000004000008000,0x0040004000000000,0x0040004000008000,\n 0x8000000000000000,0x8000000000008000,0x8040000000000000,0x8040000000008000,\n 0x8000004000000000,0x8000004000008000,0x8040004000000000,0x8040004000008000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000004000,0x0000000000004000,\n 0x0000000000000008,0x0000000000000008,0x0000000000004008,0x0000000000004008,\n 0x0000000000000010,0x0000000000000010,0x0000000000004010,0x0000000000004010,\n 0x0000000000000018,0x0000000000000018,0x0000000000004018,0x0000000000004018,),\n (0x0000000000000000,0x0000000200000000,0x0001000000000000,0x0001000200000000,\n 0x0400000000000000,0x0400000200000000,0x0401000000000000,0x0401000200000000,\n 0x0020000000000000,0x0020000200000000,0x0021000000000000,0x0021000200000000,\n 0x0420000000000000,0x0420000200000000,0x0421000000000000,0x0421000200000000,),\n (0x0000000000000000,0x0000000000000000,0x0000010000000000,0x0000010000000000,\n 0x0000000100000000,0x0000000100000000,0x0000010100000000,0x0000010100000000,\n 0x0000000000100000,0x0000000000100000,0x0000010000100000,0x0000010000100000,\n 0x0000000100100000,0x0000000100100000,0x0000010100100000,0x0000010100100000,),\n (0x0000000000000000,0x0000000080000000,0x0000040000000000,0x0000040080000000,\n 0x0010000000000000,0x0010000080000000,0x0010040000000000,0x0010040080000000,\n 0x0000000800000000,0x0000000880000000,0x0000040800000000,0x0000040880000000,\n 0x0010000800000000,0x0010000880000000,0x0010040800000000,0x0010040880000000,),\n )\n \n \n \n \n \n PC2ROTA=(\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000200000,0x0000000000200000,0x0000000000200000,0x0000000000200000,\n 0x0000000004000000,0x0000000004000000,0x0000000004000000,0x0000000004000000,\n 0x0000000004200000,0x0000000004200000,0x0000000004200000,0x0000000004200000,),\n (0x0000000000000000,0x0000000000000800,0x0000010000000000,0x0000010000000800,\n 0x0000000000002000,0x0000000000002800,0x0000010000002000,0x0000010000002800,\n 0x0000000010000000,0x0000000010000800,0x0000010010000000,0x0000010010000800,\n 0x0000000010002000,0x0000000010002800,0x0000010010002000,0x0000010010002800,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000100000000,0x0000000100000000,0x0000000100000000,0x0000000100000000,\n 0x0000000000800000,0x0000000000800000,0x0000000000800000,0x0000000000800000,\n 0x0000000100800000,0x0000000100800000,0x0000000100800000,0x0000000100800000,),\n (0x0000000000000000,0x0000020000000000,0x0000000080000000,0x0000020080000000,\n 0x0000000000400000,0x0000020000400000,0x0000000080400000,0x0000020080400000,\n 0x0000000008000000,0x0000020008000000,0x0000000088000000,0x0000020088000000,\n 0x0000000008400000,0x0000020008400000,0x0000000088400000,0x0000020088400000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000000040,0x0000000000000040,0x0000000000000040,0x0000000000000040,\n 0x0000000000001000,0x0000000000001000,0x0000000000001000,0x0000000000001000,\n 0x0000000000001040,0x0000000000001040,0x0000000000001040,0x0000000000001040,),\n (0x0000000000000000,0x0000000000000010,0x0000000000000400,0x0000000000000410,\n 0x0000000000000080,0x0000000000000090,0x0000000000000480,0x0000000000000490,\n 0x0000000040000000,0x0000000040000010,0x0000000040000400,0x0000000040000410,\n 0x0000000040000080,0x0000000040000090,0x0000000040000480,0x0000000040000490,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000080000,0x0000000000080000,0x0000000000080000,0x0000000000080000,\n 0x0000000000100000,0x0000000000100000,0x0000000000100000,0x0000000000100000,\n 0x0000000000180000,0x0000000000180000,0x0000000000180000,0x0000000000180000,),\n (0x0000000000000000,0x0000000000040000,0x0000000000000020,0x0000000000040020,\n 0x0000000000000004,0x0000000000040004,0x0000000000000024,0x0000000000040024,\n 0x0000000200000000,0x0000000200040000,0x0000000200000020,0x0000000200040020,\n 0x0000000200000004,0x0000000200040004,0x0000000200000024,0x0000000200040024,),\n (0x0000000000000000,0x0000000000000008,0x0000000000008000,0x0000000000008008,\n 0x0010000000000000,0x0010000000000008,0x0010000000008000,0x0010000000008008,\n 0x0020000000000000,0x0020000000000008,0x0020000000008000,0x0020000000008008,\n 0x0030000000000000,0x0030000000000008,0x0030000000008000,0x0030000000008008,),\n (0x0000000000000000,0x0000400000000000,0x0000080000000000,0x0000480000000000,\n 0x0000100000000000,0x0000500000000000,0x0000180000000000,0x0000580000000000,\n 0x4000000000000000,0x4000400000000000,0x4000080000000000,0x4000480000000000,\n 0x4000100000000000,0x4000500000000000,0x4000180000000000,0x4000580000000000,),\n (0x0000000000000000,0x0000000000004000,0x0000000020000000,0x0000000020004000,\n 0x0001000000000000,0x0001000000004000,0x0001000020000000,0x0001000020004000,\n 0x0200000000000000,0x0200000000004000,0x0200000020000000,0x0200000020004000,\n 0x0201000000000000,0x0201000000004000,0x0201000020000000,0x0201000020004000,),\n (0x0000000000000000,0x1000000000000000,0x0004000000000000,0x1004000000000000,\n 0x0002000000000000,0x1002000000000000,0x0006000000000000,0x1006000000000000,\n 0x0000000800000000,0x1000000800000000,0x0004000800000000,0x1004000800000000,\n 0x0002000800000000,0x1002000800000000,0x0006000800000000,0x1006000800000000,),\n (0x0000000000000000,0x0040000000000000,0x2000000000000000,0x2040000000000000,\n 0x0000008000000000,0x0040008000000000,0x2000008000000000,0x2040008000000000,\n 0x0000001000000000,0x0040001000000000,0x2000001000000000,0x2040001000000000,\n 0x0000009000000000,0x0040009000000000,0x2000009000000000,0x2040009000000000,),\n (0x0000000000000000,0x0400000000000000,0x8000000000000000,0x8400000000000000,\n 0x0000002000000000,0x0400002000000000,0x8000002000000000,0x8400002000000000,\n 0x0100000000000000,0x0500000000000000,0x8100000000000000,0x8500000000000000,\n 0x0100002000000000,0x0500002000000000,0x8100002000000000,0x8500002000000000,),\n (0x0000000000000000,0x0000800000000000,0x0800000000000000,0x0800800000000000,\n 0x0000004000000000,0x0000804000000000,0x0800004000000000,0x0800804000000000,\n 0x0000000400000000,0x0000800400000000,0x0800000400000000,0x0800800400000000,\n 0x0000004400000000,0x0000804400000000,0x0800004400000000,0x0800804400000000,),\n (0x0000000000000000,0x0080000000000000,0x0000040000000000,0x0080040000000000,\n 0x0008000000000000,0x0088000000000000,0x0008040000000000,0x0088040000000000,\n 0x0000200000000000,0x0080200000000000,0x0000240000000000,0x0080240000000000,\n 0x0008200000000000,0x0088200000000000,0x0008240000000000,0x0088240000000000,),\n )\n \n \n PC2ROTB=(\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000000400,0x0000000000000400,0x0000000000000400,0x0000000000000400,\n 0x0000000000080000,0x0000000000080000,0x0000000000080000,0x0000000000080000,\n 0x0000000000080400,0x0000000000080400,0x0000000000080400,0x0000000000080400,),\n (0x0000000000000000,0x0000000000800000,0x0000000000004000,0x0000000000804000,\n 0x0000000080000000,0x0000000080800000,0x0000000080004000,0x0000000080804000,\n 0x0000000000040000,0x0000000000840000,0x0000000000044000,0x0000000000844000,\n 0x0000000080040000,0x0000000080840000,0x0000000080044000,0x0000000080844000,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000000008,0x0000000000000008,0x0000000000000008,0x0000000000000008,\n 0x0000000040000000,0x0000000040000000,0x0000000040000000,0x0000000040000000,\n 0x0000000040000008,0x0000000040000008,0x0000000040000008,0x0000000040000008,),\n (0x0000000000000000,0x0000000020000000,0x0000000200000000,0x0000000220000000,\n 0x0000000000000080,0x0000000020000080,0x0000000200000080,0x0000000220000080,\n 0x0000000000100000,0x0000000020100000,0x0000000200100000,0x0000000220100000,\n 0x0000000000100080,0x0000000020100080,0x0000000200100080,0x0000000220100080,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000002000,0x0000000000002000,0x0000000000002000,0x0000000000002000,\n 0x0000020000000000,0x0000020000000000,0x0000020000000000,0x0000020000000000,\n 0x0000020000002000,0x0000020000002000,0x0000020000002000,0x0000020000002000,),\n (0x0000000000000000,0x0000000000000800,0x0000000100000000,0x0000000100000800,\n 0x0000000010000000,0x0000000010000800,0x0000000110000000,0x0000000110000800,\n 0x0000000000000004,0x0000000000000804,0x0000000100000004,0x0000000100000804,\n 0x0000000010000004,0x0000000010000804,0x0000000110000004,0x0000000110000804,),\n (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000000,\n 0x0000000000001000,0x0000000000001000,0x0000000000001000,0x0000000000001000,\n 0x0000000000000010,0x0000000000000010,0x0000000000000010,0x0000000000000010,\n 0x0000000000001010,0x0000000000001010,0x0000000000001010,0x0000000000001010,),\n (0x0000000000000000,0x0000000000000040,0x0000010000000000,0x0000010000000040,\n 0x0000000000200000,0x0000000000200040,0x0000010000200000,0x0000010000200040,\n 0x0000000000008000,0x0000000000008040,0x0000010000008000,0x0000010000008040,\n 0x0000000000208000,0x0000000000208040,0x0000010000208000,0x0000010000208040,),\n (0x0000000000000000,0x0000000004000000,0x0000000008000000,0x000000000c000000,\n 0x0400000000000000,0x0400000004000000,0x0400000008000000,0x040000000c000000,\n 0x8000000000000000,0x8000000004000000,0x8000000008000000,0x800000000c000000,\n 0x8400000000000000,0x8400000004000000,0x8400000008000000,0x840000000c000000,),\n (0x0000000000000000,0x0002000000000000,0x0200000000000000,0x0202000000000000,\n 0x1000000000000000,0x1002000000000000,0x1200000000000000,0x1202000000000000,\n 0x0008000000000000,0x000a000000000000,0x0208000000000000,0x020a000000000000,\n 0x1008000000000000,0x100a000000000000,0x1208000000000000,0x120a000000000000,),\n (0x0000000000000000,0x0000000000400000,0x0000000000000020,0x0000000000400020,\n 0x0040000000000000,0x0040000000400000,0x0040000000000020,0x0040000000400020,\n 0x0800000000000000,0x0800000000400000,0x0800000000000020,0x0800000000400020,\n 0x0840000000000000,0x0840000000400000,0x0840000000000020,0x0840000000400020,),\n (0x0000000000000000,0x0080000000000000,0x0000008000000000,0x0080008000000000,\n 0x2000000000000000,0x2080000000000000,0x2000008000000000,0x2080008000000000,\n 0x0020000000000000,0x00a0000000000000,0x0020008000000000,0x00a0008000000000,\n 0x2020000000000000,0x20a0000000000000,0x2020008000000000,0x20a0008000000000,),\n (0x0000000000000000,0x0000002000000000,0x0000040000000000,0x0000042000000000,\n 0x4000000000000000,0x4000002000000000,0x4000040000000000,0x4000042000000000,\n 0x0000400000000000,0x0000402000000000,0x0000440000000000,0x0000442000000000,\n 0x4000400000000000,0x4000402000000000,0x4000440000000000,0x4000442000000000,),\n (0x0000000000000000,0x0000004000000000,0x0000200000000000,0x0000204000000000,\n 0x0000080000000000,0x0000084000000000,0x0000280000000000,0x0000284000000000,\n 0x0000800000000000,0x0000804000000000,0x0000a00000000000,0x0000a04000000000,\n 0x0000880000000000,0x0000884000000000,0x0000a80000000000,0x0000a84000000000,),\n (0x0000000000000000,0x0000000800000000,0x0000000400000000,0x0000000c00000000,\n 0x0000100000000000,0x0000100800000000,0x0000100400000000,0x0000100c00000000,\n 0x0010000000000000,0x0010000800000000,0x0010000400000000,0x0010000c00000000,\n 0x0010100000000000,0x0010100800000000,0x0010100400000000,0x0010100c00000000,),\n (0x0000000000000000,0x0100000000000000,0x0001000000000000,0x0101000000000000,\n 0x0000001000000000,0x0100001000000000,0x0001001000000000,0x0101001000000000,\n 0x0004000000000000,0x0104000000000000,0x0005000000000000,0x0105000000000000,\n 0x0004001000000000,0x0104001000000000,0x0005001000000000,0x0105001000000000,),\n )\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n PCXROT=(\n (PC1ROT,PC2ROTA),(PC2ROTB,PC2ROTB),\n (PC2ROTB,PC2ROTB),(PC2ROTB,PC2ROTB),\n (PC2ROTA,PC2ROTB),(PC2ROTB,PC2ROTB),\n (PC2ROTB,PC2ROTB),(PC2ROTB,PC2ROTA),\n )\n \n \n \n \n \n \n IE3264=(\n (0x0000000000000000,0x0000000000800800,0x0000000000008008,0x0000000000808808,\n 0x0000008008000000,0x0000008008800800,0x0000008008008008,0x0000008008808808,\n 0x0000000080080000,0x0000000080880800,0x0000000080088008,0x0000000080888808,\n 0x0000008088080000,0x0000008088880800,0x0000008088088008,0x0000008088888808,),\n (0x0000000000000000,0x0080080000000000,0x0000800800000000,0x0080880800000000,\n 0x0800000000000080,0x0880080000000080,0x0800800800000080,0x0880880800000080,\n 0x8008000000000000,0x8088080000000000,0x8008800800000000,0x8088880800000000,\n 0x8808000000000080,0x8888080000000080,0x8808800800000080,0x8888880800000080,),\n (0x0000000000000000,0x0000000000001000,0x0000000000000010,0x0000000000001010,\n 0x0000000010000000,0x0000000010001000,0x0000000010000010,0x0000000010001010,\n 0x0000000000100000,0x0000000000101000,0x0000000000100010,0x0000000000101010,\n 0x0000000010100000,0x0000000010101000,0x0000000010100010,0x0000000010101010,),\n (0x0000000000000000,0x0000100000000000,0x0000001000000000,0x0000101000000000,\n 0x1000000000000000,0x1000100000000000,0x1000001000000000,0x1000101000000000,\n 0x0010000000000000,0x0010100000000000,0x0010001000000000,0x0010101000000000,\n 0x1010000000000000,0x1010100000000000,0x1010001000000000,0x1010101000000000,),\n (0x0000000000000000,0x0000000000002000,0x0000000000000020,0x0000000000002020,\n 0x0000000020000000,0x0000000020002000,0x0000000020000020,0x0000000020002020,\n 0x0000000000200000,0x0000000000202000,0x0000000000200020,0x0000000000202020,\n 0x0000000020200000,0x0000000020202000,0x0000000020200020,0x0000000020202020,),\n (0x0000000000000000,0x0000200000000000,0x0000002000000000,0x0000202000000000,\n 0x2000000000000000,0x2000200000000000,0x2000002000000000,0x2000202000000000,\n 0x0020000000000000,0x0020200000000000,0x0020002000000000,0x0020202000000000,\n 0x2020000000000000,0x2020200000000000,0x2020002000000000,0x2020202000000000,),\n (0x0000000000000000,0x0000000000004004,0x0400000000000040,0x0400000000004044,\n 0x0000000040040000,0x0000000040044004,0x0400000040040040,0x0400000040044044,\n 0x0000000000400400,0x0000000000404404,0x0400000000400440,0x0400000000404444,\n 0x0000000040440400,0x0000000040444404,0x0400000040440440,0x0400000040444444,),\n (0x0000000000000000,0x0000400400000000,0x0000004004000000,0x0000404404000000,\n 0x4004000000000000,0x4004400400000000,0x4004004004000000,0x4004404404000000,\n 0x0040040000000000,0x0040440400000000,0x0040044004000000,0x0040444404000000,\n 0x4044040000000000,0x4044440400000000,0x4044044004000000,0x4044444404000000,),\n )\n \n \n \n \n SPE=(\n (0x0080088008200000,0x0000008008000000,0x0000000000200020,0x0080088008200020,\n 0x0000000000200000,0x0080088008000020,0x0000008008000020,0x0000000000200020,\n 0x0080088008000020,0x0080088008200000,0x0000008008200000,0x0080080000000020,\n 0x0080080000200020,0x0000000000200000,0x0000000000000000,0x0000008008000020,\n 0x0000008008000000,0x0000000000000020,0x0080080000200000,0x0080088008000000,\n 0x0080088008200020,0x0000008008200000,0x0080080000000020,0x0080080000200000,\n 0x0000000000000020,0x0080080000000000,0x0080088008000000,0x0000008008200020,\n 0x0080080000000000,0x0080080000200020,0x0000008008200020,0x0000000000000000,\n 0x0000000000000000,0x0080088008200020,0x0080080000200000,0x0000008008000020,\n 0x0080088008200000,0x0000008008000000,0x0080080000000020,0x0080080000200000,\n 0x0000008008200020,0x0080080000000000,0x0080088008000000,0x0000000000200020,\n 0x0080088008000020,0x0000000000000020,0x0000000000200020,0x0000008008200000,\n 0x0080088008200020,0x0080088008000000,0x0000008008200000,0x0080080000200020,\n 0x0000000000200000,0x0080080000000020,0x0000008008000020,0x0000000000000000,\n 0x0000008008000000,0x0000000000200000,0x0080080000200020,0x0080088008200000,\n 0x0000000000000020,0x0000008008200020,0x0080080000000000,0x0080088008000020,),\n (0x1000800810004004,0x0000000000000000,0x0000800810000000,0x0000000010004004,\n 0x1000000000004004,0x1000800800000000,0x0000800800004004,0x0000800810000000,\n 0x0000800800000000,0x1000000010004004,0x1000000000000000,0x0000800800004004,\n 0x1000000010000000,0x0000800810004004,0x0000000010004004,0x1000000000000000,\n 0x0000000010000000,0x1000800800004004,0x1000000010004004,0x0000800800000000,\n 0x1000800810000000,0x0000000000004004,0x0000000000000000,0x1000000010000000,\n 0x1000800800004004,0x1000800810000000,0x0000800810004004,0x1000000000004004,\n 0x0000000000004004,0x0000000010000000,0x1000800800000000,0x1000800810004004,\n 0x1000000010000000,0x0000800810004004,0x0000800800004004,0x1000800810000000,\n 0x1000800810004004,0x1000000010000000,0x1000000000004004,0x0000000000000000,\n 0x0000000000004004,0x1000800800000000,0x0000000010000000,0x1000000010004004,\n 0x0000800800000000,0x0000000000004004,0x1000800810000000,0x1000800800004004,\n 0x0000800810004004,0x0000800800000000,0x0000000000000000,0x1000000000004004,\n 0x1000000000000000,0x1000800810004004,0x0000800810000000,0x0000000010004004,\n 0x1000000010004004,0x0000000010000000,0x1000800800000000,0x0000800800004004,\n 0x1000800800004004,0x1000000000000000,0x0000000010004004,0x0000800810000000,),\n (0x0000000000400410,0x0010004004400400,0x0010000000000000,0x0010000000400410,\n 0x0000004004000010,0x0000000000400400,0x0010000000400410,0x0010004004000000,\n 0x0010000000400400,0x0000004004000000,0x0000004004400400,0x0000000000000010,\n 0x0010004004400410,0x0010000000000010,0x0000000000000010,0x0000004004400410,\n 0x0000000000000000,0x0000004004000010,0x0010004004400400,0x0010000000000000,\n 0x0010000000000010,0x0010004004400410,0x0000004004000000,0x0000000000400410,\n 0x0000004004400410,0x0010000000400400,0x0010004004000010,0x0000004004400400,\n 0x0010004004000000,0x0000000000000000,0x0000000000400400,0x0010004004000010,\n 0x0010004004400400,0x0010000000000000,0x0000000000000010,0x0000004004000000,\n 0x0010000000000010,0x0000004004000010,0x0000004004400400,0x0010000000400410,\n 0x0000000000000000,0x0010004004400400,0x0010004004000000,0x0000004004400410,\n 0x0000004004000010,0x0000000000400400,0x0010004004400410,0x0000000000000010,\n 0x0010004004000010,0x0000000000400410,0x0000000000400400,0x0010004004400410,\n 0x0000004004000000,0x0010000000400400,0x0010000000400410,0x0010004004000000,\n 0x0010000000400400,0x0000000000000000,0x0000004004400410,0x0010000000000010,\n 0x0000000000400410,0x0010004004000010,0x0010000000000000,0x0000004004400400,),\n (0x0800100040040080,0x0000100000001000,0x0800000000000080,0x0800100040041080,\n 0x0000000000000000,0x0000000040041000,0x0800100000001080,0x0800000040040080,\n 0x0000100040041000,0x0800000000001080,0x0000000000001000,0x0800100000000080,\n 0x0800000000001080,0x0800100040040080,0x0000000040040000,0x0000000000001000,\n 0x0800000040041080,0x0000100040040000,0x0000100000000000,0x0800000000000080,\n 0x0000100040040000,0x0800100000001080,0x0000000040041000,0x0000100000000000,\n 0x0800100000000080,0x0000000000000000,0x0800000040040080,0x0000100040041000,\n 0x0000100000001000,0x0800000040041080,0x0800100040041080,0x0000000040040000,\n 0x0800000040041080,0x0800100000000080,0x0000000040040000,0x0800000000001080,\n 0x0000100040040000,0x0000100000001000,0x0800000000000080,0x0000000040041000,\n 0x0800100000001080,0x0000000000000000,0x0000100000000000,0x0800000040040080,\n 0x0000000000000000,0x0800000040041080,0x0000100040041000,0x0000100000000000,\n 0x0000000000001000,0x0800100040041080,0x0800100040040080,0x0000000040040000,\n 0x0800100040041080,0x0800000000000080,0x0000100000001000,0x0800100040040080,\n 0x0800000040040080,0x0000100040040000,0x0000000040041000,0x0800100000001080,\n 0x0800100000000080,0x0000000000001000,0x0800000000001080,0x0000100040041000,),\n (0x0000000000800800,0x0000001000000000,0x0040040000000000,0x2040041000800800,\n 0x2000001000800800,0x0040040000800800,0x2040041000000000,0x0000001000800800,\n 0x0000001000000000,0x2000000000000000,0x2000000000800800,0x0040041000000000,\n 0x2040040000800800,0x2000001000800800,0x0040041000800800,0x0000000000000000,\n 0x0040041000000000,0x0000000000800800,0x2000001000000000,0x2040040000000000,\n 0x0040040000800800,0x2040041000000000,0x0000000000000000,0x2000000000800800,\n 0x2000000000000000,0x2040040000800800,0x2040041000800800,0x2000001000000000,\n 0x0000001000800800,0x0040040000000000,0x2040040000000000,0x0040041000800800,\n 0x0040041000800800,0x2040040000800800,0x2000001000000000,0x0000001000800800,\n 0x0000001000000000,0x2000000000000000,0x2000000000800800,0x0040040000800800,\n 0x0000000000800800,0x0040041000000000,0x2040041000800800,0x0000000000000000,\n 0x2040041000000000,0x0000000000800800,0x0040040000000000,0x2000001000000000,\n 0x2040040000800800,0x0040040000000000,0x0000000000000000,0x2040041000800800,\n 0x2000001000800800,0x0040041000800800,0x2040040000000000,0x0000001000000000,\n 0x0040041000000000,0x2000001000800800,0x0040040000800800,0x2040040000000000,\n 0x2000000000000000,0x2040041000000000,0x0000001000800800,0x2000000000800800,),\n (0x4004000000008008,0x4004000020000000,0x0000000000000000,0x0000200020008008,\n 0x4004000020000000,0x0000200000000000,0x4004200000008008,0x0000000020000000,\n 0x4004200000000000,0x4004200020008008,0x0000200020000000,0x0000000000008008,\n 0x0000200000008008,0x4004000000008008,0x0000000020008008,0x4004200020000000,\n 0x0000000020000000,0x4004200000008008,0x4004000020008008,0x0000000000000000,\n 0x0000200000000000,0x4004000000000000,0x0000200020008008,0x4004000020008008,\n 0x4004200020008008,0x0000000020008008,0x0000000000008008,0x4004200000000000,\n 0x4004000000000000,0x0000200020000000,0x4004200020000000,0x0000200000008008,\n 0x4004200000000000,0x0000000000008008,0x0000200000008008,0x4004200020000000,\n 0x0000200020008008,0x4004000020000000,0x0000000000000000,0x0000200000008008,\n 0x0000000000008008,0x0000200000000000,0x4004000020008008,0x0000000020000000,\n 0x4004000020000000,0x4004200020008008,0x0000200020000000,0x4004000000000000,\n 0x4004200020008008,0x0000200020000000,0x0000000020000000,0x4004200000008008,\n 0x4004000000008008,0x0000000020008008,0x4004200020000000,0x0000000000000000,\n 0x0000200000000000,0x4004000000008008,0x4004200000008008,0x0000200020008008,\n 0x0000000020008008,0x4004200000000000,0x4004000000000000,0x4004000020008008,),\n (0x0000400400000000,0x0020000000000000,0x0020000000100000,0x0400000000100040,\n 0x0420400400100040,0x0400400400000040,0x0020400400000000,0x0000000000000000,\n 0x0000000000100000,0x0420000000100040,0x0420000000000040,0x0000400400100000,\n 0x0400000000000040,0x0020400400100000,0x0000400400100000,0x0420000000000040,\n 0x0420000000100040,0x0000400400000000,0x0400400400000040,0x0420400400100040,\n 0x0000000000000000,0x0020000000100000,0x0400000000100040,0x0020400400000000,\n 0x0400400400100040,0x0420400400000040,0x0020400400100000,0x0400000000000040,\n 0x0420400400000040,0x0400400400100040,0x0020000000000000,0x0000000000100000,\n 0x0420400400000040,0x0000400400100000,0x0400400400100040,0x0420000000000040,\n 0x0000400400000000,0x0020000000000000,0x0000000000100000,0x0400400400100040,\n 0x0420000000100040,0x0420400400000040,0x0020400400000000,0x0000000000000000,\n 0x0020000000000000,0x0400000000100040,0x0400000000000040,0x0020000000100000,\n 0x0000000000000000,0x0420000000100040,0x0020000000100000,0x0020400400000000,\n 0x0420000000000040,0x0000400400000000,0x0420400400100040,0x0000000000100000,\n 0x0020400400100000,0x0400000000000040,0x0400400400000040,0x0420400400100040,\n 0x0400000000100040,0x0020400400100000,0x0000400400100000,0x0400400400000040,),\n (0x8008000080082000,0x0000002080082000,0x8008002000000000,0x0000000000000000,\n 0x0000002000002000,0x8008000080080000,0x0000000080082000,0x8008002080082000,\n 0x8008000000000000,0x0000000000002000,0x0000002080080000,0x8008002000000000,\n 0x8008002080080000,0x8008002000002000,0x8008000000002000,0x0000000080082000,\n 0x0000002000000000,0x8008002080080000,0x8008000080080000,0x0000002000002000,\n 0x8008002080082000,0x8008000000002000,0x0000000000000000,0x0000002080080000,\n 0x0000000000002000,0x0000000080080000,0x8008002000002000,0x8008000080082000,\n 0x0000000080080000,0x0000002000000000,0x0000002080082000,0x8008000000000000,\n 0x0000000080080000,0x0000002000000000,0x8008000000002000,0x8008002080082000,\n 0x8008002000000000,0x0000000000002000,0x0000000000000000,0x0000002080080000,\n 0x8008000080082000,0x8008002000002000,0x0000002000002000,0x8008000080080000,\n 0x0000002080082000,0x8008000000000000,0x8008000080080000,0x0000002000002000,\n 0x8008002080082000,0x0000000080080000,0x0000000080082000,0x8008000000002000,\n 0x0000002080080000,0x8008002000000000,0x8008002000002000,0x0000000080082000,\n 0x8008000000000000,0x0000002080082000,0x8008002080080000,0x0000000000000000,\n 0x0000000000002000,0x8008000080082000,0x0000002000000000,0x8008002080080000,),\n )\n \n \n \n \n \n \n CF6464=(\n (0x0000000000000000,0x0000002000000000,0x0000200000000000,0x0000202000000000,\n 0x0020000000000000,0x0020002000000000,0x0020200000000000,0x0020202000000000,\n 0x2000000000000000,0x2000002000000000,0x2000200000000000,0x2000202000000000,\n 0x2020000000000000,0x2020002000000000,0x2020200000000000,0x2020202000000000,),\n (0x0000000000000000,0x0000000200000000,0x0000020000000000,0x0000020200000000,\n 0x0002000000000000,0x0002000200000000,0x0002020000000000,0x0002020200000000,\n 0x0200000000000000,0x0200000200000000,0x0200020000000000,0x0200020200000000,\n 0x0202000000000000,0x0202000200000000,0x0202020000000000,0x0202020200000000,),\n (0x0000000000000000,0x0000000000000020,0x0000000000002000,0x0000000000002020,\n 0x0000000000200000,0x0000000000200020,0x0000000000202000,0x0000000000202020,\n 0x0000000020000000,0x0000000020000020,0x0000000020002000,0x0000000020002020,\n 0x0000000020200000,0x0000000020200020,0x0000000020202000,0x0000000020202020,),\n (0x0000000000000000,0x0000000000000002,0x0000000000000200,0x0000000000000202,\n 0x0000000000020000,0x0000000000020002,0x0000000000020200,0x0000000000020202,\n 0x0000000002000000,0x0000000002000002,0x0000000002000200,0x0000000002000202,\n 0x0000000002020000,0x0000000002020002,0x0000000002020200,0x0000000002020202,),\n (0x0000000000000000,0x0000008000000000,0x0000800000000000,0x0000808000000000,\n 0x0080000000000000,0x0080008000000000,0x0080800000000000,0x0080808000000000,\n 0x8000000000000000,0x8000008000000000,0x8000800000000000,0x8000808000000000,\n 0x8080000000000000,0x8080008000000000,0x8080800000000000,0x8080808000000000,),\n (0x0000000000000000,0x0000000800000000,0x0000080000000000,0x0000080800000000,\n 0x0008000000000000,0x0008000800000000,0x0008080000000000,0x0008080800000000,\n 0x0800000000000000,0x0800000800000000,0x0800080000000000,0x0800080800000000,\n 0x0808000000000000,0x0808000800000000,0x0808080000000000,0x0808080800000000,),\n (0x0000000000000000,0x0000000000000080,0x0000000000008000,0x0000000000008080,\n 0x0000000000800000,0x0000000000800080,0x0000000000808000,0x0000000000808080,\n 0x0000000080000000,0x0000000080000080,0x0000000080008000,0x0000000080008080,\n 0x0000000080800000,0x0000000080800080,0x0000000080808000,0x0000000080808080,),\n (0x0000000000000000,0x0000000000000008,0x0000000000000800,0x0000000000000808,\n 0x0000000000080000,0x0000000000080008,0x0000000000080800,0x0000000000080808,\n 0x0000000008000000,0x0000000008000008,0x0000000008000800,0x0000000008000808,\n 0x0000000008080000,0x0000000008080008,0x0000000008080800,0x0000000008080808,),\n (0x0000000000000000,0x0000001000000000,0x0000100000000000,0x0000101000000000,\n 0x0010000000000000,0x0010001000000000,0x0010100000000000,0x0010101000000000,\n 0x1000000000000000,0x1000001000000000,0x1000100000000000,0x1000101000000000,\n 0x1010000000000000,0x1010001000000000,0x1010100000000000,0x1010101000000000,),\n (0x0000000000000000,0x0000000100000000,0x0000010000000000,0x0000010100000000,\n 0x0001000000000000,0x0001000100000000,0x0001010000000000,0x0001010100000000,\n 0x0100000000000000,0x0100000100000000,0x0100010000000000,0x0100010100000000,\n 0x0101000000000000,0x0101000100000000,0x0101010000000000,0x0101010100000000,),\n (0x0000000000000000,0x0000000000000010,0x0000000000001000,0x0000000000001010,\n 0x0000000000100000,0x0000000000100010,0x0000000000101000,0x0000000000101010,\n 0x0000000010000000,0x0000000010000010,0x0000000010001000,0x0000000010001010,\n 0x0000000010100000,0x0000000010100010,0x0000000010101000,0x0000000010101010,),\n (0x0000000000000000,0x0000000000000001,0x0000000000000100,0x0000000000000101,\n 0x0000000000010000,0x0000000000010001,0x0000000000010100,0x0000000000010101,\n 0x0000000001000000,0x0000000001000001,0x0000000001000100,0x0000000001000101,\n 0x0000000001010000,0x0000000001010001,0x0000000001010100,0x0000000001010101,),\n (0x0000000000000000,0x0000004000000000,0x0000400000000000,0x0000404000000000,\n 0x0040000000000000,0x0040004000000000,0x0040400000000000,0x0040404000000000,\n 0x4000000000000000,0x4000004000000000,0x4000400000000000,0x4000404000000000,\n 0x4040000000000000,0x4040004000000000,0x4040400000000000,0x4040404000000000,),\n (0x0000000000000000,0x0000000400000000,0x0000040000000000,0x0000040400000000,\n 0x0004000000000000,0x0004000400000000,0x0004040000000000,0x0004040400000000,\n 0x0400000000000000,0x0400000400000000,0x0400040000000000,0x0400040400000000,\n 0x0404000000000000,0x0404000400000000,0x0404040000000000,0x0404040400000000,),\n (0x0000000000000000,0x0000000000000040,0x0000000000004000,0x0000000000004040,\n 0x0000000000400000,0x0000000000400040,0x0000000000404000,0x0000000000404040,\n 0x0000000040000000,0x0000000040000040,0x0000000040004000,0x0000000040004040,\n 0x0000000040400000,0x0000000040400040,0x0000000040404000,0x0000000040404040,),\n (0x0000000000000000,0x0000000000000004,0x0000000000000400,0x0000000000000404,\n 0x0000000000040000,0x0000000000040004,0x0000000000040400,0x0000000000040404,\n 0x0000000004000000,0x0000000004000004,0x0000000004000400,0x0000000004000404,\n 0x0000000004040000,0x0000000004040004,0x0000000004040400,0x0000000004040404,),\n )\n \n \n \n \n \n \n \n \ndef _permute(c,p):\n ''\n \n \n \n out=0\n for r in p:\n  out |=r[c&0xf]\n  c >>=4\n return out\n \n \n \n \n \n_uint64_struct=struct.Struct(\">Q\")\n\ndef _pack64(value):\n return _uint64_struct.pack(value)\n \ndef _unpack64(value):\n return _uint64_struct.unpack(value)[0]\n \ndef _pack56(value):\n return _uint64_struct.pack(value)[1:]\n \ndef _unpack56(value):\n return _uint64_struct.unpack(b'\\x00'+value)[0]\n \n \n \n \n \n \n \n \n \n \n \n \n_EXPAND_ITER=irange(49,-7,-7)\n\ndef expand_des_key(key):\n ''\n if isinstance(key,bytes):\n  if len(key)!=7:\n   raise ValueError(\"key must be 7 bytes in size\")\n elif isinstance(key,int_types):\n  if key <0 or key >INT_56_MASK:\n   raise ValueError(\"key must be 56-bit non-negative integer\")\n  return _unpack64(expand_des_key(_pack56(key)))\n else :\n  raise exc.ExpectedTypeError(key,\"bytes or int\",\"key\")\n key=_unpack56(key)\n \n \n \n \n \n \n return join_byte_values(((key >>shift)&0x7f)<<1 for shift in _EXPAND_ITER)\n \ndef shrink_des_key(key):\n ''\n if isinstance(key,bytes):\n  if len(key)!=8:\n   raise ValueError(\"key must be 8 bytes in size\")\n  return _pack56(shrink_des_key(_unpack64(key)))\n elif isinstance(key,int_types):\n  if key <0 or key >INT_64_MASK:\n   raise ValueError(\"key must be 64-bit non-negative integer\")\n else :\n  raise exc.ExpectedTypeError(key,\"bytes or int\",\"key\")\n key >>=1\n result=0\n offset=0\n while offset <56:\n  result |=(key&0x7f)<<offset\n  key >>=8\n  offset +=7\n assert not (result&~INT_64_MASK)\n return result\n \n \n \n \ndef des_encrypt_block(key,input,salt=0,rounds=1):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if isinstance(key,bytes):\n  if len(key)==7:\n   key=expand_des_key(key)\n  elif len(key)!=8:\n   raise ValueError(\"key must be 7 or 8 bytes\")\n  key=_unpack64(key)\n else :\n  raise exc.ExpectedTypeError(key,\"bytes\",\"key\")\n  \n  \n if isinstance(input,bytes):\n  if len(input)!=8:\n   raise ValueError(\"input block must be 8 bytes\")\n  input=_unpack64(input)\n else :\n  raise exc.ExpectedTypeError(input,\"bytes\",\"input\")\n  \n  \n result=des_encrypt_int_block(key,input,salt,rounds)\n \n \n return _pack64(result)\n \ndef des_encrypt_int_block(key,input,salt=0,rounds=1):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n if rounds <1:\n  raise ValueError(\"rounds must be positive integer\")\n if salt <0 or salt >INT_24_MASK:\n  raise ValueError(\"salt must be 24-bit non-negative integer\")\n  \n  \n if not isinstance(key,int_types):\n  raise exc.ExpectedTypeError(key,\"int\",\"key\")\n elif key <0 or key >INT_64_MASK:\n  raise ValueError(\"key must be 64-bit non-negative integer\")\n  \n  \n if not isinstance(input,int_types):\n  raise exc.ExpectedTypeError(input,\"int\",\"input\")\n elif input <0 or input >INT_64_MASK:\n  raise ValueError(\"input must be 64-bit non-negative integer\")\n  \n  \n  \n  \n  \n global SPE,PCXROT,IE3264,CF6464\n if PCXROT is None :\n  _load_tables()\n  \n  \n SPE0,SPE1,SPE2,SPE3,SPE4,SPE5,SPE6,SPE7=SPE\n \n \n \n \n \n \n \n def _iter_key_schedule(ks_odd):\n  ''\n  for p_even,p_odd in PCXROT:\n   ks_even=_permute(ks_odd,p_even)\n   ks_odd=_permute(ks_even,p_odd)\n   yield ks_even&_KS_MASK,ks_odd&_KS_MASK\n ks_list=list(_iter_key_schedule(key))\n \n \n salt=(\n ((salt&0x00003f)<<26)|\n ((salt&0x000fc0)<<12)|\n ((salt&0x03f000)>>2)|\n ((salt&0xfc0000)>>16)\n )\n \n \n if input ==0:\n  L=R=0\n else :\n  L=((input >>31)&0xaaaaaaaa)|(input&0x55555555)\n  L=_permute(L,IE3264)\n  \n  R=((input >>32)&0xaaaaaaaa)|((input >>1)&0x55555555)\n  R=_permute(R,IE3264)\n  \n  \n  \n  \n while rounds:\n  rounds -=1\n  \n  \n  for ks_even,ks_odd in ks_list:\n   k=((R >>32)^R)&salt\n   B=(k <<32)^k ^R ^ks_even\n   \n   L ^=(SPE0[(B >>58)&0x3f]^SPE1[(B >>50)&0x3f]^\n   SPE2[(B >>42)&0x3f]^SPE3[(B >>34)&0x3f]^\n   SPE4[(B >>26)&0x3f]^SPE5[(B >>18)&0x3f]^\n   SPE6[(B >>10)&0x3f]^SPE7[(B >>2)&0x3f])\n   \n   k=((L >>32)^L)&salt\n   B=(k <<32)^k ^L ^ks_odd\n   \n   R ^=(SPE0[(B >>58)&0x3f]^SPE1[(B >>50)&0x3f]^\n   SPE2[(B >>42)&0x3f]^SPE3[(B >>34)&0x3f]^\n   SPE4[(B >>26)&0x3f]^SPE5[(B >>18)&0x3f]^\n   SPE6[(B >>10)&0x3f]^SPE7[(B >>2)&0x3f])\n   \n   \n  L,R=R,L\n  \n  \n  \n  \n C=(\n ((L >>3)&0x0f0f0f0f00000000)\n |\n ((L <<33)&0xf0f0f0f000000000)\n |\n ((R >>35)&0x000000000f0f0f0f)\n |\n ((R <<1)&0x00000000f0f0f0f0)\n )\n return _permute(C,CF6464)\n \n \n \n \n", ["passlib", "passlib.utils.compat", "struct"]], "passlib.Lib.site-packages.passlib.crypto._blowfish.unrolled": [".py", "''\n\n\n\n\n\n\n\n\n\nfrom passlib.crypto._blowfish.base import BlowfishEngine as _BlowfishEngine\n\n__all__=[\n\"BlowfishEngine\",\n]\n\n\n\nclass BlowfishEngine(_BlowfishEngine):\n\n def encipher(self,l,r):\n  ''\n  \n  (p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,\n  p10,p11,p12,p13,p14,p15,p16,p17)=self.P\n  S0,S1,S2,S3=self.S\n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  \n  return r ^p17,l\n  \n def expand(self,key_words):\n  ''\n  \n  \n  P,S=self.P,self.S\n  S0,S1,S2,S3=S\n  \n  \n  \n  \n  p0=P[0]^key_words[0]\n  p1=P[1]^key_words[1]\n  p2=P[2]^key_words[2]\n  p3=P[3]^key_words[3]\n  p4=P[4]^key_words[4]\n  p5=P[5]^key_words[5]\n  p6=P[6]^key_words[6]\n  p7=P[7]^key_words[7]\n  p8=P[8]^key_words[8]\n  p9=P[9]^key_words[9]\n  p10=P[10]^key_words[10]\n  p11=P[11]^key_words[11]\n  p12=P[12]^key_words[12]\n  p13=P[13]^key_words[13]\n  p14=P[14]^key_words[14]\n  p15=P[15]^key_words[15]\n  p16=P[16]^key_words[16]\n  p17=P[17]^key_words[17]\n  \n  \n  \n  \n  \n  \n  \n  \n  l,r=p0,0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  \n  p0,p1=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p2,p3=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p4,p5=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p6,p7=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p8,p9=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p10,p11=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p12,p13=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p14,p15=l,r=r ^p17,l\n  \n  \n  \n  \n  l ^=p0\n  \n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p1\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p2\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p3\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p4\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p5\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p6\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p7\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p8\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p9\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p10\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p11\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p12\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p13\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p14\n  \n  r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n  S3[l&0xff])&0xffffffff)^p15\n  \n  \n  l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n  S3[r&0xff])&0xffffffff)^p16\n  p16,p17=l,r=r ^p17,l\n  \n  \n  \n  \n  \n  P[:]=(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,\n  p10,p11,p12,p13,p14,p15,p16,p17)\n  \n  \n  \n  \n  \n  for box in S:\n   j=0\n   while j <256:\n    l ^=p0\n    \n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p1\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p2\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p3\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p4\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p5\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p6\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p7\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p8\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p9\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p10\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p11\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p12\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p13\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p14\n    \n    r ^=((((S0[l >>24]+S1[(l >>16)&0xff])^S2[(l >>8)&0xff])+\n    S3[l&0xff])&0xffffffff)^p15\n    \n    \n    l ^=((((S0[r >>24]+S1[(r >>16)&0xff])^S2[(r >>8)&0xff])+\n    S3[r&0xff])&0xffffffff)^p16\n    \n    box[j],box[j+1]=l,r=r ^p17,l\n    j +=2\n    \n    \n    \n    \n    \n    \n    \n", ["passlib.crypto._blowfish.base"]], "passlib.Lib.site-packages.passlib.crypto._blowfish": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom itertools import chain\nimport struct\n\nfrom passlib.utils import getrandbytes,rng\nfrom passlib.utils.binary import bcrypt64\nfrom passlib.utils.compat import BytesIO,unicode,u,native_string_types\nfrom passlib.crypto._blowfish.unrolled import BlowfishEngine\n\n__all__=[\n'BlowfishEngine',\n'raw_bcrypt',\n]\n\n\n\n\n\n\nBCRYPT_CDATA=[\n0x4f727068,0x65616e42,0x65686f6c,\n0x64657253,0x63727944,0x6f756274\n]\n\n\ndigest_struct=struct.Struct(\">6I\")\n\n\n\n\n\n\n\nBNULL=b'\\x00'\n\ndef raw_bcrypt(password,ident,salt,log_rounds):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n assert isinstance(ident,native_string_types)\n add_null_padding=True\n if ident ==u('2a')or ident ==u('2y')or ident ==u('2b'):\n  pass\n elif ident ==u('2'):\n  add_null_padding=False\n elif ident ==u('2x'):\n  raise ValueError(\"crypt_blowfish's buggy '2x' hashes are not \"\n  \"currently supported\")\n else :\n  raise ValueError(\"unknown ident: %r\"%(ident,))\n  \n  \n assert isinstance(salt,bytes)\n salt=bcrypt64.decode_bytes(salt)\n if len(salt)<16:\n  raise ValueError(\"Missing salt bytes\")\n elif len(salt)>16:\n  salt=salt[:16]\n  \n  \n assert isinstance(password,bytes)\n if add_null_padding:\n  password +=BNULL\n  \n  \n if log_rounds <4 or log_rounds >31:\n  raise ValueError(\"Bad number of rounds\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n engine=BlowfishEngine()\n \n \n pass_words=engine.key_to_words(password)\n salt_words=engine.key_to_words(salt)\n \n \n \n salt_words16=salt_words[:4]\n \n \n engine.eks_salted_expand(pass_words,salt_words16)\n \n \n rounds=1 <<log_rounds\n engine.eks_repeated_expand(pass_words,salt_words,rounds)\n \n \n data=list(BCRYPT_CDATA)\n i=0\n while i <6:\n  data[i],data[i+1]=engine.repeat_encipher(data[i],data[i+1],64)\n  i +=2\n raw=digest_struct.pack(*data)[:-1]\n return bcrypt64.encode_bytes(raw)\n \n \n \n \n", ["itertools", "passlib.crypto._blowfish.unrolled", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "struct"], 1], "passlib.Lib.site-packages.passlib.crypto._blowfish._gen_files": [".py", "''\n\n\n\n\nimport os\nimport textwrap\n\nfrom passlib.utils.compat import irange\n\n\n\n\n\ndef varlist(name,count):\n return \", \".join(name+str(x)for x in irange(count))\n \n \ndef indent_block(block,padding):\n ''\n lines=block.split(\"\\n\")\n return \"\\n\".join(\n padding+line if line else \"\"\n for line in lines\n )\n \nBFSTR=\"\"\"\\\n                ((((S0[l >> 24] + S1[(l >> 16) & 0xff]) ^ S2[(l >> 8) & 0xff]) +\n                  S3[l & 0xff]) & 0xffffffff)\n\"\"\".strip()\n\ndef render_encipher(write,indent=0):\n for i in irange(0,15,2):\n  write(indent,\"\"\"\\\n            # Feistel substitution on left word (round %(i)d)\n            r ^= %(left)s ^ p%(i1)d\n\n            # Feistel substitution on right word (round %(i1)d)\n            l ^= %(right)s ^ p%(i2)d\n        \"\"\",i=i,i1=i+1,i2=i+2,\n  left=BFSTR,right=BFSTR.replace(\"l\",\"r\"),\n  )\n  \ndef write_encipher_function(write,indent=0):\n write(indent,\"\"\"\\\n        def encipher(self, l, r):\n            \\\"\"\"blowfish encipher a single 64-bit block encoded as two 32-bit ints\\\"\"\"\n\n            (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,\n              p10, p11, p12, p13, p14, p15, p16, p17) = self.P\n            S0, S1, S2, S3 = self.S\n\n            l ^= p0\n\n            \"\"\")\n render_encipher(write,indent+1)\n \n write(indent+1,\"\"\"\\\n\n        return r ^ p17, l\n\n        \"\"\")\n \ndef write_expand_function(write,indent=0):\n write(indent,\"\"\"\\\n        def expand(self, key_words):\n            \\\"\"\"unrolled version of blowfish key expansion\\\"\"\"\n            ##assert len(key_words) >= 18, \"size of key_words must be >= 18\"\n\n            P, S = self.P, self.S\n            S0, S1, S2, S3 = S\n\n            #=============================================================\n            # integrate key\n            #=============================================================\n        \"\"\")\n for i in irange(18):\n  write(indent+1,\"\"\"\\\n            p%(i)d = P[%(i)d] ^ key_words[%(i)d]\n        \"\"\",i=i)\n write(indent+1,\"\"\"\\\n\n        #=============================================================\n        # update P\n        #=============================================================\n\n        #------------------------------------------------\n        # update P[0] and P[1]\n        #------------------------------------------------\n        l, r = p0, 0\n\n        \"\"\")\n \n render_encipher(write,indent+1)\n \n write(indent+1,\"\"\"\\\n\n        p0, p1 = l, r = r ^ p17, l\n\n        \"\"\")\n \n for i in irange(2,18,2):\n  write(indent+1,\"\"\"\\\n            #------------------------------------------------\n            # update P[%(i)d] and P[%(i1)d]\n            #------------------------------------------------\n            l ^= p0\n\n            \"\"\",i=i,i1=i+1)\n  \n  render_encipher(write,indent+1)\n  \n  write(indent+1,\"\"\"\\\n            p%(i)d, p%(i1)d = l, r = r ^ p17, l\n\n            \"\"\",i=i,i1=i+1)\n  \n write(indent+1,\"\"\"\\\n\n        #------------------------------------------------\n        # save changes to original P array\n        #------------------------------------------------\n        P[:] = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,\n          p10, p11, p12, p13, p14, p15, p16, p17)\n\n        #=============================================================\n        # update S\n        #=============================================================\n\n        for box in S:\n            j = 0\n            while j < 256:\n                l ^= p0\n\n        \"\"\")\n \n render_encipher(write,indent+3)\n \n write(indent+3,\"\"\"\\\n\n                box[j], box[j+1] = l, r = r ^ p17, l\n                j += 2\n        \"\"\")\n \n \n \n \n \ndef main():\n target=os.path.join(os.path.dirname(__file__),\"unrolled.py\")\n fh=file(target,\"w\")\n \n def write(indent,msg,**kwds):\n  literal=kwds.pop(\"literal\",False )\n  if kwds:\n   msg %=kwds\n  if not literal:\n   msg=textwrap.dedent(msg.rstrip(\" \"))\n  if indent:\n   msg=indent_block(msg,\" \"*(indent *4))\n  fh.write(msg)\n  \n write(0,\"\"\"\\\n        \\\"\"\"passlib.crypto._blowfish.unrolled - unrolled loop implementation of bcrypt,\n        autogenerated by _gen_files.py\n\n        currently this override the encipher() and expand() methods\n        with optimized versions, and leaves the other base.py methods alone.\n        \\\"\"\"\n        #=================================================================\n        # imports\n        #=================================================================\n        # pkg\n        from passlib.crypto._blowfish.base import BlowfishEngine as _BlowfishEngine\n        # local\n        __all__ = [\n            \"BlowfishEngine\",\n        ]\n        #=================================================================\n        #\n        #=================================================================\n        class BlowfishEngine(_BlowfishEngine):\n\n        \"\"\")\n \n write_encipher_function(write,indent=1)\n write_expand_function(write,indent=1)\n \n write(0,\"\"\"\\\n            #=================================================================\n            # eoc\n            #=================================================================\n\n        #=================================================================\n        # eof\n        #=================================================================\n        \"\"\")\n \nif __name__ ==\"__main__\":\n main()\n \n \n \n \n", ["os", "passlib.utils.compat", "textwrap"]], "passlib.Lib.site-packages.passlib.crypto._blowfish.base": [".py", "''\n\n\n\n\nimport struct\n\nfrom passlib.utils import repeat_string\n\n__all__=[\n\"BlowfishEngine\",\n]\n\n\n\n\nBLOWFISH_P=BLOWFISH_S=None\n\ndef _init_constants():\n global BLOWFISH_P,BLOWFISH_S\n \n \n \n \n \n BLOWFISH_P=[\n 0x243f6a88,0x85a308d3,0x13198a2e,0x03707344,\n 0xa4093822,0x299f31d0,0x082efa98,0xec4e6c89,\n 0x452821e6,0x38d01377,0xbe5466cf,0x34e90c6c,\n 0xc0ac29b7,0xc97c50dd,0x3f84d5b5,0xb5470917,\n 0x9216d5d9,0x8979fb1b,\n ]\n \n \n BLOWFISH_S=[\n \n [\n 0xd1310ba6,0x98dfb5ac,0x2ffd72db,0xd01adfb7,\n 0xb8e1afed,0x6a267e96,0xba7c9045,0xf12c7f99,\n 0x24a19947,0xb3916cf7,0x0801f2e2,0x858efc16,\n 0x636920d8,0x71574e69,0xa458fea3,0xf4933d7e,\n 0x0d95748f,0x728eb658,0x718bcd58,0x82154aee,\n 0x7b54a41d,0xc25a59b5,0x9c30d539,0x2af26013,\n 0xc5d1b023,0x286085f0,0xca417918,0xb8db38ef,\n 0x8e79dcb0,0x603a180e,0x6c9e0e8b,0xb01e8a3e,\n 0xd71577c1,0xbd314b27,0x78af2fda,0x55605c60,\n 0xe65525f3,0xaa55ab94,0x57489862,0x63e81440,\n 0x55ca396a,0x2aab10b6,0xb4cc5c34,0x1141e8ce,\n 0xa15486af,0x7c72e993,0xb3ee1411,0x636fbc2a,\n 0x2ba9c55d,0x741831f6,0xce5c3e16,0x9b87931e,\n 0xafd6ba33,0x6c24cf5c,0x7a325381,0x28958677,\n 0x3b8f4898,0x6b4bb9af,0xc4bfe81b,0x66282193,\n 0x61d809cc,0xfb21a991,0x487cac60,0x5dec8032,\n 0xef845d5d,0xe98575b1,0xdc262302,0xeb651b88,\n 0x23893e81,0xd396acc5,0x0f6d6ff3,0x83f44239,\n 0x2e0b4482,0xa4842004,0x69c8f04a,0x9e1f9b5e,\n 0x21c66842,0xf6e96c9a,0x670c9c61,0xabd388f0,\n 0x6a51a0d2,0xd8542f68,0x960fa728,0xab5133a3,\n 0x6eef0b6c,0x137a3be4,0xba3bf050,0x7efb2a98,\n 0xa1f1651d,0x39af0176,0x66ca593e,0x82430e88,\n 0x8cee8619,0x456f9fb4,0x7d84a5c3,0x3b8b5ebe,\n 0xe06f75d8,0x85c12073,0x401a449f,0x56c16aa6,\n 0x4ed3aa62,0x363f7706,0x1bfedf72,0x429b023d,\n 0x37d0d724,0xd00a1248,0xdb0fead3,0x49f1c09b,\n 0x075372c9,0x80991b7b,0x25d479d8,0xf6e8def7,\n 0xe3fe501a,0xb6794c3b,0x976ce0bd,0x04c006ba,\n 0xc1a94fb6,0x409f60c4,0x5e5c9ec2,0x196a2463,\n 0x68fb6faf,0x3e6c53b5,0x1339b2eb,0x3b52ec6f,\n 0x6dfc511f,0x9b30952c,0xcc814544,0xaf5ebd09,\n 0xbee3d004,0xde334afd,0x660f2807,0x192e4bb3,\n 0xc0cba857,0x45c8740f,0xd20b5f39,0xb9d3fbdb,\n 0x5579c0bd,0x1a60320a,0xd6a100c6,0x402c7279,\n 0x679f25fe,0xfb1fa3cc,0x8ea5e9f8,0xdb3222f8,\n 0x3c7516df,0xfd616b15,0x2f501ec8,0xad0552ab,\n 0x323db5fa,0xfd238760,0x53317b48,0x3e00df82,\n 0x9e5c57bb,0xca6f8ca0,0x1a87562e,0xdf1769db,\n 0xd542a8f6,0x287effc3,0xac6732c6,0x8c4f5573,\n 0x695b27b0,0xbbca58c8,0xe1ffa35d,0xb8f011a0,\n 0x10fa3d98,0xfd2183b8,0x4afcb56c,0x2dd1d35b,\n 0x9a53e479,0xb6f84565,0xd28e49bc,0x4bfb9790,\n 0xe1ddf2da,0xa4cb7e33,0x62fb1341,0xcee4c6e8,\n 0xef20cada,0x36774c01,0xd07e9efe,0x2bf11fb4,\n 0x95dbda4d,0xae909198,0xeaad8e71,0x6b93d5a0,\n 0xd08ed1d0,0xafc725e0,0x8e3c5b2f,0x8e7594b7,\n 0x8ff6e2fb,0xf2122b64,0x8888b812,0x900df01c,\n 0x4fad5ea0,0x688fc31c,0xd1cff191,0xb3a8c1ad,\n 0x2f2f2218,0xbe0e1777,0xea752dfe,0x8b021fa1,\n 0xe5a0cc0f,0xb56f74e8,0x18acf3d6,0xce89e299,\n 0xb4a84fe0,0xfd13e0b7,0x7cc43b81,0xd2ada8d9,\n 0x165fa266,0x80957705,0x93cc7314,0x211a1477,\n 0xe6ad2065,0x77b5fa86,0xc75442f5,0xfb9d35cf,\n 0xebcdaf0c,0x7b3e89a0,0xd6411bd3,0xae1e7e49,\n 0x00250e2d,0x2071b35e,0x226800bb,0x57b8e0af,\n 0x2464369b,0xf009b91e,0x5563911d,0x59dfa6aa,\n 0x78c14389,0xd95a537f,0x207d5ba2,0x02e5b9c5,\n 0x83260376,0x6295cfa9,0x11c81968,0x4e734a41,\n 0xb3472dca,0x7b14a94a,0x1b510052,0x9a532915,\n 0xd60f573f,0xbc9bc6e4,0x2b60a476,0x81e67400,\n 0x08ba6fb5,0x571be91f,0xf296ec6b,0x2a0dd915,\n 0xb6636521,0xe7b9f9b6,0xff34052e,0xc5855664,\n 0x53b02d5d,0xa99f8fa1,0x08ba4799,0x6e85076a,\n ],\n \n [\n 0x4b7a70e9,0xb5b32944,0xdb75092e,0xc4192623,\n 0xad6ea6b0,0x49a7df7d,0x9cee60b8,0x8fedb266,\n 0xecaa8c71,0x699a17ff,0x5664526c,0xc2b19ee1,\n 0x193602a5,0x75094c29,0xa0591340,0xe4183a3e,\n 0x3f54989a,0x5b429d65,0x6b8fe4d6,0x99f73fd6,\n 0xa1d29c07,0xefe830f5,0x4d2d38e6,0xf0255dc1,\n 0x4cdd2086,0x8470eb26,0x6382e9c6,0x021ecc5e,\n 0x09686b3f,0x3ebaefc9,0x3c971814,0x6b6a70a1,\n 0x687f3584,0x52a0e286,0xb79c5305,0xaa500737,\n 0x3e07841c,0x7fdeae5c,0x8e7d44ec,0x5716f2b8,\n 0xb03ada37,0xf0500c0d,0xf01c1f04,0x0200b3ff,\n 0xae0cf51a,0x3cb574b2,0x25837a58,0xdc0921bd,\n 0xd19113f9,0x7ca92ff6,0x94324773,0x22f54701,\n 0x3ae5e581,0x37c2dadc,0xc8b57634,0x9af3dda7,\n 0xa9446146,0x0fd0030e,0xecc8c73e,0xa4751e41,\n 0xe238cd99,0x3bea0e2f,0x3280bba1,0x183eb331,\n 0x4e548b38,0x4f6db908,0x6f420d03,0xf60a04bf,\n 0x2cb81290,0x24977c79,0x5679b072,0xbcaf89af,\n 0xde9a771f,0xd9930810,0xb38bae12,0xdccf3f2e,\n 0x5512721f,0x2e6b7124,0x501adde6,0x9f84cd87,\n 0x7a584718,0x7408da17,0xbc9f9abc,0xe94b7d8c,\n 0xec7aec3a,0xdb851dfa,0x63094366,0xc464c3d2,\n 0xef1c1847,0x3215d908,0xdd433b37,0x24c2ba16,\n 0x12a14d43,0x2a65c451,0x50940002,0x133ae4dd,\n 0x71dff89e,0x10314e55,0x81ac77d6,0x5f11199b,\n 0x043556f1,0xd7a3c76b,0x3c11183b,0x5924a509,\n 0xf28fe6ed,0x97f1fbfa,0x9ebabf2c,0x1e153c6e,\n 0x86e34570,0xeae96fb1,0x860e5e0a,0x5a3e2ab3,\n 0x771fe71c,0x4e3d06fa,0x2965dcb9,0x99e71d0f,\n 0x803e89d6,0x5266c825,0x2e4cc978,0x9c10b36a,\n 0xc6150eba,0x94e2ea78,0xa5fc3c53,0x1e0a2df4,\n 0xf2f74ea7,0x361d2b3d,0x1939260f,0x19c27960,\n 0x5223a708,0xf71312b6,0xebadfe6e,0xeac31f66,\n 0xe3bc4595,0xa67bc883,0xb17f37d1,0x018cff28,\n 0xc332ddef,0xbe6c5aa5,0x65582185,0x68ab9802,\n 0xeecea50f,0xdb2f953b,0x2aef7dad,0x5b6e2f84,\n 0x1521b628,0x29076170,0xecdd4775,0x619f1510,\n 0x13cca830,0xeb61bd96,0x0334fe1e,0xaa0363cf,\n 0xb5735c90,0x4c70a239,0xd59e9e0b,0xcbaade14,\n 0xeecc86bc,0x60622ca7,0x9cab5cab,0xb2f3846e,\n 0x648b1eaf,0x19bdf0ca,0xa02369b9,0x655abb50,\n 0x40685a32,0x3c2ab4b3,0x319ee9d5,0xc021b8f7,\n 0x9b540b19,0x875fa099,0x95f7997e,0x623d7da8,\n 0xf837889a,0x97e32d77,0x11ed935f,0x16681281,\n 0x0e358829,0xc7e61fd6,0x96dedfa1,0x7858ba99,\n 0x57f584a5,0x1b227263,0x9b83c3ff,0x1ac24696,\n 0xcdb30aeb,0x532e3054,0x8fd948e4,0x6dbc3128,\n 0x58ebf2ef,0x34c6ffea,0xfe28ed61,0xee7c3c73,\n 0x5d4a14d9,0xe864b7e3,0x42105d14,0x203e13e0,\n 0x45eee2b6,0xa3aaabea,0xdb6c4f15,0xfacb4fd0,\n 0xc742f442,0xef6abbb5,0x654f3b1d,0x41cd2105,\n 0xd81e799e,0x86854dc7,0xe44b476a,0x3d816250,\n 0xcf62a1f2,0x5b8d2646,0xfc8883a0,0xc1c7b6a3,\n 0x7f1524c3,0x69cb7492,0x47848a0b,0x5692b285,\n 0x095bbf00,0xad19489d,0x1462b174,0x23820e00,\n 0x58428d2a,0x0c55f5ea,0x1dadf43e,0x233f7061,\n 0x3372f092,0x8d937e41,0xd65fecf1,0x6c223bdb,\n 0x7cde3759,0xcbee7460,0x4085f2a7,0xce77326e,\n 0xa6078084,0x19f8509e,0xe8efd855,0x61d99735,\n 0xa969a7aa,0xc50c06c2,0x5a04abfc,0x800bcadc,\n 0x9e447a2e,0xc3453484,0xfdd56705,0x0e1e9ec9,\n 0xdb73dbd3,0x105588cd,0x675fda79,0xe3674340,\n 0xc5c43465,0x713e38d8,0x3d28f89e,0xf16dff20,\n 0x153e21e7,0x8fb03d4a,0xe6e39f2b,0xdb83adf7,\n ],\n \n [\n 0xe93d5a68,0x948140f7,0xf64c261c,0x94692934,\n 0x411520f7,0x7602d4f7,0xbcf46b2e,0xd4a20068,\n 0xd4082471,0x3320f46a,0x43b7d4b7,0x500061af,\n 0x1e39f62e,0x97244546,0x14214f74,0xbf8b8840,\n 0x4d95fc1d,0x96b591af,0x70f4ddd3,0x66a02f45,\n 0xbfbc09ec,0x03bd9785,0x7fac6dd0,0x31cb8504,\n 0x96eb27b3,0x55fd3941,0xda2547e6,0xabca0a9a,\n 0x28507825,0x530429f4,0x0a2c86da,0xe9b66dfb,\n 0x68dc1462,0xd7486900,0x680ec0a4,0x27a18dee,\n 0x4f3ffea2,0xe887ad8c,0xb58ce006,0x7af4d6b6,\n 0xaace1e7c,0xd3375fec,0xce78a399,0x406b2a42,\n 0x20fe9e35,0xd9f385b9,0xee39d7ab,0x3b124e8b,\n 0x1dc9faf7,0x4b6d1856,0x26a36631,0xeae397b2,\n 0x3a6efa74,0xdd5b4332,0x6841e7f7,0xca7820fb,\n 0xfb0af54e,0xd8feb397,0x454056ac,0xba489527,\n 0x55533a3a,0x20838d87,0xfe6ba9b7,0xd096954b,\n 0x55a867bc,0xa1159a58,0xcca92963,0x99e1db33,\n 0xa62a4a56,0x3f3125f9,0x5ef47e1c,0x9029317c,\n 0xfdf8e802,0x04272f70,0x80bb155c,0x05282ce3,\n 0x95c11548,0xe4c66d22,0x48c1133f,0xc70f86dc,\n 0x07f9c9ee,0x41041f0f,0x404779a4,0x5d886e17,\n 0x325f51eb,0xd59bc0d1,0xf2bcc18f,0x41113564,\n 0x257b7834,0x602a9c60,0xdff8e8a3,0x1f636c1b,\n 0x0e12b4c2,0x02e1329e,0xaf664fd1,0xcad18115,\n 0x6b2395e0,0x333e92e1,0x3b240b62,0xeebeb922,\n 0x85b2a20e,0xe6ba0d99,0xde720c8c,0x2da2f728,\n 0xd0127845,0x95b794fd,0x647d0862,0xe7ccf5f0,\n 0x5449a36f,0x877d48fa,0xc39dfd27,0xf33e8d1e,\n 0x0a476341,0x992eff74,0x3a6f6eab,0xf4f8fd37,\n 0xa812dc60,0xa1ebddf8,0x991be14c,0xdb6e6b0d,\n 0xc67b5510,0x6d672c37,0x2765d43b,0xdcd0e804,\n 0xf1290dc7,0xcc00ffa3,0xb5390f92,0x690fed0b,\n 0x667b9ffb,0xcedb7d9c,0xa091cf0b,0xd9155ea3,\n 0xbb132f88,0x515bad24,0x7b9479bf,0x763bd6eb,\n 0x37392eb3,0xcc115979,0x8026e297,0xf42e312d,\n 0x6842ada7,0xc66a2b3b,0x12754ccc,0x782ef11c,\n 0x6a124237,0xb79251e7,0x06a1bbe6,0x4bfb6350,\n 0x1a6b1018,0x11caedfa,0x3d25bdd8,0xe2e1c3c9,\n 0x44421659,0x0a121386,0xd90cec6e,0xd5abea2a,\n 0x64af674e,0xda86a85f,0xbebfe988,0x64e4c3fe,\n 0x9dbc8057,0xf0f7c086,0x60787bf8,0x6003604d,\n 0xd1fd8346,0xf6381fb0,0x7745ae04,0xd736fccc,\n 0x83426b33,0xf01eab71,0xb0804187,0x3c005e5f,\n 0x77a057be,0xbde8ae24,0x55464299,0xbf582e61,\n 0x4e58f48f,0xf2ddfda2,0xf474ef38,0x8789bdc2,\n 0x5366f9c3,0xc8b38e74,0xb475f255,0x46fcd9b9,\n 0x7aeb2661,0x8b1ddf84,0x846a0e79,0x915f95e2,\n 0x466e598e,0x20b45770,0x8cd55591,0xc902de4c,\n 0xb90bace1,0xbb8205d0,0x11a86248,0x7574a99e,\n 0xb77f19b6,0xe0a9dc09,0x662d09a1,0xc4324633,\n 0xe85a1f02,0x09f0be8c,0x4a99a025,0x1d6efe10,\n 0x1ab93d1d,0x0ba5a4df,0xa186f20f,0x2868f169,\n 0xdcb7da83,0x573906fe,0xa1e2ce9b,0x4fcd7f52,\n 0x50115e01,0xa70683fa,0xa002b5c4,0x0de6d027,\n 0x9af88c27,0x773f8641,0xc3604c06,0x61a806b5,\n 0xf0177a28,0xc0f586e0,0x006058aa,0x30dc7d62,\n 0x11e69ed7,0x2338ea63,0x53c2dd94,0xc2c21634,\n 0xbbcbee56,0x90bcb6de,0xebfc7da1,0xce591d76,\n 0x6f05e409,0x4b7c0188,0x39720a3d,0x7c927c24,\n 0x86e3725f,0x724d9db9,0x1ac15bb4,0xd39eb8fc,\n 0xed545578,0x08fca5b5,0xd83d7cd3,0x4dad0fc4,\n 0x1e50ef5e,0xb161e6f8,0xa28514d9,0x6c51133c,\n 0x6fd5c7e7,0x56e14ec4,0x362abfce,0xddc6c837,\n 0xd79a3234,0x92638212,0x670efa8e,0x406000e0,\n ],\n \n [\n 0x3a39ce37,0xd3faf5cf,0xabc27737,0x5ac52d1b,\n 0x5cb0679e,0x4fa33742,0xd3822740,0x99bc9bbe,\n 0xd5118e9d,0xbf0f7315,0xd62d1c7e,0xc700c47b,\n 0xb78c1b6b,0x21a19045,0xb26eb1be,0x6a366eb4,\n 0x5748ab2f,0xbc946e79,0xc6a376d2,0x6549c2c8,\n 0x530ff8ee,0x468dde7d,0xd5730a1d,0x4cd04dc6,\n 0x2939bbdb,0xa9ba4650,0xac9526e8,0xbe5ee304,\n 0xa1fad5f0,0x6a2d519a,0x63ef8ce2,0x9a86ee22,\n 0xc089c2b8,0x43242ef6,0xa51e03aa,0x9cf2d0a4,\n 0x83c061ba,0x9be96a4d,0x8fe51550,0xba645bd6,\n 0x2826a2f9,0xa73a3ae1,0x4ba99586,0xef5562e9,\n 0xc72fefd3,0xf752f7da,0x3f046f69,0x77fa0a59,\n 0x80e4a915,0x87b08601,0x9b09e6ad,0x3b3ee593,\n 0xe990fd5a,0x9e34d797,0x2cf0b7d9,0x022b8b51,\n 0x96d5ac3a,0x017da67d,0xd1cf3ed6,0x7c7d2d28,\n 0x1f9f25cf,0xadf2b89b,0x5ad6b472,0x5a88f54c,\n 0xe029ac71,0xe019a5e6,0x47b0acfd,0xed93fa9b,\n 0xe8d3c48d,0x283b57cc,0xf8d56629,0x79132e28,\n 0x785f0191,0xed756055,0xf7960e44,0xe3d35e8c,\n 0x15056dd4,0x88f46dba,0x03a16125,0x0564f0bd,\n 0xc3eb9e15,0x3c9057a2,0x97271aec,0xa93a072a,\n 0x1b3f6d9b,0x1e6321f5,0xf59c66fb,0x26dcf319,\n 0x7533d928,0xb155fdf5,0x03563482,0x8aba3cbb,\n 0x28517711,0xc20ad9f8,0xabcc5167,0xccad925f,\n 0x4de81751,0x3830dc8e,0x379d5862,0x9320f991,\n 0xea7a90c2,0xfb3e7bce,0x5121ce64,0x774fbe32,\n 0xa8b6e37e,0xc3293d46,0x48de5369,0x6413e680,\n 0xa2ae0810,0xdd6db224,0x69852dfd,0x09072166,\n 0xb39a460a,0x6445c0dd,0x586cdecf,0x1c20c8ae,\n 0x5bbef7dd,0x1b588d40,0xccd2017f,0x6bb4e3bb,\n 0xdda26a7e,0x3a59ff45,0x3e350a44,0xbcb4cdd5,\n 0x72eacea8,0xfa6484bb,0x8d6612ae,0xbf3c6f47,\n 0xd29be463,0x542f5d9e,0xaec2771b,0xf64e6370,\n 0x740e0d8d,0xe75b1357,0xf8721671,0xaf537d5d,\n 0x4040cb08,0x4eb4e2cc,0x34d2466a,0x0115af84,\n 0xe1b00428,0x95983a1d,0x06b89fb4,0xce6ea048,\n 0x6f3f3b82,0x3520ab82,0x011a1d4b,0x277227f8,\n 0x611560b1,0xe7933fdc,0xbb3a792b,0x344525bd,\n 0xa08839e1,0x51ce794b,0x2f32c9b7,0xa01fbac9,\n 0xe01cc87e,0xbcc7d1f6,0xcf0111c3,0xa1e8aac7,\n 0x1a908749,0xd44fbd9a,0xd0dadecb,0xd50ada38,\n 0x0339c32a,0xc6913667,0x8df9317c,0xe0b12b4f,\n 0xf79e59b7,0x43f5bb3a,0xf2d519ff,0x27d9459c,\n 0xbf97222c,0x15e6fc2a,0x0f91fc71,0x9b941525,\n 0xfae59361,0xceb69ceb,0xc2a86459,0x12baa8d1,\n 0xb6c1075e,0xe3056a0c,0x10d25065,0xcb03a442,\n 0xe0ec6e0e,0x1698db3b,0x4c98a0be,0x3278e964,\n 0x9f1f9532,0xe0d392df,0xd3a0342b,0x8971f21e,\n 0x1b0a7441,0x4ba3348c,0xc5be7120,0xc37632d8,\n 0xdf359f8d,0x9b992f2e,0xe60b6f47,0x0fe3f11d,\n 0xe54cda54,0x1edad891,0xce6279cf,0xcd3e7e6f,\n 0x1618b166,0xfd2c1d05,0x848fd2c5,0xf6fb2299,\n 0xf523f357,0xa6327623,0x93a83531,0x56cccd02,\n 0xacf08162,0x5a75ebb5,0x6e163697,0x88d273cc,\n 0xde966292,0x81b949d0,0x4c50901b,0x71c65614,\n 0xe6c6c7bd,0x327a140a,0x45e1d006,0xc3f27b9a,\n 0xc9aa53fd,0x62a80f00,0xbb25bfe2,0x35bdd2f6,\n 0x71126905,0xb2040222,0xb6cbcf7c,0xcd769c2b,\n 0x53113ec0,0x1640e3d3,0x38abbd60,0x2547adf0,\n 0xba38209c,0xf746ce76,0x77afa1c5,0x20756060,\n 0x85cbfe4e,0x8ae88dd8,0x7aaaf9b0,0x4cf9aa7e,\n 0x1948c25c,0x02fb8a8c,0x01c36ae4,0xd6ebe1f9,\n 0x90d4f869,0xa65cdea0,0x3f09252d,0xc208e69f,\n 0xb74e6132,0xce77e25b,0x578fdfe3,0x3ac372e6,\n ]\n ]\n \n \n \n \nclass BlowfishEngine(object):\n\n def __init__(self):\n  if BLOWFISH_P is None :\n   _init_constants()\n  self.P=list(BLOWFISH_P)\n  self.S=[list(box)for box in BLOWFISH_S]\n  \n  \n  \n  \n @staticmethod\n def key_to_words(data,size=18):\n  ''\n  \n  assert isinstance(data,bytes)\n  dlen=len(data)\n  if not dlen:\n  \n  \n   return [0]*size\n   \n   \n  data=repeat_string(data,size <<2)\n  \n  \n  return struct.unpack(\">%dI\"%(size,),data)\n  \n  \n  \n  \n def encipher(self,l,r):\n  ''\n  P,S=self.P,self.S\n  l ^=P[0]\n  i=1\n  while i <17:\n  \n   r=((((S[0][l >>24]+S[1][(l >>16)&0xff])^S[2][(l >>8)&0xff])+\n   S[3][l&0xff])&0xffffffff)^P[i]^r\n   \n   l,r=r,l\n   i +=1\n  return r ^P[17],l\n  \n  \n  \n def expand(self,key_words):\n  ''\n  assert len(key_words)>=18,\"key_words must be at least as large as P\"\n  P,S,encipher=self.P,self.S,self.encipher\n  \n  i=0\n  while i <18:\n   P[i]^=key_words[i]\n   i +=1\n   \n  i=l=r=0\n  while i <18:\n   P[i],P[i+1]=l,r=encipher(l,r)\n   i +=2\n   \n  for box in S:\n   i=0\n   while i <256:\n    box[i],box[i+1]=l,r=encipher(l,r)\n    i +=2\n    \n    \n    \n    \n def eks_salted_expand(self,key_words,salt_words):\n  ''\n  \n  \n  \n  assert len(key_words)>=18,\"key_words must be at least as large as P\"\n  salt_size=len(salt_words)\n  assert salt_size,\"salt_words must not be empty\"\n  assert not salt_size&1,\"salt_words must have even length\"\n  P,S,encipher=self.P,self.S,self.encipher\n  \n  i=0\n  while i <18:\n   P[i]^=key_words[i]\n   i +=1\n   \n  s=i=l=r=0\n  while i <18:\n   l ^=salt_words[s]\n   r ^=salt_words[s+1]\n   s +=2\n   if s ==salt_size:\n    s=0\n   P[i],P[i+1]=l,r=encipher(l,r)\n   i +=2\n   \n  for box in S:\n   i=0\n   while i <256:\n    l ^=salt_words[s]\n    r ^=salt_words[s+1]\n    s +=2\n    if s ==salt_size:\n     s=0\n    box[i],box[i+1]=l,r=encipher(l,r)\n    i +=2\n    \n def eks_repeated_expand(self,key_words,salt_words,rounds):\n  ''\n  expand=self.expand\n  n=0\n  while n <rounds:\n   expand(key_words)\n   expand(salt_words)\n   n +=1\n   \n def repeat_encipher(self,l,r,count):\n  ''\n  encipher=self.encipher\n  n=0\n  while n <count:\n   l,r=encipher(l,r)\n   n +=1\n  return l,r\n  \n  \n  \n  \n  \n  \n  \n  \n", ["passlib.utils", "struct"]], "passlib.Lib.site-packages.passlib.crypto.scrypt": [".py", "''\n\n\n\n\n\n\n\nfrom __future__ import absolute_import\n\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\nfrom passlib import exc\nfrom passlib.utils import to_bytes\nfrom passlib.utils.compat import PYPY\n\n__all__=[\n\"validate\",\n\"scrypt\",\n]\n\n\n\n\n\n\n\n\n\n\nSCRYPT_MAXMEM=-1\n\n\nMAX_KEYLEN=((1 <<32)-1)*32\n\n\nMAX_RP=(1 <<30)-1\n\n\ndef validate(n,r,p):\n ''\n\n\n\n\n\n\n\n \n if r <1:\n  raise ValueError(\"r must be > 0: r=%r\"%r)\n  \n if p <1:\n  raise ValueError(\"p must be > 0: p=%r\"%p)\n  \n if r *p >MAX_RP:\n \n \n \n  raise ValueError(\"r * p must be < 2**30: r=%r, p=%r\"%(r,p))\n  \n if n <2 or n&(n -1):\n  raise ValueError(\"n must be > 1, and a power of 2: n=%r\"%n)\n  \n return True\n \n \nUINT32_SIZE=4\n\n\ndef estimate_maxmem(n,r,p,fudge=1.05):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n maxmem=r *(128 *p+32 *(n+2)*UINT32_SIZE)\n \n maxmem=int(maxmem *fudge)\n return maxmem\n \n \n \n \n \n \n \n \n \n_scrypt=None\n\n\nbackend=None\n\ndef scrypt(secret,salt,n,r,p=1,keylen=32):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n validate(n,r,p)\n secret=to_bytes(secret,param=\"secret\")\n salt=to_bytes(salt,param=\"salt\")\n if keylen <1:\n  raise ValueError(\"keylen must be at least 1\")\n if keylen >MAX_KEYLEN:\n  raise ValueError(\"keylen too large, must be <= %d\"%MAX_KEYLEN)\n return _scrypt(secret,salt,n,r,p,keylen)\n \n \ndef _load_builtin_backend():\n ''\n\n \n slowdown=10 if PYPY else 100\n warn(\"Using builtin scrypt backend, which is %dx slower than is required \"\n \"for adequate security. Installing scrypt support (via 'pip install scrypt') \"\n \"is strongly recommended\"%slowdown,exc.PasslibSecurityWarning)\n from ._builtin import ScryptEngine\n return ScryptEngine.execute\n \n \ndef _load_cffi_backend():\n ''\n\n\n \n try :\n  from scrypt import hash\n  return hash\n except ImportError:\n  pass\n  \n try :\n  import scrypt\n except ImportError as err:\n  if \"scrypt\"not in str(err):\n  \n  \n   warn(\"'scrypt' package failed to import correctly (possible installation issue?)\",\n   exc.PasslibWarning)\n   \n else :\n  warn(\"'scrypt' package is too old (lacks ``hash()`` method)\",exc.PasslibWarning)\n return None\n \n \ndef _load_stdlib_backend():\n ''\n\n\n \n try :\n \n  from hashlib import scrypt as stdlib_scrypt\n except ImportError:\n  return None\n  \n def stdlib_scrypt_wrapper(secret,salt,n,r,p,keylen):\n \n \n \n \n \n \n \n \n \n \n \n  maxmem=SCRYPT_MAXMEM\n  if maxmem <0:\n   maxmem=estimate_maxmem(n,r,p)\n  return stdlib_scrypt(password=secret,salt=salt,n=n,r=r,p=p,dklen=keylen,\n  maxmem=maxmem)\n  \n return stdlib_scrypt_wrapper\n \n \n \nbackend_values=(\"stdlib\",\"scrypt\",\"builtin\")\n\n\n_backend_loaders=dict(\nstdlib=_load_stdlib_backend,\nscrypt=_load_cffi_backend,\nbuiltin=_load_builtin_backend,\n)\n\n\ndef _set_backend(name,dryrun=False ):\n ''\n\n\n\n\n\n \n if name ==\"any\":\n  return\n elif name ==\"default\":\n  for name in backend_values:\n   try :\n    return _set_backend(name,dryrun=dryrun)\n   except exc.MissingBackendError:\n    continue\n  raise exc.MissingBackendError(\"no scrypt backends available\")\n else :\n  loader=_backend_loaders.get(name)\n  if not loader:\n   raise ValueError(\"unknown scrypt backend: %r\"%(name,))\n  hash=loader()\n  if not hash:\n   raise exc.MissingBackendError(\"scrypt backend %r not available\"%name)\n  if dryrun:\n   return\n  global _scrypt,backend\n  backend=name\n  _scrypt=hash\n  \n  \n_set_backend(\"default\")\n\n\ndef _has_backend(name):\n try :\n  _set_backend(name,dryrun=True )\n  return True\n except exc.MissingBackendError:\n  return False\n  \n  \n  \n  \n", ["__future__", "hashlib", "logging", "passlib", "passlib.Lib.site-packages.passlib.crypto.scrypt._builtin", "passlib.utils", "passlib.utils.compat", "scrypt", "warnings"], 1], "passlib.Lib.site-packages.passlib.crypto.scrypt._salsa": [".py", "''\n\n\n\n\ndef salsa20(input):\n ''\n\n\n\n \n \n b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15=input\n v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15=\\\n b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15\n \n i=0\n while i <4:\n \n  t=(v0+v12)&0xffffffff\n  v4 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v4+v0)&0xffffffff\n  v8 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v8+v4)&0xffffffff\n  v12 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v12+v8)&0xffffffff\n  v0 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v5+v1)&0xffffffff\n  v9 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v9+v5)&0xffffffff\n  v13 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v13+v9)&0xffffffff\n  v1 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v1+v13)&0xffffffff\n  v5 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v10+v6)&0xffffffff\n  v14 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v14+v10)&0xffffffff\n  v2 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v2+v14)&0xffffffff\n  v6 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v6+v2)&0xffffffff\n  v10 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v15+v11)&0xffffffff\n  v3 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v3+v15)&0xffffffff\n  v7 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v7+v3)&0xffffffff\n  v11 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v11+v7)&0xffffffff\n  v15 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v0+v3)&0xffffffff\n  v1 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v1+v0)&0xffffffff\n  v2 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v2+v1)&0xffffffff\n  v3 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v3+v2)&0xffffffff\n  v0 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v5+v4)&0xffffffff\n  v6 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v6+v5)&0xffffffff\n  v7 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v7+v6)&0xffffffff\n  v4 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v4+v7)&0xffffffff\n  v5 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v10+v9)&0xffffffff\n  v11 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v11+v10)&0xffffffff\n  v8 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v8+v11)&0xffffffff\n  v9 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v9+v8)&0xffffffff\n  v10 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  \n  t=(v15+v14)&0xffffffff\n  v12 ^=((t&0x01ffffff)<<7)|(t >>25)\n  \n  \n  t=(v12+v15)&0xffffffff\n  v13 ^=((t&0x007fffff)<<9)|(t >>23)\n  \n  \n  t=(v13+v12)&0xffffffff\n  v14 ^=((t&0x0007ffff)<<13)|(t >>19)\n  \n  \n  t=(v14+v13)&0xffffffff\n  v15 ^=((t&0x00003fff)<<18)|(t >>14)\n  \n  i +=1\n  \n b0=(b0+v0)&0xffffffff\n b1=(b1+v1)&0xffffffff\n b2=(b2+v2)&0xffffffff\n b3=(b3+v3)&0xffffffff\n b4=(b4+v4)&0xffffffff\n b5=(b5+v5)&0xffffffff\n b6=(b6+v6)&0xffffffff\n b7=(b7+v7)&0xffffffff\n b8=(b8+v8)&0xffffffff\n b9=(b9+v9)&0xffffffff\n b10=(b10+v10)&0xffffffff\n b11=(b11+v11)&0xffffffff\n b12=(b12+v12)&0xffffffff\n b13=(b13+v13)&0xffffffff\n b14=(b14+v14)&0xffffffff\n b15=(b15+v15)&0xffffffff\n \n return b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15\n \n \n \n \n", []], "passlib.Lib.site-packages.passlib.crypto.scrypt._gen_files": [".py", "''\n\n\n\n\nimport os\n\n\n\n\n\n\n_SALSA_OPS=[\n\n\n\n\n\n\n\n\n(4,0,12,7),\n(8,4,0,9),\n(12,8,4,13),\n(0,12,8,18),\n\n\n\n(9,5,1,7),\n(13,9,5,9),\n(1,13,9,13),\n(5,1,13,18),\n\n\n\n(14,10,6,7),\n(2,14,10,9),\n(6,2,14,13),\n(10,6,2,18),\n\n\n\n(3,15,11,7),\n(7,3,15,9),\n(11,7,3,13),\n(15,11,7,18),\n\n\n\n\n(1,0,3,7),\n(2,1,0,9),\n(3,2,1,13),\n(0,3,2,18),\n\n\n\n(6,5,4,7),\n(7,6,5,9),\n(4,7,6,13),\n(5,4,7,18),\n\n\n\n(11,10,9,7),\n(8,11,10,9),\n(9,8,11,13),\n(10,9,8,18),\n\n\n\n(12,15,14,7),\n(13,12,15,9),\n(14,13,12,13),\n(15,14,13,18),\n]\n\ndef main():\n target=os.path.join(os.path.dirname(__file__),\"_salsa.py\")\n fh=file(target,\"w\")\n write=fh.write\n \n VNAMES=[\"v%d\"%i for i in range(16)]\n \n PAD=\" \"*4\n PAD2=\" \"*8\n PAD3=\" \"*12\n TLIST=\", \".join(\"b%d\"%i for i in range(16))\n VLIST=\", \".join(VNAMES)\n kwds=dict(\n VLIST=VLIST,\n TLIST=TLIST,\n )\n \n write('''\\\n\"\"\"passlib.utils.scrypt._salsa - salsa 20/8 core, autogenerated by _gen_salsa.py\"\"\"\n#=================================================================\n# salsa function\n#=================================================================\n\ndef salsa20(input):\n    \\\"\"\"apply the salsa20/8 core to the provided input\n\n    :args input: input list containing 16 32-bit integers\n    :returns: result list containing 16 32-bit integers\n    \\\"\"\"\n\n    %(TLIST)s = input\n    %(VLIST)s = \\\\\n        %(TLIST)s\n\n    i = 0\n    while i < 4:\n'''%kwds)\n \n for idx,(target,source1,source2,rotate)in enumerate(_SALSA_OPS):\n  write('''\\\n        # salsa op %(idx)d: [%(it)d] ^= ([%(is1)d]+[%(is2)d])<<<%(rot1)d\n        t = (%(src1)s + %(src2)s) & 0xffffffff\n        %(dst)s ^= ((t & 0x%(rmask)08x) << %(rot1)d) | (t >> %(rot2)d)\n\n'''%dict(\n  idx=idx,is1=source1,is2=source2,it=target,\n  src1=VNAMES[source1],\n  src2=VNAMES[source2],\n  dst=VNAMES[target],\n  rmask=(1 <<(32 -rotate))-1,\n  rot1=rotate,\n  rot2=32 -rotate,\n  ))\n  \n write('''\\\n        i += 1\n\n''')\n \n for idx in range(16):\n  write(PAD+\"b%d = (b%d + v%d) & 0xffffffff\\n\"%(idx,idx,idx))\n  \n write('''\\\n\n    return %(TLIST)s\n\n#=================================================================\n# eof\n#=================================================================\n'''%kwds)\n \nif __name__ ==\"__main__\":\n main()\n \n \n \n \n", ["os"]], "passlib.Lib.site-packages.passlib.crypto.scrypt._builtin": [".py", "''\n\n\n\n\nimport operator\nimport struct\n\nfrom passlib.utils.compat import izip\nfrom passlib.crypto.digest import pbkdf2_hmac\nfrom passlib.crypto.scrypt._salsa import salsa20\n\n__all__=[\n\"ScryptEngine\",\n]\n\n\n\n\nclass ScryptEngine(object):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n n=0\n r=0\n p=0\n \n \n smix_bytes=0\n iv_bytes=0\n bmix_len=0\n bmix_half_len=0\n bmix_struct=None\n integerify=None\n \n \n \n \n @classmethod\n def execute(cls,secret,salt,n,r,p,keylen):\n  ''\n  return cls(n,r,p).run(secret,salt,keylen)\n  \n  \n  \n  \n def __init__(self,n,r,p):\n \n  self.n=n\n  self.r=r\n  self.p=p\n  self.smix_bytes=r <<7\n  self.iv_bytes=self.smix_bytes *p\n  self.bmix_len=bmix_len=r <<5\n  self.bmix_half_len=r <<4\n  assert struct.calcsize(\"I\")==4\n  self.bmix_struct=struct.Struct(\"<\"+str(bmix_len)+\"I\")\n  \n  \n  if r ==1:\n   self.bmix=self._bmix_1\n   \n   \n   \n   \n   \n   \n  if n <=0xFFFFffff:\n   integerify=operator.itemgetter(-16)\n  else :\n   assert n <=0xFFFFffffFFFFffff\n   ig1=operator.itemgetter(-16)\n   ig2=operator.itemgetter(-17)\n   def integerify(X):\n    return ig1(X)|(ig2(X)<<32)\n  self.integerify=integerify\n  \n  \n  \n  \n def run(self,secret,salt,keylen):\n  ''\n\n\n\n\n\n\n  \n  \n  iv_bytes=self.iv_bytes\n  input=pbkdf2_hmac(\"sha256\",secret,salt,rounds=1,keylen=iv_bytes)\n  \n  \n  \n  smix=self.smix\n  if self.p ==1:\n   output=smix(input)\n  else :\n  \n  \n   smix_bytes=self.smix_bytes\n   output=b''.join(\n   smix(input[offset:offset+smix_bytes])\n   for offset in range(0,iv_bytes,smix_bytes)\n   )\n   \n   \n  return pbkdf2_hmac(\"sha256\",secret,output,rounds=1,keylen=keylen)\n  \n  \n  \n  \n def smix(self,input):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  bmix=self.bmix\n  bmix_struct=self.bmix_struct\n  integerify=self.integerify\n  n=self.n\n  \n  \n  \n  buffer=list(bmix_struct.unpack(input))\n  \n  \n  \n  \n  \n  \n  \n  \n  def vgen():\n   i=0\n   while i <n:\n    last=tuple(buffer)\n    yield last\n    bmix(last,buffer)\n    i +=1\n  V=list(vgen())\n  \n  \n  \n  \n  \n  get_v_elem=V.__getitem__\n  n_mask=n -1\n  i=0\n  while i <n:\n   j=integerify(buffer)&n_mask\n   result=tuple(a ^b for a,b in izip(buffer,get_v_elem(j)))\n   bmix(result,buffer)\n   i +=1\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  return bmix_struct.pack(*buffer)\n  \n  \n  \n  \n def bmix(self,source,target):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  half=self.bmix_half_len\n  tmp=source[-16:]\n  siter=iter(source)\n  j=0\n  while j <half:\n   jn=j+16\n   target[j:jn]=tmp=salsa20(a ^b for a,b in izip(tmp,siter))\n   target[half+j:half+jn]=tmp=salsa20(a ^b for a,b in izip(tmp,siter))\n   j=jn\n   \n def _bmix_1(self,source,target):\n  ''\n  B=source[16:]\n  target[:16]=tmp=salsa20(a ^b for a,b in izip(B,iter(source)))\n  target[16:]=salsa20(a ^b for a,b in izip(tmp,B))\n  \n  \n  \n  \n  \n  \n  \n  \n", ["operator", "passlib.crypto.digest", "passlib.crypto.scrypt._salsa", "passlib.utils.compat", "struct"]], "passlib.Lib.site-packages.passlib.ext": [".py", "", [], 1], "passlib.Lib.site-packages.passlib.ext.django.models": [".py", "''\n\n\n\n\n\n\nfrom passlib.context import CryptContext\nfrom passlib.ext.django.utils import DjangoContextAdapter\n\n__all__=[\"password_context\"]\n\n\n\n\n\n\nadapter=DjangoContextAdapter()\n\n\n\npassword_context=adapter.context\n\n\ncontext_changed=adapter.reset_hashers\n\n\n\n\n\n\nadapter.load_model()\n\n\n\n\n", ["passlib.context", "passlib.ext.django.utils"]], "passlib.Lib.site-packages.passlib.ext.django": [".py", "''\n\n\n\n\n\n", [], 1], "passlib.Lib.site-packages.passlib.ext.django.utils": [".py", "''\n\n\n\n\nfrom functools import update_wrapper,wraps\nimport logging ;log=logging.getLogger(__name__)\nimport sys\nimport weakref\nfrom warnings import warn\n\ntry :\n from django import VERSION as DJANGO_VERSION\n log.debug(\"found django %r installation\",DJANGO_VERSION)\nexcept ImportError:\n log.debug(\"django installation not found\")\n DJANGO_VERSION=()\n \nfrom passlib import exc,registry\nfrom passlib.context import CryptContext\nfrom passlib.exc import PasslibRuntimeWarning\nfrom passlib.utils.compat import get_method_function,iteritems,OrderedDict,unicode\nfrom passlib.utils.decor import memoized_property\n\n__all__=[\n\"DJANGO_VERSION\",\n\"MIN_DJANGO_VERSION\",\n\"get_preset_config\",\n\"quirks\",\n]\n\n\nMIN_DJANGO_VERSION=(1,8)\n\n\n\n\n\nclass quirks:\n\n\n\n none_causes_check_password_error=DJANGO_VERSION >=(2,1)\n \n \n empty_is_usable_password=DJANGO_VERSION >=(2,1)\n \n \n invalid_is_usable_password=DJANGO_VERSION >=(2,1)\n \n \n \n \n \n \n_preset_map={\n\"django-1.0\":\"django10_context\",\n\"django-1.4\":\"django14_context\",\n\"django-1.6\":\"django16_context\",\n\"django-latest\":\"django_context\",\n}\n\ndef get_preset_config(name):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n if name ==\"django-default\":\n  if not DJANGO_VERSION:\n   raise ValueError(\"can't resolve django-default preset, \"\n   \"django not installed\")\n  name=\"django-1.6\"\n if name ==\"passlib-default\":\n  return PASSLIB_DEFAULT\n try :\n  attr=_preset_map[name]\n except KeyError:\n  raise ValueError(\"unknown preset config name: %r\"%name)\n import passlib.apps\n return getattr(passlib.apps,attr).to_string()\n \n \nPASSLIB_DEFAULT=\"\"\"\n[passlib]\n\n; list of schemes supported by configuration\n; currently all django 1.6, 1.4, and 1.0 hashes,\n; and three common modular crypt format hashes.\nschemes =\n    django_pbkdf2_sha256, django_pbkdf2_sha1, django_bcrypt, django_bcrypt_sha256,\n    django_salted_sha1, django_salted_md5, django_des_crypt, hex_md5,\n    sha512_crypt, bcrypt, phpass\n\n; default scheme to use for new hashes\ndefault = django_pbkdf2_sha256\n\n; hashes using these schemes will automatically be re-hashed\n; when the user logs in (currently all django 1.0 hashes)\ndeprecated =\n    django_pbkdf2_sha1, django_salted_sha1, django_salted_md5,\n    django_des_crypt, hex_md5\n\n; sets some common options, including minimum rounds for two primary hashes.\n; if a hash has less than this number of rounds, it will be re-hashed.\nsha512_crypt__min_rounds = 80000\ndjango_pbkdf2_sha256__min_rounds = 10000\n\n; set somewhat stronger iteration counts for ``User.is_staff``\nstaff__sha512_crypt__default_rounds = 100000\nstaff__django_pbkdf2_sha256__default_rounds = 12500\n\n; and even stronger ones for ``User.is_superuser``\nsuperuser__sha512_crypt__default_rounds = 120000\nsuperuser__django_pbkdf2_sha256__default_rounds = 15000\n\"\"\"\n\n\n\n\n\n\nPASSLIB_WRAPPER_PREFIX=\"passlib_\"\n\n\n\nDJANGO_COMPAT_PREFIX=\"django_\"\n\n\n_other_django_hashes=set([\"hex_md5\"])\n\ndef _wrap_method(method):\n ''\n @wraps(method)\n def wrapper(*args,**kwds):\n  return method(*args,**kwds)\n return wrapper\n \n \n \n \nclass DjangoTranslator(object):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n context=None\n \n \n \n _django_hasher_cache=None\n \n \n _django_unsalted_sha1=None\n \n \n \n _passlib_hasher_cache=None\n \n \n \n \n \n def __init__(self,context=None ,**kwds):\n  super(DjangoTranslator,self).__init__(**kwds)\n  if context is not None :\n   self.context=context\n   \n  self._django_hasher_cache=weakref.WeakKeyDictionary()\n  self._passlib_hasher_cache=weakref.WeakValueDictionary()\n  \n def reset_hashers(self):\n  self._django_hasher_cache.clear()\n  self._passlib_hasher_cache.clear()\n  self._django_unsalted_sha1=None\n  \n def _get_passlib_hasher(self,passlib_name):\n  ''\n\n  \n  context=self.context\n  if context is None :\n   return registry.get_crypt_handler(passlib_name)\n  else :\n   return context.handler(passlib_name)\n   \n   \n   \n   \n   \n def passlib_to_django_name(self,passlib_name):\n  ''\n\n  \n  return self.passlib_to_django(passlib_name).algorithm\n  \n  \n  \n  \n def passlib_to_django(self,passlib_hasher,cached=True ):\n  ''\n\n\n\n\n\n\n\n  \n  \n  if not hasattr(passlib_hasher,\"name\"):\n   passlib_hasher=self._get_passlib_hasher(passlib_hasher)\n   \n   \n  if cached:\n   cache=self._django_hasher_cache\n   try :\n    return cache[passlib_hasher]\n   except KeyError:\n    pass\n   result=cache[passlib_hasher]=\\\n   self.passlib_to_django(passlib_hasher,cached=False )\n   return result\n   \n   \n  django_name=getattr(passlib_hasher,\"django_name\",None )\n  if django_name:\n   return self._create_django_hasher(django_name)\n  else :\n   return _PasslibHasherWrapper(passlib_hasher)\n   \n _builtin_django_hashers=dict(\n md5=\"MD5PasswordHasher\",\n )\n \n if DJANGO_VERSION >(2,1):\n \n \n  _builtin_django_hashers.update(\n  bcrypt=\"BCryptPasswordHasher\",\n  )\n  \n def _create_django_hasher(self,django_name):\n  ''\n\n\n  \n  \n  module=sys.modules.get(\"passlib.ext.django.models\")\n  if module is None or not module.adapter.patched:\n   from django.contrib.auth.hashers import get_hasher\n   try :\n    return get_hasher(django_name)\n   except ValueError as err:\n    if not str(err).startswith(\"Unknown password hashing algorithm\"):\n     raise\n  else :\n  \n  \n  \n   get_hashers=module.adapter._manager.getorig(\"django.contrib.auth.hashers:get_hashers\").__wrapped__\n   for hasher in get_hashers():\n    if hasher.algorithm ==django_name:\n     return hasher\n     \n     \n     \n  path=self._builtin_django_hashers.get(django_name)\n  if path:\n   if \".\"not in path:\n    path=\"django.contrib.auth.hashers.\"+path\n   from django.utils.module_loading import import_string\n   return import_string(path)()\n   \n  raise ValueError(\"unknown hasher: %r\"%django_name)\n  \n  \n  \n  \n  \n def django_to_passlib_name(self,django_name):\n  ''\n\n  \n  return self.django_to_passlib(django_name).name\n  \n def django_to_passlib(self,django_name,cached=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if hasattr(django_name,\"algorithm\"):\n  \n  \n   if isinstance(django_name,_PasslibHasherWrapper):\n    return django_name.passlib_handler\n    \n    \n   django_name=django_name.algorithm\n   \n   \n  if cached:\n   cache=self._passlib_hasher_cache\n   try :\n    return cache[django_name]\n   except KeyError:\n    pass\n   result=cache[django_name]=\\\n   self.django_to_passlib(django_name,cached=False )\n   return result\n   \n   \n  if django_name.startswith(PASSLIB_WRAPPER_PREFIX):\n   passlib_name=django_name[len(PASSLIB_WRAPPER_PREFIX):]\n   return self._get_passlib_hasher(passlib_name)\n   \n   \n  if django_name ==\"default\":\n   context=self.context\n   if context is None :\n    raise TypeError(\"can't determine default scheme w/ context\")\n   return context.handler()\n   \n   \n   \n   \n  if django_name ==\"unsalted_sha1\":\n   django_name=\"sha1\"\n   \n   \n   \n   \n  context=self.context\n  if context is None :\n  \n  \n   candidates=(\n   registry.get_crypt_handler(passlib_name)\n   for passlib_name in registry.list_crypt_handlers()\n   if passlib_name.startswith(DJANGO_COMPAT_PREFIX)or\n   passlib_name in _other_django_hashes\n   )\n  else :\n  \n   candidates=context.schemes(resolve=True )\n  for handler in candidates:\n   if getattr(handler,\"django_name\",None )==django_name:\n    return handler\n    \n    \n    \n    \n    \n  raise ValueError(\"can't translate django name to passlib name: %r\"%\n  (django_name,))\n  \n  \n  \n  \n  \n def resolve_django_hasher(self,django_name,cached=True ):\n  ''\n\n  \n  \n  if hasattr(django_name,\"algorithm\"):\n   return django_name\n   \n   \n  passlib_hasher=self.django_to_passlib(django_name,cached=cached)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if django_name ==\"unsalted_sha1\"and passlib_hasher.name ==\"django_salted_sha1\":\n   if not cached:\n    return self._create_django_hasher(django_name)\n   result=self._django_unsalted_sha1\n   if result is None :\n    result=self._django_unsalted_sha1=self._create_django_hasher(django_name)\n   return result\n   \n   \n  return self.passlib_to_django(passlib_hasher,cached=cached)\n  \n  \n  \n  \n  \n  \n  \n  \nclass DjangoContextAdapter(DjangoTranslator):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n context=None\n \n \n \n _orig_make_password=None\n \n \n is_password_usable=None\n \n \n _manager=None\n \n \n enabled=True\n \n \n patched=False\n \n \n \n \n def __init__(self,context=None ,get_user_category=None ,**kwds):\n \n \n  self.log=logging.getLogger(__name__+\".DjangoContextAdapter\")\n  \n  \n  if context is None :\n   context=CryptContext()\n  super(DjangoContextAdapter,self).__init__(context=context,**kwds)\n  \n  \n  if get_user_category:\n   assert callable(get_user_category)\n   self.get_user_category=get_user_category\n   \n   \n  try :\n   from functools import lru_cache\n  except ImportError:\n   from django.utils.lru_cache import lru_cache\n  self.get_hashers=lru_cache()(self.get_hashers)\n  \n  \n  from django.contrib.auth.hashers import make_password\n  if make_password.__module__.startswith(\"passlib.\"):\n   make_password=_PatchManager.peek_unpatched_func(make_password)\n  self._orig_make_password=make_password\n  \n  \n  from django.contrib.auth.hashers import is_password_usable\n  self.is_password_usable=is_password_usable\n  \n  \n  mlog=logging.getLogger(__name__+\".DjangoContextAdapter._manager\")\n  self._manager=_PatchManager(log=mlog)\n  \n def reset_hashers(self):\n  ''\n\n  \n  \n  from django.contrib.auth.hashers import reset_hashers\n  reset_hashers(setting=\"PASSWORD_HASHERS\")\n  \n  \n  super(DjangoContextAdapter,self).reset_hashers()\n  \n  \n  \n  \n  \n  \n def get_hashers(self):\n  ''\n\n\n  \n  passlib_to_django=self.passlib_to_django\n  return [passlib_to_django(hasher)\n  for hasher in self.context.schemes(resolve=True )]\n  \n def get_hasher(self,algorithm=\"default\"):\n  ''\n\n\n  \n  return self.resolve_django_hasher(algorithm)\n  \n def identify_hasher(self,encoded):\n  ''\n\n\n  \n  handler=self.context.identify(encoded,resolve=True ,required=True )\n  if handler.name ==\"django_salted_sha1\"and encoded.startswith(\"sha1$$\"):\n  \n  \n  \n   return self.get_hasher(\"unsalted_sha1\")\n  return self.passlib_to_django(handler)\n  \n  \n  \n  \n  \n def make_password(self,password,salt=None ,hasher=\"default\"):\n  ''\n\n  \n  if password is None :\n   return self._orig_make_password(None )\n   \n   \n  passlib_hasher=self.django_to_passlib(hasher)\n  if \"salt\"not in passlib_hasher.setting_kwds:\n  \n   pass\n  elif hasher.startswith(\"unsalted_\"):\n  \n  \n  \n   passlib_hasher=passlib_hasher.using(salt=\"\")\n  elif salt:\n  \n  \n   passlib_hasher=passlib_hasher.using(salt=salt)\n  return passlib_hasher.hash(password)\n  \n def check_password(self,password,encoded,setter=None ,preferred=\"default\"):\n  ''\n\n  \n  \n  \n  \n  \n  if password is None or not self.is_password_usable(encoded):\n   return False\n   \n   \n  context=self.context\n  try :\n   correct=context.verify(password,encoded)\n  except exc.UnknownHashError:\n  \n  \n   return False\n   \n  if not (correct and setter):\n   return correct\n   \n   \n  if preferred ==\"default\":\n   if not context.needs_update(encoded,secret=password):\n    return correct\n  else :\n  \n  \n  \n  \n  \n  \n   hasher=self.django_to_passlib(preferred)\n   if (hasher.identify(encoded)and\n   not hasher.needs_update(encoded,secret=password)):\n   \n   \n    return correct\n    \n    \n    \n  setter(password)\n  return correct\n  \n  \n  \n  \n  \n def user_check_password(self,user,password):\n  ''\n\n  \n  if password is None :\n   return False\n  hash=user.password\n  if not self.is_password_usable(hash):\n   return False\n  cat=self.get_user_category(user)\n  try :\n   ok,new_hash=self.context.verify_and_update(password,hash,category=cat)\n  except exc.UnknownHashError:\n  \n  \n   return False\n  if ok and new_hash is not None :\n  \n   user.password=new_hash\n   user.save()\n  return ok\n  \n def user_set_password(self,user,password):\n  ''\n\n  \n  if password is None :\n   user.set_unusable_password()\n  else :\n   cat=self.get_user_category(user)\n   user.password=self.context.hash(password,category=cat)\n   \n def get_user_category(self,user):\n  ''\n\n\n\n\n  \n  if user.is_superuser:\n   return \"superuser\"\n  elif user.is_staff:\n   return \"staff\"\n  else :\n   return None\n   \n   \n   \n   \n   \n HASHERS_PATH=\"django.contrib.auth.hashers\"\n MODELS_PATH=\"django.contrib.auth.models\"\n USER_CLASS_PATH=MODELS_PATH+\":User\"\n FORMS_PATH=\"django.contrib.auth.forms\"\n \n \n patch_locations=[\n \n \n \n \n \n (USER_CLASS_PATH+\".check_password\",\"user_check_password\",dict(method=True )),\n (USER_CLASS_PATH+\".set_password\",\"user_set_password\",dict(method=True )),\n \n \n \n \n (HASHERS_PATH+\":\",\"check_password\"),\n (HASHERS_PATH+\":\",\"make_password\"),\n (HASHERS_PATH+\":\",\"get_hashers\"),\n (HASHERS_PATH+\":\",\"get_hasher\"),\n (HASHERS_PATH+\":\",\"identify_hasher\"),\n \n \n \n \n (MODELS_PATH+\":\",\"check_password\"),\n (MODELS_PATH+\":\",\"make_password\"),\n (FORMS_PATH+\":\",\"get_hasher\"),\n (FORMS_PATH+\":\",\"identify_hasher\"),\n \n ]\n \n def install_patch(self):\n  ''\n\n  \n  \n  log=self.log\n  if self.patched:\n   log.warning(\"monkeypatching already applied, refusing to reapply\")\n   return False\n   \n   \n  if DJANGO_VERSION <MIN_DJANGO_VERSION:\n   raise RuntimeError(\"passlib.ext.django requires django >= %s\"%\n   (MIN_DJANGO_VERSION,))\n   \n   \n  log.debug(\"preparing to monkeypatch django ...\")\n  \n  \n  manager=self._manager\n  for record in self.patch_locations:\n   if len(record)==2:\n    record +=({},)\n   target,source,opts=record\n   if target.endswith((\":\",\",\")):\n    target +=source\n   value=getattr(self,source)\n   if opts.get(\"method\"):\n   \n   \n   \n    value=_wrap_method(value)\n   manager.patch(target,value)\n   \n   \n  self.reset_hashers()\n  \n  \n  self.patched=True\n  log.debug(\"... finished monkeypatching django\")\n  return True\n  \n def remove_patch(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  log=self.log\n  manager=self._manager\n  \n  if self.patched:\n   log.debug(\"removing django monkeypatching...\")\n   manager.unpatch_all(unpatch_conflicts=True )\n   self.context.load({})\n   self.patched=False\n   self.reset_hashers()\n   log.debug(\"...finished removing django monkeypatching\")\n   return True\n   \n  if manager.isactive():\n   log.warning(\"reverting partial monkeypatching of django...\")\n   manager.unpatch_all()\n   self.context.load({})\n   self.reset_hashers()\n   log.debug(\"...finished removing django monkeypatching\")\n   return True\n   \n  log.debug(\"django not monkeypatched\")\n  return False\n  \n  \n  \n  \n  \n def load_model(self):\n  ''\n\n  \n  self._load_settings()\n  if self.enabled:\n   try :\n    self.install_patch()\n   except :\n   \n    self.remove_patch()\n    raise\n  else :\n   if self.patched:\n    log.error(\"didn't expect monkeypatching would be applied!\")\n   self.remove_patch()\n  log.debug(\"passlib.ext.django loaded\")\n  \n def _load_settings(self):\n  ''\n\n  \n  from django.conf import settings\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  _UNSET=object()\n  config=getattr(settings,\"PASSLIB_CONFIG\",_UNSET)\n  if config is _UNSET:\n  \n   config=getattr(settings,\"PASSLIB_CONTEXT\",_UNSET)\n  if config is _UNSET:\n   config=\"passlib-default\"\n  if config is None :\n   warn(\"setting PASSLIB_CONFIG=None is deprecated, \"\n   \"and support will be removed in Passlib 1.8, \"\n   \"use PASSLIB_CONFIG='disabled' instead.\",\n   DeprecationWarning)\n   config=\"disabled\"\n  elif not isinstance(config,(unicode,bytes,dict)):\n   raise exc.ExpectedTypeError(config,\"str or dict\",\"PASSLIB_CONFIG\")\n   \n   \n  get_category=getattr(settings,\"PASSLIB_GET_CATEGORY\",None )\n  if get_category and not callable(get_category):\n   raise exc.ExpectedTypeError(get_category,\"callable\",\"PASSLIB_GET_CATEGORY\")\n   \n   \n  if config ==\"disabled\":\n   self.enabled=False\n   return\n  else :\n   self.__dict__.pop(\"enabled\",None )\n   \n   \n  if isinstance(config,str)and '\\n'not in config:\n   config=get_preset_config(config)\n   \n   \n  if get_category:\n   self.get_user_category=get_category\n  else :\n   self.__dict__.pop(\"get_category\",None )\n   \n   \n  self.context.load(config)\n  self.reset_hashers()\n  \n  \n  \n  \n  \n  \n  \n  \n_GEN_SALT_SIGNAL=\"--!!!generate-new-salt!!!--\"\n\nclass ProxyProperty(object):\n ''\n \n def __init__(self,attr):\n  self.attr=attr\n  \n def __get__(self,obj,cls):\n  if obj is None :\n   cls=obj\n  return getattr(obj,self.attr)\n  \n def __set__(self,obj,value):\n  setattr(obj,self.attr,value)\n  \n def __delete__(self,obj):\n  delattr(obj,self.attr)\n  \n  \nclass _PasslibHasherWrapper(object):\n ''\n\n\n\n\n\n \n \n \n \n \n \n passlib_handler=None\n \n \n \n \n \n \n \n \n \n def __init__(self,passlib_handler):\n \n  if getattr(passlib_handler,\"django_name\",None ):\n   raise ValueError(\"handlers that reflect an official django \"\n   \"hasher shouldn't be wrapped: %r\"%\n   (passlib_handler.name,))\n  if passlib_handler.is_disabled:\n  \n   raise ValueError(\"can't wrap disabled-hash handlers: %r\"%\n   (passlib_handler.name))\n  self.passlib_handler=passlib_handler\n  \n  \n  if self._has_rounds:\n   self.rounds=passlib_handler.default_rounds\n   self.iterations=ProxyProperty(\"rounds\")\n   \n   \n   \n   \n def __repr__(self):\n  return \"<PasslibHasherWrapper handler=%r>\"%self.passlib_handler\n  \n  \n  \n  \n  \n @memoized_property\n def __name__(self):\n  return \"Passlib_%s_PasswordHasher\"%self.passlib_handler.name.title()\n  \n @memoized_property\n def _has_rounds(self):\n  return \"rounds\"in self.passlib_handler.setting_kwds\n  \n @memoized_property\n def _translate_kwds(self):\n  ''\n\n\n  \n  out=dict(checksum=\"hash\")\n  if self._has_rounds and \"pbkdf2\"in self.passlib_handler.name:\n   out['rounds']='iterations'\n  return out\n  \n  \n  \n  \n  \n @memoized_property\n def algorithm(self):\n  return PASSLIB_WRAPPER_PREFIX+self.passlib_handler.name\n  \n  \n  \n  \n def salt(self):\n \n \n \n  return _GEN_SALT_SIGNAL\n  \n def verify(self,password,encoded):\n  return self.passlib_handler.verify(password,encoded)\n  \n def encode(self,password,salt=None ,rounds=None ,iterations=None ):\n  kwds={}\n  if salt is not None and salt !=_GEN_SALT_SIGNAL:\n   kwds['salt']=salt\n  if self._has_rounds:\n   if rounds is not None :\n    kwds['rounds']=rounds\n   elif iterations is not None :\n    kwds['rounds']=iterations\n   else :\n    kwds['rounds']=self.rounds\n  elif rounds is not None or iterations is not None :\n   warn(\"%s.hash(): 'rounds' and 'iterations' are ignored\"%self.__name__)\n  handler=self.passlib_handler\n  if kwds:\n   handler=handler.using(**kwds)\n  return handler.hash(password)\n  \n def safe_summary(self,encoded):\n  from django.contrib.auth.hashers import mask_hash\n  from django.utils.translation import ugettext_noop as _\n  handler=self.passlib_handler\n  items=[\n  \n  \n  (_('algorithm'),handler.name),\n  ]\n  if hasattr(handler,\"parsehash\"):\n   kwds=handler.parsehash(encoded,sanitize=mask_hash)\n   for key,value in iteritems(kwds):\n    key=self._translate_kwds.get(key,key)\n    items.append((_(key),value))\n  return OrderedDict(items)\n  \n def must_update(self,encoded):\n \n \n \n  if self._has_rounds:\n  \n  \n   subcls=self.passlib_handler.using(min_rounds=self.rounds,max_rounds=self.rounds)\n   if subcls.needs_update(encoded):\n    return True\n  return False\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_UNSET=object()\n\nclass _PatchManager(object):\n ''\n \n \n \n \n \n \n \n \n def __init__(self,log=None ):\n \n \n  self.log=log or logging.getLogger(__name__+\"._PatchManager\")\n  self._state={}\n  \n def isactive(self):\n  return bool(self._state)\n  \n  \n  \n __bool__=__nonzero__=isactive\n \n def _import_path(self,path):\n  ''\n  name,attr=path.split(\":\")\n  obj=__import__(name,fromlist=[attr],level=0)\n  while '.'in attr:\n   head,attr=attr.split(\".\",1)\n   obj=getattr(obj,head)\n  return obj,attr\n  \n @staticmethod\n def _is_same_value(left,right):\n  ''\n  return get_method_function(left)==get_method_function(right)\n  \n  \n  \n  \n def _get_path(self,key,default=_UNSET):\n  obj,attr=self._import_path(key)\n  return getattr(obj,attr,default)\n  \n def get(self,path,default=None ):\n  ''\n  return self._get_path(path,default)\n  \n def getorig(self,path,default=None ):\n  ''\n  try :\n   value,_=self._state[path]\n  except KeyError:\n   value=self._get_path(path)\n  return default if value is _UNSET else value\n  \n def check_all(self,strict=False ):\n  ''\n  same=self._is_same_value\n  for path,(orig,expected)in iteritems(self._state):\n   if same(self._get_path(path),expected):\n    continue\n   msg=\"another library has patched resource: %r\"%path\n   if strict:\n    raise RuntimeError(msg)\n   else :\n    warn(msg,PasslibRuntimeWarning)\n    \n    \n    \n    \n def _set_path(self,path,value):\n  obj,attr=self._import_path(path)\n  if value is _UNSET:\n   if hasattr(obj,attr):\n    delattr(obj,attr)\n  else :\n   setattr(obj,attr,value)\n   \n def patch(self,path,value,wrap=False ):\n  ''\n  assert value !=_UNSET\n  current=self._get_path(path)\n  try :\n   orig,expected=self._state[path]\n  except KeyError:\n   self.log.debug(\"patching resource: %r\",path)\n   orig=current\n  else :\n   self.log.debug(\"modifying resource: %r\",path)\n   if not self._is_same_value(current,expected):\n    warn(\"overridding resource another library has patched: %r\"\n    %path,PasslibRuntimeWarning)\n  if wrap:\n   assert callable(value)\n   wrapped=orig\n   wrapped_by=value\n   def wrapper(*args,**kwds):\n    return wrapped_by(wrapped,*args,**kwds)\n   update_wrapper(wrapper,value)\n   value=wrapper\n  if callable(value):\n  \n   get_method_function(value)._patched_original_value=orig\n  self._set_path(path,value)\n  self._state[path]=(orig,value)\n  \n @classmethod\n def peek_unpatched_func(cls,value):\n  return value._patched_original_value\n  \n  \n  \n  \n  \n  \n def monkeypatch(self,parent,name=None ,enable=True ,wrap=False ):\n  ''\n  def builder(func):\n   if enable:\n    sep=\".\"if \":\"in parent else \":\"\n    path=parent+sep+(name or func.__name__)\n    self.patch(path,func,wrap=wrap)\n   return func\n  if callable(name):\n  \n   func=name\n   name=None\n   builder(func)\n   return None\n  return builder\n  \n  \n  \n  \n def unpatch(self,path,unpatch_conflicts=True ):\n  try :\n   orig,expected=self._state[path]\n  except KeyError:\n   return\n  current=self._get_path(path)\n  self.log.debug(\"unpatching resource: %r\",path)\n  if not self._is_same_value(current,expected):\n   if unpatch_conflicts:\n    warn(\"reverting resource another library has patched: %r\"\n    %path,PasslibRuntimeWarning)\n   else :\n    warn(\"not reverting resource another library has patched: %r\"\n    %path,PasslibRuntimeWarning)\n    del self._state[path]\n    return\n  self._set_path(path,orig)\n  del self._state[path]\n  \n def unpatch_all(self,**kwds):\n  for key in list(self._state):\n   self.unpatch(key,**kwds)\n   \n   \n   \n   \n   \n   \n   \n   \n", ["django", "django.conf", "django.contrib.auth.hashers", "django.utils.lru_cache", "django.utils.module_loading", "django.utils.translation", "functools", "logging", "passlib", "passlib.apps", "passlib.context", "passlib.exc", "passlib.utils.compat", "passlib.utils.decor", "sys", "warnings", "weakref"]], "passlib.Lib.site-packages.passlib.tests.test_ext_django": [".py", "''\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\nimport logging ;log=logging.getLogger(__name__)\nimport sys\nimport re\n\n\nfrom passlib import apps as _apps,exc,registry\nfrom passlib.apps import django10_context,django14_context,django16_context\nfrom passlib.context import CryptContext\nfrom passlib.ext.django.utils import (\nDJANGO_VERSION,MIN_DJANGO_VERSION,DjangoTranslator,quirks,\n)\nfrom passlib.utils.compat import iteritems,get_method_function,u\nfrom passlib.utils.decor import memoized_property\n\nfrom passlib.tests.utils import TestCase,TEST_MODE,handler_derived_from\nfrom passlib.tests.test_handlers import get_handler_case\n\n__all__=[\n\"DjangoBehaviorTest\",\n\"ExtensionBehaviorTest\",\n\"DjangoExtensionTest\",\n\n\"_ExtensionSupport\",\n\"_ExtensionTest\",\n]\n\n\n\n\n\nhas_min_django=DJANGO_VERSION >=MIN_DJANGO_VERSION\n\n\n\n\n\n\nif has_min_django:\n\n\n\n from django.conf import settings,LazySettings\n \n if not isinstance(settings,LazySettings):\n \n \n  raise RuntimeError(\"expected django.conf.settings to be LazySettings: %r\"%(settings,))\n  \n  \n if not settings.configured:\n  settings.configure()\n  \n  \n  \n  \n  \n from django.apps import apps\n apps.populate([\"django.contrib.contenttypes\",\"django.contrib.auth\"])\n \n \n \nif DJANGO_VERSION >=(3,2):\n log.info(\"this release hasn't been tested against Django %r\",DJANGO_VERSION)\n \n \n \n \n \n \nUNSET=object()\n\ndef update_settings(**kwds):\n ''\n for k,v in iteritems(kwds):\n  if v is UNSET:\n   if hasattr(settings,k):\n    delattr(settings,k)\n  else :\n   setattr(settings,k,v)\n   \nif has_min_django:\n from django.contrib.auth.models import User\n \n class FakeUser(User):\n  ''\n  \n  \n  \n  class Meta:\n   app_label=__name__\n   \n  @memoized_property\n  def saved_passwords(self):\n   return []\n   \n  def pop_saved_passwords(self):\n   try :\n    return self.saved_passwords[:]\n   finally :\n    del self.saved_passwords[:]\n    \n  def save(self,update_fields=None ):\n  \n   self.saved_passwords.append(self.password)\n   \ndef create_mock_setter():\n state=[]\n def setter(password):\n  state.append(password)\n def popstate():\n  try :\n   return state[:]\n  finally :\n   del state[:]\n setter.popstate=popstate\n return setter\n \n \ndef check_django_hasher_has_backend(name):\n ''\n\n\n \n assert name\n from django.contrib.auth.hashers import make_password\n try :\n  make_password(\"\",hasher=name)\n  return True\n except ValueError as err:\n  if re.match(\"Couldn't load '.*?' algorithm .* No module named .*\",str(err)):\n   return False\n  raise\n  \n  \n  \n  \n  \ndef _modify_django_config(kwds,sha_rounds=None ):\n ''\n\n\n\n\n \n \n if hasattr(kwds,\"to_dict\"):\n \n  kwds=kwds.to_dict()\n  \n  \n kwds.update(\n \n deprecated=\"auto\",\n )\n \n \n \n if sha_rounds is None and has_min_django:\n  from django.contrib.auth.hashers import PBKDF2PasswordHasher\n  sha_rounds=PBKDF2PasswordHasher.iterations\n  \n  \n if sha_rounds:\n  kwds.update(\n  django_pbkdf2_sha1__default_rounds=sha_rounds,\n  django_pbkdf2_sha256__default_rounds=sha_rounds,\n  )\n  \n return kwds\n \n \n \n \n \n \n \n \n \nif DJANGO_VERSION >=(2,1):\n stock_config=_modify_django_config(_apps.django21_context)\nelif DJANGO_VERSION >=(1,10):\n stock_config=_modify_django_config(_apps.django110_context)\nelse :\n\n stock_config=_modify_django_config(_apps.django16_context)\n \n \n \n \nfrom passlib.hash import django_pbkdf2_sha256\nsample_hashes=dict(\ndjango_pbkdf2_sha256=(\"not a password\",django_pbkdf2_sha256\n.using(rounds=stock_config.get(\"django_pbkdf2_sha256__default_rounds\"))\n.hash(\"not a password\"))\n)\n\n\n\n\n\nclass _ExtensionSupport(object):\n ''\n\n\n \n \n \n \n \n @classmethod\n def _iter_patch_candidates(cls):\n  ''\n\n\n\n\n\n\n  \n  \n  \n  from django.contrib.auth import models,hashers\n  user_attrs=[\"check_password\",\"set_password\"]\n  model_attrs=[\"check_password\",\"make_password\"]\n  hasher_attrs=[\"check_password\",\"make_password\",\"get_hasher\",\"identify_hasher\",\n  \"get_hashers\"]\n  objs=[(models,model_attrs),\n  (models.User,user_attrs),\n  (hashers,hasher_attrs),\n  ]\n  for obj,patched in objs:\n   for attr in dir(obj):\n    if attr.startswith(\"_\"):\n     continue\n    value=obj.__dict__.get(attr,UNSET)\n    if value is UNSET and attr not in patched:\n     continue\n    value=get_method_function(value)\n    source=getattr(value,\"__module__\",None )\n    if source:\n     yield obj,attr,source,(attr in patched)\n     \n     \n     \n     \n     \n def assert_unpatched(self):\n  ''\n\n  \n  \n  mod=sys.modules.get(\"passlib.ext.django.models\")\n  self.assertFalse(mod and mod.adapter.patched,\"patch should not be enabled\")\n  \n  \n  for obj,attr,source,patched in self._iter_patch_candidates():\n   if patched:\n    self.assertTrue(source.startswith(\"django.contrib.auth.\"),\n    \"obj=%r attr=%r was not reverted: %r\"%\n    (obj,attr,source))\n   else :\n    self.assertFalse(source.startswith(\"passlib.\"),\n    \"obj=%r attr=%r should not have been patched: %r\"%\n    (obj,attr,source))\n    \n def assert_patched(self,context=None ):\n  ''\n\n  \n  \n  mod=sys.modules.get(\"passlib.ext.django.models\")\n  self.assertTrue(mod and mod.adapter.patched,\"patch should have been enabled\")\n  \n  \n  for obj,attr,source,patched in self._iter_patch_candidates():\n   if patched:\n    self.assertTrue(source ==\"passlib.ext.django.utils\",\n    \"obj=%r attr=%r should have been patched: %r\"%\n    (obj,attr,source))\n   else :\n    self.assertFalse(source.startswith(\"passlib.\"),\n    \"obj=%r attr=%r should not have been patched: %r\"%\n    (obj,attr,source))\n    \n    \n  if context is not None :\n   context=CryptContext._norm_source(context)\n   self.assertEqual(mod.password_context.to_dict(resolve=True ),\n   context.to_dict(resolve=True ))\n   \n   \n   \n   \n   \n _config_keys=[\"PASSLIB_CONFIG\",\"PASSLIB_CONTEXT\",\"PASSLIB_GET_CATEGORY\"]\n \n def load_extension(self,check=True ,**kwds):\n  ''\n\n  \n  self.unload_extension()\n  if check:\n   config=kwds.get(\"PASSLIB_CONFIG\")or kwds.get(\"PASSLIB_CONTEXT\")\n  for key in self._config_keys:\n   kwds.setdefault(key,UNSET)\n  update_settings(**kwds)\n  import passlib.ext.django.models\n  if check:\n   self.assert_patched(context=config)\n   \n def unload_extension(self):\n  ''\n\n  \n  \n  mod=sys.modules.get(\"passlib.ext.django.models\")\n  if mod:\n   mod.adapter.remove_patch()\n   del sys.modules[\"passlib.ext.django.models\"]\n   \n  update_settings(**dict((key,UNSET)for key in self._config_keys))\n  \n  self.assert_unpatched()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass _ExtensionTest(TestCase,_ExtensionSupport):\n ''\n\n\n \n \n \n \n \n def setUp(self):\n  super(_ExtensionTest,self).setUp()\n  \n  self.require_TEST_MODE(\"default\")\n  \n  if not DJANGO_VERSION:\n   raise self.skipTest(\"Django not installed\")\n  elif not has_min_django:\n   raise self.skipTest(\"Django version too old\")\n   \n   \n  self.unload_extension()\n  \n  \n  self.addCleanup(self.unload_extension)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nPASS1=\"toomanysecrets\"\nWRONG1=\"letmein\"\n\n\nclass DjangoBehaviorTest(_ExtensionTest):\n ''\n\n\n\n\n\n\n \n \n \n \n \n descriptionPrefix=\"verify django behavior\"\n \n \n \n patched=False\n \n \n \n config=stock_config\n \n \n \n \n \n \n \n \n \n \n @memoized_property\n def context(self):\n  ''\n\n  \n  return CryptContext._norm_source(self.config)\n  \n def assert_unusable_password(self,user):\n  ''\n\n  \n  self.assertTrue(user.password.startswith(\"!\"))\n  self.assertFalse(user.has_usable_password())\n  self.assertEqual(user.pop_saved_passwords(),[])\n  \n def assert_valid_password(self,user,hash=UNSET,saved=None ):\n  ''\n\n\n\n  \n  if hash is UNSET:\n   self.assertNotEqual(user.password,\"!\")\n   self.assertNotEqual(user.password,None )\n  else :\n   self.assertEqual(user.password,hash)\n  self.assertTrue(user.has_usable_password(),\n  \"hash should be usable: %r\"%(user.password,))\n  self.assertEqual(user.pop_saved_passwords(),\n  []if saved is None else [saved])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_extension_config(self):\n  ''\n\n  \n  if not self.patched:\n   raise self.skipTest(\"extension not loaded\")\n   \n  ctx=self.context\n  \n  \n  from django.contrib.auth.hashers import check_password\n  from passlib.ext.django.models import password_context\n  self.assertEqual(password_context.to_dict(resolve=True ),ctx.to_dict(resolve=True ))\n  \n  \n  from django.contrib.auth.models import check_password as check_password2\n  self.assertEqual(check_password2,check_password)\n  \n def test_default_algorithm(self):\n  ''\n\n  \n  ctx=self.context\n  \n  \n  from django.contrib.auth.hashers import make_password\n  \n  \n  user=FakeUser()\n  user.set_password(PASS1)\n  self.assertTrue(ctx.handler().verify(PASS1,user.password))\n  self.assert_valid_password(user)\n  \n  \n  \n  \n  hash=make_password(PASS1)\n  self.assertTrue(ctx.handler().verify(PASS1,hash))\n  \n  \n  \n def test_empty_password(self):\n  ''\n\n  \n  ctx=self.context\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  user=FakeUser()\n  user.set_password('')\n  hash=user.password\n  self.assertTrue(ctx.handler().verify('',hash))\n  self.assert_valid_password(user,hash)\n  \n  \n  self.assertTrue(user.check_password(\"\"))\n  self.assert_valid_password(user,hash)\n  \n  \n  \n  \n  \n  \n  \n  \n  self.assertTrue(check_password(\"\",hash))\n  \n def test_unusable_flag(self):\n  ''\n\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  user=FakeUser()\n  user.set_unusable_password()\n  self.assert_unusable_password(user)\n  \n  \n  user=FakeUser()\n  user.set_password(None )\n  self.assert_unusable_password(user)\n  \n  \n  self.assertFalse(user.check_password(None ))\n  self.assertFalse(user.check_password('None'))\n  self.assertFalse(user.check_password(''))\n  self.assertFalse(user.check_password(PASS1))\n  self.assertFalse(user.check_password(WRONG1))\n  self.assert_unusable_password(user)\n  \n  \n  self.assertTrue(make_password(None ).startswith(\"!\"))\n  \n  \n  self.assertFalse(check_password(PASS1,'!'))\n  \n  \n  self.assertFalse(is_password_usable(user.password))\n  self.assertRaises(ValueError,identify_hasher,user.password)\n  \n def test_none_hash_value(self):\n  ''\n\n  \n  patched=self.patched\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  user=FakeUser()\n  user.password=None\n  if quirks.none_causes_check_password_error and not patched:\n  \n   self.assertRaises(TypeError,user.check_password,PASS1)\n  else :\n   self.assertFalse(user.check_password(PASS1))\n   \n  self.assertEqual(user.has_usable_password(),\n  quirks.empty_is_usable_password)\n  \n  \n  \n  \n  \n  \n  if quirks.none_causes_check_password_error and not patched:\n   self.assertRaises(TypeError,check_password,PASS1,None )\n  else :\n   self.assertFalse(check_password(PASS1,None ))\n   \n   \n  self.assertRaises(TypeError,identify_hasher,None )\n  \n def test_empty_hash_value(self):\n  ''\n\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  \n  user=FakeUser()\n  user.password=\"\"\n  self.assertFalse(user.check_password(PASS1))\n  \n  \n  self.assertEqual(user.password,\"\")\n  self.assertEqual(user.pop_saved_passwords(),[])\n  \n  \n  self.assertEqual(user.has_usable_password(),quirks.empty_is_usable_password)\n  \n  \n  \n  \n  \n  \n  self.assertFalse(check_password(PASS1,\"\"))\n  \n  \n  self.assertRaises(ValueError,identify_hasher,\"\")\n  \n def test_invalid_hash_values(self):\n  ''\n\n  \n  for hash in [\n  \"$789$foo\",\n  ]:\n   with self.subTest(hash=hash):\n    self._do_test_invalid_hash_value(hash)\n    \n def _do_test_invalid_hash_value(self,hash):\n \n \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  \n  user=FakeUser()\n  user.password=hash\n  self.assertFalse(user.check_password(PASS1))\n  \n  \n  self.assertEqual(user.password,hash)\n  self.assertEqual(user.pop_saved_passwords(),[])\n  \n  \n  self.assertEqual(user.has_usable_password(),quirks.invalid_is_usable_password)\n  \n  \n  \n  \n  \n  \n  self.assertFalse(check_password(PASS1,hash))\n  \n  \n  self.assertRaises(ValueError,identify_hasher,hash)\n  \n def test_available_schemes(self):\n  ''\n\n\n  \n  for scheme in self.context.schemes():\n   with self.subTest(scheme=scheme):\n    self._do_test_available_scheme(scheme)\n    \n def _do_test_available_scheme(self,scheme):\n  ''\n\n\n  \n  log=self.getLogger()\n  ctx=self.context\n  patched=self.patched\n  setter=create_mock_setter()\n  \n  \n  from django.contrib.auth.hashers import (\n  check_password,\n  make_password,\n  is_password_usable,\n  identify_hasher,\n  )\n  \n  \n  \n  \n  handler=ctx.handler(scheme)\n  log.debug(\"testing scheme: %r => %r\",scheme,handler)\n  deprecated=ctx.handler(scheme).deprecated\n  assert not deprecated or scheme !=ctx.default_scheme()\n  try :\n   testcase=get_handler_case(scheme)\n  except exc.MissingBackendError:\n   raise self.skipTest(\"backend not available\")\n  assert handler_derived_from(handler,testcase.handler)\n  if handler.is_disabled:\n   raise self.skipTest(\"skip disabled hasher\")\n   \n   \n   \n   \n  if not patched and not check_django_hasher_has_backend(handler.django_name):\n   assert scheme in [\"django_bcrypt\",\"django_bcrypt_sha256\",\"django_argon2\"],\\\n   \"%r scheme should always have active backend\"%scheme\n   log.warning(\"skipping scheme %r due to missing django dependency\",scheme)\n   raise self.skipTest(\"skip due to missing dependency\")\n   \n   \n  try :\n   secret,hash=sample_hashes[scheme]\n  except KeyError:\n   get_sample_hash=testcase(\"setUp\").get_sample_hash\n   while True :\n    secret,hash=get_sample_hash()\n    if secret:\n     break\n  other='dontletmein'\n  \n  \n  \n  \n  \n  \n  \n  \n  user=FakeUser()\n  user.password=hash\n  \n  \n  self.assertFalse(user.check_password(None ))\n  \n  self.assertFalse(user.check_password(other))\n  self.assert_valid_password(user,hash)\n  \n  \n  self.assertTrue(user.check_password(secret))\n  \n  \n  \n  needs_update=deprecated\n  if needs_update:\n   self.assertNotEqual(user.password,hash)\n   self.assertFalse(handler.identify(user.password))\n   self.assertTrue(ctx.handler().verify(secret,user.password))\n   self.assert_valid_password(user,saved=user.password)\n  else :\n   self.assert_valid_password(user,hash)\n   \n   \n  if TEST_MODE(max=\"default\"):\n   return\n   \n   \n   \n   \n  alg=DjangoTranslator().passlib_to_django_name(scheme)\n  hash2=make_password(secret,hasher=alg)\n  self.assertTrue(handler.verify(secret,hash2))\n  \n  \n  \n  \n  \n  self.assertTrue(check_password(secret,hash,setter=setter))\n  self.assertEqual(setter.popstate(),[secret]if needs_update else [])\n  \n  \n  self.assertFalse(check_password(other,hash,setter=setter))\n  self.assertEqual(setter.popstate(),[])\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self.assertTrue(is_password_usable(hash))\n  name=DjangoTranslator().django_to_passlib_name(identify_hasher(hash).algorithm)\n  self.assertEqual(name,scheme)\n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass ExtensionBehaviorTest(DjangoBehaviorTest):\n ''\n\n \n descriptionPrefix=\"verify extension behavior\"\n \n config=dict(\n schemes=\"sha256_crypt,md5_crypt,des_crypt\",\n deprecated=\"des_crypt\",\n )\n \n def setUp(self):\n  super(ExtensionBehaviorTest,self).setUp()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=self.config)\n  self.patched=True\n  \n  \n  \n  \n  \nclass DjangoExtensionTest(_ExtensionTest):\n ''\n\n \n \n \n \n \n descriptionPrefix=\"passlib.ext.django plugin\"\n \n \n \n \n \n def test_00_patch_control(self):\n  ''\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"disabled\",check=False )\n  self.assert_unpatched()\n  \n  \n  with self.assertWarningList(\"PASSLIB_CONFIG=None is deprecated\"):\n   self.load_extension(PASSLIB_CONFIG=None ,check=False )\n  self.assert_unpatched()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.0\",check=False )\n  self.assert_patched(context=django10_context)\n  \n  \n  self.unload_extension()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.4\",check=False )\n  self.assert_patched(context=django14_context)\n  \n  \n  self.unload_extension()\n  \n def test_01_overwrite_detection(self):\n  ''\n  \n  \n  \n  \n  \n  config=\"[passlib]\\nschemes=des_crypt\\n\"\n  self.load_extension(PASSLIB_CONFIG=config)\n  \n  \n  import django.contrib.auth.models as models\n  from passlib.ext.django.models import adapter\n  def dummy():\n   pass\n   \n   \n  orig=models.User.set_password\n  models.User.set_password=dummy\n  with self.assertWarningList(\"another library has patched.*User\\.set_password\"):\n   adapter._manager.check_all()\n  models.User.set_password=orig\n  \n  \n  orig=models.check_password\n  models.check_password=dummy\n  with self.assertWarningList(\"another library has patched.*models:check_password\"):\n   adapter._manager.check_all()\n  models.check_password=orig\n  \n def test_02_handler_wrapper(self):\n  ''\n  from django.contrib.auth import hashers\n  \n  passlib_to_django=DjangoTranslator().passlib_to_django\n  \n  \n  if DJANGO_VERSION >(1,10):\n   self.assertRaises(ValueError,passlib_to_django,\"hex_md5\")\n  else :\n   hasher=passlib_to_django(\"hex_md5\")\n   self.assertIsInstance(hasher,hashers.UnsaltedMD5PasswordHasher)\n   \n   \n   \n   \n  hasher=passlib_to_django(\"django_bcrypt\")\n  self.assertIsInstance(hasher,hashers.BCryptPasswordHasher)\n  \n  \n  from passlib.hash import sha256_crypt\n  hasher=passlib_to_django(\"sha256_crypt\")\n  self.assertEqual(hasher.algorithm,\"passlib_sha256_crypt\")\n  \n  \n  encoded=hasher.encode(\"stub\")\n  self.assertTrue(sha256_crypt.verify(\"stub\",encoded))\n  self.assertTrue(hasher.verify(\"stub\",encoded))\n  self.assertFalse(hasher.verify(\"xxxx\",encoded))\n  \n  \n  encoded=hasher.encode(\"stub\",\"abcd\"*4,rounds=1234)\n  self.assertEqual(encoded,\"$5$rounds=1234$abcdabcdabcdabcd$\"\n  \"v2RWkZQzctPdejyRqmmTDQpZN6wTh7.RUy9zF2LftT6\")\n  self.assertEqual(hasher.safe_summary(encoded),\n  {'algorithm':'sha256_crypt',\n  'salt':u('abcdab**********'),\n  'rounds':1234,\n  'hash':u('v2RWkZ*************************************'),\n  })\n  \n  \n  \n  self.assertRaises(KeyError,passlib_to_django,\"does_not_exist\")\n  \n  \n  \n  \n def test_11_config_disabled(self):\n  ''\n  \n  with self.assertWarningList(\"PASSLIB_CONFIG=None is deprecated\"):\n   self.load_extension(PASSLIB_CONFIG=None ,check=False )\n  self.assert_unpatched()\n  \n  \n  self.load_extension(PASSLIB_CONFIG=\"disabled\",check=False )\n  self.assert_unpatched()\n  \n def test_12_config_presets(self):\n  ''\n  \n  self.load_extension(PASSLIB_CONTEXT=\"django-default\",check=False )\n  ctx=django16_context\n  self.assert_patched(ctx)\n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.0\",check=False )\n  self.assert_patched(django10_context)\n  \n  self.load_extension(PASSLIB_CONFIG=\"django-1.4\",check=False )\n  self.assert_patched(django14_context)\n  \n def test_13_config_defaults(self):\n  ''\n  \n  from passlib.ext.django.utils import PASSLIB_DEFAULT\n  default=CryptContext.from_string(PASSLIB_DEFAULT)\n  self.load_extension()\n  self.assert_patched(PASSLIB_DEFAULT)\n  \n  \n  self.load_extension(PASSLIB_CONTEXT=\"passlib-default\",check=False )\n  self.assert_patched(PASSLIB_DEFAULT)\n  \n  \n  self.load_extension(PASSLIB_CONTEXT=PASSLIB_DEFAULT,check=False )\n  self.assert_patched(PASSLIB_DEFAULT)\n  \n def test_14_config_invalid(self):\n  ''\n  update_settings(PASSLIB_CONTEXT=123,PASSLIB_CONFIG=UNSET)\n  self.assertRaises(TypeError,__import__,'passlib.ext.django.models')\n  \n  self.unload_extension()\n  update_settings(PASSLIB_CONFIG=\"missing-preset\",PASSLIB_CONTEXT=UNSET)\n  self.assertRaises(ValueError,__import__,'passlib.ext.django.models')\n  \n  \n  \n  \n def test_21_category_setting(self):\n  ''\n  \n  config=dict(\n  schemes=[\"sha256_crypt\"],\n  sha256_crypt__default_rounds=1000,\n  staff__sha256_crypt__default_rounds=2000,\n  superuser__sha256_crypt__default_rounds=3000,\n  )\n  from passlib.hash import sha256_crypt\n  \n  def run(**kwds):\n   ''\n   user=FakeUser(**kwds)\n   user.set_password(\"stub\")\n   return sha256_crypt.from_string(user.password).rounds\n   \n   \n  self.load_extension(PASSLIB_CONFIG=config)\n  self.assertEqual(run(),1000)\n  self.assertEqual(run(is_staff=True ),2000)\n  self.assertEqual(run(is_superuser=True ),3000)\n  \n  \n  def get_category(user):\n   return user.first_name or None\n  self.load_extension(PASSLIB_CONTEXT=config,\n  PASSLIB_GET_CATEGORY=get_category)\n  self.assertEqual(run(),1000)\n  self.assertEqual(run(first_name='other'),1000)\n  self.assertEqual(run(first_name='staff'),2000)\n  self.assertEqual(run(first_name='superuser'),3000)\n  \n  \n  def get_category(user):\n   return None\n  self.load_extension(PASSLIB_CONTEXT=config,\n  PASSLIB_GET_CATEGORY=get_category)\n  self.assertEqual(run(),1000)\n  self.assertEqual(run(first_name='other'),1000)\n  self.assertEqual(run(first_name='staff',is_staff=True ),1000)\n  self.assertEqual(run(first_name='superuser',is_superuser=True ),1000)\n  \n  \n  self.assertRaises(TypeError,self.load_extension,PASSLIB_CONTEXT=config,\n  PASSLIB_GET_CATEGORY='x')\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "django.apps", "django.conf", "django.contrib.auth", "django.contrib.auth.hashers", "django.contrib.auth.models", "logging", "passlib", "passlib.apps", "passlib.context", "passlib.ext.django.models", "passlib.ext.django.utils", "passlib.hash", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.compat", "passlib.utils.decor", "re", "sys"]], "passlib.Lib.site-packages.passlib.tests.test_registry": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom logging import getLogger\nimport warnings\nimport sys\n\n\nfrom passlib import hash,registry,exc\nfrom passlib.registry import register_crypt_handler,register_crypt_handler_path,\\\nget_crypt_handler,list_crypt_handlers,_unload_handler_name as unload_handler_name\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import TestCase\n\nlog=getLogger(__name__)\n\n\n\n\n\n\n\n\nclass dummy_0(uh.StaticHandler):\n name=\"dummy_0\"\n \nclass alt_dummy_0(uh.StaticHandler):\n name=\"dummy_0\"\n \ndummy_x=1\n\n\n\n\nclass RegistryTest(TestCase):\n\n descriptionPrefix=\"passlib.registry\"\n \n def setUp(self):\n  super(RegistryTest,self).setUp()\n  \n  \n  locations=dict(registry._locations)\n  handlers=dict(registry._handlers)\n  def restore():\n   registry._locations.clear()\n   registry._locations.update(locations)\n   registry._handlers.clear()\n   registry._handlers.update(handlers)\n  self.addCleanup(restore)\n  \n def test_hash_proxy(self):\n  ''\n  \n  dir(hash)\n  \n  \n  repr(hash)\n  \n  \n  self.assertRaises(AttributeError,getattr,hash,'fooey')\n  \n  \n  \n  old=getattr(hash,\"__loader__\",None )\n  test=object()\n  hash.__loader__=test\n  self.assertIs(hash.__loader__,test)\n  if old is None :\n   del hash.__loader__\n   self.assertFalse(hasattr(hash,\"__loader__\"))\n  else :\n   hash.__loader__=old\n   self.assertIs(hash.__loader__,old)\n   \n   \n  class dummy_1(uh.StaticHandler):\n   name=\"dummy_1\"\n  hash.dummy_1=dummy_1\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  \n  self.assertRaises(ValueError,setattr,hash,\"dummy_1x\",dummy_1)\n  \n def test_register_crypt_handler_path(self):\n  ''\n  \n  paths=registry._locations\n  \n  \n  self.assertTrue('dummy_0'not in paths)\n  self.assertFalse(hasattr(hash,'dummy_0'))\n  \n  \n  self.assertRaises(ValueError,register_crypt_handler_path,\n  \"dummy_0\",\".test_registry\")\n  self.assertRaises(ValueError,register_crypt_handler_path,\n  \"dummy_0\",__name__+\":dummy_0:xxx\")\n  self.assertRaises(ValueError,register_crypt_handler_path,\n  \"dummy_0\",__name__+\":dummy_0.xxx\")\n  \n  \n  register_crypt_handler_path('dummy_0',__name__)\n  self.assertTrue('dummy_0'in list_crypt_handlers())\n  self.assertTrue('dummy_0'not in list_crypt_handlers(loaded_only=True ))\n  self.assertIs(hash.dummy_0,dummy_0)\n  self.assertTrue('dummy_0'in list_crypt_handlers(loaded_only=True ))\n  unload_handler_name('dummy_0')\n  \n  \n  register_crypt_handler_path('dummy_0',__name__+':alt_dummy_0')\n  self.assertIs(hash.dummy_0,alt_dummy_0)\n  unload_handler_name('dummy_0')\n  \n  \n  register_crypt_handler_path('dummy_x',__name__)\n  self.assertRaises(TypeError,get_crypt_handler,'dummy_x')\n  \n  \n  register_crypt_handler_path('alt_dummy_0',__name__)\n  self.assertRaises(ValueError,get_crypt_handler,\"alt_dummy_0\")\n  unload_handler_name(\"alt_dummy_0\")\n  \n  \n  sys.modules.pop(\"passlib.tests._test_bad_register\",None )\n  register_crypt_handler_path(\"dummy_bad\",\"passlib.tests._test_bad_register\")\n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\",\"xxxxxxxxxx\",DeprecationWarning)\n   h=get_crypt_handler(\"dummy_bad\")\n  from passlib.tests import _test_bad_register as tbr\n  self.assertIs(h,tbr.alt_dummy_bad)\n  \n def test_register_crypt_handler(self):\n  ''\n  \n  self.assertRaises(TypeError,register_crypt_handler,{})\n  \n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=None )))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"AB_CD\")))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"ab-cd\")))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"ab__cd\")))\n  self.assertRaises(ValueError,register_crypt_handler,type('x',(uh.StaticHandler,),dict(name=\"default\")))\n  \n  class dummy_1(uh.StaticHandler):\n   name=\"dummy_1\"\n   \n  class dummy_1b(uh.StaticHandler):\n   name=\"dummy_1\"\n   \n  self.assertTrue('dummy_1'not in list_crypt_handlers())\n  \n  register_crypt_handler(dummy_1)\n  register_crypt_handler(dummy_1)\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  self.assertRaises(KeyError,register_crypt_handler,dummy_1b)\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  register_crypt_handler(dummy_1b,force=True )\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1b)\n  \n  self.assertTrue('dummy_1'in list_crypt_handlers())\n  \n def test_get_crypt_handler(self):\n  ''\n  \n  class dummy_1(uh.StaticHandler):\n   name=\"dummy_1\"\n   \n   \n  self.assertRaises(KeyError,get_crypt_handler,\"dummy_1\")\n  self.assertIs(get_crypt_handler(\"dummy_1\",None ),None )\n  \n  \n  register_crypt_handler(dummy_1)\n  self.assertIs(get_crypt_handler(\"dummy_1\"),dummy_1)\n  \n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\",\"handler names should be lower-case, and use underscores instead of hyphens:.*\",UserWarning)\n   \n   \n   self.assertIs(get_crypt_handler(\"DUMMY-1\"),dummy_1)\n   \n   \n   register_crypt_handler_path('dummy_0',__name__)\n   self.assertIs(get_crypt_handler(\"DUMMY-0\"),dummy_0)\n   \n   \n  from passlib import hash\n  hash.__dict__[\"_fake\"]=\"dummy\"\n  for name in [\"_fake\",\"__package__\"]:\n   self.assertRaises(KeyError,get_crypt_handler,name)\n   self.assertIs(get_crypt_handler(name,None ),None )\n   \n def test_list_crypt_handlers(self):\n  ''\n  from passlib.registry import list_crypt_handlers\n  \n  \n  hash.__dict__[\"_fake\"]=\"dummy\"\n  for name in list_crypt_handlers():\n   self.assertFalse(name.startswith(\"_\"),\"%r: \"%name)\n  unload_handler_name(\"_fake\")\n  \n def test_handlers(self):\n  ''\n  from passlib.registry import list_crypt_handlers\n  from passlib.tests.test_handlers import get_handler_case,conditionally_available_hashes\n  for name in list_crypt_handlers():\n  \n   if name.startswith(\"ldap_\")and name[5:]in list_crypt_handlers():\n    continue\n   if name in [\"roundup_plaintext\"]:\n    continue\n    \n   try :\n    self.assertTrue(get_handler_case(name))\n   except exc.MissingBackendError:\n    if name in conditionally_available_hashes:\n     continue\n    raise\n    \n    \n    \n    \n", ["__future__", "logging", "passlib", "passlib.registry", "passlib.tests", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.handlers", "sys", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_utils": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom functools import partial\nimport warnings\n\n\n\nfrom passlib.utils import is_ascii_safe,to_bytes\nfrom passlib.utils.compat import irange,PY2,PY3,u,unicode,join_bytes,PYPY\nfrom passlib.tests.utils import TestCase,hb,run_with_fixed_seeds\n\n\n\n\nclass MiscTest(TestCase):\n ''\n \n \n \n def test_compat(self):\n  ''\n  from passlib.utils import compat\n  \n  self.assertRegex(repr(compat),\n  r\"^<module 'passlib.utils.compat' from '.*?'>$\")\n  \n  \n  dir(compat)\n  self.assertTrue('UnicodeIO'in dir(compat))\n  self.assertTrue('irange'in dir(compat))\n  \n def test_classproperty(self):\n  from passlib.utils.decor import classproperty\n  \n  class test(object):\n   xvar=1\n   @classproperty\n   def xprop(cls):\n    return cls.xvar\n    \n  self.assertEqual(test.xprop,1)\n  prop=test.__dict__['xprop']\n  self.assertIs(prop.im_func,prop.__func__)\n  \n def test_deprecated_function(self):\n  from passlib.utils.decor import deprecated_function\n  \n  \n  @deprecated_function(deprecated=\"1.6\",removed=\"1.8\")\n  def test_func(*args):\n   ''\n   return args\n   \n  self.assertTrue(\".. deprecated::\"in test_func.__doc__)\n  \n  with self.assertWarningList(dict(category=DeprecationWarning,\n  message=\"the function passlib.tests.test_utils.test_func() \"\n  \"is deprecated as of Passlib 1.6, and will be \"\n  \"removed in Passlib 1.8.\"\n  )):\n   self.assertEqual(test_func(1,2),(1,2))\n   \n def test_memoized_property(self):\n  from passlib.utils.decor import memoized_property\n  \n  class dummy(object):\n   counter=0\n   \n   @memoized_property\n   def value(self):\n    value=self.counter\n    self.counter=value+1\n    return value\n    \n  d=dummy()\n  self.assertEqual(d.value,0)\n  self.assertEqual(d.value,0)\n  self.assertEqual(d.counter,1)\n  \n  prop=dummy.value\n  if not PY3:\n   self.assertIs(prop.im_func,prop.__func__)\n   \n def test_getrandbytes(self):\n  ''\n  from passlib.utils import getrandbytes\n  wrapper=partial(getrandbytes,self.getRandom())\n  self.assertEqual(len(wrapper(0)),0)\n  a=wrapper(10)\n  b=wrapper(10)\n  self.assertIsInstance(a,bytes)\n  self.assertEqual(len(a),10)\n  self.assertEqual(len(b),10)\n  self.assertNotEqual(a,b)\n  \n @run_with_fixed_seeds(count=1024)\n def test_getrandstr(self,seed):\n  ''\n  from passlib.utils import getrandstr\n  \n  wrapper=partial(getrandstr,self.getRandom(seed=seed))\n  \n  \n  self.assertEqual(wrapper('abc',0),'')\n  \n  \n  self.assertRaises(ValueError,wrapper,'abc',-1)\n  \n  \n  self.assertRaises(ValueError,wrapper,'',0)\n  \n  \n  self.assertEqual(wrapper('a',5),'aaaaa')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  x=wrapper(u('abc'),32)\n  y=wrapper(u('abc'),32)\n  self.assertIsInstance(x,unicode)\n  self.assertNotEqual(x,y)\n  self.assertEqual(sorted(set(x)),[u('a'),u('b'),u('c')])\n  \n  \n  x=wrapper(b'abc',32)\n  y=wrapper(b'abc',32)\n  self.assertIsInstance(x,bytes)\n  self.assertNotEqual(x,y)\n  \n  self.assertEqual(sorted(set(x.decode(\"ascii\"))),[u('a'),u('b'),u('c')])\n  \n def test_generate_password(self):\n  ''\n  from passlib.utils import generate_password\n  warnings.filterwarnings(\"ignore\",\"The function.*generate_password\\(\\) is deprecated\")\n  self.assertEqual(len(generate_password(15)),15)\n  \n def test_is_crypt_context(self):\n  ''\n  from passlib.utils import is_crypt_context\n  from passlib.context import CryptContext\n  cc=CryptContext([\"des_crypt\"])\n  self.assertTrue(is_crypt_context(cc))\n  self.assertFalse(not is_crypt_context(cc))\n  \n def test_genseed(self):\n  ''\n  import random\n  from passlib.utils import genseed\n  rng=random.Random(genseed())\n  a=rng.randint(0,10 **10)\n  \n  rng=random.Random(genseed())\n  b=rng.randint(0,10 **10)\n  \n  self.assertNotEqual(a,b)\n  \n  rng.seed(genseed(rng))\n  \n def test_crypt(self):\n  ''\n  from passlib.utils import has_crypt,safe_crypt,test_crypt\n  from passlib.registry import get_supported_os_crypt_schemes,get_crypt_handler\n  \n  \n  supported=get_supported_os_crypt_schemes()\n  if not has_crypt:\n   self.assertEqual(supported,())\n   self.assertEqual(safe_crypt(\"test\",\"aa\"),None )\n   self.assertFalse(test_crypt(\"test\",\"aaqPiZY5xR5l.\"))\n   raise self.skipTest(\"crypt.crypt() not available\")\n   \n   \n  if not supported:\n  \n  \n  \n  \n   raise self.fail(\"crypt() present, but no supported schemes found!\")\n   \n   \n   \n  for scheme in (\"md5_crypt\",\"sha256_crypt\"):\n   if scheme in supported:\n    break\n  else :\n   scheme=supported[-1]\n  hasher=get_crypt_handler(scheme)\n  if getattr(hasher,\"min_rounds\",None ):\n   hasher=hasher.using(rounds=hasher.min_rounds)\n   \n   \n  def get_hash(secret):\n   assert isinstance(secret,unicode)\n   hash=hasher.hash(secret)\n   if isinstance(hash,bytes):\n    hash=hash.decode(\"utf-8\")\n   assert isinstance(hash,unicode)\n   return hash\n   \n   \n  s1=u(\"test\")\n  h1=get_hash(s1)\n  result=safe_crypt(s1,h1)\n  self.assertIsInstance(result,unicode)\n  self.assertEqual(result,h1)\n  self.assertEqual(safe_crypt(to_bytes(s1),to_bytes(h1)),h1)\n  \n  \n  h1x=h1[:-2]+'xx'\n  self.assertEqual(safe_crypt(s1,h1x),h1)\n  \n  \n  s2=u('test\\u1234')\n  h2=get_hash(s2)\n  self.assertEqual(safe_crypt(s2,h2),h2)\n  self.assertEqual(safe_crypt(to_bytes(s2),to_bytes(h2)),h2)\n  \n  \n  self.assertRaises(ValueError,safe_crypt,'\\x00',h1)\n  \n  \n  self.assertTrue(test_crypt(\"test\",h1))\n  self.assertFalse(test_crypt(\"test\",h1x))\n  \n  \n  \n  \n  import passlib.utils as mod\n  orig=mod._crypt\n  try :\n   retval=None\n   mod._crypt=lambda secret,hash:retval\n   \n   for retval in [None ,\"\",\":\",\":0\",\"*0\"]:\n    self.assertEqual(safe_crypt(\"test\",h1),None )\n    self.assertFalse(test_crypt(\"test\",h1))\n    \n   retval='xxx'\n   self.assertEqual(safe_crypt(\"test\",h1),\"xxx\")\n   self.assertFalse(test_crypt(\"test\",h1))\n   \n  finally :\n   mod._crypt=orig\n   \n def test_consteq(self):\n  ''\n  \n  \n  from passlib.utils import consteq,str_consteq\n  \n  \n  self.assertRaises(TypeError,consteq,u(''),b'')\n  self.assertRaises(TypeError,consteq,u(''),1)\n  self.assertRaises(TypeError,consteq,u(''),None )\n  \n  self.assertRaises(TypeError,consteq,b'',u(''))\n  self.assertRaises(TypeError,consteq,b'',1)\n  self.assertRaises(TypeError,consteq,b'',None )\n  \n  self.assertRaises(TypeError,consteq,None ,u(''))\n  self.assertRaises(TypeError,consteq,None ,b'')\n  self.assertRaises(TypeError,consteq,1,u(''))\n  self.assertRaises(TypeError,consteq,1,b'')\n  \n  def consteq_supports_string(value):\n  \n  \n  \n   return (consteq is str_consteq or PY2 or is_ascii_safe(value))\n   \n   \n  for value in [\n  u(\"a\"),\n  u(\"abc\"),\n  u(\"\\xff\\xa2\\x12\\x00\")*10,\n  ]:\n   if consteq_supports_string(value):\n    self.assertTrue(consteq(value,value),\"value %r:\"%(value,))\n   else :\n    self.assertRaises(TypeError,consteq,value,value)\n   self.assertTrue(str_consteq(value,value),\"value %r:\"%(value,))\n   \n   value=value.encode(\"latin-1\")\n   self.assertTrue(consteq(value,value),\"value %r:\"%(value,))\n   \n   \n  for l,r in [\n  \n  (u(\"a\"),u(\"c\")),\n  (u(\"abcabc\"),u(\"zbaabc\")),\n  (u(\"abcabc\"),u(\"abzabc\")),\n  (u(\"abcabc\"),u(\"abcabz\")),\n  ((u(\"\\xff\\xa2\\x12\\x00\")*10)[:-1]+u(\"\\x01\"),\n  u(\"\\xff\\xa2\\x12\\x00\")*10),\n  \n  \n  (u(\"\"),u(\"a\")),\n  (u(\"abc\"),u(\"abcdef\")),\n  (u(\"abc\"),u(\"defabc\")),\n  (u(\"qwertyuiopasdfghjklzxcvbnm\"),u(\"abc\")),\n  ]:\n   if consteq_supports_string(l)and consteq_supports_string(r):\n    self.assertFalse(consteq(l,r),\"values %r %r:\"%(l,r))\n    self.assertFalse(consteq(r,l),\"values %r %r:\"%(r,l))\n   else :\n    self.assertRaises(TypeError,consteq,l,r)\n    self.assertRaises(TypeError,consteq,r,l)\n   self.assertFalse(str_consteq(l,r),\"values %r %r:\"%(l,r))\n   self.assertFalse(str_consteq(r,l),\"values %r %r:\"%(r,l))\n   \n   l=l.encode(\"latin-1\")\n   r=r.encode(\"latin-1\")\n   self.assertFalse(consteq(l,r),\"values %r %r:\"%(l,r))\n   self.assertFalse(consteq(r,l),\"values %r %r:\"%(r,l))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_saslprep(self):\n  ''\n  self.require_stringprep()\n  from passlib.utils import saslprep as sp\n  \n  \n  self.assertRaises(TypeError,sp,None )\n  self.assertRaises(TypeError,sp,1)\n  self.assertRaises(TypeError,sp,b'')\n  \n  \n  self.assertEqual(sp(u('')),u(''))\n  self.assertEqual(sp(u('\\u00AD')),u(''))\n  \n  \n  self.assertEqual(sp(u(\"$\\u00AD$\\u200D$\")),u(\"$$$\"))\n  \n  \n  self.assertEqual(sp(u(\"$ $\\u00A0$\\u3000$\")),u(\"$ $ $ $\"))\n  \n  \n  self.assertEqual(sp(u(\"a\\u0300\")),u(\"\\u00E0\"))\n  self.assertEqual(sp(u(\"\\u00E0\")),u(\"\\u00E0\"))\n  \n  \n  \n  self.assertRaises(ValueError,sp,u(\"\\u0000\"))\n  self.assertRaises(ValueError,sp,u(\"\\u007F\"))\n  self.assertRaises(ValueError,sp,u(\"\\u180E\"))\n  self.assertRaises(ValueError,sp,u(\"\\uFFF9\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uE000\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uFDD0\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uD800\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\uFFFD\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u2FF0\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u200E\"))\n  self.assertRaises(ValueError,sp,u(\"\\u206F\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u0900\"))\n  self.assertRaises(ValueError,sp,u(\"\\uFFF8\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\U000e0001\"))\n  \n  \n  \n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0031\"))\n  self.assertEqual(sp(u(\"\\u0627\")),u(\"\\u0627\"))\n  self.assertEqual(sp(u(\"\\u0627\\u0628\")),u(\"\\u0627\\u0628\"))\n  self.assertEqual(sp(u(\"\\u0627\\u0031\\u0628\")),u(\"\\u0627\\u0031\\u0628\"))\n  \n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0041\\u0628\"))\n  \n  self.assertRaises(ValueError,sp,u(\"x\\u0627z\"))\n  self.assertEqual(sp(u(\"x\\u0041z\")),u(\"x\\u0041z\"))\n  \n  \n  \n  \n  \n  \n  self.assertEqual(sp(u(\"I\\u00ADX\")),u(\"IX\"))\n  self.assertEqual(sp(u(\"user\")),u(\"user\"))\n  self.assertEqual(sp(u(\"USER\")),u(\"USER\"))\n  self.assertEqual(sp(u(\"\\u00AA\")),u(\"a\"))\n  self.assertEqual(sp(u(\"\\u2168\")),u(\"IX\"))\n  self.assertRaises(ValueError,sp,u(\"\\u0007\"))\n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0031\"))\n  \n  \n  \n  self.assertRaises(ValueError,sp,u(\"\\u0627\\u0031\"))\n  self.assertEqual(sp(u(\"\\u0627\\u0031\\u0628\")),u(\"\\u0627\\u0031\\u0628\"))\n  \n def test_splitcomma(self):\n  from passlib.utils import splitcomma\n  self.assertEqual(splitcomma(\"\"),[])\n  self.assertEqual(splitcomma(\",\"),[])\n  self.assertEqual(splitcomma(\"a\"),['a'])\n  self.assertEqual(splitcomma(\" a , \"),['a'])\n  self.assertEqual(splitcomma(\" a , b\"),['a','b'])\n  self.assertEqual(splitcomma(\" a, b, \"),['a','b'])\n  \n def test_utf8_truncate(self):\n  ''\n\n  \n  from passlib.utils import utf8_truncate\n  \n  \n  \n  \n  \n  for source in [\n  \n  b\"\",\n  \n  b\"1\",\n  b\"123\",\n  b'\\x1a',\n  b'\\x1a'*10,\n  b'\\x7f',\n  b'\\x7f'*10,\n  \n  b'a\\xc2\\xa0\\xc3\\xbe\\xc3\\xbe',\n  b'abcdefghjusdfaoiu\\xc2\\xa0\\xc3\\xbe\\xc3\\xbedsfioauweoiruer',\n  ]:\n   source.decode(\"utf-8\")\n   \n   end=len(source)\n   for idx in range(end+16):\n    prefix=\"source=%r index=%r: \"%(source,idx)\n    \n    result=utf8_truncate(source,idx)\n    \n    \n    result.decode(\"utf-8\")\n    \n    \n    self.assertLessEqual(len(result),end,msg=prefix)\n    \n    \n    self.assertGreaterEqual(len(result),min(idx,end),msg=prefix)\n    self.assertLess(len(result),min(idx+4,end+1),msg=prefix)\n    \n    \n    self.assertEqual(result,source[:len(result)],msg=prefix)\n    \n    \n    \n    \n    \n  for source in [\n  b'\\xca',\n  b'\\xca'*10,\n  \n  b'\\x00',\n  b'\\x00'*10,\n  ]:\n   end=len(source)\n   for idx in range(end+16):\n    prefix=\"source=%r index=%r: \"%(source,idx)\n    result=utf8_truncate(source,idx)\n    self.assertEqual(result,source[:idx],msg=prefix)\n    \n    \n    \n    \n    \n  for source in [\n  b'\\xaa',\n  b'\\xaa'*10,\n  ]:\n   end=len(source)\n   for idx in range(end+16):\n    prefix=\"source=%r index=%r: \"%(source,idx)\n    result=utf8_truncate(source,idx)\n    self.assertEqual(result,source[:idx+3],msg=prefix)\n    \n    \n    \n    \n    \n    \n    \n    \n  source=b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab'\n  \n  self.assertEqual(utf8_truncate(source,0),b'')\n  \n  self.assertEqual(utf8_truncate(source,1),b'M')\n  \n  self.assertEqual(utf8_truncate(source,2),b'MN')\n  \n  self.assertEqual(utf8_truncate(source,3),\n  b'MN\\xff\\xa0\\xa1\\xa2')\n  \n  self.assertEqual(utf8_truncate(source,4),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,5),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,6),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,7),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaa')\n  \n  self.assertEqual(utf8_truncate(source,8),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaO')\n  \n  self.assertEqual(utf8_truncate(source,9),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab')\n  \n  self.assertEqual(utf8_truncate(source,10),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab')\n  \n  self.assertEqual(utf8_truncate(source,11),\n  b'MN\\xff\\xa0\\xa1\\xa2\\xaaOP\\xab')\n  \n  \n  \n  \n  \nclass CodecTest(TestCase):\n ''\n \n def test_bytes(self):\n  ''\n  if PY3:\n   import builtins\n   self.assertIs(bytes,builtins.bytes)\n  else :\n   import __builtin__ as builtins\n   self.assertIs(bytes,builtins.str)\n   \n  self.assertIsInstance(b'',bytes)\n  self.assertIsInstance(b'\\x00\\xff',bytes)\n  if PY3:\n   self.assertEqual(b'\\x00\\xff'.decode(\"latin-1\"),\"\\x00\\xff\")\n  else :\n   self.assertEqual(b'\\x00\\xff',\"\\x00\\xff\")\n   \n def test_to_bytes(self):\n  ''\n  from passlib.utils import to_bytes\n  \n  \n  self.assertEqual(to_bytes(u('abc')),b'abc')\n  self.assertEqual(to_bytes(u('\\x00\\xff')),b'\\x00\\xc3\\xbf')\n  \n  \n  self.assertEqual(to_bytes(u('\\x00\\xff'),'latin-1'),b'\\x00\\xff')\n  self.assertRaises(ValueError,to_bytes,u('\\x00\\xff'),'ascii')\n  \n  \n  self.assertEqual(to_bytes(b'abc'),b'abc')\n  self.assertEqual(to_bytes(b'\\x00\\xff'),b'\\x00\\xff')\n  self.assertEqual(to_bytes(b'\\x00\\xc3\\xbf'),b'\\x00\\xc3\\xbf')\n  \n  \n  self.assertEqual(to_bytes(b'\\x00\\xc3\\xbf',\"latin-1\"),\n  b'\\x00\\xc3\\xbf')\n  \n  \n  self.assertEqual(to_bytes(b'\\x00\\xc3\\xbf',\"latin-1\",\"\",\"utf-8\"),\n  b'\\x00\\xff')\n  \n  \n  self.assertRaises(AssertionError,to_bytes,'abc',None )\n  self.assertRaises(TypeError,to_bytes,None )\n  \n def test_to_unicode(self):\n  ''\n  from passlib.utils import to_unicode\n  \n  \n  self.assertEqual(to_unicode(u('abc')),u('abc'))\n  self.assertEqual(to_unicode(u('\\x00\\xff')),u('\\x00\\xff'))\n  \n  \n  self.assertEqual(to_unicode(u('\\x00\\xff'),\"ascii\"),u('\\x00\\xff'))\n  \n  \n  self.assertEqual(to_unicode(b'abc'),u('abc'))\n  self.assertEqual(to_unicode(b'\\x00\\xc3\\xbf'),u('\\x00\\xff'))\n  self.assertEqual(to_unicode(b'\\x00\\xff','latin-1'),\n  u('\\x00\\xff'))\n  self.assertRaises(ValueError,to_unicode,b'\\x00\\xff')\n  \n  \n  self.assertRaises(AssertionError,to_unicode,'abc',None )\n  self.assertRaises(TypeError,to_unicode,None )\n  \n def test_to_native_str(self):\n  ''\n  from passlib.utils import to_native_str\n  \n  \n  self.assertEqual(to_native_str(u('abc'),'ascii'),'abc')\n  self.assertEqual(to_native_str(b'abc','ascii'),'abc')\n  \n  \n  if PY3:\n   self.assertEqual(to_native_str(u('\\xE0'),'ascii'),'\\xE0')\n   self.assertRaises(UnicodeDecodeError,to_native_str,b'\\xC3\\xA0',\n   'ascii')\n  else :\n   self.assertRaises(UnicodeEncodeError,to_native_str,u('\\xE0'),\n   'ascii')\n   self.assertEqual(to_native_str(b'\\xC3\\xA0','ascii'),'\\xC3\\xA0')\n   \n   \n  self.assertEqual(to_native_str(u('\\xE0'),'latin-1'),'\\xE0')\n  self.assertEqual(to_native_str(b'\\xE0','latin-1'),'\\xE0')\n  \n  \n  self.assertEqual(to_native_str(u('\\xE0'),'utf-8'),\n  '\\xE0'if PY3 else '\\xC3\\xA0')\n  self.assertEqual(to_native_str(b'\\xC3\\xA0','utf-8'),\n  '\\xE0'if PY3 else '\\xC3\\xA0')\n  \n  \n  self.assertRaises(TypeError,to_native_str,None ,'ascii')\n  \n def test_is_ascii_safe(self):\n  ''\n  from passlib.utils import is_ascii_safe\n  self.assertTrue(is_ascii_safe(b\"\\x00abc\\x7f\"))\n  self.assertTrue(is_ascii_safe(u(\"\\x00abc\\x7f\")))\n  self.assertFalse(is_ascii_safe(b\"\\x00abc\\x80\"))\n  self.assertFalse(is_ascii_safe(u(\"\\x00abc\\x80\")))\n  \n def test_is_same_codec(self):\n  ''\n  from passlib.utils import is_same_codec\n  \n  self.assertTrue(is_same_codec(None ,None ))\n  self.assertFalse(is_same_codec(None ,'ascii'))\n  \n  self.assertTrue(is_same_codec(\"ascii\",\"ascii\"))\n  self.assertTrue(is_same_codec(\"ascii\",\"ASCII\"))\n  \n  self.assertTrue(is_same_codec(\"utf-8\",\"utf-8\"))\n  self.assertTrue(is_same_codec(\"utf-8\",\"utf8\"))\n  self.assertTrue(is_same_codec(\"utf-8\",\"UTF_8\"))\n  \n  self.assertFalse(is_same_codec(\"ascii\",\"utf-8\"))\n  \n  \n  \n  \nclass Base64EngineTest(TestCase):\n ''\n \n \n def test_constructor(self):\n  from passlib.utils.binary import Base64Engine,AB64_CHARS\n  \n  \n  self.assertRaises(TypeError,Base64Engine,1)\n  \n  \n  self.assertRaises(ValueError,Base64Engine,AB64_CHARS[:-1])\n  \n  \n  self.assertRaises(ValueError,Base64Engine,AB64_CHARS[:-1]+\"A\")\n  \n def test_ab64_decode(self):\n  ''\n  from passlib.utils.binary import ab64_decode\n  \n  \n  self.assertEqual(ab64_decode(b\"abc\"),hb(\"69b7\"))\n  self.assertEqual(ab64_decode(u(\"abc\")),hb(\"69b7\"))\n  \n  \n  self.assertRaises(ValueError,ab64_decode,u(\"ab\\xff\"))\n  \n  \n  self.assertRaises(TypeError,ab64_decode,b\"ab\\xff\")\n  self.assertRaises(TypeError,ab64_decode,b\"ab!\")\n  self.assertRaises(TypeError,ab64_decode,u(\"ab!\"))\n  \n  \n  self.assertEqual(ab64_decode(b\"abcd\"),hb(\"69b71d\"))\n  self.assertRaises(ValueError,ab64_decode,b\"abcde\")\n  self.assertEqual(ab64_decode(b\"abcdef\"),hb(\"69b71d79\"))\n  self.assertEqual(ab64_decode(b\"abcdeQ\"),hb(\"69b71d79\"))\n  self.assertEqual(ab64_decode(b\"abcdefg\"),hb(\"69b71d79f8\"))\n  \n  \n  \n  self.assertEqual(ab64_decode(b\"ab+/\"),hb(\"69bfbf\"))\n  self.assertEqual(ab64_decode(b\"ab./\"),hb(\"69bfbf\"))\n  \n def test_ab64_encode(self):\n  ''\n  from passlib.utils.binary import ab64_encode\n  \n  \n  self.assertEqual(ab64_encode(hb(\"69b7\")),b\"abc\")\n  \n  \n  self.assertRaises(TypeError if PY3 else UnicodeEncodeError,\n  ab64_encode,hb(\"69b7\").decode(\"latin-1\"))\n  \n  \n  self.assertEqual(ab64_encode(hb(\"69b71d\")),b\"abcd\")\n  self.assertEqual(ab64_encode(hb(\"69b71d79\")),b\"abcdeQ\")\n  self.assertEqual(ab64_encode(hb(\"69b71d79f8\")),b\"abcdefg\")\n  \n  \n  self.assertEqual(ab64_encode(hb(\"69bfbf\")),b\"ab./\")\n  \n def test_b64s_decode(self):\n  ''\n  from passlib.utils.binary import b64s_decode\n  \n  \n  self.assertEqual(b64s_decode(b\"abc\"),hb(\"69b7\"))\n  self.assertEqual(b64s_decode(u(\"abc\")),hb(\"69b7\"))\n  \n  \n  self.assertRaises(ValueError,b64s_decode,u(\"ab\\xff\"))\n  \n  \n  self.assertRaises(TypeError,b64s_decode,b\"ab\\xff\")\n  self.assertRaises(TypeError,b64s_decode,b\"ab!\")\n  self.assertRaises(TypeError,b64s_decode,u(\"ab!\"))\n  \n  \n  self.assertEqual(b64s_decode(b\"abcd\"),hb(\"69b71d\"))\n  self.assertRaises(ValueError,b64s_decode,b\"abcde\")\n  self.assertEqual(b64s_decode(b\"abcdef\"),hb(\"69b71d79\"))\n  self.assertEqual(b64s_decode(b\"abcdeQ\"),hb(\"69b71d79\"))\n  self.assertEqual(b64s_decode(b\"abcdefg\"),hb(\"69b71d79f8\"))\n  \n def test_b64s_encode(self):\n  ''\n  from passlib.utils.binary import b64s_encode\n  \n  \n  self.assertEqual(b64s_encode(hb(\"69b7\")),b\"abc\")\n  \n  \n  self.assertRaises(TypeError if PY3 else UnicodeEncodeError,\n  b64s_encode,hb(\"69b7\").decode(\"latin-1\"))\n  \n  \n  self.assertEqual(b64s_encode(hb(\"69b71d\")),b\"abcd\")\n  self.assertEqual(b64s_encode(hb(\"69b71d79\")),b\"abcdeQ\")\n  self.assertEqual(b64s_encode(hb(\"69b71d79f8\")),b\"abcdefg\")\n  \n  \n  self.assertEqual(b64s_encode(hb(\"69bfbf\")),b\"ab+/\")\n  \nclass _Base64Test(TestCase):\n ''\n \n \n \n \n \n engine=None\n \n \n encoded_data=None\n \n \n encoded_ints=None\n \n \n bad_byte=b\"?\"\n \n \n def m(self,*offsets):\n  ''\n  return join_bytes(self.engine.bytemap[o:o+1]for o in offsets)\n  \n  \n  \n  \n def test_encode_bytes(self):\n  ''\n  engine=self.engine\n  encode=engine.encode_bytes\n  for raw,encoded in self.encoded_data:\n   result=encode(raw)\n   self.assertEqual(result,encoded,\"encode %r:\"%(raw,))\n   \n def test_encode_bytes_bad(self):\n  ''\n  engine=self.engine\n  encode=engine.encode_bytes\n  self.assertRaises(TypeError,encode,u('\\x00'))\n  self.assertRaises(TypeError,encode,None )\n  \n  \n  \n  \n def test_decode_bytes(self):\n  ''\n  engine=self.engine\n  decode=engine.decode_bytes\n  for raw,encoded in self.encoded_data:\n   result=decode(encoded)\n   self.assertEqual(result,raw,\"decode %r:\"%(encoded,))\n   \n def test_decode_bytes_padding(self):\n  ''\n  bchr=(lambda v:bytes([v]))if PY3 else chr\n  engine=self.engine\n  m=self.m\n  decode=engine.decode_bytes\n  BNULL=b\"\\x00\"\n  \n  \n  self.assertEqual(decode(m(0,0)),BNULL)\n  for i in range(0,6):\n   if engine.big:\n    correct=BNULL if i <4 else bchr(1 <<(i -4))\n   else :\n    correct=bchr(1 <<(i+6))if i <2 else BNULL\n   self.assertEqual(decode(m(0,1 <<i)),correct,\"%d/4 bits:\"%i)\n   \n   \n  self.assertEqual(decode(m(0,0,0)),BNULL *2)\n  for i in range(0,6):\n   if engine.big:\n    correct=BNULL if i <2 else bchr(1 <<(i -2))\n   else :\n    correct=bchr(1 <<(i+4))if i <4 else BNULL\n   self.assertEqual(decode(m(0,0,1 <<i)),BNULL+correct,\n   \"%d/2 bits:\"%i)\n   \n def test_decode_bytes_bad(self):\n  ''\n  engine=self.engine\n  decode=engine.decode_bytes\n  \n  \n  self.assertRaises(ValueError,decode,engine.bytemap[:5])\n  \n  \n  self.assertTrue(self.bad_byte not in engine.bytemap)\n  self.assertRaises(ValueError,decode,self.bad_byte *4)\n  \n  \n  self.assertRaises(TypeError,decode,engine.charmap[:4])\n  self.assertRaises(TypeError,decode,None )\n  \n  \n  \n  \n def test_codec(self):\n  ''\n  engine=self.engine\n  from passlib.utils import getrandbytes,getrandstr\n  rng=self.getRandom()\n  saw_zero=False\n  for i in irange(500):\n  \n  \n  \n  \n  \n   size=rng.randint(1 if saw_zero else 0,12)\n   if not size:\n    saw_zero=True\n   enc_size=(4 *size+2)//3\n   raw=getrandbytes(rng,size)\n   \n   \n   encoded=engine.encode_bytes(raw)\n   self.assertEqual(len(encoded),enc_size)\n   \n   \n   result=engine.decode_bytes(encoded)\n   self.assertEqual(result,raw)\n   \n   \n   \n   \n   \n   \n   if size %4 ==1:\n    size +=rng.choice([-1,1,2])\n   raw_size=3 *size //4\n   encoded=getrandstr(rng,engine.bytemap,size)\n   \n   \n   raw=engine.decode_bytes(encoded)\n   self.assertEqual(len(raw),raw_size,\"encoded %d:\"%size)\n   \n   \n   result=engine.encode_bytes(raw)\n   if size %4:\n    self.assertEqual(result[:-1],encoded[:-1])\n   else :\n    self.assertEqual(result,encoded)\n    \n def test_repair_unused(self):\n  ''\n  \n  \n  from passlib.utils import getrandstr\n  rng=self.getRandom()\n  engine=self.engine\n  check_repair_unused=self.engine.check_repair_unused\n  i=0\n  while i <300:\n   size=rng.randint(0,23)\n   cdata=getrandstr(rng,engine.charmap,size).encode(\"ascii\")\n   if size&3 ==1:\n   \n    self.assertRaises(ValueError,check_repair_unused,cdata)\n    continue\n   rdata=engine.encode_bytes(engine.decode_bytes(cdata))\n   if rng.random()<.5:\n    cdata=cdata.decode(\"ascii\")\n    rdata=rdata.decode(\"ascii\")\n   if cdata ==rdata:\n   \n    ok,result=check_repair_unused(cdata)\n    self.assertFalse(ok)\n    self.assertEqual(result,rdata)\n   else :\n   \n    self.assertNotEqual(size %4,0)\n    ok,result=check_repair_unused(cdata)\n    self.assertTrue(ok)\n    self.assertEqual(result,rdata)\n   i +=1\n   \n   \n   \n   \n   \n   \n transposed=[\n \n (b\"\\x33\\x22\\x11\",b\"\\x11\\x22\\x33\",[2,1,0]),\n (b\"\\x22\\x33\\x11\",b\"\\x11\\x22\\x33\",[1,2,0]),\n ]\n \n transposed_dups=[\n \n (b\"\\x11\\x11\\x22\",b\"\\x11\\x22\\x33\",[0,0,1]),\n ]\n \n def test_encode_transposed_bytes(self):\n  ''\n  engine=self.engine\n  for result,input,offsets in self.transposed+self.transposed_dups:\n   tmp=engine.encode_transposed_bytes(input,offsets)\n   out=engine.decode_bytes(tmp)\n   self.assertEqual(out,result)\n   \n  self.assertRaises(TypeError,engine.encode_transposed_bytes,u(\"a\"),[])\n  \n def test_decode_transposed_bytes(self):\n  ''\n  engine=self.engine\n  for input,result,offsets in self.transposed:\n   tmp=engine.encode_bytes(input)\n   out=engine.decode_transposed_bytes(tmp,offsets)\n   self.assertEqual(out,result)\n   \n def test_decode_transposed_bytes_bad(self):\n  ''\n  engine=self.engine\n  for input,_,offsets in self.transposed_dups:\n   tmp=engine.encode_bytes(input)\n   self.assertRaises(TypeError,engine.decode_transposed_bytes,tmp,\n   offsets)\n   \n   \n   \n   \n def check_int_pair(self,bits,encoded_pairs):\n  ''\n  rng=self.getRandom()\n  engine=self.engine\n  encode=getattr(engine,\"encode_int%s\"%bits)\n  decode=getattr(engine,\"decode_int%s\"%bits)\n  pad=-bits %6\n  chars=(bits+pad)//6\n  upper=1 <<bits\n  \n  \n  for value,encoded in encoded_pairs:\n   result=encode(value)\n   self.assertIsInstance(result,bytes)\n   self.assertEqual(result,encoded)\n  self.assertRaises(ValueError,encode,-1)\n  self.assertRaises(ValueError,encode,upper)\n  \n  \n  for value,encoded in encoded_pairs:\n   self.assertEqual(decode(encoded),value,\"encoded %r:\"%(encoded,))\n  m=self.m\n  self.assertRaises(ValueError,decode,m(0)*(chars+1))\n  self.assertRaises(ValueError,decode,m(0)*(chars -1))\n  self.assertRaises(ValueError,decode,self.bad_byte *chars)\n  self.assertRaises(TypeError,decode,engine.charmap[0])\n  self.assertRaises(TypeError,decode,None )\n  \n  \n  from passlib.utils import getrandstr\n  for i in irange(100):\n  \n   value=rng.randint(0,upper -1)\n   encoded=encode(value)\n   self.assertEqual(len(encoded),chars)\n   self.assertEqual(decode(encoded),value)\n   \n   \n   encoded=getrandstr(rng,engine.bytemap,chars)\n   value=decode(encoded)\n   self.assertGreaterEqual(value,0,\"decode %r out of bounds:\"%encoded)\n   self.assertLess(value,upper,\"decode %r out of bounds:\"%encoded)\n   result=encode(value)\n   if pad:\n    self.assertEqual(result[:-2],encoded[:-2])\n   else :\n    self.assertEqual(result,encoded)\n    \n def test_int6(self):\n  engine=self.engine\n  m=self.m\n  self.check_int_pair(6,[(0,m(0)),(63,m(63))])\n  \n def test_int12(self):\n  engine=self.engine\n  m=self.m\n  self.check_int_pair(12,[(0,m(0,0)),\n  (63,m(0,63)if engine.big else m(63,0)),(0xFFF,m(63,63))])\n  \n def test_int24(self):\n  engine=self.engine\n  m=self.m\n  self.check_int_pair(24,[(0,m(0,0,0,0)),\n  (63,m(0,0,0,63)if engine.big else m(63,0,0,0)),\n  (0xFFFFFF,m(63,63,63,63))])\n  \n def test_int64(self):\n \n \n  engine=self.engine\n  m=self.m\n  self.check_int_pair(64,[(0,m(0,0,0,0,0,0,0,0,0,0,0)),\n  (63,m(0,0,0,0,0,0,0,0,0,3,60)if engine.big else\n  m(63,0,0,0,0,0,0,0,0,0,0)),\n  ((1 <<64)-1,m(63,63,63,63,63,63,63,63,63,63,60)if engine.big\n  else m(63,63,63,63,63,63,63,63,63,63,15))])\n  \n def test_encoded_ints(self):\n  ''\n  if not self.encoded_ints:\n   raise self.skipTests(\"none defined for class\")\n  engine=self.engine\n  for data,value,bits in self.encoded_ints:\n   encode=getattr(engine,\"encode_int%d\"%bits)\n   decode=getattr(engine,\"decode_int%d\"%bits)\n   self.assertEqual(encode(value),data)\n   self.assertEqual(decode(data),value)\n   \n   \n   \n   \n   \n   \n   \nfrom passlib.utils.binary import h64,h64big\n\nclass H64_Test(_Base64Test):\n ''\n engine=h64\n descriptionPrefix=\"h64 codec\"\n \n encoded_data=[\n \n (b\"\",b\"\"),\n (b\"\\x55\",b\"J/\"),\n (b\"\\x55\\xaa\",b\"Jd8\"),\n (b\"\\x55\\xaa\\x55\",b\"JdOJ\"),\n (b\"\\x55\\xaa\\x55\\xaa\",b\"JdOJe0\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\",b\"JdOJeK3\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\\xaa\",b\"JdOJeKZe\"),\n \n \n (b\"\\x55\\xaa\\x55\\xaf\",b\"JdOJj0\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x5f\",b\"JdOJey3\"),\n ]\n \n encoded_ints=[\n (b\"z.\",63,12),\n (b\".z\",4032,12),\n ]\n \nclass H64Big_Test(_Base64Test):\n ''\n engine=h64big\n descriptionPrefix=\"h64big codec\"\n \n encoded_data=[\n \n (b\"\",b\"\"),\n (b\"\\x55\",b\"JE\"),\n (b\"\\x55\\xaa\",b\"JOc\"),\n (b\"\\x55\\xaa\\x55\",b\"JOdJ\"),\n (b\"\\x55\\xaa\\x55\\xaa\",b\"JOdJeU\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\",b\"JOdJeZI\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x55\\xaa\",b\"JOdJeZKe\"),\n \n \n (b\"\\x55\\xaa\\x55\\xaf\",b\"JOdJfk\"),\n (b\"\\x55\\xaa\\x55\\xaa\\x5f\",b\"JOdJeZw\"),\n ]\n \n encoded_ints=[\n (b\".z\",63,12),\n (b\"z.\",4032,12),\n ]\n \n \n \n \n", ["__builtin__", "__future__", "builtins", "functools", "passlib.context", "passlib.registry", "passlib.tests.utils", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "random", "warnings"]], "passlib.Lib.site-packages.passlib.tests.tox_support": [".py", "''\n\n\n\nimport os,sys\nroot_dir=os.path.join(os.path.dirname(__file__),os.pardir,os.pardir)\nsys.path.insert(0,root_dir)\n\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.compat import print_\n\n__all__=[\n]\n\n\n\n\nTH_PATH=\"passlib.tests.test_handlers\"\n\ndef do_hash_tests(*args):\n ''\n if not args:\n  print(TH_PATH)\n  return\n suffix=''\n args=list(args)\n while True :\n  if args[0]==\"--method\":\n   suffix='.'+args[1]\n   del args[:2]\n  else :\n   break\n from passlib.tests import test_handlers\n names=[TH_PATH+\":\"+name+suffix for name in dir(test_handlers)\n if not name.startswith(\"_\")and any(re.match(arg,name)for arg in args)]\n print_(\"\\n\".join(names))\n return not names\n \ndef do_preset_tests(name):\n ''\n if name ==\"django\"or name ==\"django-hashes\":\n  do_hash_tests(\"django_.*_test\",\"hex_md5_test\")\n  if name ==\"django\":\n   print_(\"passlib.tests.test_ext_django\")\n else :\n  raise ValueError(\"unknown name: %r\"%name)\n  \ndef do_setup_gae(path,runtime):\n ''\n from passlib.tests.utils import set_file\n set_file(os.path.join(path,\"app.yaml\"),\"\"\"\\\napplication: fake-app\nversion: 2\nruntime: %s\napi_version: 1\nthreadsafe: no\n\nhandlers:\n- url: /.*\n  script: dummy.py\n\nlibraries:\n- name: django\n  version: \"latest\"\n\"\"\"%runtime)\n \ndef main(cmd,*args):\n return globals()[\"do_\"+cmd](*args)\n \nif __name__ ==\"__main__\":\n import sys\n sys.exit(main(*sys.argv[1:])or 0)\n \n \n \n \n", ["logging", "os", "passlib.tests", "passlib.tests.utils", "passlib.utils.compat", "re", "sys"]], "passlib.Lib.site-packages.passlib.tests._test_bad_register": [".py", "''\nfrom passlib.registry import register_crypt_handler\nimport passlib.utils.handlers as uh\n\nclass dummy_bad(uh.StaticHandler):\n name=\"dummy_bad\"\n \nclass alt_dummy_bad(uh.StaticHandler):\n name=\"dummy_bad\"\n \n \n \n \nif __name__.startswith(\"passlib.tests\"):\n register_crypt_handler(alt_dummy_bad)\n", ["passlib.registry", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.tests.test_handlers": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport os\nimport sys\nimport warnings\n\n\nfrom passlib import exc,hash\nfrom passlib.utils import repeat_string\nfrom passlib.utils.compat import irange,PY3,u,get_method_function\nfrom passlib.tests.utils import TestCase,HandlerCase,skipUnless,\\\nTEST_MODE,UserHandlerMixin,EncodingHandlerMixin\n\n\n\n\n\n\n\nUPASS_WAV=u('\\u0399\\u03c9\\u03b1\\u03bd\\u03bd\\u03b7\\u03c2')\nUPASS_USD=u(\"\\u20AC\\u00A5$\")\nUPASS_TABLE=u(\"t\\u00e1\\u0411\\u2113\\u0259\")\n\nPASS_TABLE_UTF8=b't\\xc3\\xa1\\xd0\\x91\\xe2\\x84\\x93\\xc9\\x99'\n\n\n_omitted_backend_tests=[\"django_bcrypt\",\"django_bcrypt_sha256\",\"django_argon2\"]\n\n\n_handler_test_modules=[\n\"test_handlers\",\n\"test_handlers_argon2\",\n\"test_handlers_bcrypt\",\n\"test_handlers_cisco\",\n\"test_handlers_django\",\n\"test_handlers_pbkdf2\",\n\"test_handlers_scrypt\",\n]\n\ndef get_handler_case(scheme):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n from passlib.registry import get_crypt_handler\n handler=get_crypt_handler(scheme)\n if hasattr(handler,\"backends\")and scheme not in _omitted_backend_tests:\n \n \n  try :\n   backend=handler.get_backend()\n  except exc.MissingBackendError:\n   assert scheme in conditionally_available_hashes\n   raise\n  name=\"%s_%s_test\"%(scheme,backend)\n else :\n  name=\"%s_test\"%scheme\n for module in _handler_test_modules:\n  modname=\"passlib.tests.\"+module\n  __import__(modname)\n  mod=sys.modules[modname]\n  try :\n   return getattr(mod,name)\n  except AttributeError:\n   pass\n   \n   \n raise RuntimeError(\"can't find test case named %r for %r\"%(name,scheme))\n \n \n \nconditionally_available_hashes=[\"argon2\",\"bcrypt\",\"bcrypt_sha256\"]\n\n\n\n\nclass apr_md5_crypt_test(HandlerCase):\n handler=hash.apr_md5_crypt\n \n known_correct_hashes=[\n \n \n \n ('myPassword','$apr1$r31.....$HqJZimcKQFAMYayBlzkrA/'),\n \n \n \n \n \n \n (UPASS_TABLE,'$apr1$bzYrOHUx$a1FcpXuQDJV3vPY20CS6N1'),\n ]\n \n known_malformed_hashes=[\n \n '$apr1$r31.....$HqJZimcKQFAMYayBlzkrA!'\n ]\n \n \n \n \nclass bigcrypt_test(HandlerCase):\n handler=hash.bigcrypt\n \n \n known_correct_hashes=[\n \n \n \n \n (\"passphrase\",\"qiyh4XPJGsOZ2MEAyLkfWqeQ\"),\n (\"This is very long passwd\",\"f8.SVpL2fvwjkAnxn8/rgTkwvrif6bjYB5c\"),\n \n \n \n \n \n \n (UPASS_TABLE,'SEChBAyMbMNhgGLyP7kD1HZU'),\n ]\n \n known_unidentified_hashes=[\n \n \"qiyh4XPJGsOZ2MEAyLkfWqe\"\n \n \n \"f8.SVpL2fvwjkAnxn8/rgTkwvrif6bjYB5cd\"\n ]\n \n \n known_other_hashes=[row for row in HandlerCase.known_other_hashes\n if row[0]!=\"des_crypt\"]\n \n def test_90_internal(self):\n \n \n  self.assertRaises(ValueError,hash.bigcrypt,use_defaults=True ,\n  checksum=u('yh4XPJGsOZ'))\n  \n  \n  \n  \nclass _bsdi_crypt_test(HandlerCase):\n ''\n handler=hash.bsdi_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','_J9..CCCCXBrJUJV154M'),\n ('U*U***U','_J9..CCCCXUhOBTXzaiE'),\n ('U*U***U*','_J9..CCCC4gQ.mB/PffM'),\n ('*U*U*U*U','_J9..XXXXvlzQGqpPPdk'),\n ('*U*U*U*U*','_J9..XXXXsqM/YSSP..Y'),\n ('*U*U*U*U*U*U*U*U','_J9..XXXXVL7qJCnku0I'),\n ('*U*U*U*U*U*U*U*U*','_J9..XXXXAj8cFbP5scI'),\n ('ab1234567','_J9..SDizh.vll5VED9g'),\n ('cr1234567','_J9..SDizRjWQ/zePPHc'),\n ('zxyDPWgydbQjgq','_J9..SDizxmRI1GjnQuE'),\n ('726 even','_K9..SaltNrQgIYUAeoY'),\n ('','_J9..SDSD5YGyRCr4W4c'),\n \n \n \n \n (\" \",\"_K1..crsmZxOLzfJH8iw\"),\n (\"my\",'_KR/.crsmykRplHbAvwA'),\n (\"my socra\",\"_K1..crsmf/9NzZr1fLM\"),\n (\"my socrates\",'_K1..crsmOv1rbde9A9o'),\n (\"my socrates note\",\"_K1..crsm/2qeAhdISMA\"),\n \n \n (UPASS_TABLE,'_7C/.ABw0WIKy0ILVqo2'),\n ]\n known_unidentified_hashes=[\n \n \n \"_K1.!crsmZxOLzfJH8iw\"\n ]\n \n platform_crypt_support=[\n \n (\"openbsd[6789]\",False ),\n (\"openbsd5\",None ),\n (\"openbsd\",True ),\n \n (\"freebsd|netbsd|darwin\",True ),\n (\"solaris\",False ),\n (\"linux\",None ),\n ]\n \n def test_77_fuzz_input(self,**kwds):\n \n  warnings.filterwarnings(\"ignore\",\"bsdi_crypt rounds should be odd.*\")\n  super(_bsdi_crypt_test,self).test_77_fuzz_input(**kwds)\n  \n def test_needs_update_w_even_rounds(self):\n  ''\n  handler=self.handler\n  even_hash='_Y/../cG0zkJa6LY6k4c'\n  odd_hash='_Z/..TgFg0/ptQtpAgws'\n  secret='test'\n  \n  \n  self.assertTrue(handler.verify(secret,even_hash))\n  self.assertTrue(handler.verify(secret,odd_hash))\n  \n  \n  self.assertTrue(handler.needs_update(even_hash))\n  self.assertFalse(handler.needs_update(odd_hash))\n  \n  \n  new_hash=handler.hash(\"stub\")\n  self.assertFalse(handler.needs_update(new_hash))\n  \n  \nbsdi_crypt_os_crypt_test=_bsdi_crypt_test.create_backend_case(\"os_crypt\")\nbsdi_crypt_builtin_test=_bsdi_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass crypt16_test(HandlerCase):\n handler=hash.crypt16\n \n \n known_correct_hashes=[\n \n \n \n \n (\"passphrase\",\"qi8H8R7OM4xMUNMPuRAZxlY.\"),\n (\"printf\",\"aaCjFz4Sh8Eg2QSqAReePlq6\"),\n (\"printf\",\"AA/xje2RyeiSU0iBY3PDwjYo\"),\n (\"LOLOAQICI82QB4IP\",\"/.FcK3mad6JwYt8LVmDqz9Lc\"),\n (\"LOLOAQICI\",\"/.FcK3mad6JwYSaRHJoTPzY2\"),\n (\"LOLOAQIC\",\"/.FcK3mad6JwYelhbtlysKy6\"),\n (\"L\",\"/.CIu/PzYCkl6elhbtlysKy6\"),\n \n \n \n \n \n \n (UPASS_TABLE,'YeDc9tKkkmDvwP7buzpwhoqQ'),\n ]\n \n \n \n \nclass _des_crypt_test(HandlerCase):\n ''\n handler=hash.des_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','CCNf8Sbh3HDfQ'),\n ('U*U***U','CCX.K.MFy4Ois'),\n ('U*U***U*','CC4rMpbg9AMZ.'),\n ('*U*U*U*U','XXxzOu6maQKqQ'),\n ('','SDbsugeBiC58A'),\n \n \n \n \n ('','OgAwTx2l6NADI'),\n (' ','/Hk.VPuwQTXbc'),\n ('test','N1tQbOFcM5fpg'),\n ('Compl3X AlphaNu3meric','um.Wguz3eVCx2'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','sNYqfOyauIyic'),\n ('AlOtBsOl','cEpWz5IUCShqM'),\n \n \n (u('hell\\u00D6'),'saykDgk3BPZ9E'),\n ]\n known_unidentified_hashes=[\n \n \n '!gAwTx2l6NADI',\n \n \n 'OgAwTx2l6NAD',\n 'OgAwTx2l6NADIj',\n ]\n \n platform_crypt_support=[\n \n (\"openbsd[6789]\",False ),\n (\"openbsd5\",None ),\n (\"openbsd\",True ),\n \n (\"freebsd|netbsd|linux|solaris|darwin\",True ),\n ]\n \n \ndes_crypt_os_crypt_test=_des_crypt_test.create_backend_case(\"os_crypt\")\ndes_crypt_builtin_test=_des_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass fshp_test(HandlerCase):\n ''\n handler=hash.fshp\n \n known_correct_hashes=[\n \n \n \n \n ('test','{FSHP0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M='),\n \n ('test',\n '{FSHP1|8|4096}MTIzNDU2NzjTdHcmoXwNc0f'\n 'f9+ArUHoN0CvlbPZpxFi1C6RDM/MHSA=='\n ),\n \n ('OrpheanBeholderScryDoubt',\n '{FSHP1|8|4096}GVSUFDAjdh0vBosn1GUhz'\n 'GLHP7BmkbCZVH/3TQqGIjADXpc+6NCg3g=='\n ),\n ('ExecuteOrder66',\n '{FSHP3|16|8192}0aY7rZQ+/PR+Rd5/I9ss'\n 'RM7cjguyT8ibypNaSp/U1uziNO3BVlg5qPU'\n 'ng+zHUDQC3ao/JbzOnIBUtAeWHEy7a2vZeZ'\n '7jAwyJJa2EqOsq4Io='\n ),\n \n \n \n \n \n \n (UPASS_TABLE,'{FSHP1|16|16384}9v6/l3Lu/d9by5nznpOS'\n 'cqQo8eKu/b/CKli3RCkgYg4nRTgZu5y659YV8cCZ68UL'),\n ]\n \n known_unidentified_hashes=[\n \n '{FSHX0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n 'FSHP0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n ]\n \n known_malformed_hashes=[\n \n '{FSHP0|0|1}qUqP5cyxm6YcTAhz05Hph5gvu9M',\n \n \n '{FSHP0|1|1}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n \n \n '{FSHP0|0|A}qUqP5cyxm6YcTAhz05Hph5gvu9M=',\n ]\n \n def test_90_variant(self):\n  ''\n  handler=self.handler\n  kwds=dict(salt=b'a',rounds=1)\n  \n  \n  handler(variant=1,**kwds)\n  \n  \n  handler(variant=u('1'),**kwds)\n  handler(variant=b'1',**kwds)\n  \n  \n  handler(variant=u('sha256'),**kwds)\n  handler(variant=b'sha256',**kwds)\n  \n  \n  self.assertRaises(TypeError,handler,variant=None ,**kwds)\n  \n  \n  self.assertRaises(TypeError,handler,variant=complex(1,1),**kwds)\n  \n  \n  self.assertRaises(ValueError,handler,variant='9',**kwds)\n  self.assertRaises(ValueError,handler,variant=9,**kwds)\n  \n  \n  \n  \nclass hex_md4_test(HandlerCase):\n handler=hash.hex_md4\n known_correct_hashes=[\n (\"password\",'8a9d093f14f8701df17732b2bb182c74'),\n (UPASS_TABLE,'876078368c47817ce5f9115f3a42cf74'),\n ]\n \nclass hex_md5_test(HandlerCase):\n handler=hash.hex_md5\n known_correct_hashes=[\n (\"password\",'5f4dcc3b5aa765d61d8327deb882cf99'),\n (UPASS_TABLE,'05473f8a19f66815e737b33264a0d0b0'),\n ]\n \n \n def test_mock_fips_mode(self):\n  ''\n\n\n  \n  from passlib.exc import UnknownHashError\n  from passlib.crypto.digest import lookup_hash,_set_mock_fips_mode\n  \n  \n  supported=lookup_hash(\"md5\",required=False ).supported\n  self.assertEqual(self.handler.supported,supported)\n  if supported:\n   _set_mock_fips_mode()\n   self.addCleanup(_set_mock_fips_mode,False )\n   \n   \n   \n  from passlib.handlers.digests import create_hex_hash\n  hasher=create_hex_hash(\"md5\",required=False )\n  self.assertFalse(hasher.supported)\n  \n  \n  ref1='5f4dcc3b5aa765d61d8327deb882cf99'\n  ref2='xxx'\n  self.assertTrue(hasher.identify(ref1))\n  self.assertFalse(hasher.identify(ref2))\n  \n  \n  pat=\"'md5' hash disabled for fips\"\n  self.assertRaisesRegex(UnknownHashError,pat,hasher.hash,\"password\")\n  self.assertRaisesRegex(UnknownHashError,pat,hasher.verify,\"password\",ref1)\n  \n  \nclass hex_sha1_test(HandlerCase):\n handler=hash.hex_sha1\n known_correct_hashes=[\n (\"password\",'5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8'),\n (UPASS_TABLE,'e059b2628e3a3e2de095679de9822c1d1466e0f0'),\n ]\n \nclass hex_sha256_test(HandlerCase):\n handler=hash.hex_sha256\n known_correct_hashes=[\n (\"password\",'5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8'),\n (UPASS_TABLE,'6ed729e19bf24d3d20f564375820819932029df05547116cfc2cc868a27b4493'),\n ]\n \nclass hex_sha512_test(HandlerCase):\n handler=hash.hex_sha512\n known_correct_hashes=[\n (\"password\",'b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c'\n '706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cac'\n 'bc86'),\n (UPASS_TABLE,'d91bb0a23d66dca07a1781fd63ae6a05f6919ee5fc368049f350c9f'\n '293b078a18165d66097cf0d89fdfbeed1ad6e7dba2344e57348cd6d51308c843a06f'\n '29caf'),\n ]\n \n \n \n \nclass htdigest_test(UserHandlerMixin,HandlerCase):\n handler=hash.htdigest\n \n known_correct_hashes=[\n \n \n \n ((\"Circle Of Life\",\"Mufasa\",\"testrealm@host.com\"),\n '939e7578ed9e3c518a452acee763bce9'),\n \n \n ((UPASS_TABLE,UPASS_USD,UPASS_WAV),\n '4dabed2727d583178777fab468dd1f17'),\n ]\n \n known_unidentified_hashes=[\n \n '939e7578edAe3c518a452acee763bce9',\n \n \n '939e7578edxe3c518a452acee763bce9',\n ]\n \n def test_80_user(self):\n  raise self.skipTest(\"test case doesn't support 'realm' keyword\")\n  \n def populate_context(self,secret,kwds):\n  ''\n  if isinstance(secret,tuple):\n   secret,user,realm=secret\n  else :\n   user,realm=\"user\",\"realm\"\n  kwds.setdefault(\"user\",user)\n  kwds.setdefault(\"realm\",realm)\n  return secret\n  \n  \n  \n  \nclass ldap_md5_test(HandlerCase):\n handler=hash.ldap_md5\n known_correct_hashes=[\n (\"helloworld\",'{MD5}/F4DjTilcDIIVEHn/nAQsA=='),\n (UPASS_TABLE,'{MD5}BUc/ihn2aBXnN7MyZKDQsA=='),\n ]\n \nclass ldap_sha1_test(HandlerCase):\n handler=hash.ldap_sha1\n known_correct_hashes=[\n (\"helloworld\",'{SHA}at+xg6SiyUovktq1redipHiJpaE='),\n (UPASS_TABLE,'{SHA}4FmyYo46Pi3glWed6YIsHRRm4PA='),\n ]\n \nclass ldap_salted_md5_test(HandlerCase):\n handler=hash.ldap_salted_md5\n known_correct_hashes=[\n (\"testing1234\",'{SMD5}UjFY34os/pnZQ3oQOzjqGu4yeXE='),\n (UPASS_TABLE,'{SMD5}Z0ioJ58LlzUeRxm3K6JPGAvBGIM='),\n \n \n ('test','{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4cw'),\n ('test','{SMD5}XRlncfRzvGi0FDzgR98tUgBg7B3jXOs9p9S615qTkg=='),\n ('test','{SMD5}FbAkzOMOxRbMp6Nn4hnZuel9j9Gas7a2lvI+x5hT6j0='),\n ]\n \n known_malformed_hashes=[\n \n '{SMD5}IGVhwK+anvspmfDt2t0vgGjt/Q==',\n \n \n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4c',\n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4cw'\n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P4cw=',\n '{SMD5}LnuZPJhiaY95/4lmV=pg548xBsD4P4cw',\n '{SMD5}LnuZPJhiaY95/4lmVFpg548xBsD4P===',\n ]\n \nclass ldap_salted_sha1_test(HandlerCase):\n handler=hash.ldap_salted_sha1\n known_correct_hashes=[\n (\"testing123\",'{SSHA}0c0blFTXXNuAMHECS4uxrj3ZieMoWImr'),\n (\"secret\",\"{SSHA}0H+zTv8o4MR4H43n03eCsvw1luG8LdB7\"),\n (UPASS_TABLE,'{SSHA}3yCSD1nLZXznra4N8XzZgAL+s1sQYsx5'),\n \n \n ('test','{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOckw=='),\n ('test','{SSHA}/ZMF5KymNM+uEOjW+9STKlfCFj51bg3BmBNCiPHeW2ttbU0='),\n ('test','{SSHA}Pfx6Vf48AT9x3FVv8znbo8WQkEVSipHSWovxXmvNWUvp/d/7'),\n ]\n \n known_malformed_hashes=[\n \n '{SSHA}ZQK3Yvtvl6wtIRoISgMGPkcWU7Nfq5U=',\n \n \n '{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOck',\n '{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOckw=',\n '{SSHA}P90+qijSp8MJ1tN25j5o1Pf=UvlqjXHOGeOckw==',\n '{SSHA}P90+qijSp8MJ1tN25j5o1PflUvlqjXHOGeOck===',\n ]\n \n \nclass ldap_salted_sha256_test(HandlerCase):\n handler=hash.ldap_salted_sha256\n known_correct_hashes=[\n \n \n (\"password\",'{SSHA256}x1tymSTVjozxQ2PtT46ysrzhZxbcskK0o2f8hEFx7fAQQmhtDSEkJA=='),\n (\"test\",'{SSHA256}xfqc9aOR6z15YaEk3/Ufd7UL9+JozB/1EPmCDTizL0GkdA7BuNda6w=='),\n (\"toomanysecrets\",'{SSHA256}RrTKrg6HFXcjJ+eDAq4UtbODxOr9RLeG+I69FoJvutcbY0zpfU+p1Q=='),\n (u('letm\\xe8\\xefn'),'{SSHA256}km7UjUTBZN8a+gf1ND2/qn15N7LsO/jmGYJXvyTfJKAbI0RoLWWslQ=='),\n \n \n \n ('test','{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDIm'),\n ('test','{SSHA256}J6MFQdkfjdmXz9UyUPb773kekJdm4dgSL4y8WQEQW11VipHSundOKaV0LsV4L6U='),\n ('test','{SSHA256}uBLazLaiBaPb6Cpnvq2XTYDkvXbYIuqRW1anMKk85d1/j1GqFQIgpHSOMUYIIcS4'),\n ]\n \n known_malformed_hashes=[\n \n '{SSHA256}Lpdyr1+lR+rtxgp3SpQnUuNw33ENivTl28nzF2ZI4Gm41/o=',\n \n \n '{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDI@',\n '{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDI',\n '{SSHA256}TFv2RpwyO0U9mA0Hk8FsXRa1I+4dNUtv27Qa8dzGVLinlDIm===',\n ]\n \n \n \nclass ldap_salted_sha512_test(HandlerCase):\n handler=hash.ldap_salted_sha512\n known_correct_hashes=[\n \n \n (\"toomanysecrets\",'{SSHA512}wExp4xjiCHS0zidJDC4UJq9EEeIebAQPJ1PWSwfhxWjfutI9XiiKuHm2AE41cEFfK+8HyI8bh+ztbczUGsvVFIgICWWPt7qu'),\n (u('letm\\xe8\\xefn'),'{SSHA512}mpNUSmZc3TNx+RnPwkIAVMf7ocEKLPrIoQNsg4Eu8dHvyCeb2xzHp5A6n4tF7ntknSvfvRZaJII4ImvNJlYsgiwAm0FMqR+3'),\n \n \n \n (\"password\",'{SSHA512}f/lFQskkl7PdMsTGJxHZq8LDt/l+UqRMm6/pj4pV7/xZkcOaKCgvQqp+KCeXc/Vd4RY6vEHWn4y0DnFcQ6wgyv9fyxk='),\n (\"test\",'{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+Uc'),\n \n \n \n ('test','{SSHA512}Yg9DQ2wURCFGwobu7R2O6cq7nVbnGMPrFCX0aPQ9kj/y1hd6k9PEzkgWCB5aXdPwPzNrVb0PkiHiBnG1CxFiT+B8L8U='),\n ('test','{SSHA512}5ecDGWs5RY4xLszUO6hAcl90W3wAozGQoI4Gqj8xSZdcfU1lVEM4aY8s+4xVeLitcn7BO8i7xkzMFWLoxas7SeHc23sP4dx77937PyeE0A=='),\n ('test','{SSHA512}6FQv5W47HGg2MFBFZofoiIbO8KRW75Pm51NKoInpthYQQ5ujazHGhVGzrj3JXgA7j0k+UNmkHdbJjdY5xcUHPzynFEII4fwfIySEcG5NKSU='),\n ]\n \n known_malformed_hashes=[\n \n '{SSHA512}zFnn4/8x8GveUaMqgrYWyIWqFQ0Irt6gADPtRk4Uv3nUC6uR5cD8+YdQni/0ZNij9etm6p17kSFuww3M6l+d6AbAeA==',\n \n \n '{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+U',\n '{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+U@',\n '{SSHA512}Tgx/uhHnlM9/GgQvI31dN7cheDXg7WypZwaaIkyRsgV/BKIzBG3G/wUd9o1dpi06p3SYzMedg0lvTc3b6CtdO0Xo/f9/L+U===',\n ]\n \n \nclass ldap_plaintext_test(HandlerCase):\n\n handler=hash.ldap_plaintext\n known_correct_hashes=[\n (\"password\",'password'),\n (UPASS_TABLE,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n (PASS_TABLE_UTF8,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n ]\n known_unidentified_hashes=[\n \"{FOO}bar\",\n \n \n \"\",\n ]\n \n known_other_hashes=[\n (\"ldap_md5\",\"{MD5}/F4DjTilcDIIVEHn/nAQsA==\")\n ]\n \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_password(self):\n  \n   while True :\n    pwd=super(ldap_plaintext_test.FuzzHashGenerator,self).random_password()\n    if pwd:\n     return pwd\n     \nclass _ldap_md5_crypt_test(HandlerCase):\n\n\n handler=hash.ldap_md5_crypt\n \n known_correct_hashes=[\n \n \n \n ('','{CRYPT}$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.'),\n (' ','{CRYPT}$1$m/5ee7ol$bZn0kIBFipq39e.KDXX8I0'),\n ('test','{CRYPT}$1$ec6XvcoW$ghEtNK2U1MC5l.Dwgi3020'),\n ('Compl3X AlphaNu3meric','{CRYPT}$1$nX1e7EeI$ljQn72ZUgt6Wxd9hfvHdV0'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','{CRYPT}$1$jQS7o98J$V6iTcr71CGgwW2laf17pi1'),\n ('test','{CRYPT}$1$SuMrG47N$ymvzYjr7QcEQjaK5m1PGx1'),\n \n \n (UPASS_TABLE,'{CRYPT}$1$d6/Ky1lU$/xpf8m7ftmWLF.TjHCqel0'),\n ]\n \n known_malformed_hashes=[\n \n '{CRYPT}$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o!',\n ]\n \n \nldap_md5_crypt_os_crypt_test=_ldap_md5_crypt_test.create_backend_case(\"os_crypt\")\nldap_md5_crypt_builtin_test=_ldap_md5_crypt_test.create_backend_case(\"builtin\")\n\nclass _ldap_sha1_crypt_test(HandlerCase):\n\n\n handler=hash.ldap_sha1_crypt\n \n known_correct_hashes=[\n ('password','{CRYPT}$sha1$10$c.mcTzCw$gF8UeYst9yXX7WNZKc5Fjkq0.au7'),\n (UPASS_TABLE,'{CRYPT}$sha1$10$rnqXlOsF$aGJf.cdRPewJAXo1Rn1BkbaYh0fP'),\n ]\n \n def populate_settings(self,kwds):\n  kwds.setdefault(\"rounds\",10)\n  super(_ldap_sha1_crypt_test,self).populate_settings(kwds)\n  \n def test_77_fuzz_input(self,**ignored):\n  raise self.skipTest(\"unneeded\")\n  \n  \nldap_sha1_crypt_os_crypt_test=_ldap_sha1_crypt_test.create_backend_case(\"os_crypt\")\n\n\n\n\nclass lmhash_test(EncodingHandlerMixin,HandlerCase):\n handler=hash.lmhash\n secret_case_insensitive=True\n \n known_correct_hashes=[\n \n \n \n (\"OLDPASSWORD\",\"c9b81d939d6fd80cd408e6b105741864\"),\n (\"NEWPASSWORD\",'09eeab5aa415d6e4d408e6b105741864'),\n (\"welcome\",\"c23413a8a1e7665faad3b435b51404ee\"),\n \n \n \n \n ('','aad3b435b51404eeaad3b435b51404ee'),\n ('zzZZZzz','a5e6066de61c3e35aad3b435b51404ee'),\n ('passphrase','855c3697d9979e78ac404c4ba2c66533'),\n ('Yokohama','5ecd9236d21095ce7584248b8d2c9f9e'),\n \n \n (u('ENCYCLOP\\xC6DIA'),'fed6416bffc9750d48462b9d7aaac065'),\n (u('encyclop\\xE6dia'),'fed6416bffc9750d48462b9d7aaac065'),\n \n \n ((u(\"\\xC6\"),None ),'25d8ab4a0659c97aaad3b435b51404ee'),\n ((u(\"\\xC6\"),\"cp437\"),'25d8ab4a0659c97aaad3b435b51404ee'),\n ((u(\"\\xC6\"),\"latin-1\"),'184eecbbe9991b44aad3b435b51404ee'),\n ((u(\"\\xC6\"),\"utf-8\"),'00dd240fcfab20b8aad3b435b51404ee'),\n ]\n \n known_unidentified_hashes=[\n \n '855c3697d9979e78ac404c4ba2c6653X',\n ]\n \n def test_90_raw(self):\n  ''\n  from binascii import unhexlify\n  from passlib.utils.compat import str_to_bascii\n  lmhash=self.handler\n  for secret,hash in self.known_correct_hashes:\n   kwds={}\n   secret=self.populate_context(secret,kwds)\n   data=unhexlify(str_to_bascii(hash))\n   self.assertEqual(lmhash.raw(secret,**kwds),data)\n  self.assertRaises(TypeError,lmhash.raw,1)\n  \n  \n  \n  \nclass _md5_crypt_test(HandlerCase):\n handler=hash.md5_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','$1$dXc3I7Rw$ctlgjDdWJLMT.qwHsWhXR1'),\n ('U*U***U','$1$dXc3I7Rw$94JPyQc/eAgQ3MFMCoMF.0'),\n ('U*U***U*','$1$dXc3I7Rw$is1mVIAEtAhIzSdfn5JOO0'),\n ('*U*U*U*U','$1$eQT9Hwbt$XtuElNJD.eW5MN5UCWyTQ0'),\n ('','$1$Eu.GHtia$CFkL/nE1BYTlEPiVx1VWX0'),\n \n \n \n \n \n \n \n \n ('','$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.'),\n (' ','$1$m/5ee7ol$bZn0kIBFipq39e.KDXX8I0'),\n ('test','$1$ec6XvcoW$ghEtNK2U1MC5l.Dwgi3020'),\n ('Compl3X AlphaNu3meric','$1$nX1e7EeI$ljQn72ZUgt6Wxd9hfvHdV0'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','$1$jQS7o98J$V6iTcr71CGgwW2laf17pi1'),\n ('test','$1$SuMrG47N$ymvzYjr7QcEQjaK5m1PGx1'),\n (b'test','$1$SuMrG47N$ymvzYjr7QcEQjaK5m1PGx1'),\n (u('s'),'$1$ssssssss$YgmLTApYTv12qgTwBoj8i/'),\n \n \n (UPASS_TABLE,'$1$d6/Ky1lU$/xpf8m7ftmWLF.TjHCqel0'),\n ]\n \n known_malformed_hashes=[\n \n '$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o!',\n \n \n '$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.$',\n ]\n \n platform_crypt_support=[\n \n (\"openbsd[6789]\",False ),\n (\"openbsd5\",None ),\n (\"openbsd\",True ),\n \n (\"freebsd|netbsd|linux|solaris\",True ),\n (\"darwin\",False ),\n ]\n \n \nmd5_crypt_os_crypt_test=_md5_crypt_test.create_backend_case(\"os_crypt\")\nmd5_crypt_builtin_test=_md5_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass msdcc_test(UserHandlerMixin,HandlerCase):\n handler=hash.msdcc\n user_case_insensitive=True\n \n known_correct_hashes=[\n \n \n \n \n ((\"Asdf999\",\"sevans\"),\"b1176c2587478785ec1037e5abc916d0\"),\n \n \n \n \n ((\"ASDqwe123\",\"jdoe\"),\"592cdfbc3f1ef77ae95c75f851e37166\"),\n \n \n \n \n ((\"test1\",\"test1\"),\"64cd29e36a8431a2b111378564a10631\"),\n ((\"test2\",\"test2\"),\"ab60bdb4493822b175486810ac2abe63\"),\n ((\"test3\",\"test3\"),\"14dd041848e12fc48c0aa7a416a4a00c\"),\n ((\"test4\",\"test4\"),\"b945d24866af4b01a6d89b9d932a153c\"),\n \n \n \n \n ((\"1234qwer!@#$\",\"Administrator\"),\"7b69d06ef494621e3f47b9802fe7776d\"),\n \n \n \n \n ((\"password\",\"user\"),\"2d9f0b052932ad18b87f315641921cda\"),\n \n \n \n \n ((\"\",\"root\"),\"176a4c2bd45ac73687676c2f09045353\"),\n ((\"test1\",\"TEST1\"),\"64cd29e36a8431a2b111378564a10631\"),\n ((\"okolada\",\"nineteen_characters\"),\"290efa10307e36a79b3eebf2a6b29455\"),\n ((u(\"\\u00FC\"),u(\"\\u00FC\")),\"48f84e6f73d6d5305f6558a33fa2c9bb\"),\n ((u(\"\\u00FC\\u00FC\"),u(\"\\u00FC\\u00FC\")),\"593246a8335cf0261799bda2a2a9c623\"),\n ((u(\"\\u20AC\\u20AC\"),\"user\"),\"9121790702dda0fa5d353014c334c2ce\"),\n \n \n \n \n \n \n ((UPASS_TABLE,'bob'),'fcb82eb4212865c7ac3503156ca3f349'),\n ]\n \n known_alternate_hashes=[\n \n (\"B1176C2587478785EC1037E5ABC916D0\",(\"Asdf999\",\"sevans\"),\n \"b1176c2587478785ec1037e5abc916d0\"),\n ]\n \nclass msdcc2_test(UserHandlerMixin,HandlerCase):\n handler=hash.msdcc2\n user_case_insensitive=True\n \n known_correct_hashes=[\n \n \n \n ((\"test1\",\"test1\"),\"607bbe89611e37446e736f7856515bf8\"),\n ((\"qerwt\",\"Joe\"),\"e09b38f84ab0be586b730baf61781e30\"),\n ((\"12345\",\"Joe\"),\"6432f517a900b3fc34ffe57f0f346e16\"),\n ((\"\",\"bin\"),\"c0cbe0313a861062e29f92ede58f9b36\"),\n ((\"w00t\",\"nineteen_characters\"),\"87136ae0a18b2dafe4a41d555425b2ed\"),\n ((\"w00t\",\"eighteencharacters\"),\"fc5df74eca97afd7cd5abb0032496223\"),\n ((\"longpassword\",\"twentyXXX_characters\"),\"cfc6a1e33eb36c3d4f84e4c2606623d2\"),\n ((\"longpassword\",\"twentyoneX_characters\"),\"99ff74cea552799da8769d30b2684bee\"),\n ((\"longpassword\",\"twentytwoXX_characters\"),\"0a721bdc92f27d7fb23b87a445ec562f\"),\n ((\"test2\",\"TEST2\"),\"c6758e5be7fc943d00b97972a8a97620\"),\n ((\"test3\",\"test3\"),\"360e51304a2d383ea33467ab0b639cc4\"),\n ((\"test4\",\"test4\"),\"6f79ee93518306f071c47185998566ae\"),\n ((u(\"\\u00FC\"),\"joe\"),\"bdb80f2c4656a8b8591bd27d39064a54\"),\n ((u(\"\\u20AC\\u20AC\"),\"joe\"),\"1e1e20f482ff748038e47d801d0d1bda\"),\n ((u(\"\\u00FC\\u00FC\"),\"admin\"),\"0839e4a07c00f18a8c65cf5b985b9e73\"),\n \n \n \n \n \n \n ((UPASS_TABLE,'bob'),'cad511dc9edefcf69201da72efb6bb55'),\n ]\n \n \n \n \nclass mssql2000_test(HandlerCase):\n handler=hash.mssql2000\n secret_case_insensitive=\"verify-only\"\n \n \n known_correct_hashes=[\n \n \n \n ('Test','0x010034767D5C0CFA5FDCA28C4A56085E65E882E71CB0ED2503412FD54D6119FFF04129A1D72E7C3194F7284A7F3A'),\n ('TEST','0x010034767D5C2FD54D6119FFF04129A1D72E7C3194F7284A7F3A2FD54D6119FFF04129A1D72E7C3194F7284A7F3A'),\n \n \n \n \n ('x','0x010086489146C46DD7318D2514D1AC706457CBF6CD3DF8407F071DB4BBC213939D484BF7A766E974F03C96524794'),\n \n \n \n \n ('AAAA','0x0100CF465B7B12625EF019E157120D58DD46569AC7BF4118455D12625EF019E157120D58DD46569AC7BF4118455D'),\n \n \n \n \n ('123','0x01002D60BA07FE612C8DE537DF3BFCFA49CD9968324481C1A8A8FE612C8DE537DF3BFCFA49CD9968324481C1A8A8'),\n \n \n \n \n ('12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n \n \n \n \n \n \n \n \n \n \n ('foo','0x0100A607BA7C54A24D17B565C59F1743776A10250F581D482DA8B6D6261460D3F53B279CC6913CE747006A2E3254'),\n ('bar','0x01000508513EADDF6DB7DDD270CCA288BF097F2FF69CC2DB74FBB9644D6901764F999BAB9ECB80DE578D92E3F80D'),\n ('canard','0x01008408C523CF06DCB237835D701C165E68F9460580132E28ED8BC558D22CEDF8801F4503468A80F9C52A12C0A3'),\n ('lapin','0x0100BF088517935FC9183FE39FDEC77539FD5CB52BA5F5761881E5B9638641A79DBF0F1501647EC941F3355440A2'),\n \n \n \n \n \n \n (UPASS_USD,'0x0100624C0961B28E39FEE13FD0C35F57B4523F0DA1861C11D5A5B28E39FEE13FD0C35F57B4523F0DA1861C11D5A5'),\n (UPASS_TABLE,'0x010083104228FAD559BE52477F2131E538BE9734E5C4B0ADEFD7F6D784B03C98585DC634FE2B8CA3A6DFFEC729B4'),\n \n ]\n \n known_alternate_hashes=[\n \n ('0x01005b20054332752e1bc2e7c5df0f9ebfe486e9bee063e8d3b332752e1bc2e7c5df0f9ebfe486e9bee063e8d3b3',\n '12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n ]\n \n known_unidentified_hashes=[\n \n '0X01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n \n \n '0x02005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n \n \n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3',\n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3AF',\n \n \n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n ]\n \n known_malformed_hashes=[\n \n b'0x01005B200543327G2E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n u('0x01005B200543327G2E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n ]\n \nclass mssql2005_test(HandlerCase):\n handler=hash.mssql2005\n \n known_correct_hashes=[\n \n \n \n ('TEST','0x010034767D5C2FD54D6119FFF04129A1D72E7C3194F7284A7F3A'),\n \n \n \n \n ('toto','0x01004086CEB6BF932BC4151A1AF1F13CD17301D70816A8886908'),\n \n \n \n \n ('123','0x01004A335DCEDB366D99F564D460B1965B146D6184E4E1025195'),\n ('123','0x0100E11D573F359629B344990DCD3D53DE82CF8AD6BBA7B638B6'),\n \n \n \n \n \n \n \n \n \n \n ('AAAA','0x010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F30'),\n \n \n \n \n (\"toto\",\"0x01004086CEB6BF932BC4151A1AF1F13CD17301D70816A8886908\"),\n (\"titi\",\"0x01004086CEB60ED526885801C23B366965586A43D3DEAC6DD3FD\"),\n (\"foo\",\"0x0100A607BA7C54A24D17B565C59F1743776A10250F581D482DA8\"),\n (\"bar\",\"0x01000508513EADDF6DB7DDD270CCA288BF097F2FF69CC2DB74FB\"),\n (\"canard\",\"0x01008408C523CF06DCB237835D701C165E68F9460580132E28ED\"),\n (\"lapin\",\"0x0100BF088517935FC9183FE39FDEC77539FD5CB52BA5F5761881\"),\n \n \n \n \n ('Test','0x010034767D5C0CFA5FDCA28C4A56085E65E882E71CB0ED250341'),\n ('Test','0x0100993BF2315F36CC441485B35C4D84687DC02C78B0E680411F'),\n ('x','0x010086489146C46DD7318D2514D1AC706457CBF6CD3DF8407F07'),\n ('AAAA','0x0100CF465B7B12625EF019E157120D58DD46569AC7BF4118455D'),\n ('123','0x01002D60BA07FE612C8DE537DF3BFCFA49CD9968324481C1A8A8'),\n ('12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n \n \n \n \n \n \n (UPASS_USD,'0x0100624C0961B28E39FEE13FD0C35F57B4523F0DA1861C11D5A5'),\n (UPASS_TABLE,'0x010083104228FAD559BE52477F2131E538BE9734E5C4B0ADEFD7'),\n ]\n \n known_alternate_hashes=[\n \n ('0x01005b20054332752e1bc2e7c5df0f9ebfe486e9bee063e8d3b3',\n '12345','0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3'),\n ]\n \n known_unidentified_hashes=[\n \n '0X010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F30',\n \n \n '0x020036D726AE86834E97F20B198ACD219D60B446AC5E48C54F30',\n \n \n '0x010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F',\n '0x010036D726AE86834E97F20B198ACD219D60B446AC5E48C54F3012',\n \n \n '0x01005B20054332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B332752E1BC2E7C5DF0F9EBFE486E9BEE063E8D3B3',\n ]\n \n known_malformed_hashes=[\n \n '0x010036D726AE86G34E97F20B198ACD219D60B446AC5E48C54F30',\n ]\n \n \n \n \nclass mysql323_test(HandlerCase):\n handler=hash.mysql323\n \n known_correct_hashes=[\n \n \n \n ('drew','697a7de87c5390b2'),\n ('password',\"5d2e19393cc5ef67\"),\n \n \n \n \n ('mypass','6f8c114b58f2ce9e'),\n \n \n (UPASS_TABLE,'4ef327ca5491c8d7'),\n ]\n \n known_unidentified_hashes=[\n \n '6z8c114b58f2ce9e',\n ]\n \n def test_90_whitespace(self):\n  ''\n  h=self.do_encrypt(\"mypass\")\n  h2=self.do_encrypt(\"my pass\")\n  self.assertEqual(h,h2)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def accept_password_pair(self,secret,other):\n  \n   return secret.replace(\" \",\"\")!=other.replace(\" \",\"\")\n   \nclass mysql41_test(HandlerCase):\n handler=hash.mysql41\n known_correct_hashes=[\n \n \n \n ('verysecretpassword','*2C905879F74F28F8570989947D06A8429FB943E6'),\n ('12345678123456781234567812345678','*F9F1470004E888963FB466A5452C9CBD9DF6239C'),\n (\"' OR 1 /*'\",'*97CF7A3ACBE0CA58D5391AC8377B5D9AC11D46D9'),\n \n \n \n \n ('mypass','*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4'),\n \n \n (UPASS_TABLE,'*E7AFE21A9CFA2FC9D15D942AE8FB5C240FE5837B'),\n ]\n known_unidentified_hashes=[\n \n '*6Z8989366EAF75BB670AD8EA7A7FC1176A95CEF4',\n ]\n \n \n \n \nclass nthash_test(HandlerCase):\n handler=hash.nthash\n \n known_correct_hashes=[\n \n \n \n (\"OLDPASSWORD\",u(\"6677b2c394311355b54f25eec5bfacf5\")),\n (\"NEWPASSWORD\",u(\"256781a62031289d3c2c98c14f1efc8c\")),\n \n \n \n \n \n \n ('','31d6cfe0d16ae931b73c59d7e0c089c0'),\n ('tigger','b7e0ea9fbffcf6dd83086e905089effd'),\n \n \n (b'\\xC3\\xBC','8bd6e4fb88e01009818749c5443ea712'),\n (b'\\xC3\\xBC\\xC3\\xBC','cc1260adb6985ca749f150c7e0b22063'),\n (b'\\xE2\\x82\\xAC','030926b781938db4365d46adc7cfbcb8'),\n (b'\\xE2\\x82\\xAC\\xE2\\x82\\xAC','682467b963bb4e61943e170a04f7db46'),\n \n \n \n \n ('passphrase','7f8fe03093cc84b267b109625f6bbf4b'),\n ]\n \n known_unidentified_hashes=[\n \n '7f8fe03093cc84b267b109625f6bbfxb',\n ]\n \nclass bsd_nthash_test(HandlerCase):\n handler=hash.bsd_nthash\n \n known_correct_hashes=[\n ('passphrase','$3$$7f8fe03093cc84b267b109625f6bbf4b'),\n (b'\\xC3\\xBC','$3$$8bd6e4fb88e01009818749c5443ea712'),\n ]\n \n known_unidentified_hashes=[\n \n '$3$$7f8fe03093cc84b267b109625f6bbfxb',\n ]\n \n \n \n \nclass oracle10_test(UserHandlerMixin,HandlerCase):\n handler=hash.oracle10\n secret_case_insensitive=True\n user_case_insensitive=True\n \n \n known_correct_hashes=[\n \n \n \n \n \n (('tiger','scott'),'F894844C34402B67'),\n ((u('ttTiGGeR'),u('ScO')),'7AA1A84E31ED7771'),\n ((\"d_syspw\",\"SYSTEM\"),'1B9F1F9A5CB9EB31'),\n ((\"strat_passwd\",\"strat_user\"),'AEBEDBB4EFB5225B'),\n \n \n \n \n (('#95LWEIGHTS','USER'),'000EA4D72A142E29'),\n (('CIAO2010','ALFREDO'),'EB026A76F0650F7B'),\n \n \n \n \n (('GLOUGlou','Bob'),'CDC6B483874B875B'),\n (('GLOUGLOUTER','bOB'),'EF1F9139DB2D5279'),\n (('LONG_MOT_DE_PASSE_OUI','BOB'),'EC8147ABB3373D53'),\n \n \n \n \n ((UPASS_TABLE,'System'),'B915A853F297B281'),\n ]\n \n known_unidentified_hashes=[\n \n 'F894844C34402B6Z',\n ]\n \nclass oracle11_test(HandlerCase):\n handler=hash.oracle11\n \n known_correct_hashes=[\n \n \n \n (\"abc123\",\"S:5FDAB69F543563582BA57894FE1C1361FB8ED57B903603F2C52ED1B4D642\"),\n (\"SyStEm123!@#\",\"S:450F957ECBE075D2FA009BA822A9E28709FBC3DA82B44D284DDABEC14C42\"),\n (\"oracle\",\"S:3437FF72BD69E3FB4D10C750B92B8FB90B155E26227B9AB62D94F54E5951\"),\n (\"11g\",\"S:61CE616647A4F7980AFD7C7245261AF25E0AFE9C9763FCF0D54DA667D4E6\"),\n (\"11g\",\"S:B9E7556F53500C8C78A58F50F24439D79962DE68117654B6700CE7CC71CF\"),\n \n \n \n \n (\"SHAlala\",\"S:2BFCFDF5895014EE9BB2B9BA067B01E0389BB5711B7B5F82B7235E9E182C\"),\n \n \n \n \n (UPASS_TABLE,'S:51586343E429A6DF024B8F242F2E9F8507B1096FACD422E29142AA4974B0'),\n ]\n \n \n \n \nclass phpass_test(HandlerCase):\n handler=hash.phpass\n \n known_correct_hashes=[\n \n \n \n \n ('test12345','$P$9IQRaTwmfeRo7ud9Fh4E2PdI0S3r.L0'),\n \n \n \n \n ('test1','$H$9aaaaaSXBjgypwqm.JsMssPLiS8YQ00'),\n ('123456','$H$9PE8jEklgZhgLmZl5.HYJAzfGCQtzi1'),\n ('123456','$H$9pdx7dbOW3Nnt32sikrjAxYFjX8XoK1'),\n ('thisisalongertestPW','$P$912345678LIjjb6PhecupozNBmDndU0'),\n ('JohnRipper','$P$612345678si5M0DDyPpmRCmcltU/YW/'),\n ('JohnRipper','$H$712345678WhEyvy1YWzT4647jzeOmo0'),\n ('JohnRipper','$P$B12345678L6Lpt4BxNotVIMILOa9u81'),\n \n \n \n \n ('','$P$7JaFQsPzJSuenezefD/3jHgt5hVfNH0'),\n ('compL3X!','$P$FiS0N5L672xzQx1rt1vgdJQRYKnQM9/'),\n \n \n (UPASS_TABLE,'$P$7SMy8VxnfsIy2Sxm7fJxDSdil.h7TW.'),\n ]\n \n known_malformed_hashes=[\n \n \n '$P$9IQRaTwmfeRo7ud9Fh4E2PdI0S3r!L0',\n ]\n \n \n \n \nclass plaintext_test(HandlerCase):\n\n handler=hash.plaintext\n accepts_all_hashes=True\n \n known_correct_hashes=[\n ('',''),\n ('password','password'),\n \n \n (UPASS_TABLE,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n (PASS_TABLE_UTF8,UPASS_TABLE if PY3 else PASS_TABLE_UTF8),\n ]\n \n \n \n \nclass postgres_md5_test(UserHandlerMixin,HandlerCase):\n handler=hash.postgres_md5\n known_correct_hashes=[\n \n \n \n \n \n (('mypass','postgres'),'md55fba2ea04fd36069d2574ea71c8efe9d'),\n (('mypass','root'),'md540c31989b20437833f697e485811254b'),\n ((\"testpassword\",'testuser'),'md5d4fc5129cc2c25465a5370113ae9835f'),\n \n \n \n \n \n \n ((UPASS_TABLE,'postgres'),'md5cb9f11283265811ce076db86d18a22d2'),\n ]\n known_unidentified_hashes=[\n \n 'md54zc31989b20437833f697e485811254b',\n ]\n \n \n \n \nclass _sha1_crypt_test(HandlerCase):\n handler=hash.sha1_crypt\n \n known_correct_hashes=[\n \n \n \n (\"password\",\"$sha1$19703$iVdJqfSE$v4qYKl1zqYThwpjJAoKX6UvlHq/a\"),\n (\"password\",\"$sha1$21773$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH\"),\n (UPASS_TABLE,'$sha1$40000$uJ3Sp7LE$.VEmLO5xntyRFYihC7ggd3297T/D'),\n ]\n \n known_malformed_hashes=[\n \n '$sha1$21773$u!7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH',\n \n \n '$sha1$01773$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH',\n \n \n '$sha1$21773$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH$',\n \n \n '$sha1$$uV7PTeux$I9oHnvwPZHMO0Nq6/WgyGV/tDJIH$',\n ]\n \n platform_crypt_support=[\n (\"netbsd\",True ),\n (\"freebsd|openbsd|solaris|darwin\",False ),\n (\"linux\",None ),\n ]\n \n \nsha1_crypt_os_crypt_test=_sha1_crypt_test.create_backend_case(\"os_crypt\")\nsha1_crypt_builtin_test=_sha1_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\n\n\n\n\n\nclass RoundupTest(TestCase):\n\n def _test_pair(self,h,secret,hash):\n  self.assertTrue(h.verify(secret,hash))\n  self.assertFalse(h.verify('x'+secret,hash))\n  \n def test_pairs(self):\n  self._test_pair(\n  hash.ldap_hex_sha1,\n  \"sekrit\",\n  '{SHA}8d42e738c7adee551324955458b5e2c0b49ee655')\n  \n  self._test_pair(\n  hash.ldap_hex_md5,\n  \"sekrit\",\n  '{MD5}ccbc53f4464604e714f69dd11138d8b5')\n  \n  self._test_pair(\n  hash.ldap_des_crypt,\n  \"sekrit\",\n  '{CRYPT}nFia0rj2TT59A')\n  \n  self._test_pair(\n  hash.roundup_plaintext,\n  \"sekrit\",\n  '{plaintext}sekrit')\n  \n  self._test_pair(\n  hash.ldap_pbkdf2_sha1,\n  \"sekrit\",\n  '{PBKDF2}5000$7BvbBq.EZzz/O0HuwX3iP.nAG3s$g3oPnFFaga2BJaX5PoPRljl4XIE')\n  \n  \n  \n  \nclass _sha256_crypt_test(HandlerCase):\n handler=hash.sha256_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','$5$LKO/Ute40T3FNF95$U0prpBQd4PloSGU0pnpM4z9wKn4vZ1.jsrzQfPqxph9'),\n ('U*U***U','$5$LKO/Ute40T3FNF95$fdgfoJEBoMajNxCv3Ru9LyQ0xZgv0OBMQoq80LQ/Qd.'),\n ('U*U***U*','$5$LKO/Ute40T3FNF95$8Ry82xGnnPI/6HtFYnvPBTYgOL23sdMXn8C29aO.x/A'),\n ('*U*U*U*U','$5$9mx1HkCz7G1xho50$O7V7YgleJKLUhcfk9pgzdh3RapEaWqMtEp9UUBAKIPA'),\n ('','$5$kc7lRD1fpYg0g.IP$d7CMTcEqJyTXyeq8hTdu/jB/I6DGkoo62NXbHIR7S43'),\n \n \n \n \n ('','$5$rounds=10428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3'),\n (' ','$5$rounds=10376$I5lNtXtRmf.OoMd8$Ko3AI1VvTANdyKhBPavaRjJzNpSatKU6QVN9uwS9MH.'),\n ('test','$5$rounds=11858$WH1ABM5sKhxbkgCK$aTQsjPkz0rBsH3lQlJxw9HDTDXPKBxC0LlVeV69P.t1'),\n ('Compl3X AlphaNu3meric','$5$rounds=10350$o.pwkySLCzwTdmQX$nCMVsnF3TXWcBPOympBUUSQi6LGGloZoOsVJMGJ09UB'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','$5$rounds=11944$9dhlu07dQMRWvTId$LyUI5VWkGFwASlzntk1RLurxX54LUhgAcJZIt0pYGT7'),\n (u('with unic\\u00D6de'),'$5$rounds=1000$IbG0EuGQXw5EkMdP$LQ5AfPf13KufFsKtmazqnzSGZ4pxtUNw3woQ.ELRDF4'),\n ]\n \n if TEST_MODE(\"full\"):\n \n \n \n \n  known_correct_hashes.extend([\n  (\"secret\",'$5$rounds=1004$nacl$oiWPbm.kQ7.jTCZoOtdv7/tO5mWv/vxw5yTqlBagVR7'),\n  (\"secret\",'$5$rounds=1005$nacl$6Mo/TmGDrXxg.bMK9isRzyWH3a..6HnSVVsJMEX7ud/'),\n  (\"secret\",'$5$rounds=1006$nacl$I46VwuAiUBwmVkfPFakCtjVxYYaOJscsuIeuZLbfKID'),\n  (\"secret\",'$5$rounds=1007$nacl$9fY4j1AV3N/dV/YMUn1enRHKH.7nEL4xf1wWB6wfDD4'),\n  (\"secret\",'$5$rounds=1008$nacl$CiFWCfn8ODmWs0I1xAdXFo09tM8jr075CyP64bu3by9'),\n  (\"secret\",'$5$rounds=1009$nacl$QtpFX.CJHgVQ9oAjVYStxAeiU38OmFILWm684c6FyED'),\n  (\"secret\",'$5$rounds=1010$nacl$ktAwXuT5WbjBW/0ZU1eNMpqIWY1Sm4twfRE1zbZyo.B'),\n  (\"secret\",'$5$rounds=1011$nacl$QJWLBEhO9qQHyMx4IJojSN9sS41P1Yuz9REddxdO721'),\n  (\"secret\",'$5$rounds=1012$nacl$mmf/k2PkbBF4VCtERgky3bEVavmLZKFwAcvxD1p3kV2'),\n  ])\n  \n known_malformed_hashes=[\n \n '$5$rounds=10428$uy/:jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMeZGsGx2aBvxTvDFI613c3',\n \n \n '$5$rounds=010428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3',\n \n \n '$5$rounds=10428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3$',\n ]\n \n known_correct_configs=[\n \n \n \n \n \n (\"$5$saltstring\",\"Hello world!\",\n \"$5$saltstring$5B8vYYiY.CVt1RlTTf8KbXBH3hsxY/GNooZaBBGWEc5\"),\n (\"$5$rounds=10000$saltstringsaltstring\",\"Hello world!\",\n \"$5$rounds=10000$saltstringsaltst$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.\"\n \"opqey6IcA\"),\n (\"$5$rounds=5000$toolongsaltstring\",\"This is just a test\",\n \"$5$rounds=5000$toolongsaltstrin$Un/5jzAHMgOGZ5.mWJpuVolil07guHPvOW8\"\n \"mGRcvxa5\"),\n (\"$5$rounds=1400$anotherlongsaltstring\",\n \"a very much longer text to encrypt.  This one even stretches over more\"\n \"than one line.\",\n \"$5$rounds=1400$anotherlongsalts$Rx.j8H.h8HjEDGomFU8bDkXm3XIUnzyxf12\"\n \"oP84Bnq1\"),\n (\"$5$rounds=77777$short\",\n \"we have a short salt string but not a short password\",\n \"$5$rounds=77777$short$JiO1O3ZpDAxGJeaDIuqCoEFysAe1mZNJRs3pw0KQRd/\"),\n (\"$5$rounds=123456$asaltof16chars..\",\"a short string\",\n \"$5$rounds=123456$asaltof16chars..$gP3VQ/6X7UUEW3HkBn2w1/Ptq2jxPyzV/\"\n \"cZKmF/wJvD\"),\n (\"$5$rounds=10$roundstoolow\",\"the minimum number is still observed\",\n \"$5$rounds=1000$roundstoolow$yfvwcWrQ8l/K0DAWyuPMDNHpIVlTQebY9l/gL97\"\n \"2bIC\"),\n ]\n \n filter_config_warnings=True\n \n platform_crypt_support=[\n (\"freebsd(9|1\\d)|linux\",True ),\n (\"freebsd8\",None ),\n (\"freebsd|openbsd|netbsd|darwin\",False ),\n (\"solaris\",None ),\n ]\n \n \nsha256_crypt_os_crypt_test=_sha256_crypt_test.create_backend_case(\"os_crypt\")\nsha256_crypt_builtin_test=_sha256_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass _sha512_crypt_test(HandlerCase):\n handler=hash.sha512_crypt\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*',\"$6$LKO/Ute40T3FNF95$6S/6T2YuOIHY0N3XpLKABJ3soYcXD9mB7uVbtEZDj/LNscVhZoZ9DEH.sBciDrMsHOWOoASbNLTypH/5X26gN0\"),\n ('U*U***U',\"$6$LKO/Ute40T3FNF95$wK80cNqkiAUzFuVGxW6eFe8J.fSVI65MD5yEm8EjYMaJuDrhwe5XXpHDJpwF/kY.afsUs1LlgQAaOapVNbggZ1\"),\n ('U*U***U*',\"$6$LKO/Ute40T3FNF95$YS81pp1uhOHTgKLhSMtQCr2cDiUiN03Ud3gyD4ameviK1Zqz.w3oXsMgO6LrqmIEcG3hiqaUqHi/WEE2zrZqa/\"),\n ('*U*U*U*U',\"$6$OmBOuxFYBZCYAadG$WCckkSZok9xhp4U1shIZEV7CCVwQUwMVea7L3A77th6SaE9jOPupEMJB.z0vIWCDiN9WLh2m9Oszrj5G.gt330\"),\n ('',\"$6$ojWH1AiTee9x1peC$QVEnTvRVlPRhcLQCk/HnHaZmlGAAjCfrAN0FtOsOnUk5K5Bn/9eLHHiRzrTzaIKjW9NTLNIBUCtNVOowWS2mN.\"),\n \n \n \n \n ('','$6$rounds=11021$KsvQipYPWpr93wWP$v7xjI4X6vyVptJjB1Y02vZC5SaSijBkGmq1uJhPr3cvqvvkd42Xvo48yLVPFt8dvhCsnlUgpX.//Cxn91H4qy1'),\n (' ','$6$rounds=11104$ED9SA4qGmd57Fq2m$q/.PqACDM/JpAHKmr86nkPzzuR5.YpYa8ZJJvI8Zd89ZPUYTJExsFEIuTYbM7gAGcQtTkCEhBKmp1S1QZwaXx0'),\n ('test','$6$rounds=11531$G/gkPn17kHYo0gTF$Kq.uZBHlSBXyzsOJXtxJruOOH4yc0Is13uY7yK0PvAvXxbvc1w8DO1RzREMhKsc82K/Jh8OquV8FZUlreYPJk1'),\n ('Compl3X AlphaNu3meric','$6$rounds=10787$wakX8nGKEzgJ4Scy$X78uqaX1wYXcSCtS4BVYw2trWkvpa8p7lkAtS9O/6045fK4UB2/Jia0Uy/KzCpODlfVxVNZzCCoV9s2hoLfDs/'),\n ('4lpHa N|_|M3r1K W/ Cur5Es: #$%(*)(*%#','$6$rounds=11065$5KXQoE1bztkY5IZr$Jf6krQSUKKOlKca4hSW07MSerFFzVIZt/N3rOTsUgKqp7cUdHrwV8MoIVNCk9q9WL3ZRMsdbwNXpVk0gVxKtz1'),\n \n \n (UPASS_TABLE,'$6$rounds=40000$PEZTJDiyzV28M3.m$GTlnzfzGB44DGd1XqlmC4erAJKCP.rhvLvrYxiT38htrNzVGBnplFOHjejUGVrCfusGWxLQCc3pFO0A/1jYYr0'),\n ]\n \n known_malformed_hashes=[\n \n '$6$rounds=011021$KsvQipYPWpr93wWP$v7xjI4X6vyVptJjB1Y02vZC5SaSijBkGmq1uJhPr3cvqvvkd42Xvo48yLVPFt8dvhCsnlUgpX.//Cxn91H4qy1',\n \n '$6$rounds=11021$KsvQipYPWpr9:wWP$v7xjI4X6vyVptJjB1Y02vZC5SaSijBkGmq1uJhPr3cvqvvkd42Xvo48yLVPFt8dvhCsnlUgpX.//Cxn91H4qy1',\n ]\n \n known_correct_configs=[\n \n \n \n \n \n (\"$6$saltstring\",\"Hello world!\",\n \"$6$saltstring$svn8UoSVapNtMuq1ukKS4tPQd8iKwSMHWjl/O817G3uBnIFNjnQJu\"\n \"esI68u4OTLiBFdcbYEdFCoEOfaS35inz1\"),\n \n (\"$6$rounds=10000$saltstringsaltstring\",\"Hello world!\",\n \"$6$rounds=10000$saltstringsaltst$OW1/O6BYHV6BcXZu8QVeXbDWra3Oeqh0sb\"\n \"HbbMCVNSnCM/UrjmM0Dp8vOuZeHBy/YTBmSK6H9qs/y3RnOaw5v.\"),\n \n (\"$6$rounds=5000$toolongsaltstring\",\"This is just a test\",\n \"$6$rounds=5000$toolongsaltstrin$lQ8jolhgVRVhY4b5pZKaysCLi0QBxGoNeKQ\"\n \"zQ3glMhwllF7oGDZxUhx1yxdYcz/e1JSbq3y6JMxxl8audkUEm0\"),\n \n (\"$6$rounds=1400$anotherlongsaltstring\",\n \"a very much longer text to encrypt.  This one even stretches over more\"\n \"than one line.\",\n \"$6$rounds=1400$anotherlongsalts$POfYwTEok97VWcjxIiSOjiykti.o/pQs.wP\"\n \"vMxQ6Fm7I6IoYN3CmLs66x9t0oSwbtEW7o7UmJEiDwGqd8p4ur1\"),\n \n (\"$6$rounds=77777$short\",\n \"we have a short salt string but not a short password\",\n \"$6$rounds=77777$short$WuQyW2YR.hBNpjjRhpYD/ifIw05xdfeEyQoMxIXbkvr0g\"\n \"ge1a1x3yRULJ5CCaUeOxFmtlcGZelFl5CxtgfiAc0\"),\n \n (\"$6$rounds=123456$asaltof16chars..\",\"a short string\",\n \"$6$rounds=123456$asaltof16chars..$BtCwjqMJGx5hrJhZywWvt0RLE8uZ4oPwc\"\n \"elCjmw2kSYu.Ec6ycULevoBK25fs2xXgMNrCzIMVcgEJAstJeonj1\"),\n \n (\"$6$rounds=10$roundstoolow\",\"the minimum number is still observed\",\n \"$6$rounds=1000$roundstoolow$kUMsbe306n21p9R.FRkW3IGn.S9NPN0x50YhH1x\"\n \"hLsPuWGsUSklZt58jaTfF4ZEQpyUNGc0dqbpBYYBaHHrsX.\"),\n ]\n \n filter_config_warnings=True\n \n platform_crypt_support=_sha256_crypt_test.platform_crypt_support\n \n \nsha512_crypt_os_crypt_test=_sha512_crypt_test.create_backend_case(\"os_crypt\")\nsha512_crypt_builtin_test=_sha512_crypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass sun_md5_crypt_test(HandlerCase):\n handler=hash.sun_md5_crypt\n \n \n \n known_correct_hashes=[\n \n \n \n (\"Gpcs3_adm\",\"$md5$zrdhpMlZ$$wBvMOEqbSjU.hu5T2VEP01\"),\n \n \n \n \n (\"aa12345678\",\"$md5$vyy8.OVF$$FY4TWzuauRl4.VQNobqMY.\"),\n \n \n \n \n (\"this\",\"$md5$3UqYqndY$$6P.aaWOoucxxq.l00SS9k0\"),\n \n \n \n \n (\"passwd\",\"$md5$RPgLF6IJ$WTvAlUJ7MqH5xak2FMEwS/\"),\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n (UPASS_TABLE,'$md5,rounds=5000$10VYDzAA$$1arAVtMA3trgE1qJ2V0Ez1'),\n ]\n \n known_correct_configs=[\n \n \n \n \n \n \n \n \n \n \n \n \n (\"$md5$3UqYqndY$\",\n \"this\",\"$md5$3UqYqndY$$6P.aaWOoucxxq.l00SS9k0\"),\n (\"$md5$3UqYqndY$$.................DUMMY\",\n \"this\",\"$md5$3UqYqndY$$6P.aaWOoucxxq.l00SS9k0\"),\n \n \n \n \n \n \n (\"$md5$3UqYqndY\",\n \"this\",\"$md5$3UqYqndY$HIZVnfJNGCPbDZ9nIRSgP1\"),\n (\"$md5$3UqYqndY$.................DUMMY\",\n \"this\",\"$md5$3UqYqndY$HIZVnfJNGCPbDZ9nIRSgP1\"),\n ]\n \n known_malformed_hashes=[\n \n \"$md5,rounds=5000\",\n \n \n \"$md5,rounds=500A$xxxx\",\n \"$md5,rounds=0500$xxxx\",\n \"$md5,rounds=0$xxxx\",\n \n \n \"$md5$RPgL!6IJ$WTvAlUJ7MqH5xak2FMEwS/\",\n \n \n \"$md5$RPgLa6IJ$WTvAlUJ7MqH5xak2FMEwS\",\n \n \n \"$md5$RPgLa6IJ$WTvAlUJ7MqH5xak2FMEwS/.\",\n \n \n \n \"$md5$3UqYqndY$$\",\n \n \n \n \"$md5$RPgLa6IJ$$$WTvAlUJ7MqH5xak2FMEwS/\",\n \n ]\n \n platform_crypt_support=[\n (\"solaris\",True ),\n (\"freebsd|openbsd|netbsd|linux|darwin\",False ),\n ]\n def do_verify(self,secret,hash):\n \n \n  if isinstance(hash,str)and hash.endswith(\"$.................DUMMY\"):\n   raise ValueError(\"pretending '$...' stub hash is config string\")\n  return self.handler.verify(secret,hash)\n  \n  \n  \n  \nclass unix_disabled_test(HandlerCase):\n handler=hash.unix_disabled\n \n \n known_correct_hashes=[\n \n \n (\"password\",\"!\"),\n (UPASS_TABLE,\"*\"),\n ]\n \n known_unidentified_hashes=[\n \n \"$1$xxx\",\n \"abc\",\n \"./az\",\n \"{SHA}xxx\",\n ]\n \n def test_76_hash_border(self):\n \n  self.accepts_all_hashes=True\n  super(unix_disabled_test,self).test_76_hash_border()\n  \n def test_90_special(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\"passing settings to .*.hash\\(\\) is deprecated\")\n  handler=self.handler\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"!asd\"),\"!asd\")\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"\"),handler.default_marker)\n  self.assertEqual(handler.hash(\"stub\"),handler.default_marker)\n  self.assertEqual(handler.using().default_marker,handler.default_marker)\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"\",marker=\"*xxx\"),\"*xxx\")\n  self.assertEqual(handler.hash(\"stub\",marker=\"*xxx\"),\"*xxx\")\n  self.assertEqual(handler.using(marker=\"*xxx\").hash(\"stub\"),\"*xxx\")\n  \n  \n  self.assertRaises(ValueError,handler.genhash,'stub',\"\",marker='abc')\n  self.assertRaises(ValueError,handler.hash,'stub',marker='abc')\n  self.assertRaises(ValueError,handler.using,marker='abc')\n  \nclass unix_fallback_test(HandlerCase):\n handler=hash.unix_fallback\n accepts_all_hashes=True\n \n known_correct_hashes=[\n \n (\"password\",\"!\"),\n (UPASS_TABLE,\"!\"),\n ]\n \n \n def setUp(self):\n  super(unix_fallback_test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\"'unix_fallback' is deprecated\")\n  \n def test_90_wildcard(self):\n  ''\n  h=self.handler\n  self.assertTrue(h.verify('password','',enable_wildcard=True ))\n  self.assertFalse(h.verify('password',''))\n  for c in \"!*x\":\n   self.assertFalse(h.verify('password',c,enable_wildcard=True ))\n   self.assertFalse(h.verify('password',c))\n   \n def test_91_preserves_existing(self):\n  ''\n  handler=self.handler\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"\"),\"!\")\n  self.assertEqual(handler.hash(\"stub\"),\"!\")\n  \n  \n  self.assertEqual(handler.genhash(\"stub\",\"!asd\"),\"!asd\")\n  \n  \n  \n  \n", ["__future__", "binascii", "logging", "os", "passlib", "passlib.crypto.digest", "passlib.exc", "passlib.handlers.digests", "passlib.registry", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "sys", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_handlers_django": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport re\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.utils import repeat_string\nfrom passlib.utils.compat import u\nfrom passlib.tests.utils import TestCase,HandlerCase,skipUnless,SkipTest\nfrom passlib.tests.test_handlers import UPASS_USD,UPASS_TABLE\nfrom passlib.tests.test_ext_django import DJANGO_VERSION,MIN_DJANGO_VERSION,\\\ncheck_django_hasher_has_backend\n\n\n\n\n\n\n\nUPASS_LETMEIN=u('l\\xe8tmein')\n\ndef vstr(version):\n return \".\".join(str(e)for e in version)\n \nclass _DjangoHelper(TestCase):\n ''\n\n\n \n __unittest_skip=True\n \n \n min_django_version=MIN_DJANGO_VERSION\n \n \n \n \n \n \n max_django_version=None\n \n def _require_django_support(self):\n \n  if DJANGO_VERSION <self.min_django_version:\n   raise self.skipTest(\"Django >= %s not installed\"%vstr(self.min_django_version))\n  if self.max_django_version and DJANGO_VERSION >self.max_django_version:\n   raise self.skipTest(\"Django <= %s not installed\"%vstr(self.max_django_version))\n   \n   \n  name=self.handler.django_name\n  if not check_django_hasher_has_backend(name):\n   raise self.skipTest('django hasher %r not available'%name)\n   \n  return True\n  \n extra_fuzz_verifiers=HandlerCase.fuzz_verifiers+(\n \"fuzz_verifier_django\",\n )\n \n def fuzz_verifier_django(self):\n  try :\n   self._require_django_support()\n  except SkipTest:\n   return None\n  from django.contrib.auth.hashers import check_password\n  \n  def verify_django(secret,hash):\n   ''\n   if self.handler.name ==\"django_bcrypt\"and hash.startswith(\"bcrypt$$2y$\"):\n    hash=hash.replace(\"$$2y$\",\"$$2a$\")\n   if isinstance(secret,bytes):\n    secret=secret.decode(\"utf-8\")\n   return check_password(secret,hash)\n  return verify_django\n  \n def test_90_django_reference(self):\n  ''\n  self._require_django_support()\n  \n  \n  from django.contrib.auth.hashers import check_password\n  assert self.known_correct_hashes\n  for secret,hash in self.iter_known_hashes():\n   self.assertTrue(check_password(secret,hash),\n   \"secret=%r hash=%r failed to verify\"%\n   (secret,hash))\n   self.assertFalse(check_password('x'+secret,hash),\n   \"mangled secret=%r hash=%r incorrect verified\"%\n   (secret,hash))\n   \n def test_91_django_generation(self):\n  ''\n  self._require_django_support()\n  \n  \n  from passlib.utils import tick\n  from django.contrib.auth.hashers import make_password\n  name=self.handler.django_name\n  end=tick()+self.max_fuzz_time /2\n  generator=self.FuzzHashGenerator(self,self.getRandom())\n  while tick()<end:\n   secret,other=generator.random_password_pair()\n   if not secret:\n    continue\n   if isinstance(secret,bytes):\n    secret=secret.decode(\"utf-8\")\n   hash=make_password(secret,hasher=name)\n   self.assertTrue(self.do_identify(hash))\n   self.assertTrue(self.do_verify(secret,hash))\n   self.assertFalse(self.do_verify(other,hash))\n   \nclass django_disabled_test(HandlerCase):\n ''\n handler=hash.django_disabled\n disabled_contains_salt=True\n \n known_correct_hashes=[\n \n (\"password\",\"!\"),\n (\"\",\"!\"),\n (UPASS_TABLE,\"!\"),\n ]\n \n known_alternate_hashes=[\n \n (\"!9wa845vn7098ythaehasldkfj\",\"password\",\"!\"),\n ]\n \nclass django_des_crypt_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_des_crypt\n max_django_version=(1,9)\n \n known_correct_hashes=[\n \n (\"password\",'crypt$c2$c2M87q...WWcU'),\n (\"password\",'crypt$c2e86$c2M87q...WWcU'),\n (\"passwordignoreme\",'crypt$c2.AZ$c2M87q...WWcU'),\n \n \n (UPASS_USD,'crypt$c2e86$c2hN1Bxd6ZiWs'),\n (UPASS_TABLE,'crypt$0.aQs$0.wB.TT0Czvlo'),\n (u(\"hell\\u00D6\"),\"crypt$sa$saykDgk3BPZ9E\"),\n \n \n (\"foo\",'crypt$MNVY.9ajgdvDQ$MNVY.9ajgdvDQ'),\n ]\n \n known_alternate_hashes=[\n \n \n ('crypt$$c2M87q...WWcU',\"password\",'crypt$c2$c2M87q...WWcU'),\n ]\n \n known_unidentified_hashes=[\n 'sha1$aa$bb',\n ]\n \n known_malformed_hashes=[\n \n 'crypt$c2$c2M87q',\n \n \n 'crypt$f$c2M87q...WWcU',\n \n \n 'crypt$ffe86$c2M87q...WWcU',\n ]\n \nclass django_salted_md5_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_salted_md5\n max_django_version=(1,9)\n \n known_correct_hashes=[\n \n (\"password\",'md5$123abcdef$c8272612932975ee80e8a35995708e80'),\n \n \n (\"test\",'md5$3OpqnFAHW5CT$54b29300675271049a1ebae07b395e20'),\n \n \n (UPASS_USD,'md5$c2e86$92105508419a81a6babfaecf876a2fa0'),\n (UPASS_TABLE,'md5$d9eb8$01495b32852bffb27cf5d4394fe7a54c'),\n ]\n \n known_unidentified_hashes=[\n 'sha1$aa$bb',\n ]\n \n known_malformed_hashes=[\n \n 'md5$aa$bb',\n ]\n \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_salt_size(self):\n  \n  \n  \n  \n   handler=self.handler\n   default=handler.default_salt_size\n   assert handler.min_salt_size ==0\n   lower=1\n   upper=handler.max_salt_size or default *4\n   return self.randintgauss(lower,upper,default,default *.5)\n   \nclass django_salted_sha1_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_salted_sha1\n max_django_version=(1,9)\n \n known_correct_hashes=[\n \n (\"password\",'sha1$123abcdef$e4a1877b0e35c47329e7ed7e58014276168a37ba'),\n \n \n (\"test\",'sha1$bcwHF9Hy8lxS$6b4cfa0651b43161c6f1471ce9523acf1f751ba3'),\n \n \n (UPASS_USD,'sha1$c2e86$0f75c5d7fbd100d587c127ef0b693cde611b4ada'),\n (UPASS_TABLE,'sha1$6d853$ef13a4d8fb57aed0cb573fe9c82e28dc7fd372d4'),\n \n \n (\"MyPassword\",'sha1$54123$893cf12e134c3c215f3a76bd50d13f92404a54d3'),\n ]\n \n known_unidentified_hashes=[\n 'md5$aa$bb',\n ]\n \n known_malformed_hashes=[\n \n 'sha1$c2e86$0f75',\n ]\n \n \n FuzzHashGenerator=django_salted_md5_test.FuzzHashGenerator\n \nclass django_pbkdf2_sha256_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_pbkdf2_sha256\n \n known_correct_hashes=[\n \n \n \n ('not a password',\n 'pbkdf2_sha256$10000$kjVJaVz6qsnJ$5yPHw3rwJGECpUf70daLGhOrQ5+AMxIJdz1c3bqK1Rs='),\n (UPASS_TABLE,\n 'pbkdf2_sha256$10000$bEwAfNrH1TlQ$OgYUblFNUX1B8GfMqaCYUK/iHyO0pa7STTDdaEJBuY0='),\n ]\n \nclass django_pbkdf2_sha1_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_pbkdf2_sha1\n \n known_correct_hashes=[\n \n \n \n ('not a password',\n 'pbkdf2_sha1$10000$wz5B6WkasRoF$atJmJ1o+XfJxKq1+Nu1f1i57Z5I='),\n (UPASS_TABLE,\n 'pbkdf2_sha1$10000$KZKWwvqb8BfL$rw5pWsxJEU4JrZAQhHTCO+u0f5Y='),\n ]\n \n@skipUnless(hash.bcrypt.has_backend(),\"no bcrypt backends available\")\nclass django_bcrypt_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_bcrypt\n \n max_django_version=(2,0)\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n \n ('','bcrypt$$2a$06$DCq7YPn5Rq63x1Lad4cll.TV4S6ytwfsfvkgY8jIucDrjc8deX1s.'),\n ('abcdefghijklmnopqrstuvwxyz',\n 'bcrypt$$2a$10$fVH8e28OQRj9tqiDXs1e1uxpsjN0c7II7YPKXua2NAKYvM6iQk7dq'),\n (UPASS_TABLE,\n 'bcrypt$$2a$05$Z17AXnnlpzddNUvnC6cZNOSwMA/8oNiKnHTHTwLlBijfucQQlHjaG'),\n ]\n \n \n \n def populate_settings(self,kwds):\n \n  kwds.setdefault(\"rounds\",4)\n  super(django_bcrypt_test,self).populate_settings(kwds)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n  def random_ident(self):\n  \n  \n   return None\n   \n@skipUnless(hash.bcrypt.has_backend(),\"no bcrypt backends available\")\nclass django_bcrypt_sha256_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_bcrypt_sha256\n forbidden_characters=None\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n ('',\n 'bcrypt_sha256$$2a$06$/3OeRpbOf8/l6nPPRdZPp.nRiyYqPobEZGdNRBWihQhiFDh1ws1tu'),\n (UPASS_LETMEIN,\n 'bcrypt_sha256$$2a$08$NDjSAIcas.EcoxCRiArvT.MkNiPYVhrsrnJsRkLueZOoV1bsQqlmC'),\n (UPASS_TABLE,\n 'bcrypt_sha256$$2a$06$kCXUnRFQptGg491siDKNTu8RxjBGSjALHRuvhPYNFsa4Ea5d9M48u'),\n \n \n (repeat_string(\"abc123\",72),\n 'bcrypt_sha256$$2a$06$Tg/oYyZTyAf.Nb3qSgN61OySmyXA8FoY4PjGizjE1QSDfuL5MXNni'),\n (repeat_string(\"abc123\",72)+\"qwr\",\n 'bcrypt_sha256$$2a$06$Tg/oYyZTyAf.Nb3qSgN61Ocy0BEz1RK6xslSNi8PlaLX2pe7x/KQG'),\n (repeat_string(\"abc123\",72)+\"xyz\",\n 'bcrypt_sha256$$2a$06$Tg/oYyZTyAf.Nb3qSgN61OvY2zoRVUa2Pugv2ExVOUT2YmhvxUFUa'),\n ]\n \n known_malformed_hashers=[\n \n 'bcrypt_sha256$xyz$2a$06$/3OeRpbOf8/l6nPPRdZPp.nRiyYqPobEZGdNRBWihQhiFDh1ws1tu',\n ]\n \n \n \n def populate_settings(self,kwds):\n \n  kwds.setdefault(\"rounds\",4)\n  super(django_bcrypt_sha256_test,self).populate_settings(kwds)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n  def random_ident(self):\n  \n  \n   return None\n   \nfrom passlib.tests.test_handlers_argon2 import _base_argon2_test\n\n@skipUnless(hash.argon2.has_backend(),\"no argon2 backends available\")\nclass django_argon2_test(HandlerCase,_DjangoHelper):\n ''\n handler=hash.django_argon2\n \n \n \n known_correct_hashes=[\n \n (\"password\",'argon2$argon2i$v=19$m=256,t=1,p=1$c29tZXNhbHQ$AJFIsNZTMKTAewB4+ETN1A'),\n \n \n (\"password\",'argon2$argon2i$v=19$m=380,t=2,p=2$c29tZXNhbHQ$SrssP8n7m/12VWPM8dvNrw'),\n \n \n (UPASS_LETMEIN,'argon2$argon2i$v=19$m=512,t=2,p=2$V25jN1l4UUJZWkR1$MxpA1BD2Gh7+D79gaAw6sQ'),\n ]\n \n def setUpWarnings(self):\n  super(django_argon2_test,self).setUpWarnings()\n  warnings.filterwarnings(\"ignore\",\".*Using argon2pure backend.*\")\n  \n def do_stub_encrypt(self,handler=None ,**settings):\n \n \n  handler=(handler or self.handler).using(**settings)\n  self=handler.wrapped(use_defaults=True )\n  self.checksum=self._stub_checksum\n  assert self.checksum\n  return handler._wrap_hash(self.to_string())\n  \n def test_03_legacy_hash_workflow(self):\n \n  raise self.skipTest(\"legacy 1.6 workflow not supported\")\n  \n class FuzzHashGenerator(_base_argon2_test.FuzzHashGenerator):\n \n  def random_type(self):\n  \n   return \"I\"\n   \n  def random_rounds(self):\n  \n   return self.randintgauss(1,3,2,1)\n   \n   \n   \n   \n", ["__future__", "django.contrib.auth.hashers", "logging", "passlib", "passlib.tests.test_ext_django", "passlib.tests.test_handlers", "passlib.tests.test_handlers_argon2", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "re", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_totp": [".py", "''\n\n\n\n\nimport datetime\nfrom functools import partial\nimport logging ;log=logging.getLogger(__name__)\nimport sys\nimport time as _time\n\n\nfrom passlib import exc\nfrom passlib.utils.compat import unicode,u\nfrom passlib.tests.utils import TestCase,time_call\n\nfrom passlib import totp as totp_module\nfrom passlib.totp import TOTP,AppWallet,AES_SUPPORT\n\n__all__=[\n\"EngineTest\",\n]\n\n\n\n\n\n\n\n\n\nBase32DecodeError=Base16DecodeError=TypeError\nif sys.version_info >=(3,0):\n from binascii import Error as Base16DecodeError\nif sys.version_info >=(3,3):\n from binascii import Error as Base32DecodeError\n \nPASS1=\"abcdef\"\nPASS2=b\"\\x00\\xFF\"\nKEY1='4AOGGDBBQSYHNTUZ'\nKEY1_RAW=b'\\xe0\\x1cc\\x0c!\\x84\\xb0v\\xce\\x99'\nKEY2_RAW=b'\\xee]\\xcb9\\x870\\x06 D\\xc8y/\\xa54&\\xe4\\x9c\\x13\\xc2\\x18'\nKEY3='S3JDVB7QD2R7JPXX'\nKEY4='JBSWY3DPEHPK3PXP'\nKEY4_RAW=b'Hello!\\xde\\xad\\xbe\\xef'\n\n\n\n\n\n\n\nassert sys.float_info.radix ==2,\"unexpected float_info.radix\"\nassert sys.float_info.mant_dig >=44,\"double precision unexpectedly small\"\n\ndef _get_max_time_t():\n ''\n\n \n value=1 <<30\n year=0\n while True :\n  next_value=value <<1\n  try :\n   next_year=datetime.datetime.utcfromtimestamp(next_value -1).year\n  except (ValueError,OSError,OverflowError):\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   break\n   \n   \n   \n   \n   \n   \n   \n  if next_year <year:\n   break\n   \n  value=next_value\n  \n  \n value -=1\n \n \n \n \n max_datetime_timestamp=253402318800\n return min(value,max_datetime_timestamp)\n \n \n \nmax_time_t=_get_max_time_t()\n\ndef to_b32_size(raw_size):\n return (raw_size *8+4)//5\n \n \n \n \nclass AppWalletTest(TestCase):\n descriptionPrefix=\"passlib.totp.AppWallet\"\n \n \n \n \n \n def test_secrets_types(self):\n  ''\n  \n  \n  wallet=AppWallet()\n  self.assertEqual(wallet._secrets,{})\n  self.assertFalse(wallet.has_secrets)\n  \n  \n  ref={\"1\":b\"aaa\",\"2\":b\"bbb\"}\n  wallet=AppWallet(ref)\n  self.assertEqual(wallet._secrets,ref)\n  self.assertTrue(wallet.has_secrets)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  wallet=AppWallet(\"\\n 1: aaa\\n# comment\\n \\n2: bbb   \")\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  wallet=AppWallet(\"1: aaa: bbb \\n# comment\\n \\n2: bbb   \")\n  self.assertEqual(wallet._secrets,{\"1\":b\"aaa: bbb\",\"2\":b\"bbb\"})\n  \n  \n  wallet=AppWallet('{\"1\":\"aaa\",\"2\":\"bbb\"}')\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  \n  \n  \n  \n  self.assertRaises(TypeError,AppWallet,123)\n  \n  \n  self.assertRaises(TypeError,AppWallet,\"[123]\")\n  \n  \n  \n  \n  \n  self.assertRaises(ValueError,AppWallet,{\"1\":\"aaa\",\"2\":\"\"})\n  \n def test_secrets_tags(self):\n  ''\n  \n  \n  ref={\"1\":b\"aaa\",\"02\":b\"bbb\",\"C\":b\"ccc\"}\n  wallet=AppWallet(ref)\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  wallet=AppWallet({u(\"1\"):b\"aaa\",u(\"02\"):b\"bbb\",u(\"C\"):b\"ccc\"})\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  wallet=AppWallet({1:b\"aaa\",\"02\":b\"bbb\",\"C\":b\"ccc\"})\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  self.assertRaises(TypeError,AppWallet,{(1,):\"aaa\"})\n  \n  \n  wallet=AppWallet({\"1-2_3.4\":b\"aaa\"})\n  \n  \n  self.assertRaises(ValueError,AppWallet,{\"-abc\":\"aaa\"})\n  self.assertRaises(ValueError,AppWallet,{\"ab*$\":\"aaa\"})\n  \n  \n  wallet=AppWallet({\"1\":u(\"aaa\"),\"02\":\"bbb\",\"C\":b\"ccc\"})\n  self.assertEqual(wallet._secrets,ref)\n  \n  \n  self.assertRaises(TypeError,AppWallet,{\"1\":123})\n  self.assertRaises(TypeError,AppWallet,{\"1\":None })\n  self.assertRaises(TypeError,AppWallet,{\"1\":[]})\n  \n  \n  \n def test_default_tag(self):\n  ''\n  \n  \n  wallet=AppWallet({\"1\":\"one\",\"02\":\"two\"})\n  self.assertEqual(wallet.default_tag,\"02\")\n  self.assertEqual(wallet.get_secret(wallet.default_tag),b\"two\")\n  \n  \n  wallet=AppWallet({\"1\":\"one\",\"02\":\"two\",\"A\":\"aaa\"})\n  self.assertEqual(wallet.default_tag,\"A\")\n  self.assertEqual(wallet.get_secret(wallet.default_tag),b\"aaa\")\n  \n  \n  wallet=AppWallet({\"1\":\"one\",\"02\":\"two\",\"A\":\"aaa\"},default_tag=\"1\")\n  self.assertEqual(wallet.default_tag,\"1\")\n  self.assertEqual(wallet.get_secret(wallet.default_tag),b\"one\")\n  \n  \n  self.assertRaises(KeyError,AppWallet,{\"1\":\"one\",\"02\":\"two\",\"A\":\"aaa\"},\n  default_tag=\"B\")\n  \n  \n  wallet=AppWallet()\n  self.assertEqual(wallet.default_tag,None )\n  self.assertRaises(KeyError,wallet.get_secret,None )\n  \n  \n  \n  \n  \n  \n def require_aes_support(self,canary=None ):\n  if AES_SUPPORT:\n   canary and canary()\n  else :\n   canary and self.assertRaises(RuntimeError,canary)\n   raise self.skipTest(\"'cryptography' package not installed\")\n   \n def test_decrypt_key(self):\n  ''\n  \n  wallet=AppWallet({\"1\":PASS1,\"2\":PASS2})\n  \n  \n  CIPHER1=dict(v=1,c=13,s='6D7N7W53O7HHS37NLUFQ',\n  k='MHCTEGSNPFN5CGBJ',t='1')\n  self.require_aes_support(canary=partial(wallet.decrypt_key,CIPHER1))\n  \n  \n  self.assertEqual(wallet.decrypt_key(CIPHER1)[0],KEY1_RAW)\n  \n  \n  CIPHER2=dict(v=1,c=13,s='SPZJ54Y6IPUD2BYA4C6A',\n  k='ZGDXXTVQOWYLC2AU',t='1')\n  self.assertEqual(wallet.decrypt_key(CIPHER2)[0],KEY1_RAW)\n  \n  \n  CIPHER3=dict(v=1,c=8,s='FCCTARTIJWE7CPQHUDKA',\n  k='D2DRS32YESGHHINWFFCELKN7Z6NAHM4M',t='2')\n  self.assertEqual(wallet.decrypt_key(CIPHER3)[0],KEY2_RAW)\n  \n  \n  temp=CIPHER1.copy()\n  temp.update(t='2')\n  self.assertEqual(wallet.decrypt_key(temp)[0],b'\\xafD6.F7\\xeb\\x19\\x05Q')\n  \n  \n  temp=CIPHER1.copy()\n  temp.update(t='3')\n  self.assertRaises(KeyError,wallet.decrypt_key,temp)\n  \n  \n  temp=CIPHER1.copy()\n  temp.update(v=999)\n  self.assertRaises(ValueError,wallet.decrypt_key,temp)\n  \n def test_decrypt_key_needs_recrypt(self):\n  ''\n  self.require_aes_support()\n  \n  wallet=AppWallet({\"1\":PASS1,\"2\":PASS2},encrypt_cost=13)\n  \n  \n  ref=dict(v=1,c=13,s='AAAA',k='AAAA',t='2')\n  self.assertFalse(wallet.decrypt_key(ref)[1])\n  \n  \n  temp=ref.copy()\n  temp.update(c=8)\n  self.assertTrue(wallet.decrypt_key(temp)[1])\n  \n  \n  temp=ref.copy()\n  temp.update(t=\"1\")\n  self.assertTrue(wallet.decrypt_key(temp)[1])\n  \n  \n  \n def assertSaneResult(self,result,wallet,key,tag=\"1\",\n needs_recrypt=False ):\n  ''\n  \n  self.assertEqual(set(result),set([\"v\",\"t\",\"c\",\"s\",\"k\"]))\n  \n  self.assertEqual(result['v'],1)\n  self.assertEqual(result['t'],tag)\n  self.assertEqual(result['c'],wallet.encrypt_cost)\n  \n  self.assertEqual(len(result['s']),to_b32_size(wallet.salt_size))\n  self.assertEqual(len(result['k']),to_b32_size(len(key)))\n  \n  result_key,result_needs_recrypt=wallet.decrypt_key(result)\n  self.assertEqual(result_key,key)\n  self.assertEqual(result_needs_recrypt,needs_recrypt)\n  \n def test_encrypt_key(self):\n  ''\n  \n  \n  wallet=AppWallet({\"1\":PASS1},encrypt_cost=5)\n  self.require_aes_support(canary=partial(wallet.encrypt_key,KEY1_RAW))\n  \n  \n  result=wallet.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet,KEY1_RAW)\n  \n  \n  other=wallet.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet,KEY1_RAW)\n  self.assertNotEqual(other['s'],result['s'])\n  self.assertNotEqual(other['k'],result['k'])\n  \n  \n  wallet2=AppWallet({\"1\":PASS1},encrypt_cost=6)\n  result=wallet2.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet2,KEY1_RAW)\n  \n  \n  wallet2=AppWallet({\"1\":PASS1,\"2\":PASS2})\n  result=wallet2.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet2,KEY1_RAW,tag=\"2\")\n  \n  \n  wallet2=AppWallet({\"1\":PASS1})\n  wallet2.salt_size=64\n  result=wallet2.encrypt_key(KEY1_RAW)\n  self.assertSaneResult(result,wallet2,KEY1_RAW)\n  \n  \n  result=wallet.encrypt_key(KEY2_RAW)\n  self.assertSaneResult(result,wallet,KEY2_RAW)\n  \n  \n  \n  self.assertRaises(ValueError,wallet.encrypt_key,b\"\")\n  \n def test_encrypt_cost_timing(self):\n  ''\n  self.require_aes_support()\n  \n  \n  wallet=AppWallet({\"1\":\"aaa\"})\n  wallet.encrypt_cost -=2\n  delta,_=time_call(partial(wallet.encrypt_key,KEY1_RAW),maxtime=0)\n  \n  \n  wallet.encrypt_cost +=3\n  delta2,_=time_call(partial(wallet.encrypt_key,KEY1_RAW),maxtime=0)\n  \n  \n  \n  self.assertAlmostEqual(delta2,delta *8,delta=(delta *8)*0.5)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nRFC_KEY_BYTES_20=\"12345678901234567890\".encode(\"ascii\")\nRFC_KEY_BYTES_32=(RFC_KEY_BYTES_20 *2)[:32]\nRFC_KEY_BYTES_64=(RFC_KEY_BYTES_20 *4)[:64]\n\n\n\n\nclass TotpTest(TestCase):\n ''\n\n \n \n \n \n \n descriptionPrefix=\"passlib.totp.TOTP\"\n \n \n \n \n def setUp(self):\n  super(TotpTest,self).setUp()\n  \n  \n  from passlib.crypto.digest import lookup_hash\n  lookup_hash.clear_cache()\n  \n  \n  self.patchAttr(totp_module,\"rng\",self.getRandom())\n  \n  \n  \n  \n def randtime(self):\n  ''\n\n\n  \n  return self.getRandom().random()*max_time_t\n  \n def randotp(self,cls=None ,**kwds):\n  ''\n\n  \n  rng=self.getRandom()\n  if \"key\"not in kwds:\n   kwds['new']=True\n  kwds.setdefault(\"digits\",rng.randint(6,10))\n  kwds.setdefault(\"alg\",rng.choice([\"sha1\",\"sha256\",\"sha512\"]))\n  kwds.setdefault(\"period\",rng.randint(10,120))\n  return (cls or TOTP)(**kwds)\n  \n def test_randotp(self):\n  ''\n\n  \n  otp1=self.randotp()\n  otp2=self.randotp()\n  \n  self.assertNotEqual(otp1.key,otp2.key,\"key not randomized:\")\n  \n  \n  for _ in range(10):\n   if otp1.digits !=otp2.digits:\n    break\n   otp2=self.randotp()\n  else :\n   self.fail(\"digits not randomized\")\n   \n   \n  for _ in range(10):\n   if otp1.alg !=otp2.alg:\n    break\n   otp2=self.randotp()\n  else :\n   self.fail(\"alg not randomized\")\n   \n   \n   \n   \n   \n   \n vector_defaults=dict(format=\"base32\",alg=\"sha1\",period=30,digits=8)\n \n \n \n vectors=[\n \n \n \n \n \n \n [dict(key=\"ACDEFGHJKL234567\",digits=6),\n \n (1412873399,'221105'),\n (1412873400,'178491'),\n (1412873401,'178491'),\n (1412873429,'178491'),\n (1412873430,'915114'),\n ],\n \n \n [dict(key=\"ACDEFGHJKL234567\",digits=8),\n \n (1412873399,'20221105'),\n (1412873400,'86178491'),\n (1412873401,'86178491'),\n (1412873429,'86178491'),\n (1412873430,'03915114'),\n ],\n \n \n [dict(key=\"S3JD-VB7Q-D2R7-JPXX\",digits=6),\n (1419622709,'000492'),\n (1419622739,'897212'),\n ],\n \n \n \n \n \n \n \n \n \n [dict(key=RFC_KEY_BYTES_20,format=\"raw\",alg=\"sha1\"),\n (59,'94287082'),\n (1111111109,'07081804'),\n (1111111111,'14050471'),\n (1234567890,'89005924'),\n (2000000000,'69279037'),\n (20000000000,'65353130'),\n ],\n \n \n [dict(key=RFC_KEY_BYTES_32,format=\"raw\",alg=\"sha256\"),\n (59,'46119246'),\n (1111111109,'68084774'),\n (1111111111,'67062674'),\n (1234567890,'91819424'),\n (2000000000,'90698825'),\n (20000000000,'77737706'),\n ],\n \n \n [dict(key=RFC_KEY_BYTES_64,format=\"raw\",alg=\"sha512\"),\n (59,'90693936'),\n (1111111109,'25091201'),\n (1111111111,'99943326'),\n (1234567890,'93441116'),\n (2000000000,'38618901'),\n (20000000000,'47863826'),\n ],\n \n \n \n \n \n \n [dict(key=\"JBSWY3DPEHPK3PXP\",digits=6),(1409192430,'727248'),(1419890990,'122419')],\n [dict(key=\"JBSWY3DPEHPK3PXP\",digits=9,period=41),(1419891152,'662331049')],\n \n \n [dict(key=RFC_KEY_BYTES_20,format=\"raw\",period=60),(1111111111,'19360094')],\n [dict(key=RFC_KEY_BYTES_32,format=\"raw\",alg=\"sha256\",period=60),(1111111111,'40857319')],\n [dict(key=RFC_KEY_BYTES_64,format=\"raw\",alg=\"sha512\",period=60),(1111111111,'37023009')],\n \n ]\n \n def iter_test_vectors(self):\n  ''\n\n\n  \n  from passlib.totp import TOTP\n  for row in self.vectors:\n   kwds=self.vector_defaults.copy()\n   kwds.update(row[0])\n   for entry in row[1:]:\n    if len(entry)==3:\n     time,token,expires=entry\n    else :\n     time,token=entry\n     expires=None\n     \n     \n    log.debug(\"test vector: %r time=%r token=%r expires=%r\",kwds,time,token,expires)\n    otp=TOTP(**kwds)\n    prefix=\"alg=%r time=%r token=%r: \"%(otp.alg,time,token)\n    yield otp,time,token,expires,prefix\n    \n    \n    \n    \n def test_ctor_w_new(self):\n  ''\n  \n  \n  self.assertRaises(TypeError,TOTP)\n  self.assertRaises(TypeError,TOTP,key='4aoggdbbqsyhntuz',new=True )\n  \n  \n  otp=TOTP(new=True )\n  otp2=TOTP(new=True )\n  self.assertNotEqual(otp.key,otp2.key)\n  \n def test_ctor_w_size(self):\n  ''\n  \n  \n  self.assertEqual(len(TOTP(new=True ,alg=\"sha1\").key),20)\n  self.assertEqual(len(TOTP(new=True ,alg=\"sha256\").key),32)\n  self.assertEqual(len(TOTP(new=True ,alg=\"sha512\").key),64)\n  \n  \n  self.assertEqual(len(TOTP(new=True ,size=10).key),10)\n  self.assertEqual(len(TOTP(new=True ,size=16).key),16)\n  \n  \n  self.assertRaises(ValueError,TOTP,new=True ,size=21,alg=\"sha1\")\n  \n  \n  self.assertRaises(ValueError,TOTP,new=True ,size=9)\n  \n  \n  with self.assertWarningList([\n  dict(category=exc.PasslibSecurityWarning,message_re=\".*for security purposes, secret key must be.*\")\n  ]):\n   _=TOTP('0A'*9,'hex')\n   \n def test_ctor_w_key_and_format(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1).key,KEY1_RAW)\n  \n  \n  self.assertEqual(TOTP(KEY1.lower()).key,KEY1_RAW)\n  \n  \n  self.assertEqual(TOTP(' 4aog gdbb qsyh ntuz ').key,KEY1_RAW)\n  \n  \n  self.assertRaises(Base32DecodeError,TOTP,'ao!ggdbbqsyhntuz')\n  \n  \n  self.assertEqual(TOTP('e01c630c2184b076ce99','hex').key,KEY1_RAW)\n  \n  \n  self.assertRaises(Base16DecodeError,TOTP,'X01c630c2184b076ce99','hex')\n  \n  \n  self.assertEqual(TOTP(KEY1_RAW,\"raw\").key,KEY1_RAW)\n  \n def test_ctor_w_alg(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1,alg=\"SHA-256\").alg,\"sha256\")\n  self.assertEqual(TOTP(KEY1,alg=\"SHA256\").alg,\"sha256\")\n  \n  \n  self.assertRaises(ValueError,TOTP,KEY1,alg=\"SHA-333\")\n  \n def test_ctor_w_digits(self):\n  ''\n  self.assertRaises(ValueError,TOTP,KEY1,digits=5)\n  self.assertEqual(TOTP(KEY1,digits=6).digits,6)\n  self.assertEqual(TOTP(KEY1,digits=10).digits,10)\n  self.assertRaises(ValueError,TOTP,KEY1,digits=11)\n  \n def test_ctor_w_period(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1).period,30)\n  \n  \n  self.assertEqual(TOTP(KEY1,period=63).period,63)\n  \n  \n  self.assertRaises(TypeError,TOTP,KEY1,period=1.5)\n  self.assertRaises(TypeError,TOTP,KEY1,period='abc')\n  \n  \n  self.assertRaises(ValueError,TOTP,KEY1,period=0)\n  self.assertRaises(ValueError,TOTP,KEY1,period=-1)\n  \n def test_ctor_w_label(self):\n  ''\n  self.assertEqual(TOTP(KEY1).label,None )\n  self.assertEqual(TOTP(KEY1,label=\"foo@bar\").label,\"foo@bar\")\n  self.assertRaises(ValueError,TOTP,KEY1,label=\"foo:bar\")\n  \n def test_ctor_w_issuer(self):\n  ''\n  self.assertEqual(TOTP(KEY1).issuer,None )\n  self.assertEqual(TOTP(KEY1,issuer=\"foo.com\").issuer,\"foo.com\")\n  self.assertRaises(ValueError,TOTP,KEY1,issuer=\"foo.com:bar\")\n  \n  \n  \n  \n  \n  \n  \n def test_using_w_period(self):\n  ''\n  \n  \n  self.assertEqual(TOTP(KEY1).period,30)\n  \n  \n  self.assertEqual(TOTP.using(period=63)(KEY1).period,63)\n  \n  \n  self.assertRaises(TypeError,TOTP.using,period=1.5)\n  self.assertRaises(TypeError,TOTP.using,period='abc')\n  \n  \n  self.assertRaises(ValueError,TOTP.using,period=0)\n  self.assertRaises(ValueError,TOTP.using,period=-1)\n  \n def test_using_w_now(self):\n  ''\n  \n  \n  \n  \n  otp=self.randotp()\n  self.assertIs(otp.now,_time.time)\n  self.assertAlmostEqual(otp.normalize_time(None ),int(_time.time()))\n  \n  \n  counter=[123.12]\n  def now():\n   counter[0]+=1\n   return counter[0]\n  otp=self.randotp(cls=TOTP.using(now=now))\n  \n  self.assertEqual(otp.normalize_time(None ),126)\n  self.assertEqual(otp.normalize_time(None ),127)\n  \n  \n  self.assertRaises(TypeError,TOTP.using,now=123)\n  \n  \n  msg_re=r\"now\\(\\) function must return non-negative\"\n  self.assertRaisesRegex(AssertionError,msg_re,TOTP.using,now=lambda :'abc')\n  \n  \n  self.assertRaisesRegex(AssertionError,msg_re,TOTP.using,now=lambda :-1)\n  \n  \n  \n  \n  \n def test_normalize_token_instance(self,otp=None ):\n  ''\n  if otp is None :\n   otp=self.randotp(digits=7)\n   \n   \n  self.assertEqual(otp.normalize_token(u('1234567')),'1234567')\n  self.assertEqual(otp.normalize_token(b'1234567'),'1234567')\n  \n  \n  self.assertEqual(otp.normalize_token(1234567),'1234567')\n  \n  \n  self.assertEqual(otp.normalize_token(234567),'0234567')\n  \n  \n  self.assertRaises(TypeError,otp.normalize_token,1234567.0)\n  self.assertRaises(TypeError,otp.normalize_token,None )\n  \n  \n  self.assertRaises(exc.MalformedTokenError,otp.normalize_token,'123456')\n  \n  \n  self.assertRaises(exc.MalformedTokenError,otp.normalize_token,'01234567')\n  self.assertRaises(exc.MalformedTokenError,otp.normalize_token,12345678)\n  \n def test_normalize_token_class(self):\n  ''\n  self.test_normalize_token_instance(otp=TOTP.using(digits=7))\n  \n def test_normalize_time(self):\n  ''\n  TotpFactory=TOTP.using()\n  otp=self.randotp(TotpFactory)\n  \n  for _ in range(10):\n   time=self.randtime()\n   tint=int(time)\n   \n   self.assertEqual(otp.normalize_time(time),tint)\n   self.assertEqual(otp.normalize_time(tint+0.5),tint)\n   \n   self.assertEqual(otp.normalize_time(tint),tint)\n   \n   dt=datetime.datetime.utcfromtimestamp(time)\n   self.assertEqual(otp.normalize_time(dt),tint)\n   \n   orig=TotpFactory.now\n   try :\n    TotpFactory.now=staticmethod(lambda :time)\n    self.assertEqual(otp.normalize_time(None ),tint)\n   finally :\n    TotpFactory.now=orig\n    \n  self.assertRaises(TypeError,otp.normalize_time,'1234')\n  \n  \n  \n  \n  \n def test_key_attrs(self):\n  ''\n  rng=self.getRandom()\n  \n  \n  otp=TOTP(KEY1_RAW,\"raw\")\n  self.assertEqual(otp.key,KEY1_RAW)\n  self.assertEqual(otp.hex_key,'e01c630c2184b076ce99')\n  self.assertEqual(otp.base32_key,KEY1)\n  \n  \n  self.assertEqual(otp.pretty_key(),'4AOG-GDBB-QSYH-NTUZ')\n  self.assertEqual(otp.pretty_key(sep=\" \"),'4AOG GDBB QSYH NTUZ')\n  self.assertEqual(otp.pretty_key(sep=False ),KEY1)\n  self.assertEqual(otp.pretty_key(format=\"hex\"),'e01c-630c-2184-b076-ce99')\n  \n  \n  otp=TOTP(new=True ,size=rng.randint(10,20))\n  _=otp.hex_key\n  _=otp.base32_key\n  _=otp.pretty_key()\n  \n  \n  \n  \n def test_totp_token(self):\n  ''\n  from passlib.totp import TOTP,TotpToken\n  \n  \n  otp=TOTP('s3jdvb7qd2r7jpxx')\n  result=otp.generate(1419622739)\n  self.assertIsInstance(result,TotpToken)\n  self.assertEqual(result.token,'897212')\n  self.assertEqual(result.counter,47320757)\n  \n  self.assertEqual(result.expire_time,1419622740)\n  self.assertEqual(result,('897212',1419622740))\n  self.assertEqual(len(result),2)\n  self.assertEqual(result[0],'897212')\n  self.assertEqual(result[1],1419622740)\n  self.assertRaises(IndexError,result.__getitem__,-3)\n  self.assertRaises(IndexError,result.__getitem__,2)\n  self.assertTrue(result)\n  \n  \n  otp.now=lambda :1419622739.5\n  self.assertEqual(result.remaining,0.5)\n  self.assertTrue(result.valid)\n  \n  otp.now=lambda :1419622741\n  self.assertEqual(result.remaining,0)\n  self.assertFalse(result.valid)\n  \n  \n  result2=otp.generate(1419622739)\n  self.assertIsNot(result2,result)\n  self.assertEqual(result2,result)\n  \n  \n  result3=otp.generate(1419622711)\n  self.assertIsNot(result3,result)\n  self.assertEqual(result3,result)\n  \n  \n  result4=otp.generate(1419622999)\n  self.assertNotEqual(result4,result)\n  \n def test_generate(self):\n  ''\n  from passlib.totp import TOTP\n  \n  \n  otp=TOTP(new=True )\n  time=self.randtime()\n  result=otp.generate(time)\n  token=result.token\n  self.assertIsInstance(token,unicode)\n  start_time=result.counter *30\n  \n  \n  self.assertEqual(otp.generate(start_time+29).token,token)\n  \n  \n  self.assertNotEqual(otp.generate(start_time+30).token,token)\n  \n  \n  dt=datetime.datetime.utcfromtimestamp(time)\n  self.assertEqual(int(otp.normalize_time(dt)),int(time))\n  \n  \n  self.assertEqual(otp.generate(dt).token,token)\n  \n  \n  otp2=TOTP.using(now=lambda :time)(key=otp.base32_key)\n  self.assertEqual(otp2.generate().token,token)\n  \n  \n  self.assertRaises(ValueError,otp.generate,-1)\n  \n def test_generate_w_reference_vectors(self):\n  ''\n  for otp,time,token,expires,prefix in self.iter_test_vectors():\n  \n   result=otp.generate(time)\n   self.assertEqual(result.token,token,msg=prefix)\n   self.assertEqual(result.counter,time //otp.period,msg=prefix)\n   if expires:\n    self.assertEqual(result.expire_time,expires)\n    \n    \n    \n    \n    \n def assertTotpMatch(self,match,time,skipped=0,period=30,window=30,msg=''):\n  from passlib.totp import TotpMatch\n  \n  \n  self.assertIsInstance(match,TotpMatch)\n  \n  \n  self.assertIsInstance(match.totp,TOTP)\n  self.assertEqual(match.totp.period,period)\n  \n  \n  self.assertEqual(match.time,time,msg=msg+\" matched time:\")\n  expected=time //period\n  counter=expected+skipped\n  self.assertEqual(match.counter,counter,msg=msg+\" matched counter:\")\n  self.assertEqual(match.expected_counter,expected,msg=msg+\" expected counter:\")\n  self.assertEqual(match.skipped,skipped,msg=msg+\" skipped:\")\n  self.assertEqual(match.cache_seconds,period+window)\n  expire_time=(counter+1)*period\n  self.assertEqual(match.expire_time,expire_time)\n  self.assertEqual(match.cache_time,expire_time+window)\n  \n  \n  self.assertEqual(len(match),2)\n  self.assertEqual(match,(counter,time))\n  self.assertRaises(IndexError,match.__getitem__,-3)\n  self.assertEqual(match[0],counter)\n  self.assertEqual(match[1],time)\n  self.assertRaises(IndexError,match.__getitem__,2)\n  \n  \n  self.assertTrue(match)\n  \n def test_totp_match_w_valid_token(self):\n  ''\n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  result=otp.match(token,time)\n  self.assertTotpMatch(result,time=time,skipped=0)\n  \n def test_totp_match_w_older_token(self):\n  ''\n  from passlib.totp import TotpMatch\n  \n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  result=otp.match(token,time -30)\n  self.assertTotpMatch(result,time=time -30,skipped=1)\n  \n def test_totp_match_w_new_token(self):\n  ''\n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  result=otp.match(token,time+30)\n  self.assertTotpMatch(result,time=time+30,skipped=-1)\n  \n def test_totp_match_w_invalid_token(self):\n  ''\n  time=141230981\n  token='781501'\n  otp=TOTP.using(now=lambda :time+24 *3600)(KEY3)\n  self.assertRaises(exc.InvalidTokenError,otp.match,token,time+60)\n  \n  \n  \n  \n  \n def assertVerifyMatches(self,expect_skipped,token,time,\n otp,gen_time=None ,**kwds):\n  ''\n  \n  msg=\"key=%r alg=%r period=%r token=%r gen_time=%r time=%r:\"%\\\n  (otp.base32_key,otp.alg,otp.period,token,gen_time,time)\n  result=otp.match(token,time,**kwds)\n  self.assertTotpMatch(result,\n  time=otp.normalize_time(time),\n  period=otp.period,\n  window=kwds.get(\"window\",30),\n  skipped=expect_skipped,\n  msg=msg)\n  \n def assertVerifyRaises(self,exc_class,token,time,\n otp,gen_time=None ,\n **kwds):\n  ''\n  \n  msg=\"key=%r alg=%r period=%r token=%r gen_time=%r time=%r:\"%\\\n  (otp.base32_key,otp.alg,otp.period,token,gen_time,time)\n  return self.assertRaises(exc_class,otp.match,token,time,\n  __msg__=msg,**kwds)\n  \n def test_match_w_window(self):\n  ''\n  \n  \n  otp=self.randotp()\n  period=otp.period\n  time=self.randtime()\n  token=otp.generate(time).token\n  common=dict(otp=otp,gen_time=time)\n  assertMatches=partial(self.assertVerifyMatches,**common)\n  assertRaises=partial(self.assertVerifyRaises,**common)\n  \n  \n  \n  \n  \n  \n  assertRaises(exc.InvalidTokenError,token,time -period,window=0)\n  assertMatches(+1,token,time -period,window=period)\n  assertMatches(+1,token,time -period,window=2 *period)\n  \n  \n  assertMatches(0,token,time,window=0)\n  \n  \n  assertRaises(exc.InvalidTokenError,token,time+period,window=0)\n  assertMatches(-1,token,time+period,window=period)\n  assertMatches(-1,token,time+period,window=2 *period)\n  \n  \n  assertRaises(exc.InvalidTokenError,token,time+2 *period,window=0)\n  assertRaises(exc.InvalidTokenError,token,time+2 *period,window=period)\n  assertMatches(-2,token,time+2 *period,window=2 *period)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  dt=datetime.datetime.utcfromtimestamp(time)\n  assertMatches(0,token,dt,window=0)\n  \n  \n  assertRaises(ValueError,token,-1)\n  \n def test_match_w_skew(self):\n  ''\n  \n  otp=self.randotp()\n  period=otp.period\n  time=self.randtime()\n  common=dict(otp=otp,gen_time=time)\n  assertMatches=partial(self.assertVerifyMatches,**common)\n  assertRaises=partial(self.assertVerifyRaises,**common)\n  \n  \n  skew=3 *period\n  behind_token=otp.generate(time -skew).token\n  assertRaises(exc.InvalidTokenError,behind_token,time,window=0)\n  assertMatches(-3,behind_token,time,window=0,skew=-skew)\n  \n  \n  ahead_token=otp.generate(time+skew).token\n  assertRaises(exc.InvalidTokenError,ahead_token,time,window=0)\n  assertMatches(+3,ahead_token,time,window=0,skew=skew)\n  \n  \n  \n def test_match_w_reuse(self):\n  ''\n  \n  \n  otp=self.randotp()\n  period=otp.period\n  time=self.randtime()\n  tdata=otp.generate(time)\n  token=tdata.token\n  counter=tdata.counter\n  expire_time=tdata.expire_time\n  common=dict(otp=otp,gen_time=time)\n  assertMatches=partial(self.assertVerifyMatches,**common)\n  assertRaises=partial(self.assertVerifyRaises,**common)\n  \n  \n  \n  assertMatches(-1,token,time+period,window=period)\n  \n  \n  \n  assertMatches(-1,token,time+period,last_counter=counter -1,\n  window=period)\n  \n  \n  \n  assertRaises(exc.InvalidTokenError,token,time+2 *period,\n  last_counter=counter,window=period)\n  \n  \n  \n  err=assertRaises(exc.UsedTokenError,token,time+period,\n  last_counter=counter,window=period)\n  self.assertEqual(err.expire_time,expire_time)\n  \n  \n  \n  err=assertRaises(exc.UsedTokenError,token,time,\n  last_counter=counter,window=0)\n  self.assertEqual(err.expire_time,expire_time)\n  \n def test_match_w_token_normalization(self):\n  ''\n  \n  otp=TOTP('otxl2f5cctbprpzx')\n  match=otp.match\n  time=1412889861\n  \n  \n  self.assertTrue(match('    3 32-136  ',time))\n  \n  \n  self.assertTrue(match(b'332136',time))\n  \n  \n  self.assertRaises(exc.MalformedTokenError,match,'12345',time)\n  \n  \n  self.assertRaises(exc.MalformedTokenError,match,'12345X',time)\n  \n  \n  self.assertRaises(exc.MalformedTokenError,match,'0123456',time)\n  \n def test_match_w_reference_vectors(self):\n  ''\n  for otp,time,token,expires,msg in self.iter_test_vectors():\n  \n   match=otp.match\n   \n   \n   result=match(token,time)\n   self.assertTrue(result)\n   self.assertEqual(result.counter,time //otp.period,msg=msg)\n   \n   \n   self.assertRaises(exc.InvalidTokenError,match,token,time+100,window=0)\n   \n   \n   \n   \n def test_verify(self):\n  ''\n  \n  \n  \n  from passlib.totp import TOTP\n  \n  time=1412889861\n  TotpFactory=TOTP.using(now=lambda :time)\n  \n  \n  source1=dict(v=1,type=\"totp\",key='otxl2f5cctbprpzx')\n  match=TotpFactory.verify('332136',source1)\n  self.assertTotpMatch(match,time=time)\n  \n  \n  source1=dict(v=1,type=\"totp\",key='otxl2f5cctbprpzx')\n  self.assertRaises(exc.InvalidTokenError,TotpFactory.verify,'332155',source1)\n  \n  \n  source1=dict(v=1,type=\"totp\")\n  self.assertRaises(ValueError,TotpFactory.verify,'332155',source1)\n  \n  \n  source1json='{\"v\": 1, \"type\": \"totp\", \"key\": \"otxl2f5cctbprpzx\"}'\n  match=TotpFactory.verify('332136',source1json)\n  self.assertTotpMatch(match,time=time)\n  \n  \n  source1uri='otpauth://totp/Label?secret=otxl2f5cctbprpzx'\n  match=TotpFactory.verify('332136',source1uri)\n  self.assertTotpMatch(match,time=time)\n  \n  \n  \n  \n def test_from_source(self):\n  ''\n  from passlib.totp import TOTP\n  from_source=TOTP.from_source\n  \n  \n  otp=from_source(u(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Example\"))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(b\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  b\"issuer=Example\")\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(dict(v=1,type=\"totp\",key=KEY4))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(u('{\"v\": 1, \"type\": \"totp\", \"key\": \"JBSWY3DPEHPK3PXP\"}'))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  otp=from_source(b'{\"v\": 1, \"type\": \"totp\", \"key\": \"JBSWY3DPEHPK3PXP\"}')\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  self.assertIs(from_source(otp),otp)\n  \n  \n  wallet1=AppWallet()\n  otp1=TOTP.using(wallet=wallet1).from_source(otp)\n  self.assertIsNot(otp1,otp)\n  self.assertEqual(otp1.to_dict(),otp.to_dict())\n  \n  \n  otp2=TOTP.using(wallet=wallet1).from_source(otp1)\n  self.assertIs(otp2,otp1)\n  \n  \n  self.assertRaises(ValueError,from_source,u(\"foo\"))\n  self.assertRaises(ValueError,from_source,b\"foo\")\n  \n  \n  \n  \n def test_from_uri(self):\n  ''\n  from passlib.totp import TOTP\n  from_uri=TOTP.from_uri\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Example\")\n  self.assertIsInstance(otp,TOTP)\n  self.assertEqual(otp.key,KEY4_RAW)\n  self.assertEqual(otp.label,\"alice@google.com\")\n  self.assertEqual(otp.issuer,\"Example\")\n  self.assertEqual(otp.alg,\"sha1\")\n  self.assertEqual(otp.period,30)\n  self.assertEqual(otp.digits,6)\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=jbswy3dpehpk3pxp&\"\n  \"issuer=Example\")\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?digits=6\")\n  \n  \n  self.assertRaises(Base32DecodeError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHP@3PXP\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Provider1:Alice%20Smith?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Provider1\")\n  self.assertEqual(otp.label,\"Alice Smith\")\n  self.assertEqual(otp.issuer,\"Provider1\")\n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Big%20Corporation%3A%20alice@bigco.com?\"\n  \"secret=JBSWY3DPEHPK3PXP\")\n  self.assertEqual(otp.label,\"alice@bigco.com\")\n  self.assertEqual(otp.issuer,\"Big Corporation\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/alice@bigco.com?secret=JBSWY3DPEHPK3PXP&issuer=Big%20Corporation\")\n  self.assertEqual(otp.label,\"alice@bigco.com\")\n  self.assertEqual(otp.issuer,\"Big Corporation\")\n  \n  \n  self.assertRaises(ValueError,TOTP.from_uri,\n  \"otpauth://totp/Provider1:alice?secret=JBSWY3DPEHPK3PXP&issuer=Provider2\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&algorithm=SHA256\")\n  self.assertEqual(otp.alg,\"sha256\")\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHPK3PXP&algorithm=SHA333\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=8\")\n  self.assertEqual(otp.digits,8)\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=A\")\n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=%20\")\n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&digits=15\")\n  \n  \n  \n  \n  \n  \n  otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&period=63\")\n  self.assertEqual(otp.period,63)\n  \n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHPK3PXP&period=0\")\n  \n  self.assertRaises(ValueError,from_uri,\"otpauth://totp/Example:alice@google.com?\"\n  \"secret=JBSWY3DPEHPK3PXP&period=-1\")\n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([\n  dict(category=exc.PasslibRuntimeWarning,message_re=\"unexpected parameters encountered\")\n  ]):\n   otp=from_uri(\"otpauth://totp/Example:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n   \"foo=bar&period=63\")\n  self.assertEqual(otp.base32_key,KEY4)\n  self.assertEqual(otp.period,63)\n  \n def test_to_uri(self):\n  ''\n  \n  \n  \n  \n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30)\n  self.assertEqual(otp.to_uri(\"alice@google.com\",\"Example Org\"),\n  \"otpauth://totp/Example%20Org:alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"issuer=Example%20Org\")\n  \n  \n  self.assertRaises(ValueError,otp.to_uri,None ,\"Example Org\")\n  \n  \n  self.assertEqual(otp.to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP\")\n  \n  \n  otp.label=\"alice@google.com\"\n  self.assertEqual(otp.to_uri(),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP\")\n  \n  \n  otp.issuer=\"Example Org\"\n  self.assertEqual(otp.to_uri(),\n  \"otpauth://totp/Example%20Org:alice@google.com?secret=JBSWY3DPEHPK3PXP\"\n  \"&issuer=Example%20Org\")\n  \n  \n  self.assertRaises(ValueError,otp.to_uri,\"label:with:semicolons\")\n  \n  \n  self.assertRaises(ValueError,otp.to_uri,\"alice@google.com\",\"issuer:with:semicolons\")\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,alg=\"sha256\").to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"algorithm=SHA256\")\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,digits=8).to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"digits=8\")\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,period=63).to_uri(\"alice@google.com\"),\n  \"otpauth://totp/alice@google.com?secret=JBSWY3DPEHPK3PXP&\"\n  \"period=63\")\n  \n  \n  \n  \n def test_from_dict(self):\n  ''\n  from passlib.totp import TOTP\n  from_dict=TOTP.from_dict\n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,label=\"alice@google.com\",issuer=\"Example\"))\n  self.assertIsInstance(otp,TOTP)\n  self.assertEqual(otp.key,KEY4_RAW)\n  self.assertEqual(otp.label,\"alice@google.com\")\n  self.assertEqual(otp.issuer,\"Example\")\n  self.assertEqual(otp.alg,\"sha1\")\n  self.assertEqual(otp.period,30)\n  self.assertEqual(otp.digits,6)\n  \n  \n  \n  \n  \n  \n  self.assertRaises(ValueError,from_dict,dict(type=\"totp\",key=KEY4))\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=0,type=\"totp\",key=KEY4))\n  self.assertRaises(ValueError,from_dict,dict(v=999,type=\"totp\",key=KEY4))\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,key=KEY4))\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4.lower(),label=\"alice@google.com\",issuer=\"Example\"))\n  self.assertEqual(otp.key,KEY4_RAW)\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\"))\n  \n  \n  self.assertRaises(Base32DecodeError,from_dict,\n  dict(v=1,type=\"totp\",key=\"JBSWY3DPEHP@3PXP\"))\n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,label=\"Alice Smith\",issuer=\"Provider1\"))\n  self.assertEqual(otp.label,\"Alice Smith\")\n  self.assertEqual(otp.issuer,\"Provider1\")\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,alg=\"sha256\"))\n  self.assertEqual(otp.alg,\"sha256\")\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,alg=\"sha333\"))\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,digits=8))\n  self.assertEqual(otp.digits,8)\n  \n  \n  self.assertRaises(TypeError,from_dict,dict(v=1,type=\"totp\",key=KEY4,digits=\"A\"))\n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,digits=15))\n  \n  \n  \n  \n  \n  \n  otp=from_dict(dict(v=1,type=\"totp\",key=KEY4,period=63))\n  self.assertEqual(otp.period,63)\n  \n  \n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,period=0))\n  self.assertRaises(ValueError,from_dict,dict(v=1,type=\"totp\",key=KEY4,period=-1))\n  \n  \n  \n  \n  self.assertRaises(TypeError,from_dict,dict(v=1,type=\"totp\",key=KEY4,INVALID=123))\n  \n def test_to_dict(self):\n  ''\n  \n  \n  \n  \n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30)\n  self.assertEqual(otp.to_dict(),dict(v=1,type=\"totp\",key=KEY4))\n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30,\n  label=\"alice@google.com\",issuer=\"Example Org\")\n  self.assertEqual(otp.to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,\n  label=\"alice@google.com\",issuer=\"Example Org\"))\n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30,\n  label=\"alice@google.com\")\n  self.assertEqual(otp.to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,\n  label=\"alice@google.com\"))\n  \n  \n  otp=TOTP(KEY4,alg=\"sha1\",digits=6,period=30,\n  issuer=\"Example Org\")\n  self.assertEqual(otp.to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,\n  issuer=\"Example Org\"))\n  \n  \n  TotpFactory=TOTP.using(issuer=\"Example Org\")\n  otp=TotpFactory(KEY4)\n  self.assertEqual(otp.to_dict(),dict(v=1,type=\"totp\",key=KEY4))\n  \n  \n  otp=TotpFactory(KEY4,issuer=\"Example Org\")\n  self.assertEqual(otp.to_dict(),dict(v=1,type=\"totp\",key=KEY4))\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,alg=\"sha256\").to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,alg=\"sha256\"))\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,digits=8).to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,digits=8))\n  \n  \n  \n  \n  self.assertEqual(TOTP(KEY4,period=63).to_dict(),\n  dict(v=1,type=\"totp\",key=KEY4,period=63))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "datetime", "functools", "logging", "passlib", "passlib.crypto.digest", "passlib.tests.utils", "passlib.totp", "passlib.utils.compat", "sys", "time"]], "passlib.Lib.site-packages.passlib.tests.test_ext_django_source": [".py", "''\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.compat import suppress_cause\nfrom passlib.ext.django.utils import DJANGO_VERSION,DjangoTranslator,_PasslibHasherWrapper\n\nfrom passlib.tests.utils import TestCase,TEST_MODE\nfrom .test_ext_django import (\nhas_min_django,stock_config,_ExtensionSupport,\n)\nif has_min_django:\n from .test_ext_django import settings\n \n__all__=[\n\"HashersTest\",\n]\n\n\n\n\n\n\n\n\n\ntest_hashers_mod=None\n\n\nhashers_skip_msg=None\n\n\n\n\n\nif TEST_MODE(max=\"quick\"):\n hashers_skip_msg=\"requires >= 'default' test mode\"\n \nelif has_min_django:\n import os\n import sys\n source_path=os.environ.get(\"PASSLIB_TESTS_DJANGO_SOURCE_PATH\")\n \n if source_path:\n  if not os.path.exists(source_path):\n   raise EnvironmentError(\"django source path not found: %r\"%source_path)\n  if not all(os.path.exists(os.path.join(source_path,name))\n  for name in [\"django\",\"tests\"]):\n   raise EnvironmentError(\"invalid django source path: %r\"%source_path)\n  log.info(\"using django tests from source path: %r\",source_path)\n  tests_path=os.path.join(source_path,\"tests\")\n  sys.path.insert(0,tests_path)\n  try :\n   from auth_tests import test_hashers as test_hashers_mod\n  except ImportError as err:\n   raise suppress_cause(\n   EnvironmentError(\"error trying to import django tests \"\n   \"from source path (%r): %r\"%\n   (source_path,err)))\n  finally :\n   sys.path.remove(tests_path)\n   \n else :\n  hashers_skip_msg=\"requires PASSLIB_TESTS_DJANGO_SOURCE_PATH to be set\"\n  \n  if TEST_MODE(\"full\"):\n  \n   sys.stderr.write(\"\\nWARNING: $PASSLIB_TESTS_DJANGO_SOURCE_PATH is not set; \"\n   \"can't run Django's own unittests against passlib.ext.django\\n\")\n   \nelif DJANGO_VERSION:\n hashers_skip_msg=\"django version too old\"\n \nelse :\n hashers_skip_msg=\"django not installed\"\n \n \n \n \n \nif test_hashers_mod:\n from django.core.signals import setting_changed\n from django.dispatch import receiver\n from django.utils.module_loading import import_string\n from passlib.utils.compat import get_unbound_method_function\n \n class HashersTest(test_hashers_mod.TestUtilsHashPass,_ExtensionSupport):\n  ''\n\n\n  \n  \n  \n  \n  \n  \n  \n  patchAttr=get_unbound_method_function(TestCase.patchAttr)\n  \n  \n  \n  \n  def setUp(self):\n  \n  \n  \n   self.load_extension(PASSLIB_CONTEXT=stock_config,check=False )\n   from passlib.ext.django.models import adapter\n   context=adapter.context\n   \n   \n   \n   \n   \n   from django.contrib.auth import hashers\n   for attr in [\"make_password\",\n   \"check_password\",\n   \"identify_hasher\",\n   \"is_password_usable\",\n   \"get_hasher\"]:\n    self.patchAttr(test_hashers_mod,attr,getattr(hashers,attr))\n    \n    \n    \n    \n   from passlib.hash import django_des_crypt\n   self.patchAttr(django_des_crypt,\"use_duplicate_salt\",False )\n   \n   \n   \n   \n   django_to_passlib_name=DjangoTranslator().django_to_passlib_name\n   \n   @receiver(setting_changed,weak=False )\n   def update_schemes(**kwds):\n    if kwds and kwds['setting']!='PASSWORD_HASHERS':\n     return\n    assert context is adapter.context\n    schemes=[\n    django_to_passlib_name(import_string(hash_path)())\n    for hash_path in settings.PASSWORD_HASHERS\n    ]\n    \n    \n    if \"hex_md5\"in schemes and \"django_salted_md5\"not in schemes:\n     schemes.append(\"django_salted_md5\")\n    schemes.append(\"django_disabled\")\n    context.update(schemes=schemes,deprecated=\"auto\")\n    adapter.reset_hashers()\n    \n   self.addCleanup(setting_changed.disconnect,update_schemes)\n   \n   update_schemes()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   def update_rounds():\n    ''\n\n    \n    for handler in context.schemes(resolve=True ):\n     if 'rounds'not in handler.setting_kwds:\n      continue\n     hasher=adapter.passlib_to_django(handler)\n     if isinstance(hasher,_PasslibHasherWrapper):\n      continue\n     rounds=getattr(hasher,\"rounds\",None )or\\\n     getattr(hasher,\"iterations\",None )\n     if rounds is None :\n      continue\n      \n      \n      \n     handler.min_desired_rounds=handler.max_desired_rounds=handler.default_rounds=rounds\n     \n   _in_update=[False ]\n   \n   def update_wrapper(wrapped,*args,**kwds):\n    ''\n\n    \n    if not _in_update[0]:\n     _in_update[0]=True\n     try :\n      update_rounds()\n     finally :\n      _in_update[0]=False\n    return wrapped(*args,**kwds)\n    \n    \n   for attr in [\"schemes\",\"handler\",\"default_scheme\",\"hash\",\n   \"verify\",\"needs_update\",\"verify_and_update\"]:\n    self.patchAttr(context,attr,update_wrapper,wrap=True )\n    \n    \n   self.patchAttr(adapter,\"django_to_passlib\",update_wrapper,wrap=True )\n   \n  def tearDown(self):\n  \n   self.unload_extension()\n   super(HashersTest,self).tearDown()\n   \n   \n   \n   \n   \n   \n  _OMIT=lambda self:self.skipTest(\"omitted by passlib\")\n  \n  \n  \n  \n  test_pbkdf2_upgrade_new_hasher=_OMIT\n  \n  \n  \n  test_check_password_calls_harden_runtime=_OMIT\n  test_bcrypt_harden_runtime=_OMIT\n  test_pbkdf2_harden_runtime=_OMIT\n  \n  \n  \n  \n  \nelse :\n\n\n class HashersTest(TestCase):\n \n  def test_external_django_hasher_tests(self):\n   ''\n   raise self.skipTest(hashers_skip_msg)\n   \n   \n   \n   \n", ["__future__", "auth_tests", "django.contrib.auth", "django.core.signals", "django.dispatch", "django.utils.module_loading", "logging", "os", "passlib.Lib.site-packages.passlib.tests.test_ext_django", "passlib.ext.django.models", "passlib.ext.django.utils", "passlib.hash", "passlib.tests.utils", "passlib.utils.compat", "sys"]], "passlib.Lib.site-packages.passlib.tests.test_apps": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib import apps,hash as hashmod\nfrom passlib.tests.utils import TestCase\n\n\n\n\n\nclass AppsTest(TestCase):\n ''\n \n \n \n \n \n \n \n def test_master_context(self):\n  ctx=apps.master_context\n  self.assertGreater(len(ctx.schemes()),50)\n  \n def test_custom_app_context(self):\n  ctx=apps.custom_app_context\n  self.assertEqual(ctx.schemes(),(\"sha512_crypt\",\"sha256_crypt\"))\n  for hash in [\n  ('$6$rounds=41128$VoQLvDjkaZ6L6BIE$4pt.1Ll1XdDYduEwEYPCMOBiR6W6'\n  'znsyUEoNlcVXpv2gKKIbQolgmTGe6uEEVJ7azUxuc8Tf7zV9SD2z7Ij751'),\n  ('$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0itGny'\n  'xDGgMlDcOsfaI17'),\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n def test_django16_context(self):\n  ctx=apps.django16_context\n  for hash in [\n  'pbkdf2_sha256$29000$ZsgquwnCyBs2$fBxRQpfKd2PIeMxtkKPy0h7SrnrN+EU/cm67aitoZ2s=',\n  'sha1$0d082$cdb462ae8b6be8784ef24b20778c4d0c82d5957f',\n  'md5$b887a$37767f8a745af10612ad44c80ff52e92',\n  'crypt$95a6d$95x74hLDQKXI2',\n  '098f6bcd4621d373cade4e832627b4f6',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  self.assertEqual(ctx.identify(\"!\"),\"django_disabled\")\n  self.assertFalse(ctx.verify(\"test\",\"!\"))\n  \n def test_django_context(self):\n  ctx=apps.django_context\n  for hash in [\n  'pbkdf2_sha256$29000$ZsgquwnCyBs2$fBxRQpfKd2PIeMxtkKPy0h7SrnrN+EU/cm67aitoZ2s=',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  self.assertEqual(ctx.identify(\"!\"),\"django_disabled\")\n  self.assertFalse(ctx.verify(\"test\",\"!\"))\n  \n def test_ldap_nocrypt_context(self):\n  ctx=apps.ldap_nocrypt_context\n  for hash in [\n  '{SSHA}cPusOzd6d5n3OjSVK3R329ZGCNyFcC7F',\n  'test',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  self.assertIs(ctx.identify('{CRYPT}$5$rounds=31817$iZGmlyBQ99JSB5'\n  'n6$p4E.pdPBWx19OajgjLRiOW0itGnyxDGgMlDcOsfaI17'),None )\n  \n def test_ldap_context(self):\n  ctx=apps.ldap_context\n  for hash in [\n  ('{CRYPT}$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0'\n  'itGnyxDGgMlDcOsfaI17'),\n  '{SSHA}cPusOzd6d5n3OjSVK3R329ZGCNyFcC7F',\n  'test',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n def test_ldap_mysql_context(self):\n  ctx=apps.mysql_context\n  for hash in [\n  '*94BDCEBE19083CE2A1F959FD02F964C7AF4CFC29',\n  '378b243e220ca493',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n def test_postgres_context(self):\n  ctx=apps.postgres_context\n  hash='md55d9c68c6c50ed3d02a2fcf54f63993b6'\n  self.assertTrue(ctx.verify(\"test\",hash,user='user'))\n  \n def test_phppass_context(self):\n  ctx=apps.phpass_context\n  for hash in [\n  '$P$8Ja1vJsKa5qyy/b3mCJGXM7GyBnt6..',\n  '$H$8b95CoYQnQ9Y6fSTsACyphNh5yoM02.',\n  '_cD..aBxeRhYFJvtUvsI',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n  h1=\"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n  if hashmod.bcrypt.has_backend():\n   self.assertTrue(ctx.verify(\"test\",h1))\n   self.assertEqual(ctx.default_scheme(),\"bcrypt\")\n   self.assertEqual(ctx.handler().name,\"bcrypt\")\n  else :\n   self.assertEqual(ctx.identify(h1),\"bcrypt\")\n   self.assertEqual(ctx.default_scheme(),\"phpass\")\n   self.assertEqual(ctx.handler().name,\"phpass\")\n   \n def test_phpbb3_context(self):\n  ctx=apps.phpbb3_context\n  for hash in [\n  '$P$8Ja1vJsKa5qyy/b3mCJGXM7GyBnt6..',\n  '$H$8b95CoYQnQ9Y6fSTsACyphNh5yoM02.',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n  self.assertTrue(ctx.hash(\"test\").startswith(\"$H$\"))\n  \n def test_roundup_context(self):\n  ctx=apps.roundup_context\n  for hash in [\n  '{PBKDF2}9849$JMTYu3eOUSoFYExprVVqbQ$N5.gV.uR1.BTgLSvi0qyPiRlGZ0',\n  '{SHA}a94a8fe5ccb19ba61c4c0873d391e987982fbbd3',\n  '{CRYPT}dptOmKDriOGfU',\n  '{plaintext}test',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n   \n   \n   \n   \n", ["__future__", "logging", "passlib", "passlib.tests.utils"]], "passlib.Lib.site-packages.passlib.tests.test_handlers_argon2": [".py", "''\n\n\n\n\nimport logging\nlog=logging.getLogger(__name__)\nimport re\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.utils.compat import unicode\nfrom passlib.tests.utils import HandlerCase,TEST_MODE\nfrom passlib.tests.test_handlers import UPASS_TABLE,PASS_TABLE_UTF8\n\n\n\n\n\n\ndef hashtest(version,t,logM,p,secret,salt,hex_digest,hash):\n return dict(version=version,rounds=t,logM=logM,memory_cost=1 <<logM,parallelism=p,\n secret=secret,salt=salt,hex_digest=hex_digest,hash=hash)\n \n \nversion=0x10\nreference_data=[\nhashtest(version,2,16,1,\"password\",\"somesalt\",\n\"f6c4db4a54e2a370627aff3db6176b94a2a209a62c8e36152711802f7b30c694\",\n\"$argon2i$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$9sTbSlTio3Biev89thdrlKKiCaYsjjYVJxGAL3swxpQ\"),\nhashtest(version,2,20,1,\"password\",\"somesalt\",\n\"9690ec55d28d3ed32562f2e73ea62b02b018757643a2ae6e79528459de8106e9\",\n\"$argon2i$m=1048576,t=2,p=1$c29tZXNhbHQ\"\n\"$lpDsVdKNPtMlYvLnPqYrArAYdXZDoq5ueVKEWd6BBuk\"),\nhashtest(version,2,18,1,\"password\",\"somesalt\",\n\"3e689aaa3d28a77cf2bc72a51ac53166761751182f1ee292e3f677a7da4c2467\",\n\"$argon2i$m=262144,t=2,p=1$c29tZXNhbHQ\"\n\"$Pmiaqj0op3zyvHKlGsUxZnYXURgvHuKS4/Z3p9pMJGc\"),\nhashtest(version,2,8,1,\"password\",\"somesalt\",\n\"fd4dd83d762c49bdeaf57c47bdcd0c2f1babf863fdeb490df63ede9975fccf06\",\n\"$argon2i$m=256,t=2,p=1$c29tZXNhbHQ\"\n\"$/U3YPXYsSb3q9XxHvc0MLxur+GP960kN9j7emXX8zwY\"),\nhashtest(version,2,8,2,\"password\",\"somesalt\",\n\"b6c11560a6a9d61eac706b79a2f97d68b4463aa3ad87e00c07e2b01e90c564fb\",\n\"$argon2i$m=256,t=2,p=2$c29tZXNhbHQ\"\n\"$tsEVYKap1h6scGt5ovl9aLRGOqOth+AMB+KwHpDFZPs\"),\nhashtest(version,1,16,1,\"password\",\"somesalt\",\n\"81630552b8f3b1f48cdb1992c4c678643d490b2b5eb4ff6c4b3438b5621724b2\",\n\"$argon2i$m=65536,t=1,p=1$c29tZXNhbHQ\"\n\"$gWMFUrjzsfSM2xmSxMZ4ZD1JCytetP9sSzQ4tWIXJLI\"),\nhashtest(version,4,16,1,\"password\",\"somesalt\",\n\"f212f01615e6eb5d74734dc3ef40ade2d51d052468d8c69440a3a1f2c1c2847b\",\n\"$argon2i$m=65536,t=4,p=1$c29tZXNhbHQ\"\n\"$8hLwFhXm6110c03D70Ct4tUdBSRo2MaUQKOh8sHChHs\"),\nhashtest(version,2,16,1,\"differentpassword\",\"somesalt\",\n\"e9c902074b6754531a3a0be519e5baf404b30ce69b3f01ac3bf21229960109a3\",\n\"$argon2i$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$6ckCB0tnVFMaOgvlGeW69ASzDOabPwGsO/ISKZYBCaM\"),\nhashtest(version,2,16,1,\"password\",\"diffsalt\",\n\"79a103b90fe8aef8570cb31fc8b22259778916f8336b7bdac3892569d4f1c497\",\n\"$argon2i$m=65536,t=2,p=1$ZGlmZnNhbHQ\"\n\"$eaEDuQ/orvhXDLMfyLIiWXeJFvgza3vaw4kladTxxJc\"),\n]\n\n\nversion=0x13\nreference_data.extend([\nhashtest(version,2,16,1,\"password\",\"somesalt\",\n\"c1628832147d9720c5bd1cfd61367078729f6dfb6f8fea9ff98158e0d7816ed0\",\n\"$argon2i$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$wWKIMhR9lyDFvRz9YTZweHKfbftvj+qf+YFY4NeBbtA\"),\nhashtest(version,2,20,1,\"password\",\"somesalt\",\n\"d1587aca0922c3b5d6a83edab31bee3c4ebaef342ed6127a55d19b2351ad1f41\",\n\"$argon2i$v=19$m=1048576,t=2,p=1$c29tZXNhbHQ\"\n\"$0Vh6ygkiw7XWqD7asxvuPE667zQu1hJ6VdGbI1GtH0E\"),\nhashtest(version,2,18,1,\"password\",\"somesalt\",\n\"296dbae80b807cdceaad44ae741b506f14db0959267b183b118f9b24229bc7cb\",\n\"$argon2i$v=19$m=262144,t=2,p=1$c29tZXNhbHQ\"\n\"$KW266AuAfNzqrUSudBtQbxTbCVkmexg7EY+bJCKbx8s\"),\nhashtest(version,2,8,1,\"password\",\"somesalt\",\n\"89e9029f4637b295beb027056a7336c414fadd43f6b208645281cb214a56452f\",\n\"$argon2i$v=19$m=256,t=2,p=1$c29tZXNhbHQ\"\n\"$iekCn0Y3spW+sCcFanM2xBT63UP2sghkUoHLIUpWRS8\"),\nhashtest(version,2,8,2,\"password\",\"somesalt\",\n\"4ff5ce2769a1d7f4c8a491df09d41a9fbe90e5eb02155a13e4c01e20cd4eab61\",\n\"$argon2i$v=19$m=256,t=2,p=2$c29tZXNhbHQ\"\n\"$T/XOJ2mh1/TIpJHfCdQan76Q5esCFVoT5MAeIM1Oq2E\"),\nhashtest(version,1,16,1,\"password\",\"somesalt\",\n\"d168075c4d985e13ebeae560cf8b94c3b5d8a16c51916b6f4ac2da3ac11bbecf\",\n\"$argon2i$v=19$m=65536,t=1,p=1$c29tZXNhbHQ\"\n\"$0WgHXE2YXhPr6uVgz4uUw7XYoWxRkWtvSsLaOsEbvs8\"),\nhashtest(version,4,16,1,\"password\",\"somesalt\",\n\"aaa953d58af3706ce3df1aefd4a64a84e31d7f54175231f1285259f88174ce5b\",\n\"$argon2i$v=19$m=65536,t=4,p=1$c29tZXNhbHQ\"\n\"$qqlT1YrzcGzj3xrv1KZKhOMdf1QXUjHxKFJZ+IF0zls\"),\nhashtest(version,2,16,1,\"differentpassword\",\"somesalt\",\n\"14ae8da01afea8700c2358dcef7c5358d9021282bd88663a4562f59fb74d22ee\",\n\"$argon2i$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$FK6NoBr+qHAMI1jc73xTWNkCEoK9iGY6RWL1n7dNIu4\"),\nhashtest(version,2,16,1,\"password\",\"diffsalt\",\n\"b0357cccfbef91f3860b0dba447b2348cbefecadaf990abfe9cc40726c521271\",\n\"$argon2i$v=19$m=65536,t=2,p=1$ZGlmZnNhbHQ\"\n\"$sDV8zPvvkfOGCw26RHsjSMvv7K2vmQq/6cxAcmxSEnE\"),\n])\n\n\nversion=0x13\nreference_data.extend([\nhashtest(version,2,16,1,\"password\",\"somesalt\",\n\"09316115d5cf24ed5a15a31a3ba326e5cf32edc24702987c02b6566f61913cf7\",\n\"$argon2id$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$CTFhFdXPJO1aFaMaO6Mm5c8y7cJHAph8ArZWb2GRPPc\"),\nhashtest(version,2,18,1,\"password\",\"somesalt\",\n\"78fe1ec91fb3aa5657d72e710854e4c3d9b9198c742f9616c2f085bed95b2e8c\",\n\"$argon2id$v=19$m=262144,t=2,p=1$c29tZXNhbHQ\"\n\"$eP4eyR+zqlZX1y5xCFTkw9m5GYx0L5YWwvCFvtlbLow\"),\nhashtest(version,2,8,1,\"password\",\"somesalt\",\n\"9dfeb910e80bad0311fee20f9c0e2b12c17987b4cac90c2ef54d5b3021c68bfe\",\n\"$argon2id$v=19$m=256,t=2,p=1$c29tZXNhbHQ\"\n\"$nf65EOgLrQMR/uIPnA4rEsF5h7TKyQwu9U1bMCHGi/4\"),\nhashtest(version,2,8,2,\"password\",\"somesalt\",\n\"6d093c501fd5999645e0ea3bf620d7b8be7fd2db59c20d9fff9539da2bf57037\",\n\"$argon2id$v=19$m=256,t=2,p=2$c29tZXNhbHQ\"\n\"$bQk8UB/VmZZF4Oo79iDXuL5/0ttZwg2f/5U52iv1cDc\"),\nhashtest(version,1,16,1,\"password\",\"somesalt\",\n\"f6a5adc1ba723dddef9b5ac1d464e180fcd9dffc9d1cbf76cca2fed795d9ca98\",\n\"$argon2id$v=19$m=65536,t=1,p=1$c29tZXNhbHQ\"\n\"$9qWtwbpyPd3vm1rB1GThgPzZ3/ydHL92zKL+15XZypg\"),\nhashtest(version,4,16,1,\"password\",\"somesalt\",\n\"9025d48e68ef7395cca9079da4c4ec3affb3c8911fe4f86d1a2520856f63172c\",\n\"$argon2id$v=19$m=65536,t=4,p=1$c29tZXNhbHQ\"\n\"$kCXUjmjvc5XMqQedpMTsOv+zyJEf5PhtGiUghW9jFyw\"),\nhashtest(version,2,16,1,\"differentpassword\",\"somesalt\",\n\"0b84d652cf6b0c4beaef0dfe278ba6a80df6696281d7e0d2891b817d8c458fde\",\n\"$argon2id$v=19$m=65536,t=2,p=1$c29tZXNhbHQ\"\n\"$C4TWUs9rDEvq7w3+J4umqA32aWKB1+DSiRuBfYxFj94\"),\nhashtest(version,2,16,1,\"password\",\"diffsalt\",\n\"bdf32b05ccc42eb15d58fd19b1f856b113da1e9a5874fdcc544308565aa8141c\",\n\"$argon2id$v=19$m=65536,t=2,p=1$ZGlmZnNhbHQ\"\n\"$vfMrBczELrFdWP0ZsfhWsRPaHppYdP3MVEMIVlqoFBw\"),\n])\n\n\n\n\nclass _base_argon2_test(HandlerCase):\n handler=hash.argon2\n \n known_correct_hashes=[\n \n \n \n \n \n (\"password\",'$argon2i$v=19$m=256,t=1,p=1$c29tZXNhbHQ$AJFIsNZTMKTAewB4+ETN1A'),\n \n \n (\"password\",'$argon2i$v=19$m=380,t=2,p=2$c29tZXNhbHQ$SrssP8n7m/12VWPM8dvNrw'),\n \n \n (UPASS_TABLE,'$argon2i$v=19$m=512,t=2,p=2$1sV0O4PWLtc12Ypv1f7oGw$'\n 'z+yqzlKtrq3SaNfXDfIDnQ'),\n (PASS_TABLE_UTF8,'$argon2i$v=19$m=512,t=2,p=2$1sV0O4PWLtc12Ypv1f7oGw$'\n 'z+yqzlKtrq3SaNfXDfIDnQ'),\n \n \n ('password\\x00','$argon2i$v=19$m=512,t=2,p=2$c29tZXNhbHQ$Fb5+nPuLzZvtqKRwqUEtUQ'),\n \n \n (\"password\",'$argon2d$v=19$m=102400,t=2,p=8$g2RodLh8j8WbSdCp+lUy/A$zzAJqL/HSjm809PYQu6qkA'),\n \n ]\n \n known_malformed_hashes=[\n \n \"$argon2qq$v=19$t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$m=65536,t=8589934592,p=4$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$m=65536,t=2,p=4,q=5$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$t=2,m=65536,p=4,q=5$c29tZXNhbHQAAAAAAAAAAA$QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\",\n \n \n \"$argon2i$v=19$m=127,t=2,p=16$c29tZXNhbHQ$IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\",\n ]\n \n known_parsehash_results=[\n ('$argon2i$v=19$m=256,t=2,p=3$c29tZXNhbHQ$AJFIsNZTMKTAewB4+ETN1A',\n dict(type=\"i\",memory_cost=256,rounds=2,parallelism=3,salt=b'somesalt',\n checksum=b'\\x00\\x91H\\xb0\\xd6S0\\xa4\\xc0{\\x00x\\xf8D\\xcd\\xd4')),\n ]\n \n def setUpWarnings(self):\n  super(_base_argon2_test,self).setUpWarnings()\n  warnings.filterwarnings(\"ignore\",\".*Using argon2pure backend.*\")\n  \n def do_stub_encrypt(self,handler=None ,**settings):\n  if self.backend ==\"argon2_cffi\":\n  \n  \n   handler=(handler or self.handler).using(**settings)\n   self=handler(use_defaults=True )\n   self.checksum=self._stub_checksum\n   assert self.checksum\n   return self.to_string()\n  else :\n   return super(_base_argon2_test,self).do_stub_encrypt(handler,**settings)\n   \n def test_03_legacy_hash_workflow(self):\n \n  raise self.skipTest(\"legacy 1.6 workflow not supported\")\n  \n def test_keyid_parameter(self):\n \n \n \n \n  self.assertRaises(NotImplementedError,self.handler.verify,'password',\n  \"$argon2i$v=19$m=65536,t=2,p=4,keyid=ABCD$c29tZXNhbHQ$\"\n  \"IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\")\n  \n def test_data_parameter(self):\n \n \n \n \n  handler=self.handler\n  \n  \n  sample1='$argon2i$v=19$m=512,t=2,p=2,data=c29tZWRhdGE$c29tZXNhbHQ$KgHyCesFyyjkVkihZ5VNFw'\n  \n  \n  sample2='$argon2i$v=19$m=512,t=2,p=2,data=c29tZWRhdGE$c29tZXNhbHQ$uEeXt1dxN1iFKGhklseW4w'\n  \n  \n  sample3='$argon2i$v=19$m=512,t=2,p=2$c29tZXNhbHQ$uEeXt1dxN1iFKGhklseW4w'\n  \n  \n  \n  \n  \n  if self.backend ==\"argon2_cffi\":\n  \n  \n  \n   self.assertRaises(NotImplementedError,handler.verify,\"password\",sample1)\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample1),sample3)\n   \n  else :\n   assert self.backend ==\"argon2pure\"\n   \n   self.assertTrue(handler.verify(\"password\",sample1))\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample1),sample1)\n   \n   \n   \n   \n   \n  if self.backend ==\"argon2_cffi\":\n  \n  \n  \n   self.assertRaises(NotImplementedError,handler.verify,\"password\",sample2)\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample1),sample3)\n   \n  else :\n   assert self.backend ==\"argon2pure\"\n   \n   self.assertFalse(self.handler.verify(\"password\",sample2))\n   \n   \n   self.assertEqual(handler.genhash(\"password\",sample2),sample1)\n   \n def test_keyid_and_data_parameters(self):\n \n  self.assertRaises(NotImplementedError,self.handler.verify,'stub',\n  \"$argon2i$v=19$m=65536,t=2,p=4,keyid=ABCD,data=EFGH$c29tZXNhbHQ$\"\n  \"IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\")\n  \n def test_type_kwd(self):\n  cls=self.handler\n  \n  \n  \n  \n  \n  self.assertTrue(\"type\"in cls.setting_kwds)\n  \n  \n  for value in cls.type_values:\n   self.assertIsInstance(value,unicode)\n  self.assertTrue(\"i\"in cls.type_values)\n  self.assertTrue(\"d\"in cls.type_values)\n  \n  \n  self.assertTrue(cls.type in cls.type_values)\n  \n  \n  handler=cls\n  hash=self.get_sample_hash()[1]\n  kwds=handler.parsehash(hash)\n  del kwds['type']\n  \n  \n  handler(type=cls.type,**kwds)\n  \n  \n  \n  \n  handler(**kwds)\n  \n  \n  handler(use_defaults=True ,**kwds)\n  \n  \n  self.assertRaises(ValueError,handler,type='xXx',**kwds)\n  \n def test_type_using(self):\n  handler=self.handler\n  \n  \n  \n  \n  orig_type=handler.type\n  for alt_type in handler.type_values:\n   if alt_type !=orig_type:\n    break\n  else :\n   raise AssertionError(\"expected to find alternate type: default=%r values=%r\"%\n   (orig_type,handler.type_values))\n   \n  def effective_type(cls):\n   return cls(use_defaults=True ).type\n   \n   \n  subcls=handler.using()\n  self.assertEqual(subcls.type,orig_type)\n  \n  \n  subcls=handler.using(type=alt_type)\n  self.assertEqual(subcls.type,alt_type)\n  self.assertEqual(handler.type,orig_type)\n  \n  \n  \n  self.assertEqual(effective_type(subcls),alt_type)\n  self.assertEqual(effective_type(handler),orig_type)\n  \n  \n  self.assertRaises(ValueError,handler.using,type='xXx')\n  \n  \n  subcls=handler.using(type=alt_type)\n  self.assertEqual(subcls.type,alt_type)\n  self.assertEqual(handler.type,orig_type)\n  \n  \n  self.assertEqual(effective_type(handler.using(type=\"I\")),\"i\")\n  \n def test_needs_update_w_type(self):\n  handler=self.handler\n  \n  hash=handler.hash(\"stub\")\n  self.assertFalse(handler.needs_update(hash))\n  \n  hash2=re.sub(r\"\\$argon2\\w+\\$\",\"$argon2d$\",hash)\n  self.assertTrue(handler.needs_update(hash2))\n  \n def test_needs_update_w_version(self):\n  handler=self.handler.using(memory_cost=65536,time_cost=2,parallelism=4,\n  digest_size=32)\n  hash=(\"$argon2i$m=65536,t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$\"\n  \"QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\")\n  if handler.max_version ==0x10:\n   self.assertFalse(handler.needs_update(hash))\n  else :\n   self.assertTrue(handler.needs_update(hash))\n   \n def test_argon_byte_encoding(self):\n  ''\n  handler=self.handler\n  if handler.version !=0x13:\n  \n   raise self.skipTest(\"handler uses wrong version for sample hashes\")\n   \n   \n  salt=b'somesalt'\n  temp=handler.using(memory_cost=256,time_cost=2,parallelism=2,salt=salt,\n  checksum_size=32,type=\"i\")\n  hash=temp.hash(\"password\")\n  self.assertEqual(hash,\"$argon2i$v=19$m=256,t=2,p=2\"\n  \"$c29tZXNhbHQ\"\n  \"$T/XOJ2mh1/TIpJHfCdQan76Q5esCFVoT5MAeIM1Oq2E\")\n  \n  \n  salt=b'somesalt\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n  temp=handler.using(memory_cost=256,time_cost=2,parallelism=2,salt=salt,\n  checksum_size=32,type=\"i\")\n  hash=temp.hash(\"password\")\n  self.assertEqual(hash,\"$argon2i$v=19$m=256,t=2,p=2\"\n  \"$c29tZXNhbHQAAAAAAAAAAA\"\n  \"$rqnbEp1/jFDUEKZZmw+z14amDsFqMDC53dIe57ZHD38\")\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  settings_map=HandlerCase.FuzzHashGenerator.settings_map.copy()\n  settings_map.update(memory_cost=\"random_memory_cost\",type=\"random_type\")\n  \n  def random_type(self):\n   return self.rng.choice(self.handler.type_values)\n   \n  def random_memory_cost(self):\n   if self.test.backend ==\"argon2pure\":\n    return self.randintgauss(128,384,256,128)\n   else :\n    return self.randintgauss(128,32767,16384,4096)\n    \n    \n    \n    \n    \n    \n    \nclass argon2_argon2_cffi_test(_base_argon2_test.create_backend_case(\"argon2_cffi\")):\n\n\n known_correct_hashes=_base_argon2_test.known_correct_hashes+[\n \n \n \n \n \n \n ('password',\"$argon2i$m=65536,t=2,p=4$c29tZXNhbHQAAAAAAAAAAA$\"\n \"QWLzI4TY9HkL2ZTLc8g6SinwdhZewYrzz9zxCo0bkGY\"),\n \n \n ('password',\"$argon2i$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"IMit9qkFULCMA/ViizL57cnTLOa5DiVM9eMwpAvPwr4\"),\n \n \n ('password',\"$argon2d$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"cZn5d+rFh+ZfuRhm2iGUGgcrW5YLeM6q7L3vBsdmFA0\"),\n \n \n ('password',\"$argon2id$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"GpZ3sK/oH9p7VIiV56G/64Zo/8GaUw434IimaPqxwCo\"),\n \n \n \n \n \n \n ('password\\x00',\"$argon2i$v=19$m=65536,t=2,p=4$c29tZXNhbHQ$\"\n \"Vpzuc0v0SrP88LcVvmg+z5RoOYpMDKH/lt6O+CZabIQ\"),\n \n ]\n \n \n known_correct_hashes.extend(\n (info['secret'],info['hash'])for info in reference_data\n if info['logM']<=(18 if TEST_MODE(\"full\")else 16)\n )\n \nclass argon2_argon2pure_test(_base_argon2_test.create_backend_case(\"argon2pure\")):\n\n\n\n\n handler=hash.argon2.using(memory_cost=32,parallelism=2)\n \n \n \n handler.pure_use_threads=True\n \n \n known_correct_hashes=_base_argon2_test.known_correct_hashes[:]\n \n known_correct_hashes.extend(\n (info['secret'],info['hash'])for info in reference_data\n if info['logM']<16\n )\n \n class FuzzHashGenerator(_base_argon2_test.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(1,3,2,1)\n   \n   \n   \n   \n", ["logging", "passlib", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.compat", "re", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_handlers_scrypt": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nimport warnings\nwarnings.filterwarnings(\"ignore\",\".*using builtin scrypt backend.*\")\n\n\nfrom passlib import hash\nfrom passlib.tests.utils import HandlerCase,TEST_MODE\nfrom passlib.tests.test_handlers import UPASS_TABLE,PASS_TABLE_UTF8\n\n\n\n\n\nclass _scrypt_test(HandlerCase):\n handler=hash.scrypt\n \n known_correct_hashes=[\n \n \n \n \n \n \n \n (\"\",\"$scrypt$ln=4,r=1,p=1$$d9ZXYjhleyA7GcpCwYoEl/FrSETjB0ro39/6P+3iFEI\"),\n \n \n (\"password\",\"$scrypt$ln=10,r=8,p=16$TmFDbA$/bq+HJ00cgB4VucZDQHp/nxq18vII3gw53N2Y0s3MWI\"),\n \n \n \n \n \n \n (\"test\",'$scrypt$ln=8,r=8,p=1$wlhLyXmP8b53bm1NKYVQqg$mTpvG8lzuuDk+DWz8HZIB6Vum6erDuUm0As5yU+VxWA'),\n \n \n (\"password\",'$scrypt$ln=8,r=2,p=1$dO6d0xoDoLT2PofQGoNQag$g/Wf2A0vhHhaJM+addK61QPBthSmYB6uVTtQzh8CM3o'),\n \n \n (UPASS_TABLE,'$scrypt$ln=7,r=8,p=1$jjGmtDamdA4BQAjBeA9BSA$OiWRHhQtpDx7M/793x6UXK14AD512jg/qNm/hkWZG4M'),\n \n \n (PASS_TABLE_UTF8,'$scrypt$ln=7,r=8,p=1$jjGmtDamdA4BQAjBeA9BSA$OiWRHhQtpDx7M/793x6UXK14AD512jg/qNm/hkWZG4M'),\n \n \n (\"nacl\",'$scrypt$ln=1,r=4,p=2$yhnD+J+Tci4lZCwFgHCuVQ$fAsEWmxSHuC0cHKMwKVFPzrQukgvK09Sj+NueTSxKds')\n ]\n \n if TEST_MODE(\"full\"):\n \n  known_correct_hashes.extend([\n  \n  \n  \n  \n  \n  (\"pleaseletmein\",\"$scrypt$ln=14,r=8,p=1$U29kaXVtQ2hsb3JpZGU\"\n  \"$cCO9yzr9c0hGHAbNgf046/2o+7qQT44+qbVD9lRdofI\"),\n  \n  \n  \n  \n  (\"pleaseletmein\",\n  \"$7$C6..../....SodiumChloride$kBGj9fHznVYFQMEn/qDCfrDevf9YDtcDdKvEqHJLV8D\"),\n  \n  ])\n  \n known_malformed_hashes=[\n \n '$scrypt$ln=10,r=1$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n \n \n '$scrypt$ln=0,r=1,p=1$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n \n \n '$scrypt$ln=10,r=A,p=1$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n \n \n '$scrypt$ln=10,r=134217728,p=8$wvif8/4fg1Cq9V7L2dv73w$bJcLia1lyfQ1X2x0xflehwVXPzWIUQWWdnlGwfVzBeQ',\n ]\n \n def setUpWarnings(self):\n  super(_scrypt_test,self).setUpWarnings()\n  warnings.filterwarnings(\"ignore\",\".*using builtin scrypt backend.*\")\n  \n def populate_settings(self,kwds):\n \n  if self.backend ==\"builtin\":\n   kwds.setdefault(\"rounds\",6)\n  super(_scrypt_test,self).populate_settings(kwds)\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(4,10,6,1)\n   \n   \nscrypt_stdlib_test=_scrypt_test.create_backend_case(\"stdlib\")\nscrypt_scrypt_test=_scrypt_test.create_backend_case(\"scrypt\")\nscrypt_builtin_test=_scrypt_test.create_backend_case(\"builtin\")\n\n\n\n\n", ["logging", "passlib", "passlib.tests.test_handlers", "passlib.tests.utils", "warnings"]], "passlib.Lib.site-packages.passlib.tests": [".py", "''\n", [], 1], "passlib.Lib.site-packages.passlib.tests.test_crypto_des": [".py", "''\n\n\n\nfrom __future__ import with_statement,division\n\nfrom functools import partial\n\n\n\nfrom passlib.utils import getrandbytes\nfrom passlib.tests.utils import TestCase\n\n\n\n\nclass DesTest(TestCase):\n descriptionPrefix=\"passlib.crypto.des\"\n \n \n des_test_vectors=[\n \n (0x0000000000000000,0x0000000000000000,0x8CA64DE9C1B123A7),\n (0xFFFFFFFFFFFFFFFF,0xFFFFFFFFFFFFFFFF,0x7359B2163E4EDC58),\n (0x3000000000000000,0x1000000000000001,0x958E6E627A05557B),\n (0x1111111111111111,0x1111111111111111,0xF40379AB9E0EC533),\n (0x0123456789ABCDEF,0x1111111111111111,0x17668DFC7292532D),\n (0x1111111111111111,0x0123456789ABCDEF,0x8A5AE1F81AB8F2DD),\n (0x0000000000000000,0x0000000000000000,0x8CA64DE9C1B123A7),\n (0xFEDCBA9876543210,0x0123456789ABCDEF,0xED39D950FA74BCC4),\n (0x7CA110454A1A6E57,0x01A1D6D039776742,0x690F5B0D9A26939B),\n (0x0131D9619DC1376E,0x5CD54CA83DEF57DA,0x7A389D10354BD271),\n (0x07A1133E4A0B2686,0x0248D43806F67172,0x868EBB51CAB4599A),\n (0x3849674C2602319E,0x51454B582DDF440A,0x7178876E01F19B2A),\n (0x04B915BA43FEB5B6,0x42FD443059577FA2,0xAF37FB421F8C4095),\n (0x0113B970FD34F2CE,0x059B5E0851CF143A,0x86A560F10EC6D85B),\n (0x0170F175468FB5E6,0x0756D8E0774761D2,0x0CD3DA020021DC09),\n (0x43297FAD38E373FE,0x762514B829BF486A,0xEA676B2CB7DB2B7A),\n (0x07A7137045DA2A16,0x3BDD119049372802,0xDFD64A815CAF1A0F),\n (0x04689104C2FD3B2F,0x26955F6835AF609A,0x5C513C9C4886C088),\n (0x37D06BB516CB7546,0x164D5E404F275232,0x0A2AEEAE3FF4AB77),\n (0x1F08260D1AC2465E,0x6B056E18759F5CCA,0xEF1BF03E5DFA575A),\n (0x584023641ABA6176,0x004BD6EF09176062,0x88BF0DB6D70DEE56),\n (0x025816164629B007,0x480D39006EE762F2,0xA1F9915541020B56),\n (0x49793EBC79B3258F,0x437540C8698F3CFA,0x6FBF1CAFCFFD0556),\n (0x4FB05E1515AB73A7,0x072D43A077075292,0x2F22E49BAB7CA1AC),\n (0x49E95D6D4CA229BF,0x02FE55778117F12A,0x5A6B612CC26CCE4A),\n (0x018310DC409B26D6,0x1D9D5C5018F728C2,0x5F4C038ED12B2E41),\n (0x1C587F1C13924FEF,0x305532286D6F295A,0x63FAC0D034D9F793),\n (0x0101010101010101,0x0123456789ABCDEF,0x617B3A0CE8F07100),\n (0x1F1F1F1F0E0E0E0E,0x0123456789ABCDEF,0xDB958605F8C8C606),\n (0xE0FEE0FEF1FEF1FE,0x0123456789ABCDEF,0xEDBFD1C66C29CCC7),\n (0x0000000000000000,0xFFFFFFFFFFFFFFFF,0x355550B2150E2451),\n (0xFFFFFFFFFFFFFFFF,0x0000000000000000,0xCAAAAF4DEAF1DBAE),\n (0x0123456789ABCDEF,0x0000000000000000,0xD5D44FF720683D0D),\n (0xFEDCBA9876543210,0xFFFFFFFFFFFFFFFF,0x2A2BB008DF97C2F2),\n ]\n \n def test_01_expand(self):\n  ''\n  from passlib.crypto.des import expand_des_key,shrink_des_key,\\\n  _KDATA_MASK,INT_56_MASK\n  \n  \n  \n  for key1,_,_ in self.des_test_vectors:\n   key2=shrink_des_key(key1)\n   key3=expand_des_key(key2)\n   \n   self.assertEqual(key3,key1&_KDATA_MASK)\n   \n   \n  self.assertRaises(TypeError,expand_des_key,1.0)\n  \n  \n  self.assertRaises(ValueError,expand_des_key,INT_56_MASK+1)\n  self.assertRaises(ValueError,expand_des_key,b\"\\x00\"*8)\n  \n  \n  self.assertRaises(ValueError,expand_des_key,-1)\n  self.assertRaises(ValueError,expand_des_key,b\"\\x00\"*6)\n  \n def test_02_shrink(self):\n  ''\n  from passlib.crypto.des import expand_des_key,shrink_des_key,INT_64_MASK\n  rng=self.getRandom()\n  \n  \n  \n  for i in range(20):\n   key1=getrandbytes(rng,7)\n   key2=expand_des_key(key1)\n   key3=shrink_des_key(key2)\n   self.assertEqual(key3,key1)\n   \n   \n  self.assertRaises(TypeError,shrink_des_key,1.0)\n  \n  \n  self.assertRaises(ValueError,shrink_des_key,INT_64_MASK+1)\n  self.assertRaises(ValueError,shrink_des_key,b\"\\x00\"*9)\n  \n  \n  self.assertRaises(ValueError,shrink_des_key,-1)\n  self.assertRaises(ValueError,shrink_des_key,b\"\\x00\"*7)\n  \n def _random_parity(self,key):\n  ''\n  from passlib.crypto.des import _KDATA_MASK,_KPARITY_MASK,INT_64_MASK\n  rng=self.getRandom()\n  return (key&_KDATA_MASK)|(rng.randint(0,INT_64_MASK)&_KPARITY_MASK)\n  \n def test_03_encrypt_bytes(self):\n  ''\n  from passlib.crypto.des import (des_encrypt_block,shrink_des_key,\n  _pack64,_unpack64)\n  \n  \n  for key,plaintext,correct in self.des_test_vectors:\n  \n   key=_pack64(key)\n   plaintext=_pack64(plaintext)\n   correct=_pack64(correct)\n   \n   \n   result=des_encrypt_block(key,plaintext)\n   self.assertEqual(result,correct,\"key=%r plaintext=%r:\"%\n   (key,plaintext))\n   \n   \n   key2=shrink_des_key(key)\n   result=des_encrypt_block(key2,plaintext)\n   self.assertEqual(result,correct,\"key=%r shrink(key)=%r plaintext=%r:\"%\n   (key,key2,plaintext))\n   \n   \n   for _ in range(20):\n    key3=_pack64(self._random_parity(_unpack64(key)))\n    result=des_encrypt_block(key3,plaintext)\n    self.assertEqual(result,correct,\"key=%r rndparity(key)=%r plaintext=%r:\"%\n    (key,key3,plaintext))\n    \n    \n  stub=b'\\x00'*8\n  self.assertRaises(TypeError,des_encrypt_block,0,stub)\n  self.assertRaises(ValueError,des_encrypt_block,b'\\x00'*6,stub)\n  \n  \n  self.assertRaises(TypeError,des_encrypt_block,stub,0)\n  self.assertRaises(ValueError,des_encrypt_block,stub,b'\\x00'*7)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_block,stub,stub,salt=-1)\n  self.assertRaises(ValueError,des_encrypt_block,stub,stub,salt=1 <<24)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_block,stub,stub,0,rounds=0)\n  \n def test_04_encrypt_ints(self):\n  ''\n  from passlib.crypto.des import des_encrypt_int_block\n  \n  \n  for key,plaintext,correct in self.des_test_vectors:\n  \n   result=des_encrypt_int_block(key,plaintext)\n   self.assertEqual(result,correct,\"key=%r plaintext=%r:\"%\n   (key,plaintext))\n   \n   \n   for _ in range(20):\n    key3=self._random_parity(key)\n    result=des_encrypt_int_block(key3,plaintext)\n    self.assertEqual(result,correct,\"key=%r rndparity(key)=%r plaintext=%r:\"%\n    (key,key3,plaintext))\n    \n    \n  self.assertRaises(TypeError,des_encrypt_int_block,b'\\x00',0)\n  self.assertRaises(ValueError,des_encrypt_int_block,-1,0)\n  \n  \n  self.assertRaises(TypeError,des_encrypt_int_block,0,b'\\x00')\n  self.assertRaises(ValueError,des_encrypt_int_block,0,-1)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_int_block,0,0,salt=-1)\n  self.assertRaises(ValueError,des_encrypt_int_block,0,0,salt=1 <<24)\n  \n  \n  self.assertRaises(ValueError,des_encrypt_int_block,0,0,0,rounds=0)\n  \n  \n  \n  \n", ["__future__", "functools", "passlib.crypto.des", "passlib.tests.utils", "passlib.utils"]], "passlib.Lib.site-packages.passlib.tests.test_handlers_bcrypt": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport os\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.handlers.bcrypt import IDENT_2,IDENT_2X\nfrom passlib.utils import repeat_string,to_bytes,is_safe_crypt_input\nfrom passlib.utils.compat import irange,PY3\nfrom passlib.tests.utils import HandlerCase,TEST_MODE\nfrom passlib.tests.test_handlers import UPASS_TABLE\n\n\n\n\n\nclass _bcrypt_test(HandlerCase):\n ''\n handler=hash.bcrypt\n reduce_default_rounds=True\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n ('U*U*U*U*','$2a$05$c92SVSfjeiCD6F2nAD6y0uBpJDjdRkt0EgeC4/31Rf2LUZbDRDE.O'),\n ('U*U***U','$2a$05$WY62Xk2TXZ7EvVDQ5fmjNu7b0GEzSzUXUh2cllxJwhtOeMtWV3Ujq'),\n ('U*U***U*','$2a$05$Fa0iKV3E2SYVUlMknirWU.CFYGvJ67UwVKI1E2FP6XeLiZGcH3MJi'),\n ('*U*U*U*U','$2a$05$.WRrXibc1zPgIdRXYfv.4uu6TD1KWf0VnHzq/0imhUhuxSxCyeBs2'),\n ('','$2a$05$Otz9agnajgrAe0.kFVF9V.tzaStZ2s1s4ZWi/LY4sw2k/MTVFj/IO'),\n \n \n \n \n \n \n \n \n ('U*U','$2a$05$CCCCCCCCCCCCCCCCCCCCC.E5YPO9kmyuRGyh0XouQYb4YMJKvyOeW'),\n ('U*U*','$2a$05$CCCCCCCCCCCCCCCCCCCCC.VGOzA784oUp/Z0DY336zx7pLYAy0lwK'),\n ('U*U*U','$2a$05$XXXXXXXXXXXXXXXXXXXXXOAcXxm9kjPGEMsLznoKqmqw7tc8WCx4a'),\n ('','$2a$05$CCCCCCCCCCCCCCCCCCCCC.7uG0VCzI2bS7j6ymqJi9CdcdxiRTWNy'),\n ('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n '0123456789chars after 72 are ignored',\n '$2a$05$abcdefghijklmnopqrstuu5s2v8.iXieOjg/.AySBTTZIIVFJeBui'),\n (b'\\xa3',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.Sa7shbm4.OzKpvFnX1pQLmQW96oUlCq'),\n (b'\\xff\\xa3345',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.nRht2l/HRhr6zmCp9vYUvvsqynflf9e'),\n (b'\\xa3ab',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.6IflQkJytoRVc1yuaNtHfiuq.FRlSIS'),\n (b'\\xaa'*72+b'chars after 72 are ignored as usual',\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.swQOIzjOiJ9GHEPuhEkvqrUyvWhEMx6'),\n (b'\\xaa\\x55'*36,\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.R9xrDjiycxMbQE2bp.vgqlYpW5wx2yy'),\n (b'\\x55\\xaa\\xff'*24,\n '$2a$05$/OK.fbVrR/bpIqNJ5ianF.9tQZzcJfm3uj2NvJ/n5xkhpqLrMpWCe'),\n \n \n (b'\\xa3',\n '$2y$05$/OK.fbVrR/bpIqNJ5ianF.Sa7shbm4.OzKpvFnX1pQLmQW96oUlCq'),\n \n \n \n \n \n \n (b\"\\xd1\\x91\",\"$2y$05$6bNw2HLQYeqHYyBfLMsv/OUcZd0LKP39b87nBw3.S2tVZSqiQX6eu\"),\n \n \n \n \n \n \n \n \n \n ((\"0123456789\"*26)[:254],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n ((\"0123456789\"*26)[:255],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n ((\"0123456789\"*26)[:256],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n ((\"0123456789\"*26)[:257],'$2a$04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi'),\n \n \n \n \n \n ('','$2a$06$DCq7YPn5Rq63x1Lad4cll.TV4S6ytwfsfvkgY8jIucDrjc8deX1s.'),\n ('a','$2a$10$k87L/MF28Q673VKh8/cPi.SUl7MU/rWuSiIDDFayrKk/1tBsSQu4u'),\n ('abc','$2a$10$WvvTPHKwdBJ3uk0Z37EMR.hLA2W6N9AEBhEgrAOljy2Ae5MtaSIUi'),\n ('abcdefghijklmnopqrstuvwxyz',\n '$2a$10$fVH8e28OQRj9tqiDXs1e1uxpsjN0c7II7YPKXua2NAKYvM6iQk7dq'),\n ('~!@#$%^&*()      ~!@#$%^&*()PNBFRD',\n '$2a$10$LgfYWkbzEvQ4JakH7rOvHe0y8pHKF9OaFgwUZ2q7W2FFZmZzJYlfS'),\n \n \n \n \n \n \n (UPASS_TABLE,\n '$2a$05$Z17AXnnlpzddNUvnC6cZNOSwMA/8oNiKnHTHTwLlBijfucQQlHjaG'),\n \n \n (UPASS_TABLE,\n '$2b$05$Z17AXnnlpzddNUvnC6cZNOSwMA/8oNiKnHTHTwLlBijfucQQlHjaG'),\n \n ]\n \n if TEST_MODE(\"full\"):\n \n \n \n  CONFIG_2='$2$05$'+'.'*22\n  CONFIG_A='$2a$05$'+'.'*22\n  known_correct_hashes.extend([\n  (\"\",CONFIG_2+'J2ihDv8vVf7QZ9BsaRrKyqs2tkn55Yq'),\n  (\"\",CONFIG_A+'J2ihDv8vVf7QZ9BsaRrKyqs2tkn55Yq'),\n  (\"abc\",CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\",CONFIG_A+'ev6gDwpVye3oMCUpLY85aTpfBNHD0Ga'),\n  (\"abc\"*23,CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*23,CONFIG_A+'2kIdfSj/4/R/Q6n847VTvc68BXiRYZC'),\n  (\"abc\"*24,CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*24,CONFIG_A+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*24+'x',CONFIG_2+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  (\"abc\"*24+'x',CONFIG_A+'XuQjdH.wPVNUZ/bOfstdW/FqB8QSjte'),\n  ])\n  \n known_correct_configs=[\n ('$2a$04$uM6csdM8R9SXTex/gbTaye',UPASS_TABLE,\n '$2a$04$uM6csdM8R9SXTex/gbTayezuvzFEufYGd2uB6of7qScLjQ4GwcD4G'),\n ]\n \n known_unidentified_hashes=[\n \n \"$2f$12$EXRkfkdmXnagzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n \"$2`$12$EXRkfkdmXnagzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n ]\n \n known_malformed_hashes=[\n \n \n \"$2a$12$EXRkfkdmXn!gzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n \n \n \"$2x$12$EXRkfkdmXnagzds2SSitu.MW9.gAVqa9eLS1//RYtYCmB1eLHg.9q\",\n \n \n '$2a$6$DCq7YPn5Rq63x1Lad4cll.TV4S6ytwfsfvkgY8jIucDrjc8deX1s.'\n \n \n \n ]\n \n platform_crypt_support=[\n (\"freedbsd|openbsd|netbsd\",True ),\n (\"darwin\",False ),\n (\"linux\",None ),\n (\"solaris\",None ),\n ]\n \n \n \n \n def setUp(self):\n \n  if TEST_MODE(\"full\")and self.backend ==\"builtin\":\n   key=\"PASSLIB_BUILTIN_BCRYPT\"\n   orig=os.environ.get(key)\n   if orig:\n    self.addCleanup(os.environ.__setitem__,key,orig)\n   else :\n    self.addCleanup(os.environ.__delitem__,key)\n   os.environ[key]=\"true\"\n   \n  super(_bcrypt_test,self).setUp()\n  \n  \n  warnings.filterwarnings(\"ignore\",\".*backend is vulnerable to the bsd wraparound bug.*\")\n  \n def populate_settings(self,kwds):\n \n  if self.backend ==\"builtin\":\n   kwds.setdefault(\"rounds\",4)\n  super(_bcrypt_test,self).populate_settings(kwds)\n  \n  \n  \n  \n def crypt_supports_variant(self,hash):\n  ''\n  from passlib.handlers.bcrypt import bcrypt,IDENT_2X,IDENT_2Y\n  from passlib.utils import safe_crypt\n  ident=bcrypt.from_string(hash)\n  return (safe_crypt(\"test\",ident+\"04$5BJqKfqMQvV7nS.yUguNcu\")or \"\").startswith(ident)\n  \n fuzz_verifiers=HandlerCase.fuzz_verifiers+(\n \"fuzz_verifier_bcrypt\",\n \"fuzz_verifier_pybcrypt\",\n \"fuzz_verifier_bcryptor\",\n )\n \n def fuzz_verifier_bcrypt(self):\n \n  from passlib.handlers.bcrypt import IDENT_2,IDENT_2A,IDENT_2B,IDENT_2X,IDENT_2Y,_detect_pybcrypt\n  from passlib.utils import to_native_str,to_bytes\n  try :\n   import bcrypt\n  except ImportError:\n   return\n  if _detect_pybcrypt():\n   return\n  def check_bcrypt(secret,hash):\n   ''\n   secret=to_bytes(secret,self.FuzzHashGenerator.password_encoding)\n   if hash.startswith(IDENT_2B):\n   \n    hash=IDENT_2A+hash[4:]\n   elif hash.startswith(IDENT_2):\n   \n   \n   \n    hash=IDENT_2A+hash[3:]\n    if secret:\n     secret=repeat_string(secret,72)\n   elif hash.startswith(IDENT_2Y)and bcrypt.__version__ ==\"3.0.0\":\n    hash=IDENT_2B+hash[4:]\n   hash=to_bytes(hash)\n   try :\n    return bcrypt.hashpw(secret,hash)==hash\n   except ValueError:\n    raise ValueError(\"bcrypt rejected hash: %r (secret=%r)\"%(hash,secret))\n  return check_bcrypt\n  \n def fuzz_verifier_pybcrypt(self):\n \n  from passlib.handlers.bcrypt import (\n  IDENT_2,IDENT_2A,IDENT_2B,IDENT_2X,IDENT_2Y,\n  _PyBcryptBackend,\n  )\n  from passlib.utils import to_native_str\n  \n  loaded=_PyBcryptBackend._load_backend_mixin(\"pybcrypt\",False )\n  if not loaded:\n   return\n   \n  from passlib.handlers.bcrypt import _pybcrypt as bcrypt_mod\n  \n  lock=_PyBcryptBackend._calc_lock\n  \n  def check_pybcrypt(secret,hash):\n   ''\n   secret=to_native_str(secret,self.FuzzHashGenerator.password_encoding)\n   if len(secret)>200:\n    secret=secret[:200]\n   if hash.startswith((IDENT_2B,IDENT_2Y)):\n    hash=IDENT_2A+hash[4:]\n   try :\n    if lock:\n     with lock:\n      return bcrypt_mod.hashpw(secret,hash)==hash\n    else :\n     return bcrypt_mod.hashpw(secret,hash)==hash\n   except ValueError:\n    raise ValueError(\"py-bcrypt rejected hash: %r\"%(hash,))\n  return check_pybcrypt\n  \n def fuzz_verifier_bcryptor(self):\n \n  from passlib.handlers.bcrypt import IDENT_2,IDENT_2A,IDENT_2Y,IDENT_2B\n  from passlib.utils import to_native_str\n  try :\n   from bcryptor.engine import Engine\n  except ImportError:\n   return\n  def check_bcryptor(secret,hash):\n   ''\n   secret=to_native_str(secret,self.FuzzHashGenerator.password_encoding)\n   if hash.startswith((IDENT_2B,IDENT_2Y)):\n    hash=IDENT_2A+hash[4:]\n   elif hash.startswith(IDENT_2):\n   \n   \n   \n    hash=IDENT_2A+hash[3:]\n    if secret:\n     secret=repeat_string(secret,72)\n   return Engine(False ).hash_key(secret,hash)==hash\n  return check_bcryptor\n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def generate(self):\n   opts=super(_bcrypt_test.FuzzHashGenerator,self).generate()\n   \n   secret=opts['secret']\n   other=opts['other']\n   settings=opts['settings']\n   ident=settings.get('ident')\n   \n   if ident ==IDENT_2X:\n   \n    del settings['ident']\n    \n   elif ident ==IDENT_2 and other and repeat_string(to_bytes(other),len(to_bytes(secret)))==to_bytes(secret):\n   \n   \n    opts['secret'],opts['other']=self.random_password_pair()\n    \n   return opts\n   \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n   \n   \n   \n known_incorrect_padding=[\n \n \n \n \n \n \n (\"test\",\n '$2a$04$oaQbBqq8JnSM1NHRPQGXORY4Vw3bdHKLIXTecPDRAcJ98cz1ilveO',\n '$2a$04$oaQbBqq8JnSM1NHRPQGXOOY4Vw3bdHKLIXTecPDRAcJ98cz1ilveO'),\n \n \n \n \n \n (\"test\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSScrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"),\n \n \n (\"test\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIV\",\n \"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"),\n ]\n \n def test_90_bcrypt_padding(self):\n  ''\n  self.require_TEST_MODE(\"full\")\n  \n  \n  \n  \n  \n  bcrypt=self.handler\n  corr_desc=\".*incorrectly set padding bits\"\n  \n  \n  \n  \n  def check_padding(hash):\n   assert hash.startswith((\"$2a$\",\"$2b$\"))and len(hash)>=28,\\\n   \"unexpectedly malformed hash: %r\"%(hash,)\n   self.assertTrue(hash[28]in '.Oeu',\n   \"unused bits incorrectly set in hash: %r\"%(hash,))\n  for i in irange(6):\n   check_padding(bcrypt.genconfig())\n  for i in irange(3):\n   check_padding(bcrypt.using(rounds=bcrypt.min_rounds).hash(\"bob\"))\n   \n   \n   \n   \n  with self.assertWarningList([\"salt too large\",corr_desc]):\n   hash=bcrypt.genconfig(salt=\".\"*21+\"A.\",rounds=5,relaxed=True )\n  self.assertEqual(hash,\"$2b$05$\"+\".\"*(22+31))\n  \n  \n  \n  \n  samples=self.known_incorrect_padding\n  for pwd,bad,good in samples:\n  \n  \n   with self.assertWarningList([corr_desc]):\n    self.assertEqual(bcrypt.genhash(pwd,bad),good)\n   with self.assertWarningList([]):\n    self.assertEqual(bcrypt.genhash(pwd,good),good)\n    \n    \n   with self.assertWarningList([corr_desc]):\n    self.assertTrue(bcrypt.verify(pwd,bad))\n   with self.assertWarningList([]):\n    self.assertTrue(bcrypt.verify(pwd,good))\n    \n    \n   with self.assertWarningList([corr_desc]):\n    self.assertEqual(bcrypt.normhash(bad),good)\n   with self.assertWarningList([]):\n    self.assertEqual(bcrypt.normhash(good),good)\n    \n    \n  self.assertEqual(bcrypt.normhash(\"$md5$abc\"),\"$md5$abc\")\n  \n def test_needs_update_w_padding(self):\n  ''\n  \n  bcrypt=self.handler.using(rounds=4)\n  \n  \n  \n  \n  BAD1=\"$2a$04$yjDgE74RJkeqC0/1NheSScrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n  GOOD1=\"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n  \n  self.assertTrue(bcrypt.needs_update(BAD1))\n  self.assertFalse(bcrypt.needs_update(GOOD1))\n  \n  \n  \n  \n  \n  \nbcrypt_bcrypt_test=_bcrypt_test.create_backend_case(\"bcrypt\")\nbcrypt_pybcrypt_test=_bcrypt_test.create_backend_case(\"pybcrypt\")\nbcrypt_bcryptor_test=_bcrypt_test.create_backend_case(\"bcryptor\")\n\nclass bcrypt_os_crypt_test(_bcrypt_test.create_backend_case(\"os_crypt\")):\n\n\n known_correct_hashes=[row for row in _bcrypt_test.known_correct_hashes\n if is_safe_crypt_input(row[0])]\n \n \n has_os_crypt_fallback=False\n \nbcrypt_builtin_test=_bcrypt_test.create_backend_case(\"builtin\")\n\n\n\n\nclass _bcrypt_sha256_test(HandlerCase):\n ''\n handler=hash.bcrypt_sha256\n reduce_default_rounds=True\n forbidden_characters=None\n fuzz_salts_need_bcrypt_repair=True\n \n known_correct_hashes=[\n \n \n \n \n \n (\"\",\n '$bcrypt-sha256$2a,5$E/e/2AOhqM5W/KJTFQzLce$F6dYSxOdAEoJZO2eoHUZWZljW/e0TXO'),\n \n \n (\"password\",\n '$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu'),\n \n \n (UPASS_TABLE,\n '$bcrypt-sha256$2a,5$.US1fQ4TQS.ZTz/uJ5Kyn.$QNdPDOTKKT5/sovNz1iWg26quOU4Pje'),\n (UPASS_TABLE.encode(\"utf-8\"),\n '$bcrypt-sha256$2a,5$.US1fQ4TQS.ZTz/uJ5Kyn.$QNdPDOTKKT5/sovNz1iWg26quOU4Pje'),\n \n \n (\"password\",\n '$bcrypt-sha256$2b,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu'),\n (UPASS_TABLE,\n '$bcrypt-sha256$2b,5$.US1fQ4TQS.ZTz/uJ5Kyn.$QNdPDOTKKT5/sovNz1iWg26quOU4Pje'),\n \n \n \n (repeat_string(\"abc123\",72),\n '$bcrypt-sha256$2b,5$X1g1nh3g0v4h6970O68cxe$r/hyEtqJ0teqPEmfTLoZ83ciAI1Q74.'),\n (repeat_string(\"abc123\",72)+\"qwr\",\n '$bcrypt-sha256$2b,5$X1g1nh3g0v4h6970O68cxe$021KLEif6epjot5yoxk0m8I0929ohEa'),\n (repeat_string(\"abc123\",72)+\"xyz\",\n '$bcrypt-sha256$2b,5$X1g1nh3g0v4h6970O68cxe$7.1kgpHduMGEjvM3fX6e/QCvfn6OKja'),\n \n \n \n \n \n \n \n (\"\",\n '$bcrypt-sha256$v=2,t=2b,r=5$E/e/2AOhqM5W/KJTFQzLce$WFPIZKtDDTriqWwlmRFfHiOTeheAZWe'),\n \n \n (\"password\",\n '$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$wOK1VFFtS8IGTrGa7.h5fs0u84qyPbS'),\n \n \n (UPASS_TABLE,\n '$bcrypt-sha256$v=2,t=2b,r=5$.US1fQ4TQS.ZTz/uJ5Kyn.$pzzgp40k8reM1CuQb03PvE0IDPQSdV6'),\n (UPASS_TABLE.encode(\"utf-8\"),\n '$bcrypt-sha256$v=2,t=2b,r=5$.US1fQ4TQS.ZTz/uJ5Kyn.$pzzgp40k8reM1CuQb03PvE0IDPQSdV6'),\n \n \n \n (repeat_string(\"abc123\",72),\n '$bcrypt-sha256$v=2,t=2b,r=5$X1g1nh3g0v4h6970O68cxe$zu1cloESVFIOsUIo7fCEgkdHaI9SSue'),\n (repeat_string(\"abc123\",72)+\"qwr\",\n '$bcrypt-sha256$v=2,t=2b,r=5$X1g1nh3g0v4h6970O68cxe$CBF9csfEdW68xv3DwE6xSULXMtqEFP.'),\n (repeat_string(\"abc123\",72)+\"xyz\",\n '$bcrypt-sha256$v=2,t=2b,r=5$X1g1nh3g0v4h6970O68cxe$zC/1UDUG2ofEXB6Onr2vvyFzfhEOS3S'),\n ]\n \n known_correct_configs=[\n \n ('$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe',\n \"password\",'$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu'),\n \n ('$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe',\n \"password\",'$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$wOK1VFFtS8IGTrGa7.h5fs0u84qyPbS'),\n ]\n \n known_malformed_hashes=[\n \n \n \n \n \n \n '$bcrypt-sha256$2a,5$5Hg1DKF!PE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2c,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2x,5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2a,05$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$2a,5$5Hg1DKFqPE8C2aflZ5vVoe$',\n \n \n \n \n \n \n \n '$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKF!PE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=1,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=3,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2c,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2a,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n '$bcrypt-sha256$v=2,t=2x,r=5$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2b,r=05$5Hg1DKFqPE8C2aflZ5vVoe$12BjNE0p7axMg55.Y/mHsYiVuFBDQyu',\n \n \n '$bcrypt-sha256$v=2,t=2b,r=5$5Hg1DKFqPE8C2aflZ5vVoe$',\n ]\n \n \n \n \n def setUp(self):\n \n  if TEST_MODE(\"full\")and self.backend ==\"builtin\":\n   key=\"PASSLIB_BUILTIN_BCRYPT\"\n   orig=os.environ.get(key)\n   if orig:\n    self.addCleanup(os.environ.__setitem__,key,orig)\n   else :\n    self.addCleanup(os.environ.__delitem__,key)\n   os.environ[key]=\"enabled\"\n  super(_bcrypt_sha256_test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*backend is vulnerable to the bsd wraparound bug.*\")\n  \n def populate_settings(self,kwds):\n \n  if self.backend ==\"builtin\":\n   kwds.setdefault(\"rounds\",4)\n  super(_bcrypt_sha256_test,self).populate_settings(kwds)\n  \n  \n  \n  \n  \n def require_many_idents(self):\n  raise self.skipTest(\"multiple idents not supported\")\n  \n def test_30_HasOneIdent(self):\n \n  handler=self.handler\n  handler(use_defaults=True )\n  self.assertRaises(ValueError,handler,ident=\"$2y$\",use_defaults=True )\n  \n  \n  \n  \n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  def random_rounds(self):\n  \n   return self.randintgauss(5,8,6,1)\n   \n  def random_ident(self):\n   return \"2b\"\n   \n   \n   \n   \n   \n def test_using_version(self):\n \n  handler=self.handler\n  self.assertEqual(handler.version,2)\n  \n  \n  subcls=handler.using(version=1)\n  self.assertEqual(subcls.version,1)\n  \n  \n  self.assertRaises(ValueError,handler.using,version=999)\n  \n  \n  subcls=handler.using(version=1,ident=\"2a\")\n  self.assertRaises(ValueError,handler.using,ident=\"2a\")\n  \n def test_calc_digest_v2(self):\n  ''\n\n  \n  from passlib.hash import bcrypt\n  from passlib.crypto.digest import compile_hmac\n  from passlib.utils.binary import b64encode\n  \n  \n  salt=\"nyKYxTAvjmy6lMDYMl11Uu\"\n  secret=\"test\"\n  temp_digest=compile_hmac(\"sha256\",salt.encode(\"ascii\"))(secret.encode(\"ascii\"))\n  temp_digest=b64encode(temp_digest).decode(\"ascii\")\n  self.assertEqual(temp_digest,\"J5TlyIDm+IcSWmKiDJm+MeICndBkFVPn4kKdJW8f+xY=\")\n  \n  \n  \n  bcrypt_digest=bcrypt(ident=\"2b\",salt=salt,rounds=12)._calc_checksum(temp_digest)\n  self.assertEqual(bcrypt_digest,\"M0wE0Ov/9LXoQFCe.jRHu3MSHPF54Ta\")\n  self.assertTrue(bcrypt.verify(temp_digest,\"$2b$12$\"+salt+bcrypt_digest))\n  \n  \n  \n  result=self.handler(ident=\"2b\",salt=salt,rounds=12)._calc_checksum(secret)\n  self.assertEqual(result,bcrypt_digest)\n  \n  \n  \n  \n  \n  \nbcrypt_sha256_bcrypt_test=_bcrypt_sha256_test.create_backend_case(\"bcrypt\")\nbcrypt_sha256_pybcrypt_test=_bcrypt_sha256_test.create_backend_case(\"pybcrypt\")\nbcrypt_sha256_bcryptor_test=_bcrypt_sha256_test.create_backend_case(\"bcryptor\")\n\nclass bcrypt_sha256_os_crypt_test(_bcrypt_sha256_test.create_backend_case(\"os_crypt\")):\n\n @classmethod\n def _get_safe_crypt_handler_backend(cls):\n  return bcrypt_os_crypt_test._get_safe_crypt_handler_backend()\n  \n has_os_crypt_fallback=False\n \nbcrypt_sha256_builtin_test=_bcrypt_sha256_test.create_backend_case(\"builtin\")\n\n\n\n\n", ["__future__", "bcrypt", "bcryptor.engine", "logging", "os", "passlib", "passlib.crypto.digest", "passlib.handlers.bcrypt", "passlib.hash", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "warnings"]], "passlib.Lib.site-packages.passlib.tests.utils": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom binascii import unhexlify\nimport contextlib\nfrom functools import wraps,partial\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\nimport random\nimport re\nimport os\nimport sys\nimport tempfile\nimport threading\nimport time\nfrom passlib.exc import PasslibHashWarning,PasslibConfigWarning\nfrom passlib.utils.compat import PY3,JYTHON\nimport warnings\nfrom warnings import warn\n\n\nfrom passlib import exc\nfrom passlib.exc import MissingBackendError\nimport passlib.registry as registry\nfrom passlib.tests.backports import TestCase as _TestCase,skip,skipIf,skipUnless,SkipTest\nfrom passlib.utils import has_rounds_info,has_salt_info,rounds_cost_values,\\\nrng as sys_rng,getrandstr,is_ascii_safe,to_native_str,\\\nrepeat_string,tick,batch\nfrom passlib.utils.compat import iteritems,irange,u,unicode,PY2,nullcontext\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\n'TEST_MODE',\n'set_file','get_file',\n\n\n'TestCase',\n'HandlerCase',\n]\n\n\n\n\n\n\n\ntry :\n import google.appengine\nexcept ImportError:\n GAE=False\nelse :\n GAE=True\n \ndef ensure_mtime_changed(path):\n ''\n \n \n last=os.path.getmtime(path)\n while os.path.getmtime(path)==last:\n  time.sleep(0.1)\n  os.utime(path,None )\n  \ndef _get_timer_resolution(timer):\n def sample():\n  start=cur=timer()\n  while start ==cur:\n   cur=timer()\n  return cur -start\n return min(sample()for _ in range(3))\nTICK_RESOLUTION=_get_timer_resolution(tick)\n\n\n\n\n_TEST_MODES=[\"quick\",\"default\",\"full\"]\n_test_mode=_TEST_MODES.index(os.environ.get(\"PASSLIB_TEST_MODE\",\n\"default\").strip().lower())\n\ndef TEST_MODE(min=None ,max=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if min and _test_mode <_TEST_MODES.index(min):\n  return False\n if max and _test_mode >_TEST_MODES.index(max):\n  return False\n return True\n \n \n \n \ndef has_relaxed_setting(handler):\n ''\n \n \n \n \n if hasattr(handler,\"orig_prefix\"):\n  return False\n  \n return 'relaxed'in handler.setting_kwds or issubclass(handler,\n uh.GenericHandler)\n \ndef get_effective_rounds(handler,rounds=None ):\n ''\n handler=unwrap_handler(handler)\n return handler(rounds=rounds,use_defaults=True ).rounds\n \ndef is_default_backend(handler,backend):\n ''\n try :\n  orig=handler.get_backend()\n except MissingBackendError:\n  return False\n try :\n  handler.set_backend(\"default\")\n  return handler.get_backend()==backend\n finally :\n  handler.set_backend(orig)\n  \ndef iter_alt_backends(handler,current=None ,fallback=False ):\n ''\n\n\n\n\n \n if current is None :\n  current=handler.get_backend()\n backends=handler.backends\n idx=backends.index(current)+1 if fallback else 0\n for backend in backends[idx:]:\n  if backend !=current and handler.has_backend(backend):\n   yield backend\n   \ndef get_alt_backend(*args,**kwds):\n for backend in iter_alt_backends(*args,**kwds):\n  return backend\n return None\n \ndef unwrap_handler(handler):\n ''\n while hasattr(handler,\"wrapped\"):\n  handler=handler.wrapped\n return handler\n \ndef handler_derived_from(handler,base):\n ''\n\n \n \n \n if handler ==base:\n  return True\n elif isinstance(handler,uh.PrefixWrapper):\n  while handler:\n   if handler ==base:\n    return True\n    \n   handler=handler._derived_from\n  return False\n elif isinstance(handler,type)and issubclass(handler,uh.MinimalHandler):\n  return issubclass(handler,base)\n else :\n  raise NotImplementedError(\"don't know how to inspect handler: %r\"%(handler,))\n  \n@contextlib.contextmanager\ndef patch_calc_min_rounds(handler):\n ''\n\n\n\n\n \n if isinstance(handler,type)and issubclass(handler,uh.HasRounds):\n \n  wrapped=handler._calc_checksum\n  def wrapper(self,*args,**kwds):\n   rounds=self.rounds\n   try :\n    self.rounds=self.min_rounds\n    return wrapped(self,*args,**kwds)\n   finally :\n    self.rounds=rounds\n  handler._calc_checksum=wrapper\n  try :\n   yield\n  finally :\n   handler._calc_checksum=wrapped\n elif isinstance(handler,uh.PrefixWrapper):\n  with patch_calc_min_rounds(handler.wrapped):\n   yield\n else :\n  yield\n  return\n  \n  \n  \n  \ndef set_file(path,content):\n ''\n if isinstance(content,unicode):\n  content=content.encode(\"utf-8\")\n with open(path,\"wb\")as fh:\n  fh.write(content)\n  \ndef get_file(path):\n ''\n with open(path,\"rb\")as fh:\n  return fh.read()\n  \ndef tonn(source):\n ''\n if not isinstance(source,str):\n  return source\n elif PY3:\n  return source.encode(\"utf-8\")\n else :\n  try :\n   return source.decode(\"utf-8\")\n  except UnicodeDecodeError:\n   return source.decode(\"latin-1\")\n   \ndef hb(source):\n ''\n\n\n\n \n return unhexlify(re.sub(r\"\\s\",\"\",source))\n \ndef limit(value,lower,upper):\n if value <lower:\n  return lower\n elif value >upper:\n  return upper\n return value\n \ndef quicksleep(delay):\n ''\n start=tick()\n while tick()-start <delay:\n  pass\n  \ndef time_call(func,setup=None ,maxtime=1,bestof=10):\n ''\n\n\n\n\n \n from timeit import Timer\n from math import log\n timer=Timer(func,setup=setup or '')\n number=1\n end=tick()+maxtime\n while True :\n  delta=min(timer.repeat(bestof,number))\n  if tick()>=end:\n   return delta /number,int(log(number,10))\n  number *=10\n  \ndef run_with_fixed_seeds(count=128,master_seed=0x243F6A8885A308D3):\n ''\n\n \n def builder(func):\n  @wraps(func)\n  def wrapper(*args,**kwds):\n   rng=random.Random(master_seed)\n   for _ in irange(count):\n    kwds['seed']=rng.getrandbits(32)\n    func(*args,**kwds)\n  return wrapper\n return builder\n \n \n \n \n \nclass TestCase(_TestCase):\n ''\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n descriptionPrefix=None\n \n def shortDescription(self):\n  ''\n  desc=super(TestCase,self).shortDescription()\n  prefix=self.descriptionPrefix\n  if prefix:\n   desc=\"%s: %s\"%(prefix,desc or str(self))\n  return desc\n  \n  \n  \n  \n  \n @classproperty\n def __unittest_skip__(cls):\n \n  name=cls.__name__\n  return name.startswith(\"_\")or\\\n  getattr(cls,\"_%s__unittest_skip\"%name,False )\n  \n @classproperty\n def __test__(cls):\n \n  return not cls.__unittest_skip__\n  \n  \n __unittest_skip=True\n \n \n \n \n \n \n resetWarningState=True\n \n def setUp(self):\n  super(TestCase,self).setUp()\n  self.setUpWarnings()\n  \n  self.patchAttr(exc,\"ENABLE_DEBUG_ONLY_REPR\",True )\n  \n def setUpWarnings(self):\n  ''\n  if self.resetWarningState:\n   ctx=reset_warnings()\n   ctx.__enter__()\n   self.addCleanup(ctx.__exit__)\n   \n   \n   \n   \n   \n   \n   \n   \n   warnings.filterwarnings(\"ignore\",r\"the method .*\\.(encrypt|genconfig|genhash)\\(\\) is deprecated\")\n   warnings.filterwarnings(\"ignore\",r\"the 'vary_rounds' option is deprecated\")\n   warnings.filterwarnings(\"ignore\",r\"Support for `(py-bcrypt|bcryptor)` is deprecated\")\n   \n   \n   \n   \n   \n longMessage=True\n \n def _formatMessage(self,msg,std):\n  if self.longMessage and msg and msg.rstrip().endswith(\":\"):\n   return '%s %s'%(msg.rstrip(),std)\n  else :\n   return msg or std\n   \n   \n   \n   \n   \n def assertRaises(self,_exc_type,_callable=None ,*args,**kwds):\n  msg=kwds.pop(\"__msg__\",None )\n  if _callable is None :\n  \n   return super(TestCase,self).assertRaises(_exc_type,None ,\n   *args,**kwds)\n  try :\n   result=_callable(*args,**kwds)\n  except _exc_type as err:\n   return err\n  std=\"function returned %r, expected it to raise %r\"%(result,\n  _exc_type)\n  raise self.failureException(self._formatMessage(msg,std))\n  \n  \n  \n  \n def assertEquals(self,*a,**k):\n  raise AssertionError(\"this alias is deprecated by unittest2\")\n assertNotEquals=assertRegexMatches=assertEquals\n \n \n \n \n def assertWarning(self,warning,\n message_re=None ,message=None ,\n category=None ,\n filename_re=None ,filename=None ,\n lineno=None ,\n msg=None ,\n ):\n  ''\n\n\n  \n  \n  if hasattr(warning,\"category\"):\n  \n   wmsg=warning\n   warning=warning.message\n  else :\n  \n   wmsg=None\n   \n   \n  if message:\n   self.assertEqual(str(warning),message,msg)\n  if message_re:\n   self.assertRegex(str(warning),message_re,msg)\n  if category:\n   self.assertIsInstance(warning,category,msg)\n   \n   \n  if filename or filename_re:\n   if not wmsg:\n    raise TypeError(\"matching on filename requires a \"\n    \"WarningMessage instance\")\n   real=wmsg.filename\n   if real.endswith(\".pyc\")or real.endswith(\".pyo\"):\n   \n   \n    real=real[:-1]\n   if filename:\n    self.assertEqual(real,filename,msg)\n   if filename_re:\n    self.assertRegex(real,filename_re,msg)\n  if lineno:\n   if not wmsg:\n    raise TypeError(\"matching on lineno requires a \"\n    \"WarningMessage instance\")\n   self.assertEqual(wmsg.lineno,lineno,msg)\n   \n class _AssertWarningList(warnings.catch_warnings):\n  ''\n  def __init__(self,case,**kwds):\n   self.case=case\n   self.kwds=kwds\n   self.__super=super(TestCase._AssertWarningList,self)\n   self.__super.__init__(record=True )\n   \n  def __enter__(self):\n   self.log=self.__super.__enter__()\n   \n  def __exit__(self,*exc_info):\n   self.__super.__exit__(*exc_info)\n   if exc_info[0]is None :\n    self.case.assertWarningList(self.log,**self.kwds)\n    \n def assertWarningList(self,wlist=None ,desc=None ,msg=None ):\n  ''\n  if desc is None :\n   assert wlist is not None\n   return self._AssertWarningList(self,desc=wlist,msg=msg)\n   \n  assert desc is not None\n  if not isinstance(desc,(list,tuple)):\n   desc=[desc]\n  for idx,entry in enumerate(desc):\n   if isinstance(entry,str):\n    entry=dict(message_re=entry)\n   elif isinstance(entry,type)and issubclass(entry,Warning):\n    entry=dict(category=entry)\n   elif not isinstance(entry,dict):\n    raise TypeError(\"entry must be str, warning, or dict\")\n   try :\n    data=wlist[idx]\n   except IndexError:\n    break\n   self.assertWarning(data,msg=msg,**entry)\n  else :\n   if len(wlist)==len(desc):\n    return\n  std=\"expected %d warnings, found %d: wlist=%s desc=%r\"%\\\n  (len(desc),len(wlist),self._formatWarningList(wlist),desc)\n  raise self.failureException(self._formatMessage(msg,std))\n  \n def consumeWarningList(self,wlist,desc=None ,*args,**kwds):\n  ''\n  if desc is None :\n   desc=[]\n  self.assertWarningList(wlist,desc,*args,**kwds)\n  del wlist[:]\n  \n def _formatWarning(self,entry):\n  tail=\"\"\n  if hasattr(entry,\"message\"):\n  \n   tail=\" filename=%r lineno=%r\"%(entry.filename,entry.lineno)\n   if entry.line:\n    tail +=\" line=%r\"%(entry.line,)\n   entry=entry.message\n  cls=type(entry)\n  return \"<%s.%s message=%r%s>\"%(cls.__module__,cls.__name__,\n  str(entry),tail)\n  \n def _formatWarningList(self,wlist):\n  return \"[%s]\"%\", \".join(self._formatWarning(entry)for entry in wlist)\n  \n  \n  \n  \n def require_stringprep(self):\n  ''\n  from passlib.utils import stringprep\n  if not stringprep:\n   from passlib.utils import _stringprep_missing_reason\n   raise self.skipTest(\"not available - stringprep module is \"+\n   _stringprep_missing_reason)\n   \n def require_TEST_MODE(self,level):\n  ''\n  if not TEST_MODE(level):\n   raise self.skipTest(\"requires >= %r test mode\"%level)\n   \n def require_writeable_filesystem(self):\n  ''\n  if GAE:\n   return self.skipTest(\"GAE doesn't offer read/write filesystem access\")\n   \n   \n   \n   \n   \n   \n   \n _random_global_lock=threading.Lock()\n \n \n _random_global_seed=None\n \n \n _random_cache=None\n \n def getRandom(self,name=\"default\",seed=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  cache=self._random_cache\n  if cache and name in cache:\n   return cache[name]\n   \n  with self._random_global_lock:\n  \n  \n   cache=self._random_cache\n   if cache and name in cache:\n    return cache[name]\n   elif not cache:\n    cache=self._random_cache={}\n    \n    \n   global_seed=seed or TestCase._random_global_seed\n   if global_seed is None :\n   \n   \n    global_seed=TestCase._random_global_seed=\\\n    int(os.environ.get(\"RANDOM_TEST_SEED\")or\n    os.environ.get(\"PYTHONHASHSEED\")or\n    sys_rng.getrandbits(32))\n    \n    log.info(\"using RANDOM_TEST_SEED=%d\",global_seed)\n    \n    \n   cls=type(self)\n   source=\"\\n\".join([str(global_seed),cls.__module__,cls.__name__,\n   self._testMethodName,name])\n   digest=hashlib.sha256(source.encode(\"utf-8\")).hexdigest()\n   seed=int(digest[:16],16)\n   \n   \n   value=cache[name]=random.Random(seed)\n   return value\n   \n   \n   \n   \n   \n has_real_subtest=hasattr(_TestCase,\"subTest\")\n \n @contextlib.contextmanager\n def subTest(self,*args,**kwds):\n  ''\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def _render_title(_msg=None ,**params):\n   out=(\"[%s] \"%_msg if _msg else \"\")\n   if params:\n    out +=\"(%s)\"%\" \".join(\"%s=%r\"%tuple(item)for item in params.items())\n   return out.strip()or \"<subtest>\"\n   \n  test_log=self.getLogger()\n  title=_render_title(*args,**kwds)\n  \n  \n  if self.has_real_subtest:\n   ctx=super(TestCase,self).subTest(*args,**kwds)\n  else :\n   ctx=nullcontext()\n   \n   \n  with ctx:\n   test_log.info(\"running subtest: %s\",title)\n   try :\n    yield\n   except SkipTest:\n   \n    test_log.info(\"subtest skipped: %s\",title)\n    pass\n   except Exception as err:\n   \n   \n    test_log.warning(\"subtest failed: %s: %s: %r\",title,type(err).__name__,str(err))\n    raise\n    \n    \n  test_log.info(\"subtest passed: %s\",title)\n  \n  \n  \n  \n _mktemp_queue=None\n \n def mktemp(self,*args,**kwds):\n  ''\n  self.require_writeable_filesystem()\n  fd,path=tempfile.mkstemp(*args,**kwds)\n  os.close(fd)\n  queue=self._mktemp_queue\n  if queue is None :\n   queue=self._mktemp_queue=[]\n   def cleaner():\n    for path in queue:\n     if os.path.exists(path):\n      os.remove(path)\n    del queue[:]\n   self.addCleanup(cleaner)\n  queue.append(path)\n  return path\n  \n def patchAttr(self,obj,attr,value,require_existing=True ,wrap=False ):\n  ''\n  try :\n   orig=getattr(obj,attr)\n  except AttributeError:\n   if require_existing:\n    raise\n   def cleanup():\n    try :\n     delattr(obj,attr)\n    except AttributeError:\n     pass\n   self.addCleanup(cleanup)\n  else :\n   self.addCleanup(setattr,obj,attr,orig)\n  if wrap:\n   value=partial(value,orig)\n   wraps(orig)(value)\n  setattr(obj,attr,value)\n  \n def getLogger(self):\n  ''\n\n  \n  cls=type(self)\n  \n  path=cls.__module__+\".\"+getattr(cls,\"__qualname__\",cls.__name__)\n  name=self._testMethodName\n  if name:\n   path=path+\".\"+name\n  return logging.getLogger(path)\n  \n  \n  \n  \n  \n  \n  \n  \n  \nRESERVED_BACKEND_NAMES=[\"any\",\"default\"]\n\n\ndef doesnt_require_backend(func):\n ''\n\n\n\n\n\n \n func._doesnt_require_backend=True\n return func\n \n \nclass HandlerCase(TestCase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n handler=None\n \n \n backend=None\n \n \n \n \n \n \n known_correct_hashes=[]\n \n \n known_correct_configs=[]\n \n \n \n \n \n known_alternate_hashes=[]\n \n \n known_unidentified_hashes=[]\n \n \n \n known_malformed_hashes=[]\n \n \n \n \n known_other_hashes=[\n ('des_crypt','6f8c114b58f2c'),\n ('md5_crypt','$1$dOHYPKoP$tnxS1T8Q6VVn3kpV8cN6o.'),\n ('sha512_crypt',\"$6$rounds=123456$asaltof16chars..$BtCwjqMJGx5hrJhZywW\"\n \"vt0RLE8uZ4oPwcelCjmw2kSYu.Ec6ycULevoBK25fs2xXgMNrCzIMVcgEJAstJeonj1\"),\n ]\n \n \n \n stock_passwords=[\n u(\"test\"),\n u(\"\\u20AC\\u00A5$\"),\n b'\\xe2\\x82\\xac\\xc2\\xa5$'\n ]\n \n \n \n \n \n \n \n \n secret_case_insensitive=False\n \n \n accepts_all_hashes=False\n \n \n disabled_contains_salt=False\n \n \n filter_config_warnings=False\n \n \n @classproperty\n def forbidden_characters(cls):\n \n \n  if 'os_crypt'in getattr(cls.handler,\"backends\",()):\n   return b\"\\x00\"\n  return None\n  \n  \n  \n  \n __unittest_skip=True\n \n @property\n def descriptionPrefix(self):\n  handler=self.handler\n  name=handler.name\n  if hasattr(handler,\"get_backend\"):\n   name +=\" (%s backend)\"%(handler.get_backend(),)\n  return name\n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def iter_known_hashes(cls):\n  ''\n  for secret,hash in cls.known_correct_hashes:\n   yield secret,hash\n  for config,secret,hash in cls.known_correct_configs:\n   yield secret,hash\n  for alt,secret,hash in cls.known_alternate_hashes:\n   yield secret,hash\n   \n def get_sample_hash(self):\n  ''\n  known=list(self.iter_known_hashes())\n  return self.getRandom().choice(known)\n  \n  \n  \n  \n def check_verify(self,secret,hash,msg=None ,negate=False ):\n  ''\n  result=self.do_verify(secret,hash)\n  self.assertTrue(result is True or result is False ,\n  \"verify() returned non-boolean value: %r\"%(result,))\n  if self.handler.is_disabled or negate:\n   if not result:\n    return\n   if not msg:\n    msg=(\"verify incorrectly returned True: secret=%r, hash=%r\"%\n    (secret,hash))\n   raise self.failureException(msg)\n  else :\n   if result:\n    return\n   if not msg:\n    msg=\"verify failed: secret=%r, hash=%r\"%(secret,hash)\n   raise self.failureException(msg)\n   \n def check_returned_native_str(self,result,func_name):\n  self.assertIsInstance(result,str,\n  \"%s() failed to return native string: %r\"%(func_name,result,))\n  \n  \n  \n  \n  \n def populate_settings(self,kwds):\n  ''\n  \n  handler=self.handler\n  if 'rounds'in handler.setting_kwds and 'rounds'not in kwds:\n   mn=handler.min_rounds\n   df=handler.default_rounds\n   if TEST_MODE(max=\"quick\"):\n   \n    kwds['rounds']=max(3,mn)\n   else :\n   \n    factor=3\n    if getattr(handler,\"rounds_cost\",None )==\"log2\":\n     df -=factor\n    else :\n     df //=(1 <<factor)\n    kwds['rounds']=max(3,mn,df)\n    \n def populate_context(self,secret,kwds):\n  ''\n  return secret\n  \n  \n def do_encrypt(self,secret,use_encrypt=False ,handler=None ,context=None ,**settings):\n  ''\n  self.populate_settings(settings)\n  if context is None :\n   context={}\n  secret=self.populate_context(secret,context)\n  if use_encrypt:\n  \n   warnings=[]\n   if settings:\n    context.update(**settings)\n    warnings.append(\"passing settings to.*is deprecated\")\n   with self.assertWarningList(warnings):\n    return (handler or self.handler).encrypt(secret,**context)\n  else :\n  \n   return (handler or self.handler).using(**settings).hash(secret,**context)\n   \n def do_verify(self,secret,hash,handler=None ,**kwds):\n  ''\n  secret=self.populate_context(secret,kwds)\n  return (handler or self.handler).verify(secret,hash,**kwds)\n  \n def do_identify(self,hash):\n  ''\n  return self.handler.identify(hash)\n  \n def do_genconfig(self,**kwds):\n  ''\n  self.populate_settings(kwds)\n  return self.handler.genconfig(**kwds)\n  \n def do_genhash(self,secret,config,**kwds):\n  ''\n  secret=self.populate_context(secret,kwds)\n  return self.handler.genhash(secret,config,**kwds)\n  \n def do_stub_encrypt(self,handler=None ,context=None ,**settings):\n  ''\n\n\n  \n  handler=(handler or self.handler).using(**settings)\n  if context is None :\n   context={}\n  secret=self.populate_context(\"\",context)\n  with patch_calc_min_rounds(handler):\n   return handler.hash(secret,**context)\n   \n   \n   \n   \n   \n   \n   \n _BACKEND_NOT_AVAILABLE=\"backend not available\"\n \n @classmethod\n def _get_skip_backend_reason(cls,backend):\n  ''\n\n\n  \n  handler=cls.handler\n  if not is_default_backend(handler,backend)and not TEST_MODE(\"full\"):\n   return \"only default backend is being tested\"\n  if handler.has_backend(backend):\n   return None\n  return cls._BACKEND_NOT_AVAILABLE\n  \n @classmethod\n def create_backend_case(cls,backend):\n  handler=cls.handler\n  name=handler.name\n  assert hasattr(handler,\"backends\"),\"handler must support uh.HasManyBackends protocol\"\n  assert backend in handler.backends,\"unknown backend: %r\"%(backend,)\n  bases=(cls,)\n  if backend ==\"os_crypt\":\n   bases +=(OsCryptMixin,)\n  subcls=type(\n  \"%s_%s_test\"%(name,backend),\n  bases,\n  dict(\n  descriptionPrefix=\"%s (%s backend)\"%(name,backend),\n  backend=backend,\n  _skip_backend_reason=cls._get_skip_backend_reason(backend),\n  __module__=cls.__module__,\n  )\n  )\n  return subcls\n  \n  \n  \n _skip_backend_reason=None\n \n def _test_requires_backend(self):\n  ''\n\n  \n  meth=getattr(self,self._testMethodName,None )\n  return not getattr(meth,\"_doesnt_require_backend\",False )\n  \n  \n  \n  \n def setUp(self):\n \n \n \n  test_requires_backend=self._test_requires_backend()\n  if test_requires_backend and self._skip_backend_reason:\n   raise self.skipTest(self._skip_backend_reason)\n   \n  super(HandlerCase,self).setUp()\n  \n  \n  \n  \n  handler=self.handler\n  backend=self.backend\n  if backend:\n   if not hasattr(handler,\"set_backend\"):\n    raise RuntimeError(\"handler doesn't support multiple backends\")\n   try :\n    self.addCleanup(handler.set_backend,handler.get_backend())\n    handler.set_backend(backend)\n   except uh.exc.MissingBackendError:\n    if test_requires_backend:\n     raise\n     \n     \n     \n  from passlib.utils import handlers\n  self.patchAttr(handlers,\"rng\",self.getRandom(\"salt generator\"))\n  \n  \n  \n  \n def test_01_required_attributes(self):\n  ''\n  handler=self.handler\n  def ga(name):\n   return getattr(handler,name,None )\n   \n   \n   \n   \n  name=ga(\"name\")\n  self.assertTrue(name,\"name not defined:\")\n  self.assertIsInstance(name,str,\"name must be native str\")\n  self.assertTrue(name.lower()==name,\"name not lower-case:\")\n  self.assertTrue(re.match(\"^[a-z0-9_]+$\",name),\n  \"name must be alphanum + underscore: %r\"%(name,))\n  \n  \n  \n  \n  settings=ga(\"setting_kwds\")\n  self.assertTrue(settings is not None ,\"setting_kwds must be defined:\")\n  self.assertIsInstance(settings,tuple,\"setting_kwds must be a tuple:\")\n  \n  \n  \n  \n  context=ga(\"context_kwds\")\n  self.assertTrue(context is not None ,\"context_kwds must be defined:\")\n  self.assertIsInstance(context,tuple,\"context_kwds must be a tuple:\")\n  \n  \n  \n def test_02_config_workflow(self):\n  ''\n\n\n\n  \n  \n  \n  \n  \n  config=self.do_genconfig()\n  self.check_returned_native_str(config,\"genconfig\")\n  \n  \n  \n  \n  \n  result=self.do_genhash('stub',config)\n  self.check_returned_native_str(result,\"genhash\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self.do_verify('',config)\n  \n  \n  \n  \n  \n  \n  \n  self.assertTrue(self.do_identify(config),\n  \"identify() failed to identify genconfig() output: %r\"%\n  (config,))\n  \n def test_02_using_workflow(self):\n  ''\n  handler=self.handler\n  subcls=handler.using()\n  self.assertIsNot(subcls,handler)\n  self.assertEqual(subcls.name,handler.name)\n  \n  \n  \n def test_03_hash_workflow(self,use_16_legacy=False ):\n  ''\n\n\n\n\n  \n  wrong_secret='stub'\n  for secret in self.stock_passwords:\n  \n  \n  \n  \n   result=self.do_encrypt(secret,use_encrypt=use_16_legacy)\n   self.check_returned_native_str(result,\"hash\")\n   \n   \n   \n   \n   self.check_verify(secret,result)\n   self.check_verify(wrong_secret,result,negate=True )\n   \n   \n   \n   \n   other=self.do_genhash(secret,result)\n   self.check_returned_native_str(other,\"genhash\")\n   if self.handler.is_disabled and self.disabled_contains_salt:\n    self.assertNotEqual(other,result,\"genhash() failed to salt result \"\n    \"hash: secret=%r hash=%r: result=%r\"%\n    (secret,result,other))\n   else :\n    self.assertEqual(other,result,\"genhash() failed to reproduce \"\n    \"hash: secret=%r hash=%r: result=%r\"%\n    (secret,result,other))\n    \n    \n    \n    \n   other=self.do_genhash(wrong_secret,result)\n   self.check_returned_native_str(other,\"genhash\")\n   if self.handler.is_disabled and not self.disabled_contains_salt:\n    self.assertEqual(other,result,\"genhash() failed to reproduce \"\n    \"disabled-hash: secret=%r hash=%r other_secret=%r: result=%r\"%\n    (secret,result,wrong_secret,other))\n   else :\n    self.assertNotEqual(other,result,\"genhash() duplicated \"\n    \"hash: secret=%r hash=%r wrong_secret=%r: result=%r\"%\n    (secret,result,wrong_secret,other))\n    \n    \n    \n    \n   self.assertTrue(self.do_identify(result))\n   \n def test_03_legacy_hash_workflow(self):\n  ''\n  self.test_03_hash_workflow(use_16_legacy=True )\n  \n def test_04_hash_types(self):\n  ''\n  \n  \n  \n  \n  \n  result=self.do_encrypt(tonn('stub'))\n  self.check_returned_native_str(result,\"hash\")\n  \n  \n  self.check_verify('stub',tonn(result))\n  \n  \n  self.check_verify(tonn('stub'),tonn(result))\n  \n  \n  other=self.do_genhash('stub',tonn(result))\n  self.check_returned_native_str(other,\"genhash\")\n  if self.handler.is_disabled and self.disabled_contains_salt:\n   self.assertNotEqual(other,result)\n  else :\n   self.assertEqual(other,result)\n   \n   \n  other=self.do_genhash(tonn('stub'),tonn(result))\n  self.check_returned_native_str(other,\"genhash\")\n  if self.handler.is_disabled and self.disabled_contains_salt:\n   self.assertNotEqual(other,result)\n  else :\n   self.assertEqual(other,result)\n   \n   \n  self.assertTrue(self.do_identify(tonn(result)))\n  \n def test_05_backends(self):\n  ''\n  \n  \n  handler=self.handler\n  if not hasattr(handler,\"set_backend\"):\n   raise self.skipTest(\"handler only has one backend\")\n   \n   \n  self.addCleanup(handler.set_backend,handler.get_backend())\n  \n  \n  for backend in handler.backends:\n  \n  \n  \n  \n   self.assertIsInstance(backend,str)\n   self.assertNotIn(backend,RESERVED_BACKEND_NAMES,\n   \"invalid backend name: %r\"%(backend,))\n   \n   \n   \n   \n   ret=handler.has_backend(backend)\n   if ret is True :\n   \n    handler.set_backend(backend)\n    self.assertEqual(handler.get_backend(),backend)\n    \n   elif ret is False :\n   \n    self.assertRaises(MissingBackendError,handler.set_backend,\n    backend)\n    \n   else :\n   \n   \n    raise TypeError(\"has_backend(%r) returned invalid \"\n    \"value: %r\"%(backend,ret))\n    \n    \n    \n    \n def require_salt(self):\n  if 'salt'not in self.handler.setting_kwds:\n   raise self.skipTest(\"handler doesn't have salt\")\n   \n def require_salt_info(self):\n  self.require_salt()\n  if not has_salt_info(self.handler):\n   raise self.skipTest(\"handler doesn't provide salt info\")\n   \n def test_10_optional_salt_attributes(self):\n  ''\n  self.require_salt_info()\n  AssertionError=self.failureException\n  cls=self.handler\n  \n  \n  mx_set=(cls.max_salt_size is not None )\n  if mx_set and cls.max_salt_size <1:\n   raise AssertionError(\"max_salt_chars must be >= 1\")\n   \n   \n  if cls.min_salt_size <0:\n   raise AssertionError(\"min_salt_chars must be >= 0\")\n  if mx_set and cls.min_salt_size >cls.max_salt_size:\n   raise AssertionError(\"min_salt_chars must be <= max_salt_chars\")\n   \n   \n  if cls.default_salt_size <cls.min_salt_size:\n   raise AssertionError(\"default_salt_size must be >= min_salt_size\")\n  if mx_set and cls.default_salt_size >cls.max_salt_size:\n   raise AssertionError(\"default_salt_size must be <= max_salt_size\")\n   \n   \n   \n   \n  if 'salt_size'not in cls.setting_kwds and (not mx_set or cls.default_salt_size <cls.max_salt_size):\n   warn('%s: hash handler supports range of salt sizes, '\n   'but doesn\\'t offer \\'salt_size\\' setting'%(cls.name,))\n   \n   \n  if cls.salt_chars:\n   if not cls.default_salt_chars:\n    raise AssertionError(\"default_salt_chars must not be empty\")\n   for c in cls.default_salt_chars:\n    if c not in cls.salt_chars:\n     raise AssertionError(\"default_salt_chars must be subset of salt_chars: %r not in salt_chars\"%(c,))\n  else :\n   if not cls.default_salt_chars:\n    raise AssertionError(\"default_salt_chars MUST be specified if salt_chars is empty\")\n    \n @property\n def salt_bits(self):\n  ''\n  \n  handler=self.handler\n  assert has_salt_info(handler),\"need explicit bit-size for \"+handler.name\n  from math import log\n  \n  \n  return int(handler.default_salt_size *\n  log(len(handler.default_salt_chars),2))\n  \n def test_11_unique_salt(self):\n  ''\n  self.require_salt()\n  \n  \n  \n  \n  \n  samples=max(1,4+12 -self.salt_bits)\n  \n  def sampler(func):\n   value1=func()\n   for _ in irange(samples):\n    value2=func()\n    if value1 !=value2:\n     return\n   raise self.failureException(\"failed to find different salt after \"\n   \"%d samples\"%(samples,))\n  sampler(self.do_genconfig)\n  sampler(lambda :self.do_encrypt(\"stub\"))\n  \n def test_12_min_salt_size(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  salt_char=handler.salt_chars[0:1]\n  min_size=handler.min_salt_size\n  \n  \n  \n  \n  s1=salt_char *min_size\n  self.do_genconfig(salt=s1)\n  \n  self.do_encrypt('stub',salt_size=min_size)\n  \n  \n  \n  \n  if min_size >0:\n   self.assertRaises(ValueError,self.do_genconfig,\n   salt=s1[:-1])\n   \n  self.assertRaises(ValueError,self.do_encrypt,'stub',\n  salt_size=min_size -1)\n  \n def test_13_max_salt_size(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  max_size=handler.max_salt_size\n  salt_char=handler.salt_chars[0:1]\n  \n  \n  if max_size is None or max_size >(1 <<20):\n  \n  \n  \n  \n   s1=salt_char *1024\n   c1=self.do_stub_encrypt(salt=s1)\n   c2=self.do_stub_encrypt(salt=s1+salt_char)\n   self.assertNotEqual(c1,c2)\n   \n   self.do_stub_encrypt(salt_size=1024)\n   \n  else :\n  \n  \n  \n   s1=salt_char *max_size\n   c1=self.do_stub_encrypt(salt=s1)\n   \n   self.do_stub_encrypt(salt_size=max_size)\n   \n   \n   \n   \n   s2=s1+salt_char\n   self.assertRaises(ValueError,self.do_stub_encrypt,salt=s2)\n   \n   self.assertRaises(ValueError,self.do_stub_encrypt,salt_size=max_size+1)\n   \n   \n   \n   \n   if has_relaxed_setting(handler):\n    with warnings.catch_warnings(record=True ):\n     c2=self.do_stub_encrypt(salt=s2,relaxed=True )\n    self.assertEqual(c2,c1)\n    \n    \n    \n    \n   if handler.min_salt_size <max_size:\n    c3=self.do_stub_encrypt(salt=s1[:-1])\n    self.assertNotEqual(c3,c1)\n    \n    \n fuzz_salts_need_bcrypt_repair=False\n \n def prepare_salt(self,salt):\n  ''\n  if self.fuzz_salts_need_bcrypt_repair:\n   from passlib.utils.binary import bcrypt64\n   salt=bcrypt64.repair_unused(salt)\n  return salt\n  \n def test_14_salt_chars(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  mx=handler.max_salt_size\n  mn=handler.min_salt_size\n  cs=handler.salt_chars\n  raw=isinstance(cs,bytes)\n  \n  \n  for salt in batch(cs,mx or 32):\n   if len(salt)<mn:\n    salt=repeat_string(salt,mn)\n   salt=self.prepare_salt(salt)\n   self.do_stub_encrypt(salt=salt)\n   \n   \n  source=u('\\x00\\xff')\n  if raw:\n   source=source.encode(\"latin-1\")\n  chunk=max(mn,1)\n  for c in source:\n   if c not in cs:\n    self.assertRaises(ValueError,self.do_stub_encrypt,salt=c *chunk,\n    __msg__=\"invalid salt char %r:\"%(c,))\n    \n @property\n def salt_type(self):\n  ''\n  \n  if getattr(self.handler,\"_salt_is_bytes\",False ):\n   return bytes\n  else :\n   return unicode\n   \n def test_15_salt_type(self):\n  ''\n  self.require_salt()\n  salt_type=self.salt_type\n  salt_size=getattr(self.handler,\"min_salt_size\",0)or 8\n  \n  \n  class fake(object):\n   pass\n  self.assertRaises(TypeError,self.do_encrypt,'stub',salt=fake())\n  \n  \n  if salt_type is not unicode:\n   self.assertRaises(TypeError,self.do_encrypt,'stub',salt=u('x')*salt_size)\n   \n   \n   \n  if not (salt_type is bytes or (PY2 and salt_type is unicode)):\n   self.assertRaises(TypeError,self.do_encrypt,'stub',salt=b'x'*salt_size)\n   \n def test_using_salt_size(self):\n  ''\n  self.require_salt_info()\n  \n  handler=self.handler\n  mn=handler.min_salt_size\n  mx=handler.max_salt_size\n  df=handler.default_salt_size\n  \n  \n  self.assertRaises(ValueError,handler.using,default_salt_size=-1)\n  with self.assertWarningList([PasslibHashWarning]):\n   temp=handler.using(default_salt_size=-1,relaxed=True )\n  self.assertEqual(temp.default_salt_size,mn)\n  \n  \n  if mx:\n   self.assertRaises(ValueError,handler.using,default_salt_size=mx+1)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(default_salt_size=mx+1,relaxed=True )\n   self.assertEqual(temp.default_salt_size,mx)\n   \n   \n  if mn !=mx:\n   temp=handler.using(default_salt_size=mn+1)\n   self.assertEqual(temp.default_salt_size,mn+1)\n   self.assertEqual(handler.default_salt_size,df)\n   \n   temp=handler.using(default_salt_size=mn+2)\n   self.assertEqual(temp.default_salt_size,mn+2)\n   self.assertEqual(handler.default_salt_size,df)\n   \n   \n  if mn ==mx:\n   ref=mn\n  else :\n   ref=mn+1\n  temp=handler.using(default_salt_size=str(ref))\n  self.assertEqual(temp.default_salt_size,ref)\n  \n  \n  self.assertRaises(ValueError,handler.using,default_salt_size=str(ref)+\"xxx\")\n  \n  \n  temp=handler.using(salt_size=ref)\n  self.assertEqual(temp.default_salt_size,ref)\n  \n  \n  \n  \n def require_rounds_info(self):\n  if not has_rounds_info(self.handler):\n   raise self.skipTest(\"handler lacks rounds attributes\")\n   \n def test_20_optional_rounds_attributes(self):\n  ''\n  self.require_rounds_info()\n  \n  cls=self.handler\n  AssertionError=self.failureException\n  \n  \n  if cls.max_rounds is None :\n   raise AssertionError(\"max_rounds not specified\")\n  if cls.max_rounds <1:\n   raise AssertionError(\"max_rounds must be >= 1\")\n   \n   \n  if cls.min_rounds <0:\n   raise AssertionError(\"min_rounds must be >= 0\")\n  if cls.min_rounds >cls.max_rounds:\n   raise AssertionError(\"min_rounds must be <= max_rounds\")\n   \n   \n  if cls.default_rounds is not None :\n   if cls.default_rounds <cls.min_rounds:\n    raise AssertionError(\"default_rounds must be >= min_rounds\")\n   if cls.default_rounds >cls.max_rounds:\n    raise AssertionError(\"default_rounds must be <= max_rounds\")\n    \n    \n  if cls.rounds_cost not in rounds_cost_values:\n   raise AssertionError(\"unknown rounds cost constant: %r\"%(cls.rounds_cost,))\n   \n def test_21_min_rounds(self):\n  ''\n  self.require_rounds_info()\n  handler=self.handler\n  min_rounds=handler.min_rounds\n  \n  \n  self.do_genconfig(rounds=min_rounds)\n  self.do_encrypt('stub',rounds=min_rounds)\n  \n  \n  self.assertRaises(ValueError,self.do_genconfig,rounds=min_rounds -1)\n  self.assertRaises(ValueError,self.do_encrypt,'stub',rounds=min_rounds -1)\n  \n  \n  \n def test_21b_max_rounds(self):\n  ''\n  self.require_rounds_info()\n  handler=self.handler\n  max_rounds=handler.max_rounds\n  \n  if max_rounds is not None :\n  \n   self.assertRaises(ValueError,self.do_genconfig,rounds=max_rounds+1)\n   self.assertRaises(ValueError,self.do_encrypt,'stub',rounds=max_rounds+1)\n   \n   \n  if max_rounds is None :\n   self.do_stub_encrypt(rounds=(1 <<31)-1)\n  else :\n   self.do_stub_encrypt(rounds=max_rounds)\n   \n   \n   \n   \n   \n   \n def _create_using_rounds_helper(self):\n  ''\n\n  \n  self.require_rounds_info()\n  handler=self.handler\n  \n  if handler.name ==\"bsdi_crypt\":\n  \n   orig_handler=handler\n   handler=handler.using()\n   handler._generate_rounds=classmethod(lambda cls:super(orig_handler,cls)._generate_rounds())\n   \n   \n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  orig_default_rounds=handler.default_rounds\n  medium=((orig_max_rounds or 9999)+orig_min_rounds)//2\n  if medium ==orig_default_rounds:\n   medium +=1\n  small=(orig_min_rounds+medium)//2\n  large=((orig_max_rounds or 9999)+medium)//2\n  \n  if handler.name ==\"bsdi_crypt\":\n  \n   small |=1\n   medium |=1\n   large |=1\n   adj=2\n  else :\n   adj=1\n   \n   \n  with self.assertWarningList([]):\n   subcls=handler.using(\n   min_desired_rounds=small,\n   max_desired_rounds=large,\n   default_rounds=medium,\n   )\n   \n   \n  return handler,subcls,small,medium,large,adj\n  \n def test_has_rounds_using_harness(self):\n  ''\n\n  \n  \n  self.require_rounds_info()\n  handler=self.handler\n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  orig_default_rounds=handler.default_rounds\n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  \n  self.assertEqual(handler.min_rounds,orig_min_rounds)\n  self.assertEqual(handler.max_rounds,orig_max_rounds)\n  self.assertEqual(handler.min_desired_rounds,None )\n  self.assertEqual(handler.max_desired_rounds,None )\n  self.assertEqual(handler.default_rounds,orig_default_rounds)\n  \n  \n  self.assertEqual(subcls.min_rounds,orig_min_rounds)\n  self.assertEqual(subcls.max_rounds,orig_max_rounds)\n  self.assertEqual(subcls.default_rounds,medium)\n  self.assertEqual(subcls.min_desired_rounds,small)\n  self.assertEqual(subcls.max_desired_rounds,large)\n  \n def test_has_rounds_using_w_min_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  orig_default_rounds=handler.default_rounds\n  \n  \n  if orig_min_rounds >0:\n   self.assertRaises(ValueError,handler.using,min_desired_rounds=orig_min_rounds -adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(min_desired_rounds=orig_min_rounds -adj,relaxed=True )\n   self.assertEqual(temp.min_desired_rounds,orig_min_rounds)\n   \n   \n  if orig_max_rounds:\n   self.assertRaises(ValueError,handler.using,min_desired_rounds=orig_max_rounds+adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(min_desired_rounds=orig_max_rounds+adj,relaxed=True )\n   self.assertEqual(temp.min_desired_rounds,orig_max_rounds)\n   \n   \n  with self.assertWarningList([]):\n   temp=subcls.using(min_desired_rounds=small -adj)\n  self.assertEqual(temp.min_desired_rounds,small -adj)\n  \n  \n  temp=subcls.using(min_desired_rounds=small+2 *adj)\n  self.assertEqual(temp.min_desired_rounds,small+2 *adj)\n  \n  \n  with self.assertWarningList([]):\n   temp=subcls.using(min_desired_rounds=large+adj)\n  self.assertEqual(temp.min_desired_rounds,large+adj)\n  \n  \n  \n  self.assertEqual(get_effective_rounds(subcls,small+adj),small+adj)\n  self.assertEqual(get_effective_rounds(subcls,small),small)\n  with self.assertWarningList([]):\n   self.assertEqual(get_effective_rounds(subcls,small -adj),small -adj)\n   \n   \n  temp=handler.using(min_rounds=small)\n  self.assertEqual(temp.min_desired_rounds,small)\n  \n  \n  temp=handler.using(min_rounds=str(small))\n  self.assertEqual(temp.min_desired_rounds,small)\n  \n  \n  self.assertRaises(ValueError,handler.using,min_rounds=str(small)+\"xxx\")\n  \n def test_has_rounds_replace_w_max_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_min_rounds=handler.min_rounds\n  orig_max_rounds=handler.max_rounds\n  \n  \n  if orig_min_rounds >0:\n   self.assertRaises(ValueError,handler.using,max_desired_rounds=orig_min_rounds -adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(max_desired_rounds=orig_min_rounds -adj,relaxed=True )\n   self.assertEqual(temp.max_desired_rounds,orig_min_rounds)\n   \n   \n  if orig_max_rounds:\n   self.assertRaises(ValueError,handler.using,max_desired_rounds=orig_max_rounds+adj)\n   with self.assertWarningList([PasslibHashWarning]):\n    temp=handler.using(max_desired_rounds=orig_max_rounds+adj,relaxed=True )\n   self.assertEqual(temp.max_desired_rounds,orig_max_rounds)\n   \n   \n  with self.assertWarningList([PasslibConfigWarning]):\n   temp=subcls.using(max_desired_rounds=small -adj)\n  self.assertEqual(temp.max_desired_rounds,small)\n  \n  \n  self.assertRaises(ValueError,subcls.using,\n  min_desired_rounds=medium+adj,\n  max_desired_rounds=medium -adj)\n  \n  \n  temp=subcls.using(min_desired_rounds=large -2 *adj)\n  self.assertEqual(temp.min_desired_rounds,large -2 *adj)\n  \n  \n  with self.assertWarningList([]):\n   temp=subcls.using(max_desired_rounds=large+adj)\n  self.assertEqual(temp.max_desired_rounds,large+adj)\n  \n  \n  \n  self.assertEqual(get_effective_rounds(subcls,large -adj),large -adj)\n  self.assertEqual(get_effective_rounds(subcls,large),large)\n  with self.assertWarningList([]):\n   self.assertEqual(get_effective_rounds(subcls,large+adj),large+adj)\n   \n   \n  temp=handler.using(max_rounds=large)\n  self.assertEqual(temp.max_desired_rounds,large)\n  \n  \n  temp=handler.using(max_desired_rounds=str(large))\n  self.assertEqual(temp.max_desired_rounds,large)\n  \n  \n  self.assertRaises(ValueError,handler.using,max_desired_rounds=str(large)+\"xxx\")\n  \n def test_has_rounds_using_w_default_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_max_rounds=handler.max_rounds\n  \n  \n  \n  \n  temp=subcls.using(min_rounds=medium+adj)\n  self.assertEqual(temp.default_rounds,medium+adj)\n  \n  \n  temp=subcls.using(max_rounds=medium -adj)\n  self.assertEqual(temp.default_rounds,medium -adj)\n  \n  \n  \n  self.assertRaises(ValueError,subcls.using,default_rounds=small -adj)\n  \n  \n  \n  if orig_max_rounds:\n   self.assertRaises(ValueError,subcls.using,default_rounds=large+adj)\n   \n   \n  self.assertEqual(get_effective_rounds(subcls),medium)\n  self.assertEqual(get_effective_rounds(subcls,medium+adj),medium+adj)\n  \n  \n  temp=handler.using(default_rounds=str(medium))\n  self.assertEqual(temp.default_rounds,medium)\n  \n  \n  self.assertRaises(ValueError,handler.using,default_rounds=str(medium)+\"xxx\")\n  \n def test_has_rounds_using_w_rounds(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  orig_max_rounds=handler.max_rounds\n  \n  \n  temp=subcls.using(rounds=medium+adj)\n  self.assertEqual(temp.min_desired_rounds,medium+adj)\n  self.assertEqual(temp.default_rounds,medium+adj)\n  self.assertEqual(temp.max_desired_rounds,medium+adj)\n  \n  \n  temp=subcls.using(rounds=medium+1,min_rounds=small+adj,\n  default_rounds=medium,max_rounds=large -adj)\n  self.assertEqual(temp.min_desired_rounds,small+adj)\n  self.assertEqual(temp.default_rounds,medium)\n  self.assertEqual(temp.max_desired_rounds,large -adj)\n  \n def test_has_rounds_using_w_vary_rounds_parsing(self):\n  ''\n\n  \n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  def parse(value):\n   return subcls.using(vary_rounds=value).vary_rounds\n   \n   \n  self.assertEqual(parse(0.1),0.1)\n  self.assertEqual(parse('0.1'),0.1)\n  \n  \n  self.assertEqual(parse('10%'),0.1)\n  \n  \n  self.assertEqual(parse(1000),1000)\n  self.assertEqual(parse('1000'),1000)\n  \n  \n  self.assertRaises(ValueError,parse,-0.1)\n  self.assertRaises(ValueError,parse,1.1)\n  \n def test_has_rounds_using_w_vary_rounds_generation(self):\n  ''\n\n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  def get_effective_range(cls):\n   seen=set(get_effective_rounds(cls)for _ in irange(1000))\n   return min(seen),max(seen)\n   \n  def assert_rounds_range(vary_rounds,lower,upper):\n   temp=subcls.using(vary_rounds=vary_rounds)\n   seen_lower,seen_upper=get_effective_range(temp)\n   self.assertEqual(seen_lower,lower,\"vary_rounds had wrong lower limit:\")\n   self.assertEqual(seen_upper,upper,\"vary_rounds had wrong upper limit:\")\n   \n   \n  assert_rounds_range(0,medium,medium)\n  assert_rounds_range(\"0%\",medium,medium)\n  \n  \n  assert_rounds_range(adj,medium -adj,medium+adj)\n  assert_rounds_range(50,max(small,medium -50),min(large,medium+50))\n  \n  \n  if handler.rounds_cost ==\"log2\":\n  \n   assert_rounds_range(\"1%\",medium,medium)\n   assert_rounds_range(\"49%\",medium,medium)\n   assert_rounds_range(\"50%\",medium -adj,medium)\n  else :\n  \n  \n   lower,upper=get_effective_range(subcls.using(vary_rounds=\"50%\"))\n   \n   self.assertGreaterEqual(lower,max(small,medium *0.5))\n   self.assertLessEqual(lower,max(small,medium *0.8))\n   \n   self.assertGreaterEqual(upper,min(large,medium *1.2))\n   self.assertLessEqual(upper,min(large,medium *1.5))\n   \n def test_has_rounds_using_and_needs_update(self):\n  ''\n\n  \n  handler,subcls,small,medium,large,adj=self._create_using_rounds_helper()\n  \n  temp=subcls.using(min_desired_rounds=small+2,max_desired_rounds=large -2)\n  \n  \n  small_hash=self.do_stub_encrypt(subcls,rounds=small)\n  medium_hash=self.do_stub_encrypt(subcls,rounds=medium)\n  large_hash=self.do_stub_encrypt(subcls,rounds=large)\n  \n  \n  self.assertFalse(subcls.needs_update(small_hash))\n  self.assertFalse(subcls.needs_update(medium_hash))\n  self.assertFalse(subcls.needs_update(large_hash))\n  \n  \n  self.assertTrue(temp.needs_update(small_hash))\n  self.assertFalse(temp.needs_update(medium_hash))\n  self.assertTrue(temp.needs_update(large_hash))\n  \n  \n  \n  \n def require_many_idents(self):\n  handler=self.handler\n  if not isinstance(handler,type)or not issubclass(handler,uh.HasManyIdents):\n   raise self.skipTest(\"handler doesn't derive from HasManyIdents\")\n   \n def test_30_HasManyIdents(self):\n  ''\n  cls=self.handler\n  self.require_many_idents()\n  \n  \n  self.assertTrue('ident'in cls.setting_kwds)\n  \n  \n  for value in cls.ident_values:\n   self.assertIsInstance(value,unicode,\n   \"cls.ident_values must be unicode:\")\n  self.assertTrue(len(cls.ident_values)>1,\n  \"cls.ident_values must have 2+ elements:\")\n  \n  \n  self.assertIsInstance(cls.default_ident,unicode,\n  \"cls.default_ident must be unicode:\")\n  self.assertTrue(cls.default_ident in cls.ident_values,\n  \"cls.default_ident must specify member of cls.ident_values\")\n  \n  \n  if cls.ident_aliases:\n   for alias,ident in iteritems(cls.ident_aliases):\n    self.assertIsInstance(alias,unicode,\n    \"cls.ident_aliases keys must be unicode:\")\n    self.assertIsInstance(ident,unicode,\n    \"cls.ident_aliases values must be unicode:\")\n    self.assertTrue(ident in cls.ident_values,\n    \"cls.ident_aliases must map to cls.ident_values members: %r\"%(ident,))\n    \n    \n  handler=cls\n  hash=self.get_sample_hash()[1]\n  kwds=handler.parsehash(hash)\n  del kwds['ident']\n  \n  \n  handler(ident=cls.default_ident,**kwds)\n  \n  \n  self.assertRaises(TypeError,handler,**kwds)\n  \n  \n  handler(use_defaults=True ,**kwds)\n  \n  \n  self.assertRaises(ValueError,handler,ident='xXx',**kwds)\n  \n  \n  \n def test_has_many_idents_using(self):\n  ''\n  self.require_many_idents()\n  \n  \n  handler=self.handler\n  orig_ident=handler.default_ident\n  for alt_ident in handler.ident_values:\n   if alt_ident !=orig_ident:\n    break\n  else :\n   raise AssertionError(\"expected to find alternate ident: default=%r values=%r\"%\n   (orig_ident,handler.ident_values))\n   \n  def effective_ident(cls):\n   cls=unwrap_handler(cls)\n   return cls(use_defaults=True ).ident\n   \n   \n  subcls=handler.using()\n  self.assertEqual(subcls.default_ident,orig_ident)\n  \n  \n  subcls=handler.using(default_ident=alt_ident)\n  self.assertEqual(subcls.default_ident,alt_ident)\n  self.assertEqual(handler.default_ident,orig_ident)\n  \n  \n  \n  self.assertEqual(effective_ident(subcls),alt_ident)\n  self.assertEqual(effective_ident(handler),orig_ident)\n  \n  \n  self.assertRaises(ValueError,handler.using,default_ident='xXx')\n  \n  \n  subcls=handler.using(ident=alt_ident)\n  self.assertEqual(subcls.default_ident,alt_ident)\n  self.assertEqual(handler.default_ident,orig_ident)\n  \n  \n  self.assertRaises(TypeError,handler.using,default_ident=alt_ident,ident=alt_ident)\n  \n  \n  if handler.ident_aliases:\n   for alias,ident in handler.ident_aliases.items():\n    subcls=handler.using(ident=alias)\n    self.assertEqual(subcls.default_ident,ident,msg=\"alias %r:\"%alias)\n    \n    \n    \n    \n def test_truncate_error_setting(self):\n  ''\n\n  \n  \n  \n  hasher=self.handler\n  if hasher.truncate_size is None :\n   self.assertNotIn(\"truncate_error\",hasher.setting_kwds)\n   return\n   \n   \n   \n   \n  if not hasher.truncate_error:\n   self.assertFalse(hasher.truncate_verify_reject)\n   \n   \n   \n  if \"truncate_error\"not in hasher.setting_kwds:\n   self.assertTrue(hasher.truncate_error)\n   return\n   \n   \n  def parse_value(value):\n   return hasher.using(truncate_error=value).truncate_error\n  self.assertEqual(parse_value(None ),hasher.truncate_error)\n  self.assertEqual(parse_value(True ),True )\n  self.assertEqual(parse_value(\"true\"),True )\n  self.assertEqual(parse_value(False ),False )\n  self.assertEqual(parse_value(\"false\"),False )\n  self.assertRaises(ValueError,parse_value,\"xxx\")\n  \n def test_secret_wo_truncate_size(self):\n  ''\n\n  \n  \n  hasher=self.handler\n  if hasher.truncate_size is not None :\n   self.assertGreaterEqual(hasher.truncate_size,1)\n   raise self.skipTest(\"truncate_size is set\")\n   \n   \n   \n   \n   \n   \n   \n   \n  secret=\"too many secrets\"*16\n  alt=\"x\"\n  hash=self.do_encrypt(secret)\n  \n  \n  \n  verify_success=not hasher.is_disabled\n  self.assertEqual(self.do_verify(secret,hash),verify_success,\n  msg=\"verify rejected correct secret\")\n  \n  \n  alt_secret=secret[:-1]+alt\n  self.assertFalse(self.do_verify(alt_secret,hash),\n  \"full password not used in digest\")\n  \n def test_secret_w_truncate_size(self):\n  ''\n\n  \n  \n  \n  \n  handler=self.handler\n  truncate_size=handler.truncate_size\n  if not truncate_size:\n   raise self.skipTest(\"truncate_size not set\")\n   \n   \n   \n   \n   \n   \n  size_error_type=exc.PasswordSizeError\n  if \"truncate_error\"in handler.setting_kwds:\n   without_error=handler.using(truncate_error=False )\n   with_error=handler.using(truncate_error=True )\n   size_error_type=exc.PasswordTruncateError\n  elif handler.truncate_error:\n   without_error=None\n   with_error=handler\n  else :\n  \n   without_error=handler\n   with_error=None\n   \n   \n  base=\"too many secrets\"\n  alt=\"x\"\n  long_secret=repeat_string(base,truncate_size+1)\n  short_secret=long_secret[:-1]\n  alt_long_secret=long_secret[:-1]+alt\n  alt_short_secret=short_secret[:-1]+alt\n  \n  \n  short_verify_success=not handler.is_disabled\n  long_verify_success=short_verify_success and\\\n  not handler.truncate_verify_reject\n  \n  \n  \n  \n  \n  assert without_error or with_error\n  for cand_hasher in [without_error,with_error]:\n  \n  \n   short_hash=self.do_encrypt(short_secret,handler=cand_hasher)\n   \n   \n   self.assertEqual(self.do_verify(short_secret,short_hash,\n   handler=cand_hasher),\n   short_verify_success)\n   \n   \n   \n   self.assertFalse(self.do_verify(alt_short_secret,short_hash,\n   handler=with_error),\n   \"truncate_size value is too large\")\n   \n   \n   \n   self.assertEqual(self.do_verify(long_secret,short_hash,\n   handler=cand_hasher),\n   long_verify_success)\n   \n   \n   \n   \n   \n  if without_error:\n  \n  \n   long_hash=self.do_encrypt(long_secret,handler=without_error)\n   \n   \n   self.assertEqual(self.do_verify(long_secret,long_hash,\n   handler=without_error),\n   short_verify_success)\n   \n   \n   \n   self.assertEqual(self.do_verify(alt_long_secret,long_hash,\n   handler=without_error),\n   short_verify_success)\n   \n   \n   \n   self.assertTrue(self.do_verify(short_secret,long_hash,\n   handler=without_error))\n   \n   \n   \n   \n   \n  if with_error:\n  \n  \n   err=self.assertRaises(size_error_type,self.do_encrypt,\n   long_secret,handler=with_error)\n   self.assertEqual(err.max_size,truncate_size)\n   \n   \n   \n   \n def test_61_secret_case_sensitive(self):\n  ''\n  hash_insensitive=self.secret_case_insensitive is True\n  verify_insensitive=self.secret_case_insensitive in [True ,\n  \"verify-only\"]\n  \n  \n  lower='test'\n  upper='TEST'\n  h1=self.do_encrypt(lower)\n  if verify_insensitive and not self.handler.is_disabled:\n   self.assertTrue(self.do_verify(upper,h1),\n   \"verify() should not be case sensitive\")\n  else :\n   self.assertFalse(self.do_verify(upper,h1),\n   \"verify() should be case sensitive\")\n   \n   \n  h2=self.do_encrypt(upper)\n  if verify_insensitive and not self.handler.is_disabled:\n   self.assertTrue(self.do_verify(lower,h2),\n   \"verify() should not be case sensitive\")\n  else :\n   self.assertFalse(self.do_verify(lower,h2),\n   \"verify() should be case sensitive\")\n   \n   \n   \n   \n   \n  h2=self.do_genhash(upper,h1)\n  if hash_insensitive or (self.handler.is_disabled and not self.disabled_contains_salt):\n   self.assertEqual(h2,h1,\n   \"genhash() should not be case sensitive\")\n  else :\n   self.assertNotEqual(h2,h1,\n   \"genhash() should be case sensitive\")\n   \n def test_62_secret_border(self):\n  ''\n  hash=self.get_sample_hash()[1]\n  \n  \n  self.assertRaises(TypeError,self.do_encrypt,None )\n  self.assertRaises(TypeError,self.do_genhash,None ,hash)\n  self.assertRaises(TypeError,self.do_verify,None ,hash)\n  \n  \n  self.assertRaises(TypeError,self.do_encrypt,1)\n  self.assertRaises(TypeError,self.do_genhash,1,hash)\n  self.assertRaises(TypeError,self.do_verify,1,hash)\n  \n  \n def test_63_large_secret(self):\n  ''\n  from passlib.exc import PasswordSizeError\n  from passlib.utils import MAX_PASSWORD_SIZE\n  secret='.'*(1+MAX_PASSWORD_SIZE)\n  hash=self.get_sample_hash()[1]\n  err=self.assertRaises(PasswordSizeError,self.do_genhash,secret,hash)\n  self.assertEqual(err.max_size,MAX_PASSWORD_SIZE)\n  self.assertRaises(PasswordSizeError,self.do_encrypt,secret)\n  self.assertRaises(PasswordSizeError,self.do_verify,secret,hash)\n  \n def test_64_forbidden_chars(self):\n  ''\n  chars=self.forbidden_characters\n  if not chars:\n   raise self.skipTest(\"none listed\")\n  base=u('stub')\n  if isinstance(chars,bytes):\n   from passlib.utils.compat import iter_byte_chars\n   chars=iter_byte_chars(chars)\n   base=base.encode(\"ascii\")\n  for c in chars:\n   self.assertRaises(ValueError,self.do_encrypt,base+c+base)\n   \n   \n   \n   \n def is_secret_8bit(self,secret):\n  secret=self.populate_context(secret,{})\n  return not is_ascii_safe(secret)\n  \n def expect_os_crypt_failure(self,secret):\n  ''\n\n  \n  if PY3 and self.backend ==\"os_crypt\"and isinstance(secret,bytes):\n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n    return True\n  return False\n  \n def test_70_hashes(self):\n  ''\n  \n  \n  self.assertTrue(self.known_correct_hashes or self.known_correct_configs,\n  \"test must set at least one of 'known_correct_hashes' \"\n  \"or 'known_correct_configs'\")\n  \n  \n  saw8bit=False\n  for secret,hash in self.iter_known_hashes():\n   if self.is_secret_8bit(secret):\n    saw8bit=True\n    \n    \n   self.assertTrue(self.do_identify(hash),\n   \"identify() failed to identify hash: %r\"%(hash,))\n   \n   \n   expect_os_crypt_failure=self.expect_os_crypt_failure(secret)\n   try :\n   \n   \n    self.check_verify(secret,hash,\"verify() of known hash failed: \"\n    \"secret=%r, hash=%r\"%(secret,hash))\n    \n    \n    result=self.do_genhash(secret,hash)\n    self.assertIsInstance(result,str,\n    \"genhash() failed to return native string: %r\"%(result,))\n    if self.handler.is_disabled and self.disabled_contains_salt:\n     continue\n    self.assertEqual(result,hash,\"genhash() failed to reproduce \"\n    \"known hash: secret=%r, hash=%r: result=%r\"%\n    (secret,hash,result))\n    \n   except MissingBackendError:\n    if not expect_os_crypt_failure:\n     raise\n     \n     \n  if not saw8bit:\n   warn(\"%s: no 8-bit secrets tested\"%self.__class__)\n   \n def test_71_alternates(self):\n  ''\n  if not self.known_alternate_hashes:\n   raise self.skipTest(\"no alternate hashes provided\")\n  for alt,secret,hash in self.known_alternate_hashes:\n  \n  \n   self.assertTrue(self.do_identify(hash),\n   \"identify() failed to identify alternate hash: %r\"%\n   (hash,))\n   \n   \n   self.check_verify(secret,alt,\"verify() of known alternate hash \"\n   \"failed: secret=%r, hash=%r\"%(secret,alt))\n   \n   \n   result=self.do_genhash(secret,alt)\n   self.assertIsInstance(result,str,\n   \"genhash() failed to return native string: %r\"%(result,))\n   if self.handler.is_disabled and self.disabled_contains_salt:\n    continue\n   self.assertEqual(result,hash,\"genhash() failed to normalize \"\n   \"known alternate hash: secret=%r, alt=%r, hash=%r: \"\n   \"result=%r\"%(secret,alt,hash,result))\n   \n def test_72_configs(self):\n  ''\n  \n  if not self.handler.setting_kwds:\n   self.assertFalse(self.known_correct_configs,\n   \"handler should not have config strings\")\n   raise self.skipTest(\"hash has no settings\")\n   \n  if not self.known_correct_configs:\n  \n   raise self.skipTest(\"no config strings provided\")\n   \n   \n  if self.filter_config_warnings:\n   warnings.filterwarnings(\"ignore\",category=PasslibHashWarning)\n  for config,secret,hash in self.known_correct_configs:\n  \n  \n   self.assertTrue(self.do_identify(config),\n   \"identify() failed to identify known config string: %r\"%\n   (config,))\n   \n   \n   self.assertRaises(ValueError,self.do_verify,secret,config,\n   __msg__=\"verify() failed to reject config string: %r\"%\n   (config,))\n   \n   \n   result=self.do_genhash(secret,config)\n   self.assertIsInstance(result,str,\n   \"genhash() failed to return native string: %r\"%(result,))\n   self.assertEqual(result,hash,\"genhash() failed to reproduce \"\n   \"known hash from config: secret=%r, config=%r, hash=%r: \"\n   \"result=%r\"%(secret,config,hash,result))\n   \n def test_73_unidentified(self):\n  ''\n  if not self.known_unidentified_hashes:\n   raise self.skipTest(\"no unidentified hashes provided\")\n  for hash in self.known_unidentified_hashes:\n  \n  \n   self.assertFalse(self.do_identify(hash),\n   \"identify() incorrectly identified known unidentifiable \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_verify,'stub',hash,\n   __msg__=\"verify() failed to throw error for unidentifiable \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n   __msg__=\"genhash() failed to throw error for unidentifiable \"\n   \"hash: %r\"%(hash,))\n   \n def test_74_malformed(self):\n  ''\n  if not self.known_malformed_hashes:\n   raise self.skipTest(\"no malformed hashes provided\")\n  for hash in self.known_malformed_hashes:\n  \n  \n   self.assertTrue(self.do_identify(hash),\n   \"identify() failed to identify known malformed \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_verify,'stub',hash,\n   __msg__=\"verify() failed to throw error for malformed \"\n   \"hash: %r\"%(hash,))\n   \n   \n   self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n   __msg__=\"genhash() failed to throw error for malformed \"\n   \"hash: %r\"%(hash,))\n   \n def test_75_foreign(self):\n  ''\n  if self.accepts_all_hashes:\n   raise self.skipTest(\"not applicable\")\n  if not self.known_other_hashes:\n   raise self.skipTest(\"no foreign hashes provided\")\n  for name,hash in self.known_other_hashes:\n  \n  \n  \n  \n   if name ==self.handler.name:\n   \n    self.assertTrue(self.do_identify(hash),\n    \"identify() failed to identify known hash: %r\"%(hash,))\n    \n    \n    self.do_verify('stub',hash)\n    result=self.do_genhash('stub',hash)\n    self.assertIsInstance(result,str,\n    \"genhash() failed to return native string: %r\"%(result,))\n    \n   else :\n   \n    self.assertFalse(self.do_identify(hash),\n    \"identify() incorrectly identified hash belonging to \"\n    \"%s: %r\"%(name,hash))\n    \n    \n    self.assertRaises(ValueError,self.do_verify,'stub',hash,\n    __msg__=\"verify() failed to throw error for hash \"\n    \"belonging to %s: %r\"%(name,hash,))\n    \n    \n    self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n    __msg__=\"genhash() failed to throw error for hash \"\n    \"belonging to %s: %r\"%(name,hash))\n    \n def test_76_hash_border(self):\n  ''\n  \n  \n  \n  self.assertRaises(TypeError,self.do_identify,None )\n  self.assertRaises(TypeError,self.do_verify,'stub',None )\n  \n  \n  self.assertRaises(TypeError,self.do_genhash,'stub',None )\n  \n  \n  \n  \n  self.assertRaises(TypeError,self.do_identify,1)\n  self.assertRaises(TypeError,self.do_verify,'stub',1)\n  self.assertRaises(TypeError,self.do_genhash,'stub',1)\n  \n  \n  \n  \n  for hash in [u(''),b'']:\n   if self.accepts_all_hashes:\n   \n    self.assertTrue(self.do_identify(hash))\n    self.do_verify('stub',hash)\n    result=self.do_genhash('stub',hash)\n    self.check_returned_native_str(result,\"genhash\")\n   else :\n   \n    self.assertFalse(self.do_identify(hash),\n    \"identify() incorrectly identified empty hash\")\n    self.assertRaises(ValueError,self.do_verify,'stub',hash,\n    __msg__=\"verify() failed to reject empty hash\")\n    self.assertRaises(ValueError,self.do_genhash,'stub',hash,\n    __msg__=\"genhash() failed to reject empty hash\")\n    \n    \n    \n    \n  self.do_identify('\\xe2\\x82\\xac\\xc2\\xa5$')\n  self.do_identify('abc\\x91\\x00')\n  \n  \n  \n  \n  \n  \n known_parsehash_results=[]\n \n def require_parsehash(self):\n  if not hasattr(self.handler,\"parsehash\"):\n   raise SkipTest(\"parsehash() not implemented\")\n   \n def test_70_parsehash(self):\n  ''\n\n  \n  \n  \n  self.require_parsehash()\n  handler=self.handler\n  \n  \n  hash=self.do_encrypt(\"stub\")\n  result=handler.parsehash(hash)\n  self.assertIsInstance(result,dict)\n  \n  \n  \n  \n  result2=handler.parsehash(hash,checksum=False )\n  correct2=result.copy()\n  correct2.pop(\"checksum\",None )\n  self.assertEqual(result2,correct2)\n  \n  \n  \n  \n  result3=handler.parsehash(hash,sanitize=True )\n  correct3=result.copy()\n  if PY2:\n  \n  \n   warnings.filterwarnings(\"ignore\",\".*unequal comparison failed to convert.*\",\n   category=UnicodeWarning)\n  for key in (\"salt\",\"checksum\"):\n   if key in result3:\n    self.assertNotEqual(result3[key],correct3[key])\n    self.assert_is_masked(result3[key])\n    correct3[key]=result3[key]\n  self.assertEqual(result3,correct3)\n  \n def assert_is_masked(self,value):\n  ''\n\n  \n  if value is None :\n   return\n  self.assertIsInstance(value,unicode)\n  \n  \n  ref=value if len(value)<8 else value[4:]\n  if set(ref)==set([\"*\"]):\n   return True\n  raise self.fail(\"value not masked: %r\"%value)\n  \n def test_71_parsehash_results(self):\n  ''\n\n  \n  self.require_parsehash()\n  samples=self.known_parsehash_results\n  if not samples:\n   raise self.skipTest(\"no samples present\")\n   \n   \n  for hash,correct in self.known_parsehash_results:\n   result=self.handler.parsehash(hash)\n   self.assertEqual(result,correct,\"hash=%r:\"%hash)\n   \n   \n   \n   \n def test_77_fuzz_input(self,threaded=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.handler.is_disabled:\n   raise self.skipTest(\"not applicable\")\n   \n   \n  from passlib.utils import tick\n  max_time=self.max_fuzz_time\n  if max_time <=0:\n   raise self.skipTest(\"disabled by test mode\")\n  verifiers=self.get_fuzz_verifiers(threaded=threaded)\n  def vname(v):\n   return (v.__doc__ or v.__name__).splitlines()[0]\n   \n   \n   \n   \n  if threaded:\n   thread_name=threading.current_thread().name\n  else :\n   thread_name=\"fuzz test\"\n  rng=self.getRandom(name=thread_name)\n  generator=self.FuzzHashGenerator(self,rng)\n  \n  \n  log.debug(\"%s: %s: started; max_time=%r verifiers=%d (%s)\",\n  self.descriptionPrefix,thread_name,max_time,len(verifiers),\n  \", \".join(vname(v)for v in verifiers))\n  start=tick()\n  stop=start+max_time\n  count=0\n  while tick()<=stop:\n  \n   opts=generator.generate()\n   secret=opts['secret']\n   other=opts['other']\n   settings=opts['settings']\n   ctx=opts['context']\n   if ctx:\n    settings['context']=ctx\n    \n    \n   hash=self.do_encrypt(secret,**settings)\n   \n   \n   \n   \n   for verify in verifiers:\n    name=vname(verify)\n    result=verify(secret,hash,**ctx)\n    if result ==\"skip\":\n     continue\n    assert result is True or result is False\n    if not result:\n     raise self.failureException(\"failed to verify against %r verifier: \"\n     \"secret=%r config=%r hash=%r\"%\n     (name,secret,settings,hash))\n     \n     \n    if rng.random()<.1:\n     result=verify(other,hash,**ctx)\n     if result and result !=\"skip\":\n      raise self.failureException(\"was able to verify wrong \"\n      \"password using %s: wrong_secret=%r real_secret=%r \"\n      \"config=%r hash=%r\"%(name,other,secret,settings,hash))\n   count +=1\n   \n  log.debug(\"%s: %s: done; elapsed=%r count=%r\",\n  self.descriptionPrefix,thread_name,tick()-start,count)\n  \n def test_78_fuzz_threading(self):\n  ''\n\n\n\n\n  \n  self.require_TEST_MODE(\"full\")\n  import threading\n  \n  \n  if self.handler.is_disabled:\n   raise self.skipTest(\"not applicable\")\n  thread_count=self.fuzz_thread_count\n  if thread_count <1 or self.max_fuzz_time <=0:\n   raise self.skipTest(\"disabled by test mode\")\n   \n   \n  failed_lock=threading.Lock()\n  failed=[0]\n  \n  \n  \n  \n  def wrapper():\n   try :\n    self.test_77_fuzz_input(threaded=True )\n   except SkipTest:\n    pass\n   except :\n    with failed_lock:\n     failed[0]+=1\n    raise\n  def launch(n):\n   cls=type(self)\n   name=\"Fuzz-Thread-%d ('%s:%s.%s')\"%(n,cls.__module__,cls.__name__,\n   self._testMethodName)\n   thread=threading.Thread(target=wrapper,name=name)\n   thread.setDaemon(True )\n   thread.start()\n   return thread\n  threads=[launch(n)for n in irange(thread_count)]\n  \n  \n  timeout=self.max_fuzz_time *thread_count *4\n  stalled=0\n  for thread in threads:\n   thread.join(timeout)\n   if not thread.is_alive():\n    continue\n    \n   log.error(\"%s timed out after %f seconds\",thread.name,timeout)\n   stalled +=1\n   \n   \n  if failed[0]:\n   raise self.fail(\"%d/%d threads failed concurrent fuzz testing \"\n   \"(see error log for details)\"%(failed[0],thread_count))\n  if stalled:\n   raise self.fail(\"%d/%d threads stalled during concurrent fuzz testing \"\n   \"(see error log for details)\"%(stalled,thread_count))\n   \n   \n   \n   \n   \n @property\n def max_fuzz_time(self):\n  ''\n  value=float(os.environ.get(\"PASSLIB_TEST_FUZZ_TIME\")or 0)\n  if value:\n   return value\n  elif TEST_MODE(max=\"quick\"):\n   return 0\n  elif TEST_MODE(max=\"default\"):\n   return 1\n  else :\n   return 5\n   \n @property\n def fuzz_thread_count(self):\n  ''\n  value=int(os.environ.get(\"PASSLIB_TEST_FUZZ_THREADS\")or 0)\n  if value:\n   return value\n  elif TEST_MODE(max=\"quick\"):\n   return 0\n  else :\n   return 10\n   \n   \n   \n   \n   \n   \n   \n   \n fuzz_verifiers=(\"fuzz_verifier_default\",)\n \n def get_fuzz_verifiers(self,threaded=False ):\n  ''\n\n\n\n\n  \n  handler=self.handler\n  verifiers=[]\n  \n  \n  for method_name in self.fuzz_verifiers:\n   func=getattr(self,method_name)()\n   if func is not None :\n    verifiers.append(func)\n    \n    \n    \n    \n  if hasattr(handler,\"backends\")and TEST_MODE(\"full\")and not threaded:\n   def maker(backend):\n    def func(secret,hash):\n     orig_backend=handler.get_backend()\n     try :\n      handler.set_backend(backend)\n      return handler.verify(secret,hash)\n     finally :\n      handler.set_backend(orig_backend)\n    func.__name__=\"check_\"+backend+\"_backend\"\n    func.__doc__=backend+\"-backend\"\n    return func\n   for backend in iter_alt_backends(handler):\n    verifiers.append(maker(backend))\n    \n  return verifiers\n  \n def fuzz_verifier_default(self):\n \n  def check_default(secret,hash,**ctx):\n   return self.do_verify(secret,hash,**ctx)\n  if self.backend:\n   check_default.__doc__=self.backend+\"-backend\"\n  else :\n   check_default.__doc__=\"self\"\n  return check_default\n  \n  \n  \n  \n class FuzzHashGenerator(object):\n  ''\n\n\n\n  \n  \n  \n  \n  \n  \n  password_alphabet=u('qwertyASDF1234<>.@*#! \\u00E1\\u0259\\u0411\\u2113')\n  \n  \n  password_encoding=\"utf-8\"\n  \n  \n  \n  \n  settings_map=dict(rounds=\"random_rounds\",\n  salt_size=\"random_salt_size\",\n  ident=\"random_ident\")\n  \n  \n  context_map={}\n  \n  \n  \n  \n  \n  def __init__(self,test,rng):\n   self.test=test\n   self.handler=test.handler\n   self.rng=rng\n   \n  def generate(self):\n   ''\n\n\n\n   \n   def gendict(map):\n    out={}\n    for key,meth in map.items():\n     value=getattr(self,meth)()\n     if value is not None :\n      out[key]=value\n    return out\n   secret,other=self.random_password_pair()\n   return dict(secret=secret,\n   other=other,\n   settings=gendict(self.settings_map),\n   context=gendict(self.context_map),\n   )\n   \n   \n   \n   \n  def randintgauss(self,lower,upper,mu,sigma):\n   ''\n   value=self.rng.normalvariate(mu,sigma)\n   return int(limit(value,lower,upper))\n   \n   \n   \n   \n   \n  def random_rounds(self):\n   handler=self.handler\n   if not has_rounds_info(handler):\n    return None\n   default=handler.default_rounds or handler.min_rounds\n   lower=handler.min_rounds\n   if handler.rounds_cost ==\"log2\":\n    upper=default\n   else :\n    upper=min(default *2,handler.max_rounds)\n   return self.randintgauss(lower,upper,default,default *.5)\n   \n  def random_salt_size(self):\n   handler=self.handler\n   if not (has_salt_info(handler)and 'salt_size'in handler.setting_kwds):\n    return None\n   default=handler.default_salt_size\n   lower=handler.min_salt_size\n   upper=handler.max_salt_size or default *4\n   return self.randintgauss(lower,upper,default,default *.5)\n   \n  def random_ident(self):\n   rng=self.rng\n   handler=self.handler\n   if 'ident'not in handler.setting_kwds or not hasattr(handler,\"ident_values\"):\n    return None\n   if rng.random()<.5:\n    return None\n    \n   handler=getattr(handler,\"wrapped\",handler)\n   return rng.choice(handler.ident_values)\n   \n   \n   \n   \n  def random_password_pair(self):\n   ''\n   secret=self.random_password()\n   while True :\n    other=self.random_password()\n    if self.accept_password_pair(secret,other):\n     break\n   rng=self.rng\n   if rng.randint(0,1):\n    secret=secret.encode(self.password_encoding)\n   if rng.randint(0,1):\n    other=other.encode(self.password_encoding)\n   return secret,other\n   \n  def random_password(self):\n   ''\n   \n   rng=self.rng\n   if rng.random()<.0001:\n    return u('')\n    \n    \n   handler=self.handler\n   truncate_size=handler.truncate_error and handler.truncate_size\n   max_size=truncate_size or 999999\n   \n   \n   if max_size <50 or rng.random()<.5:\n   \n    size=self.randintgauss(1,min(max_size,50),15,15)\n   else :\n   \n    size=self.randintgauss(50,min(max_size,99),70,20)\n    \n    \n   result=getrandstr(rng,self.password_alphabet,size)\n   \n   \n   if truncate_size and isinstance(result,unicode):\n    while len(result.encode(\"utf-8\"))>truncate_size:\n     result=result[:-1]\n     \n   return result\n   \n  def accept_password_pair(self,secret,other):\n   ''\n   return secret !=other\n   \n   \n   \n   \n   \n   \n   \n   \n   \n def test_disable_and_enable(self):\n  ''\n  \n  \n  \n  handler=self.handler\n  if not handler.is_disabled:\n   self.assertFalse(hasattr(handler,\"disable\"))\n   self.assertFalse(hasattr(handler,\"enable\"))\n   self.assertFalse(self.disabled_contains_salt)\n   raise self.skipTest(\"not applicable\")\n   \n   \n   \n   \n   \n   \n  disabled_default=handler.disable()\n  self.assertIsInstance(disabled_default,str,\n  msg=\"disable() must return native string\")\n  self.assertTrue(handler.identify(disabled_default),\n  msg=\"identify() didn't recognize disable() result: %r\"%(disabled_default))\n  \n  \n  stub=self.getRandom().choice(self.known_other_hashes)[1]\n  disabled_stub=handler.disable(stub)\n  self.assertIsInstance(disabled_stub,str,\n  msg=\"disable() must return native string\")\n  self.assertTrue(handler.identify(disabled_stub),\n  msg=\"identify() didn't recognize disable() result: %r\"%(disabled_stub))\n  \n  \n  \n  \n  \n  \n  self.assertRaisesRegex(ValueError,\"cannot restore original hash\",\n  handler.enable,disabled_default)\n  \n  \n  try :\n   result=handler.enable(disabled_stub)\n   error=None\n  except ValueError as e:\n   result=None\n   error=e\n   \n  if error is None :\n  \n   self.assertIsInstance(result,str,\n   msg=\"enable() must return native string\")\n   self.assertEqual(result,stub)\n  else :\n  \n   self.assertIsInstance(error,ValueError)\n   self.assertRegex(\"cannot restore original hash\",str(error))\n   \n   \n   \n   \n   \n   \n  disabled_default2=handler.disable()\n  if self.disabled_contains_salt:\n  \n   self.assertNotEqual(disabled_default2,disabled_default)\n  elif error is None :\n  \n   self.assertEqual(disabled_default2,disabled_default)\n   \n   \n  disabled_stub2=handler.disable(stub)\n  if self.disabled_contains_salt:\n  \n   self.assertNotEqual(disabled_stub2,disabled_stub)\n  else :\n  \n   self.assertEqual(disabled_stub2,disabled_stub)\n   \n   \n  disabled_other=handler.disable(stub+'xxx')\n  if self.disabled_contains_salt or error is None :\n  \n   self.assertNotEqual(disabled_other,disabled_stub)\n  else :\n  \n   self.assertEqual(disabled_other,disabled_stub)\n   \n   \n   \n   \n   \n   \n   \n   \nclass OsCryptMixin(HandlerCase):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n platform_crypt_support=[]\n \n \n \n \n __unittest_skip=True\n \n \n backend=\"os_crypt\"\n \n \n using_patched_crypt=False\n \n \n \n \n def setUp(self):\n  assert self.backend ==\"os_crypt\"\n  if not self.handler.has_backend(\"os_crypt\"):\n  \n   self._patch_safe_crypt()\n  super(OsCryptMixin,self).setUp()\n  \n @classmethod\n def _get_safe_crypt_handler_backend(cls):\n  ''\n\n\n  \n  \n  handler=unwrap_handler(cls.handler)\n  \n  \n  handler.get_backend()\n  \n  \n  alt_backend=get_alt_backend(handler,\"os_crypt\")\n  return handler,alt_backend\n  \n @property\n def has_os_crypt_fallback(self):\n  ''\n\n\n  \n  return self._get_safe_crypt_handler_backend()[0]is not None\n  \n def _patch_safe_crypt(self):\n  ''\n\n\n\n  \n  \n  handler,alt_backend=self._get_safe_crypt_handler_backend()\n  if not alt_backend:\n   raise AssertionError(\"handler has no available alternate backends!\")\n   \n   \n  alt_handler=handler.using()\n  alt_handler.set_backend(alt_backend)\n  \n  def crypt_stub(secret,hash):\n   hash=alt_handler.genhash(secret,hash)\n   assert isinstance(hash,str)\n   return hash\n   \n  import passlib.utils as mod\n  self.patchAttr(mod,\"_crypt\",crypt_stub)\n  self.using_patched_crypt=True\n  \n @classmethod\n def _get_skip_backend_reason(cls,backend):\n  ''\n\n\n  \n  assert backend ==\"os_crypt\"\n  reason=super(OsCryptMixin,cls)._get_skip_backend_reason(backend)\n  \n  from passlib.utils import has_crypt\n  if reason ==cls._BACKEND_NOT_AVAILABLE and has_crypt:\n   if TEST_MODE(\"full\")and cls._get_safe_crypt_handler_backend()[1]:\n   \n   \n    return None\n   else :\n    return \"hash not supported by os crypt()\"\n    \n  return reason\n  \n  \n  \n  \n  \n  \n def _use_mock_crypt(self):\n  ''\n\n\n\n  \n  import passlib.utils as mod\n  \n  def mock_crypt(secret,config):\n  \n   if secret ==\"test\":\n    return mock_crypt.__wrapped__(secret,config)\n   else :\n    return mock_crypt.return_value\n    \n  mock_crypt.__wrapped__=mod._crypt\n  mock_crypt.return_value=None\n  \n  self.patchAttr(mod,\"_crypt\",mock_crypt)\n  \n  return mock_crypt\n  \n def test_80_faulty_crypt(self):\n  ''\n  hash=self.get_sample_hash()[1]\n  exc_types=(exc.InternalBackendError,)\n  mock_crypt=self._use_mock_crypt()\n  \n  def test(value):\n  \n  \n   mock_crypt.return_value=value\n   self.assertRaises(exc_types,self.do_genhash,\"stub\",hash)\n   self.assertRaises(exc_types,self.do_encrypt,\"stub\")\n   self.assertRaises(exc_types,self.do_verify,\"stub\",hash)\n   \n  test('$x'+hash[2:])\n  test(hash[:-1])\n  test(hash+'x')\n  \n def test_81_crypt_fallback(self):\n  ''\n  \n  \n  mock_crypt=self._use_mock_crypt()\n  mock_crypt.return_value=None\n  \n  if self.has_os_crypt_fallback:\n  \n   h1=self.do_encrypt(\"stub\")\n   h2=self.do_genhash(\"stub\",h1)\n   self.assertEqual(h2,h1)\n   self.assertTrue(self.do_verify(\"stub\",h1))\n  else :\n  \n   from passlib.exc import InternalBackendError as err_type\n   hash=self.get_sample_hash()[1]\n   self.assertRaises(err_type,self.do_encrypt,'stub')\n   self.assertRaises(err_type,self.do_genhash,'stub',hash)\n   self.assertRaises(err_type,self.do_verify,'stub',hash)\n   \n @doesnt_require_backend\n def test_82_crypt_support(self):\n  ''\n\n\n\n\n\n  \n  \n  \n  if hasattr(self.handler,\"orig_prefix\"):\n   raise self.skipTest(\"not applicable to wrappers\")\n   \n   \n   \n   \n   \n  using_backend=not self.using_patched_crypt\n  name=self.handler.name\n  platform=sys.platform\n  for pattern,expected in self.platform_crypt_support:\n   if re.match(pattern,platform):\n    break\n  else :\n   raise self.skipTest(\"no data for %r platform (current host support = %r)\"%\n   (platform,using_backend))\n   \n   \n   \n  if expected is None :\n   raise self.skipTest(\"varied support on %r platform (current host support = %r)\"%\n   (platform,using_backend))\n   \n   \n  if expected ==using_backend:\n   pass\n  elif expected:\n   self.fail(\"expected %r platform would have native support for %r\"%\n   (platform,name))\n  else :\n   self.fail(\"did not expect %r platform would have native support for %r\"%\n   (platform,name))\n   \n   \n   \n   \n   \n def fuzz_verifier_crypt(self):\n  ''\n  \n  \n  \n  handler=self.handler\n  if self.using_patched_crypt or hasattr(handler,\"wrapped\"):\n   return None\n   \n   \n  from crypt import crypt\n  from passlib.utils import _safe_crypt_lock\n  encoding=self.FuzzHashGenerator.password_encoding\n  \n  def check_crypt(secret,hash):\n   ''\n   if not self.crypt_supports_variant(hash):\n    return \"skip\"\n    \n   secret=to_native_str(secret,encoding)\n   with _safe_crypt_lock:\n    return crypt(secret,hash)==hash\n    \n  return check_crypt\n  \n def crypt_supports_variant(self,hash):\n  ''\n\n\n  \n  return True\n  \n  \n  \n  \n  \nclass UserHandlerMixin(HandlerCase):\n ''\n\n\n\n\n\n \n \n \n \n default_user=\"user\"\n requires_user=True\n user_case_insensitive=False\n \n \n \n \n __unittest_skip=True\n \n \n \n \n def test_80_user(self):\n  ''\n  handler=self.handler\n  password='stub'\n  hash=handler.hash(password,user=self.default_user)\n  \n  if self.requires_user:\n   self.assertRaises(TypeError,handler.hash,password)\n   self.assertRaises(TypeError,handler.genhash,password,hash)\n   self.assertRaises(TypeError,handler.verify,password,hash)\n  else :\n  \n   handler.hash(password)\n   handler.genhash(password,hash)\n   handler.verify(password,hash)\n   \n def test_81_user_case(self):\n  ''\n  lower=self.default_user.lower()\n  upper=lower.upper()\n  hash=self.do_encrypt('stub',context=dict(user=lower))\n  if self.user_case_insensitive:\n   self.assertTrue(self.do_verify('stub',hash,user=upper),\n   \"user should not be case sensitive\")\n  else :\n   self.assertFalse(self.do_verify('stub',hash,user=upper),\n   \"user should be case sensitive\")\n   \n def test_82_user_salt(self):\n  ''\n  config=self.do_stub_encrypt()\n  h1=self.do_genhash('stub',config,user='admin')\n  h2=self.do_genhash('stub',config,user='admin')\n  self.assertEqual(h2,h1)\n  h3=self.do_genhash('stub',config,user='root')\n  self.assertNotEqual(h3,h1)\n  \n  \n  \n  \n  \n  \n def populate_context(self,secret,kwds):\n  ''\n  if isinstance(secret,tuple):\n   secret,user=secret\n  elif not self.requires_user:\n   return secret\n  else :\n   user=self.default_user\n  if 'user'not in kwds:\n   kwds['user']=user\n  return secret\n  \n  \n  \n  \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  context_map=HandlerCase.FuzzHashGenerator.context_map.copy()\n  context_map.update(user=\"random_user\")\n  \n  user_alphabet=u(\"asdQWE123\")\n  \n  def random_user(self):\n   rng=self.rng\n   if not self.test.requires_user and rng.random()<.1:\n    return None\n   return getrandstr(rng,self.user_alphabet,rng.randint(2,10))\n   \n   \n   \n   \n   \nclass EncodingHandlerMixin(HandlerCase):\n ''\n\n\n\n\n\n \n \n \n \n __unittest_skip=True\n \n \n \n stock_passwords=[\n u(\"test\"),\n b\"test\",\n u(\"\\u00AC\\u00BA\"),\n ]\n \n class FuzzHashGenerator(HandlerCase.FuzzHashGenerator):\n \n  password_alphabet=u('qwerty1234<>.@*#! \\u00AC')\n  \n def populate_context(self,secret,kwds):\n  ''\n  if isinstance(secret,tuple):\n   secret,encoding=secret\n   kwds.setdefault('encoding',encoding)\n  return secret\n  \n  \n  \n  \n  \n  \n  \nclass reset_warnings(warnings.catch_warnings):\n ''\n \n def __init__(self,reset_filter=\"always\",reset_registry=\".*\",**kwds):\n  super(reset_warnings,self).__init__(**kwds)\n  self._reset_filter=reset_filter\n  self._reset_registry=re.compile(reset_registry)if reset_registry else None\n  \n def __enter__(self):\n \n  ret=super(reset_warnings,self).__enter__()\n  \n  \n  if self._reset_filter:\n   warnings.resetwarnings()\n   warnings.simplefilter(self._reset_filter)\n   \n   \n   \n  pattern=self._reset_registry\n  if pattern:\n   backup=self._orig_registry={}\n   for name,mod in list(sys.modules.items()):\n    if mod is None or not pattern.match(name):\n     continue\n    reg=getattr(mod,\"__warningregistry__\",None )\n    if reg:\n     backup[name]=reg.copy()\n     reg.clear()\n  return ret\n  \n def __exit__(self,*exc_info):\n \n  pattern=self._reset_registry\n  if pattern:\n  \n   backup=self._orig_registry\n   for name,mod in list(sys.modules.items()):\n    if mod is None or not pattern.match(name):\n     continue\n    reg=getattr(mod,\"__warningregistry__\",None )\n    if reg:\n     reg.clear()\n    orig=backup.get(name)\n    if orig:\n     if reg is None :\n      setattr(mod,\"__warningregistry__\",orig)\n     else :\n      reg.update(orig)\n  super(reset_warnings,self).__exit__(*exc_info)\n  \n  \n  \n  \n", ["__future__", "binascii", "contextlib", "crypt", "functools", "google.appengine", "hashlib", "logging", "math", "os", "passlib", "passlib.exc", "passlib.registry", "passlib.tests.backports", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers", "random", "re", "sys", "tempfile", "threading", "time", "timeit", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_handlers_pbkdf2": [".py", "''\n\n\n\n\nimport logging\nlog=logging.getLogger(__name__)\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.utils.compat import u\nfrom passlib.tests.utils import TestCase,HandlerCase\nfrom passlib.tests.test_handlers import UPASS_WAV\n\n\n\n\n\n\n\n\nclass ldap_pbkdf2_test(TestCase):\n\n def test_wrappers(self):\n  ''\n  \n  self.assertTrue(\n  hash.ldap_pbkdf2_sha1.verify(\n  \"password\",\n  '{PBKDF2}1212$OB.dtnSEXZK8U5cgxU/GYQ$y5LKPOplRmok7CZp/aqVDVg8zGI',\n  )\n  )\n  \n  self.assertTrue(\n  hash.ldap_pbkdf2_sha256.verify(\n  \"password\",\n  '{PBKDF2-SHA256}1212$4vjV83LKPjQzk31VI4E0Vw$hsYF68OiOUPdDZ1Fg'\n  '.fJPeq1h/gXXY7acBp9/6c.tmQ'\n  )\n  )\n  \n  self.assertTrue(\n  hash.ldap_pbkdf2_sha512.verify(\n  \"password\",\n  '{PBKDF2-SHA512}1212$RHY0Fr3IDMSVO/RSZyb5ow$eNLfBK.eVozomMr.1gYa1'\n  '7k9B7KIK25NOEshvhrSX.esqY3s.FvWZViXz4KoLlQI.BzY/YTNJOiKc5gBYFYGww'\n  )\n  )\n  \n  \n  \n  \nclass atlassian_pbkdf2_sha1_test(HandlerCase):\n handler=hash.atlassian_pbkdf2_sha1\n \n known_correct_hashes=[\n \n \n \n (\"admin\",'{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy60IPksHChwoTAVYFrhsgoq8/p'),\n (UPASS_WAV,\n \"{PKCS5S2}cE9Yq6Am5tQGdHSHhky2XLeOnURwzaLBG2sur7FHKpvy2u0qDn6GcVGRjlmJoIUy\"),\n ]\n \n known_malformed_hashes=[\n \n '{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy!0IPksHChwoTAVYFrhsgoq8/p'\n \n \n '{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy60IPksHChwoTAVYFrhsgoq8/'\n \n \n '{PKCS5S2}c4xaeTQM0lUieMS3V5voiexyX9XhqC2dBd5ecVy60IPksHChwoTAVYFrhsgoq8/='\n ]\n \nclass pbkdf2_sha1_test(HandlerCase):\n handler=hash.pbkdf2_sha1\n known_correct_hashes=[\n (\"password\",'$pbkdf2$1212$OB.dtnSEXZK8U5cgxU/GYQ$y5LKPOplRmok7CZp/aqVDVg8zGI'),\n (UPASS_WAV,\n '$pbkdf2$1212$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc'),\n ]\n \n known_malformed_hashes=[\n \n '$pbkdf2$01212$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc',\n \n \n '$pbkdf2$$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc',\n \n \n '$pbkdf2$1212$THDqatpidANpadlLeTeOEg$HV3oi1k5C5LQCgG1BMOL.BX4YZc$',\n ]\n \nclass pbkdf2_sha256_test(HandlerCase):\n handler=hash.pbkdf2_sha256\n known_correct_hashes=[\n (\"password\",\n '$pbkdf2-sha256$1212$4vjV83LKPjQzk31VI4E0Vw$hsYF68OiOUPdDZ1Fg.fJPeq1h/gXXY7acBp9/6c.tmQ'\n ),\n (UPASS_WAV,\n '$pbkdf2-sha256$1212$3SABFJGDtyhrQMVt1uABPw$WyaUoqCLgvz97s523nF4iuOqZNbp5Nt8do/cuaa7AiI'\n ),\n ]\n \nclass pbkdf2_sha512_test(HandlerCase):\n handler=hash.pbkdf2_sha512\n known_correct_hashes=[\n (\"password\",\n '$pbkdf2-sha512$1212$RHY0Fr3IDMSVO/RSZyb5ow$eNLfBK.eVozomMr.1gYa1'\n '7k9B7KIK25NOEshvhrSX.esqY3s.FvWZViXz4KoLlQI.BzY/YTNJOiKc5gBYFYGww'\n ),\n (UPASS_WAV,\n '$pbkdf2-sha512$1212$KkbvoKGsAIcF8IslDR6skQ$8be/PRmd88Ps8fmPowCJt'\n 'tH9G3vgxpG.Krjt3KT.NP6cKJ0V4Prarqf.HBwz0dCkJ6xgWnSj2ynXSV7MlvMa8Q'\n ),\n ]\n \nclass cta_pbkdf2_sha1_test(HandlerCase):\n handler=hash.cta_pbkdf2_sha1\n known_correct_hashes=[\n \n \n \n (u(\"hashy the \\N{SNOWMAN}\"),'$p5k2$1000$ZxK4ZBJCfQg=$jJZVscWtO--p1-xIZl6jhO2LKR0='),\n \n \n \n \n (\"password\",\"$p5k2$1$$h1TDLGSw9ST8UMAPeIE13i0t12c=\"),\n (UPASS_WAV,\n \"$p5k2$4321$OTg3NjU0MzIx$jINJrSvZ3LXeIbUdrJkRpN62_WQ=\"),\n ]\n \nclass dlitz_pbkdf2_sha1_test(HandlerCase):\n handler=hash.dlitz_pbkdf2_sha1\n known_correct_hashes=[\n \n \n \n ('cloadm','$p5k2$$exec$r1EWMCMk7Rlv3L/RNcFXviDefYa0hlql'),\n ('gnu','$p5k2$c$u9HvcT4d$Sd1gwSVCLZYAuqZ25piRnbBEoAesaa/g'),\n ('dcl','$p5k2$d$tUsch7fU$nqDkaxMDOFBeJsTSfABsyn.PYUXilHwL'),\n ('spam','$p5k2$3e8$H0NX9mT/$wk/sE8vv6OMKuMaqazCJYDSUhWY9YB2J'),\n (UPASS_WAV,\n '$p5k2$$KosHgqNo$9mjN8gqjt02hDoP0c2J0ABtLIwtot8cQ'),\n ]\n \nclass grub_pbkdf2_sha512_test(HandlerCase):\n handler=hash.grub_pbkdf2_sha512\n known_correct_hashes=[\n \n \n \n \n \n (UPASS_WAV,\n 'grub.pbkdf2.sha512.10000.BCAC1CEC5E4341C8C511C529'\n '7FA877BE91C2817B32A35A3ECF5CA6B8B257F751.6968526A'\n '2A5B1AEEE0A29A9E057336B48D388FFB3F600233237223C21'\n '04DE1752CEC35B0DD1ED49563398A282C0F471099C2803FBA'\n '47C7919CABC43192C68F60'),\n \n \n ('toomanysecrets',\n 'grub.pbkdf2.sha512.10000.9B436BB6978682363D5C449B'\n 'BEAB322676946C632208BC1294D51F47174A9A3B04A7E4785'\n '986CD4EA7470FAB8FE9F6BD522D1FC6C51109A8596FB7AD48'\n '7C4493.0FE5EF169AFFCB67D86E2581B1E251D88C777B98BA'\n '2D3256ECC9F765D84956FC5CA5C4B6FD711AA285F0A04DCF4'\n '634083F9A20F4B6F339A52FBD6BED618E527B'),\n \n ]\n \n \n \n \nclass scram_test(HandlerCase):\n handler=hash.scram\n \n \n \n known_correct_hashes=[\n \n \n \n ('pencil','$scram$4096$QSXCR.Q6sek8bf92$'\n 'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30'),\n \n \n \n \n \n \n ('pencil','$scram$4096$QSXCR.Q6sek8bf92$'\n 'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n 'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY,'\n 'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n 'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ'),\n \n \n \n (u('IX \\xE0'),'$scram$6400$0BojBCBE6P2/N4bQ$'\n 'sha-1=YniLes.b8WFMvBhtSACZyyvxeCc'),\n (u('\\u2168\\u3000a\\u0300'),'$scram$6400$0BojBCBE6P2/N4bQ$'\n 'sha-1=YniLes.b8WFMvBhtSACZyyvxeCc'),\n (u('\\u00ADIX \\xE0'),'$scram$6400$0BojBCBE6P2/N4bQ$'\n 'sha-1=YniLes.b8WFMvBhtSACZyyvxeCc'),\n ]\n \n known_malformed_hashes=[\n \n '$scram$04096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$409A$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf9-$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX3-',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92',\n '$scram$4096$QSXCR.Q6sek8bf92$',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30$',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30'\n 'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n 'shaxxx-190=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha-256=HZbuOlKbWl.eR8AfIposuKbhX30',\n \n \n '$scram$4096$QSXCR.Q6sek8bf92$sha1=HZbuOlKbWl.eR8AfIposuKbhX30',\n ]\n \n def setUp(self):\n  super(scram_test,self).setUp()\n  \n  \n  self.require_stringprep()\n  \n  \n  warnings.filterwarnings(\"ignore\",r\"norm_hash_name\\(\\): unknown hash\")\n  \n def test_90_algs(self):\n  ''\n  defaults=dict(salt=b'A'*10,rounds=1000)\n  def parse(algs,**kwds):\n   for k in defaults:\n    kwds.setdefault(k,defaults[k])\n   return self.handler(algs=algs,**kwds).algs\n   \n   \n  self.assertEqual(parse(None ,use_defaults=True ),hash.scram.default_algs)\n  self.assertRaises(TypeError,parse,None )\n  \n  \n  self.assertEqual(parse(\"sha1\"),[\"sha-1\"])\n  self.assertEqual(parse(\"sha1, sha256, md5\"),[\"md5\",\"sha-1\",\"sha-256\"])\n  \n  \n  self.assertEqual(parse([\"sha-1\",\"sha256\"]),[\"sha-1\",\"sha-256\"])\n  \n  \n  self.assertRaises(ValueError,parse,[\"sha-256\"])\n  self.assertRaises(ValueError,parse,algs=[],use_defaults=True )\n  \n  \n  self.assertRaises(ValueError,parse,[\"sha-1\",\"shaxxx-190\"])\n  \n  \n  self.assertRaises(RuntimeError,parse,['sha-1'],\n  checksum={\"sha-1\":b\"\\x00\"*20})\n  \n def test_90_checksums(self):\n  ''\n  \n  self.assertRaises(TypeError,self.handler,use_defaults=True ,\n  checksum={'sha-1':u('X')*20})\n  \n  \n  self.assertRaises(ValueError,self.handler,use_defaults=True ,\n  checksum={'sha-256':b'X'*32})\n  \n  \n  \n def test_91_extract_digest_info(self):\n  ''\n  edi=self.handler.extract_digest_info\n  \n  \n  h=\"$scram$10$AAAAAA$sha-1=AQ,bbb=Ag,ccc=Aw\"\n  s=b'\\x00'*4\n  self.assertEqual(edi(h,\"SHA1\"),(s,10,b'\\x01'))\n  self.assertEqual(edi(h,\"bbb\"),(s,10,b'\\x02'))\n  self.assertEqual(edi(h,\"ccc\"),(s,10,b'\\x03'))\n  self.assertRaises(KeyError,edi,h,\"ddd\")\n  \n  \n  c=\"$scram$10$....$sha-1,bbb,ccc\"\n  self.assertRaises(ValueError,edi,c,\"sha-1\")\n  self.assertRaises(ValueError,edi,c,\"bbb\")\n  self.assertRaises(ValueError,edi,c,\"ddd\")\n  \n def test_92_extract_digest_algs(self):\n  ''\n  eda=self.handler.extract_digest_algs\n  \n  self.assertEqual(eda('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30'),[\"sha-1\"])\n  \n  self.assertEqual(eda('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30',format=\"hashlib\"),\n  [\"sha1\"])\n  \n  self.assertEqual(eda('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ'),\n  [\"sha-1\",\"sha-256\",\"sha-512\"])\n  \n def test_93_derive_digest(self):\n  ''\n  \n  \n  hash=self.handler.derive_digest\n  \n  \n  s1=b'\\x01\\x02\\x03'\n  d1=b'\\xb2\\xfb\\xab\\x82[tNuPnI\\x8aZZ\\x19\\x87\\xcen\\xe9\\xd3'\n  self.assertEqual(hash(u(\"\\u2168\"),s1,1000,'sha-1'),d1)\n  self.assertEqual(hash(b\"\\xe2\\x85\\xa8\",s1,1000,'SHA-1'),d1)\n  self.assertEqual(hash(u(\"IX\"),s1,1000,'sha1'),d1)\n  self.assertEqual(hash(b\"IX\",s1,1000,'SHA1'),d1)\n  \n  \n  self.assertEqual(hash(\"IX\",s1,1000,'md5'),\n  b'3\\x19\\x18\\xc0\\x1c/\\xa8\\xbf\\xe4\\xa3\\xc2\\x8eM\\xe8od')\n  self.assertRaises(ValueError,hash,\"IX\",s1,1000,'sha-666')\n  \n  \n  self.assertRaises(ValueError,hash,\"IX\",s1,0,'sha-1')\n  \n  \n  self.assertEqual(hash(u(\"IX\"),s1.decode(\"latin-1\"),1000,'sha1'),d1)\n  \n def test_94_saslprep(self):\n  ''\n  \n  \n  \n  \n  \n  h=self.do_encrypt(u(\"I\\u00ADX\"))\n  self.assertTrue(self.do_verify(u(\"IX\"),h))\n  self.assertTrue(self.do_verify(u(\"\\u2168\"),h))\n  \n  \n  h=self.do_encrypt(u(\"\\xF3\"))\n  self.assertTrue(self.do_verify(u(\"o\\u0301\"),h))\n  self.assertTrue(self.do_verify(u(\"\\u200Do\\u0301\"),h))\n  \n  \n  self.assertRaises(ValueError,self.do_encrypt,u(\"\\uFDD0\"))\n  self.assertRaises(ValueError,self.do_verify,u(\"\\uFDD0\"),h)\n  \n def test_94_using_w_default_algs(self,param=\"default_algs\"):\n  ''\n  \n  handler=self.handler\n  orig=list(handler.default_algs)\n  subcls=handler.using(**{param:\"sha1,md5\"})\n  \n  \n  self.assertEqual(handler.default_algs,orig)\n  \n  \n  self.assertEqual(subcls.default_algs,[\"md5\",\"sha-1\"])\n  \n  \n  h1=subcls.hash(\"dummy\")\n  self.assertEqual(handler.extract_digest_algs(h1),[\"md5\",\"sha-1\"])\n  \n def test_94_using_w_algs(self):\n  ''\n  self.test_94_using_w_default_algs(param=\"algs\")\n  \n def test_94_needs_update_algs(self):\n  ''\n  handler1=self.handler.using(algs=\"sha1,md5\")\n  \n  \n  h1=handler1.hash(\"dummy\")\n  self.assertFalse(handler1.needs_update(h1))\n  \n  \n  \n  handler2=handler1.using(algs=\"sha1\")\n  self.assertFalse(handler2.needs_update(h1))\n  \n  \n  handler3=handler1.using(algs=\"sha1,sha256\")\n  self.assertTrue(handler3.needs_update(h1))\n  \n def test_95_context_algs(self):\n  ''\n  handler=self.handler\n  from passlib.context import CryptContext\n  c1=CryptContext([\"scram\"],scram__algs=\"sha1,md5\")\n  \n  h=c1.hash(\"dummy\")\n  self.assertEqual(handler.extract_digest_algs(h),[\"md5\",\"sha-1\"])\n  self.assertFalse(c1.needs_update(h))\n  \n  c2=c1.copy(scram__algs=\"sha1\")\n  self.assertFalse(c2.needs_update(h))\n  \n  c2=c1.copy(scram__algs=\"sha1,sha256\")\n  self.assertTrue(c2.needs_update(h))\n  \n def test_96_full_verify(self):\n  ''\n  def vpart(s,h):\n   return self.handler.verify(s,h)\n  def vfull(s,h):\n   return self.handler.verify(s,h,full=True )\n   \n   \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVY,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertTrue(vfull('pencil',h))\n  self.assertFalse(vfull('tape',h))\n  \n  \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhV,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertRaises(ValueError,vfull,'pencil',h)\n  \n  \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=qXUXrlcvnaxxWG00DdRgVioR2gnUpuX5r.3EZ1rdhVYa,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertRaises(ValueError,vfull,'pencil',h)\n  \n  \n  \n  \n  h=('$scram$4096$QSXCR.Q6sek8bf92$'\n  'sha-1=HZbuOlKbWl.eR8AfIposuKbhX30,'\n  'sha-256=R7RJDWIbeKRTFwhE9oxh04kab0CllrQ3kCcpZUcligc,'\n  'sha-512=lzgniLFcvglRLS0gt.C4gy.NurS3OIOVRAU1zZOV4P.qFiVFO2/'\n  'edGQSu/kD1LwdX0SNV/KsPdHSwEl5qRTuZQ')\n  self.assertTrue(vpart('tape',h))\n  self.assertFalse(vpart('pencil',h))\n  self.assertRaises(ValueError,vfull,'pencil',h)\n  self.assertRaises(ValueError,vfull,'tape',h)\n  \n  \n  \n  \n", ["logging", "passlib", "passlib.context", "passlib.tests.test_handlers", "passlib.tests.utils", "passlib.utils.compat", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_utils_pbkdf2": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement\n\nimport hashlib\nimport warnings\n\n\n\nfrom passlib.utils.compat import u,JYTHON\nfrom passlib.tests.utils import TestCase,hb\n\n\n\n\nclass UtilsTest(TestCase):\n ''\n descriptionPrefix=\"passlib.utils.pbkdf2\"\n \n ndn_formats=[\"hashlib\",\"iana\"]\n ndn_values=[\n \n (\"md5\",\"md5\",\"SCRAM-MD5-PLUS\",\"MD-5\"),\n (\"sha1\",\"sha-1\",\"SCRAM-SHA-1\",\"SHA1\"),\n (\"sha256\",\"sha-256\",\"SHA_256\",\"sha2-256\"),\n (\"ripemd160\",\"ripemd-160\",\"SCRAM-RIPEMD-160\",\"RIPEmd160\",\n \n \n \"ripemd\",\"SCRAM-RIPEMD\"),\n (\"test128\",\"test-128\",\"TEST128\"),\n (\"test2\",\"test2\",\"TEST-2\"),\n (\"test3_128\",\"test3-128\",\"TEST-3-128\"),\n ]\n \n def setUp(self):\n  super(UtilsTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.pbkdf2.*deprecated\",DeprecationWarning)\n  \n def test_norm_hash_name(self):\n  ''\n  from itertools import chain\n  from passlib.utils.pbkdf2 import norm_hash_name\n  from passlib.crypto.digest import _known_hash_names\n  \n  \n  for format in self.ndn_formats:\n   norm_hash_name(\"md4\",format)\n  self.assertRaises(ValueError,norm_hash_name,\"md4\",None )\n  self.assertRaises(ValueError,norm_hash_name,\"md4\",\"fake\")\n  \n  \n  self.assertEqual(norm_hash_name(u(\"MD4\")),\"md4\")\n  self.assertEqual(norm_hash_name(b\"MD4\"),\"md4\")\n  self.assertRaises(TypeError,norm_hash_name,None )\n  \n  \n  with warnings.catch_warnings():\n   warnings.filterwarnings(\"ignore\",'.*unknown hash')\n   for row in chain(_known_hash_names,self.ndn_values):\n    for idx,format in enumerate(self.ndn_formats):\n     correct=row[idx]\n     for value in row:\n      result=norm_hash_name(value,format)\n      self.assertEqual(result,correct,\n      \"name=%r, format=%r:\"%(value,\n      format))\n      \n      \n      \n      \nclass Pbkdf1_Test(TestCase):\n ''\n descriptionPrefix=\"passlib.utils.pbkdf2.pbkdf1()\"\n \n pbkdf1_tests=[\n \n \n \n \n \n (b'password',hb('78578E5A5D63CB06'),1000,16,'sha1',hb('dc19847e05c64d2faf10ebfb4a3d2a20')),\n \n \n \n \n (b'password',b'salt',1000,0,'md5',b''),\n (b'password',b'salt',1000,1,'md5',hb('84')),\n (b'password',b'salt',1000,8,'md5',hb('8475c6a8531a5d27')),\n (b'password',b'salt',1000,16,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'sha1',hb('4a8fd48e426ed081b535be5769892fa396293efb')),\n ]\n if not JYTHON:\n  pbkdf1_tests.append(\n  (b'password',b'salt',1000,None ,'md4',hb('f7f2e91100a8f96190f2dd177cb26453'))\n  )\n  \n def setUp(self):\n  super(Pbkdf1_Test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.pbkdf2.*deprecated\",DeprecationWarning)\n  \n def test_known(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf1\n  for secret,salt,rounds,keylen,digest,correct in self.pbkdf1_tests:\n   result=pbkdf1(secret,salt,rounds,keylen,digest)\n   self.assertEqual(result,correct)\n   \n def test_border(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf1\n  def helper(secret=b'secret',salt=b'salt',rounds=1,keylen=1,hash='md5'):\n   return pbkdf1(secret,salt,rounds,keylen,hash)\n  helper()\n  \n  \n  self.assertRaises(TypeError,helper,secret=1)\n  self.assertRaises(TypeError,helper,salt=1)\n  \n  \n  self.assertRaises(ValueError,helper,hash='missing')\n  \n  \n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='1')\n  \n  \n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=17,hash='md5')\n  self.assertRaises(TypeError,helper,keylen='1')\n  \n  \n  \n  \nclass Pbkdf2_Test(TestCase):\n ''\n descriptionPrefix=\"passlib.utils.pbkdf2.pbkdf2()\"\n \n pbkdf2_test_vectors=[\n \n \n \n \n \n \n \n (\n hb(\"cdedb5281bb2f801565a1122b2563515\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935d\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,32\n ),\n \n \n (\n hb(\"5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1200,32\n ),\n \n \n (\n hb(\"d1daa78615f287e6a1c8b120d7062a493f98d203e6be49a6adf4fa574b6e64ee\"),\n b\"password\",b'\\x12\\x34\\x56\\x78\\x78\\x56\\x34\\x12',5,32\n ),\n \n \n (\n hb(\"139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1\"),\n b\"X\"*64,b\"pass phrase equals block size\",1200,32\n ),\n \n \n (\n hb(\"9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a\"),\n b\"X\"*65,b\"pass phrase exceeds block size\",1200,32\n ),\n \n \n \n \n (\n hb(\"0c60c80f961f0e71f3a9b524af6012062fe037a6\"),\n b\"password\",b\"salt\",1,20,\n ),\n \n (\n hb(\"ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957\"),\n b\"password\",b\"salt\",2,20,\n ),\n \n (\n hb(\"4b007901b765489abead49d926f721d065a429c1\"),\n b\"password\",b\"salt\",4096,20,\n ),\n \n \n \n \n \n \n \n \n (\n hb(\"3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038\"),\n b\"passwordPASSWORDpassword\",\n b\"saltSALTsaltSALTsaltSALTsaltSALTsalt\",\n 4096,25,\n ),\n \n (\n hb(\"56fa6aa75548099dcc37d7f03425e0c3\"),\n b\"pass\\00word\",b\"sa\\00lt\",4096,16,\n ),\n \n \n \n \n (\n hb(\"887CFF169EA8335235D8004242AA7D6187A41E3187DF0CE14E256D85ED\"\n \"97A97357AAA8FF0A3871AB9EEFF458392F462F495487387F685B7472FC\"\n \"6C29E293F0A0\"),\n b\"hello\",\n hb(\"9290F727ED06C38BA4549EF7DE25CF5642659211B7FC076F2D28FEFD71\"\n \"784BB8D8F6FB244A8CC5C06240631B97008565A120764C0EE9C2CB0073\"\n \"994D79080136\"),\n 10000,64,\"hmac-sha512\"\n ),\n \n \n \n \n (\n hb('e248fb6b13365146f8ac6307cc222812'),\n b\"secret\",b\"salt\",10,16,\"hmac-sha1\",\n ),\n (\n hb('e248fb6b13365146f8ac6307cc2228127872da6d'),\n b\"secret\",b\"salt\",10,None ,\"hmac-sha1\",\n ),\n \n ]\n \n def setUp(self):\n  super(Pbkdf2_Test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.pbkdf2.*deprecated\",DeprecationWarning)\n  \n def test_known(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  for row in self.pbkdf2_test_vectors:\n   correct,secret,salt,rounds,keylen=row[:5]\n   prf=row[5]if len(row)==6 else \"hmac-sha1\"\n   result=pbkdf2(secret,salt,rounds,keylen,prf)\n   self.assertEqual(result,correct)\n   \n def test_border(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,prf=\"hmac-sha1\"):\n   return pbkdf2(secret,salt,rounds,keylen,prf)\n  helper()\n  \n  \n  self.assertRaises(ValueError,helper,rounds=-1)\n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='x')\n  \n  \n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=0)\n  helper(keylen=1)\n  self.assertRaises(OverflowError,helper,keylen=20 *(2 **32 -1)+1)\n  self.assertRaises(TypeError,helper,keylen='x')\n  \n  \n  self.assertRaises(TypeError,helper,salt=5)\n  self.assertRaises(TypeError,helper,secret=5)\n  \n  \n  self.assertRaises(ValueError,helper,prf='hmac-foo')\n  self.assertRaises(NotImplementedError,helper,prf='foo')\n  self.assertRaises(TypeError,helper,prf=5)\n  \n def test_default_keylen(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,prf=\"hmac-sha1\"):\n   return pbkdf2(secret,salt,rounds,keylen,prf)\n  self.assertEqual(len(helper(prf='hmac-sha1')),20)\n  self.assertEqual(len(helper(prf='hmac-sha256')),32)\n  \n def test_custom_prf(self):\n  ''\n  from passlib.utils.pbkdf2 import pbkdf2\n  def prf(key,msg):\n   return hashlib.md5(key+msg+b'fooey').digest()\n  self.assertRaises(NotImplementedError,pbkdf2,b'secret',b'salt',1000,20,prf)\n  \n  \n  \n  \n", ["__future__", "hashlib", "itertools", "passlib.crypto.digest", "passlib.tests.utils", "passlib.utils.compat", "passlib.utils.pbkdf2", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_crypto_digest": [".py", "''\n\n\n\nfrom __future__ import with_statement,division\n\nfrom binascii import hexlify\nimport hashlib\nimport warnings\n\n\n\nfrom passlib.exc import UnknownHashError\nfrom passlib.utils.compat import PY3,u,JYTHON\nfrom passlib.tests.utils import TestCase,TEST_MODE,skipUnless,hb\n\n\n\n\nclass HashInfoTest(TestCase):\n ''\n descriptionPrefix=\"passlib.crypto.digest\"\n \n \n norm_hash_formats=[\"hashlib\",\"iana\"]\n \n \n \n norm_hash_samples=[\n \n (\"md5\",\"md5\",\"SCRAM-MD5-PLUS\",\"MD-5\"),\n (\"sha1\",\"sha-1\",\"SCRAM-SHA-1\",\"SHA1\"),\n (\"sha256\",\"sha-256\",\"SHA_256\",\"sha2-256\"),\n (\"ripemd160\",\"ripemd-160\",\"SCRAM-RIPEMD-160\",\"RIPEmd160\",\n \n \n \"ripemd\",\"SCRAM-RIPEMD\"),\n \n \n (\"sha4_256\",\"sha4-256\",\"SHA4-256\",\"SHA-4-256\"),\n (\"test128\",\"test-128\",\"TEST128\"),\n (\"test2\",\"test2\",\"TEST-2\"),\n (\"test3_128\",\"test3-128\",\"TEST-3-128\"),\n ]\n \n def test_norm_hash_name(self):\n  ''\n  from itertools import chain\n  from passlib.crypto.digest import norm_hash_name,_known_hash_names\n  \n  \n  ctx=warnings.catch_warnings()\n  ctx.__enter__()\n  self.addCleanup(ctx.__exit__)\n  warnings.filterwarnings(\"ignore\",'.*unknown hash')\n  warnings.filterwarnings(\"ignore\",'.*unsupported hash')\n  \n  \n  self.assertEqual(norm_hash_name(u(\"MD4\")),\"md4\")\n  self.assertEqual(norm_hash_name(b\"MD4\"),\"md4\")\n  self.assertRaises(TypeError,norm_hash_name,None )\n  \n  \n  for row in chain(_known_hash_names,self.norm_hash_samples):\n   for idx,format in enumerate(self.norm_hash_formats):\n    correct=row[idx]\n    for value in row:\n     result=norm_hash_name(value,format)\n     self.assertEqual(result,correct,\n     \"name=%r, format=%r:\"%(value,\n     format))\n     \n def test_lookup_hash_ctor(self):\n  ''\n  from passlib.crypto.digest import lookup_hash\n  \n  \n  self.assertRaises(ValueError,lookup_hash,\"new\")\n  self.assertRaises(ValueError,lookup_hash,\"__name__\")\n  self.assertRaises(ValueError,lookup_hash,\"sha4\")\n  \n  \n  self.assertEqual(lookup_hash(\"md5\"),(hashlib.md5,16,64))\n  \n  \n  try :\n   hashlib.new(\"sha\")\n   has_sha=True\n  except ValueError:\n   has_sha=False\n  if has_sha:\n   record=lookup_hash(\"sha\")\n   const=record[0]\n   self.assertEqual(record,(const,20,64))\n   self.assertEqual(hexlify(const(b\"abc\").digest()),\n   b\"0164b8a914cd2a5e74c4f7ff082c4d97f1edf880\")\n   \n  else :\n   self.assertRaises(ValueError,lookup_hash,\"sha\")\n   \n   \n  try :\n   hashlib.new(\"md4\")\n   has_md4=True\n  except ValueError:\n   has_md4=False\n  record=lookup_hash(\"md4\")\n  const=record[0]\n  if not has_md4:\n   from passlib.crypto._md4 import md4\n   self.assertIs(const,md4)\n  self.assertEqual(record,(const,16,64))\n  self.assertEqual(hexlify(const(b\"abc\").digest()),\n  b\"a448017aaf21d8525fc10ae87aa6729d\")\n  \n  \n  self.assertIs(lookup_hash(\"md5\"),lookup_hash(\"md5\"))\n  \n def test_lookup_hash_w_unknown_name(self):\n  ''\n  from passlib.crypto.digest import lookup_hash\n  \n  \n  self.assertRaises(UnknownHashError,lookup_hash,\"xxx256\")\n  \n  \n  info=lookup_hash(\"xxx256\",required=False )\n  self.assertFalse(info.supported)\n  self.assertRaisesRegex(UnknownHashError,\"unknown hash: 'xxx256'\",info.const)\n  self.assertEqual(info.name,\"xxx256\")\n  self.assertEqual(info.digest_size,None )\n  self.assertEqual(info.block_size,None )\n  \n  \n  info2=lookup_hash(\"xxx256\",required=False )\n  self.assertIs(info2,info)\n  \n def test_mock_fips_mode(self):\n  ''\n\n  \n  from passlib.crypto.digest import lookup_hash,_set_mock_fips_mode\n  \n  \n  if not lookup_hash(\"md5\",required=False ).supported:\n   raise self.skipTest(\"md5 not supported\")\n   \n   \n  _set_mock_fips_mode()\n  self.addCleanup(_set_mock_fips_mode,False )\n  \n  pat=\"'md5' hash disabled for fips\"\n  self.assertRaisesRegex(UnknownHashError,pat,lookup_hash,\"md5\")\n  \n  info=lookup_hash(\"md5\",required=False )\n  self.assertRegex(info.error_text,pat)\n  self.assertRaisesRegex(UnknownHashError,pat,info.const)\n  \n  \n  self.assertEqual(info.digest_size,16)\n  self.assertEqual(info.block_size,64)\n  \n def test_lookup_hash_metadata(self):\n  ''\n  \n  from passlib.crypto.digest import lookup_hash\n  \n  \n  info=lookup_hash(\"sha256\")\n  self.assertEqual(info.name,\"sha256\")\n  self.assertEqual(info.iana_name,\"sha-256\")\n  self.assertEqual(info.block_size,64)\n  self.assertEqual(info.digest_size,32)\n  self.assertIs(lookup_hash(\"SHA2-256\"),info)\n  \n  \n  info=lookup_hash(\"md5\")\n  self.assertEqual(info.name,\"md5\")\n  self.assertEqual(info.iana_name,\"md5\")\n  self.assertEqual(info.block_size,64)\n  self.assertEqual(info.digest_size,16)\n  \n def test_lookup_hash_alt_types(self):\n  ''\n  \n  from passlib.crypto.digest import lookup_hash\n  \n  info=lookup_hash(\"sha256\")\n  self.assertIs(lookup_hash(info),info)\n  self.assertIs(lookup_hash(info.const),info)\n  \n  self.assertRaises(TypeError,lookup_hash,123)\n  \n  \n  \n  \n  \n  \nclass Pbkdf1_Test(TestCase):\n ''\n descriptionPrefix=\"passlib.crypto.digest.pbkdf1\"\n \n pbkdf1_tests=[\n \n \n \n \n \n (b'password',hb('78578E5A5D63CB06'),1000,16,'sha1',hb('dc19847e05c64d2faf10ebfb4a3d2a20')),\n \n \n \n \n (b'password',b'salt',1000,0,'md5',b''),\n (b'password',b'salt',1000,1,'md5',hb('84')),\n (b'password',b'salt',1000,8,'md5',hb('8475c6a8531a5d27')),\n (b'password',b'salt',1000,16,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'md5',hb('8475c6a8531a5d27e386cd496457812c')),\n (b'password',b'salt',1000,None ,'sha1',hb('4a8fd48e426ed081b535be5769892fa396293efb')),\n ]\n if not JYTHON:\n  pbkdf1_tests.append(\n  (b'password',b'salt',1000,None ,'md4',hb('f7f2e91100a8f96190f2dd177cb26453'))\n  )\n  \n def test_known(self):\n  ''\n  from passlib.crypto.digest import pbkdf1\n  for secret,salt,rounds,keylen,digest,correct in self.pbkdf1_tests:\n   result=pbkdf1(digest,secret,salt,rounds,keylen)\n   self.assertEqual(result,correct)\n   \n def test_border(self):\n  ''\n  from passlib.crypto.digest import pbkdf1\n  def helper(secret=b'secret',salt=b'salt',rounds=1,keylen=1,hash='md5'):\n   return pbkdf1(hash,secret,salt,rounds,keylen)\n  helper()\n  \n  \n  self.assertRaises(TypeError,helper,secret=1)\n  self.assertRaises(TypeError,helper,salt=1)\n  \n  \n  self.assertRaises(ValueError,helper,hash='missing')\n  \n  \n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='1')\n  \n  \n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=17,hash='md5')\n  self.assertRaises(TypeError,helper,keylen='1')\n  \n  \n  \n  \n  \n  \nfrom passlib.crypto.digest import pbkdf2_hmac,PBKDF2_BACKENDS\n\n\nclass Pbkdf2Test(TestCase):\n ''\n descriptionPrefix=\"passlib.crypto.digest.pbkdf2_hmac() <backends: %s>\"%\", \".join(PBKDF2_BACKENDS)\n \n pbkdf2_test_vectors=[\n \n \n \n \n \n \n \n (\n hb(\"cdedb5281bb2f801565a1122b2563515\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935d\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,16\n ),\n \n \n (\n hb(\"01dbee7f4a9e243e988b62c73cda935da05378b93244ec8f48a99e61ad799d86\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",2,32\n ),\n \n \n (\n hb(\"5c08eb61fdf71e4e4ec3cf6ba1f5512ba7e52ddbc5e5142f708a31e2e62b1e13\"),\n b\"password\",b\"ATHENA.MIT.EDUraeburn\",1200,32\n ),\n \n \n (\n hb(\"d1daa78615f287e6a1c8b120d7062a493f98d203e6be49a6adf4fa574b6e64ee\"),\n b\"password\",b'\\x12\\x34\\x56\\x78\\x78\\x56\\x34\\x12',5,32\n ),\n \n \n (\n hb(\"139c30c0966bc32ba55fdbf212530ac9c5ec59f1a452f5cc9ad940fea0598ed1\"),\n b\"X\"*64,b\"pass phrase equals block size\",1200,32\n ),\n \n \n (\n hb(\"9ccad6d468770cd51b10e6a68721be611a8b4d282601db3b36be9246915ec82a\"),\n b\"X\"*65,b\"pass phrase exceeds block size\",1200,32\n ),\n \n \n \n \n (\n hb(\"0c60c80f961f0e71f3a9b524af6012062fe037a6\"),\n b\"password\",b\"salt\",1,20,\n ),\n \n (\n hb(\"ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957\"),\n b\"password\",b\"salt\",2,20,\n ),\n \n (\n hb(\"4b007901b765489abead49d926f721d065a429c1\"),\n b\"password\",b\"salt\",4096,20,\n ),\n \n \n \n \n \n \n \n \n (\n hb(\"3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038\"),\n b\"passwordPASSWORDpassword\",\n b\"saltSALTsaltSALTsaltSALTsaltSALTsalt\",\n 4096,25,\n ),\n \n (\n hb(\"56fa6aa75548099dcc37d7f03425e0c3\"),\n b\"pass\\00word\",b\"sa\\00lt\",4096,16,\n ),\n \n \n \n \n (\n hb(\"887CFF169EA8335235D8004242AA7D6187A41E3187DF0CE14E256D85ED\"\n \"97A97357AAA8FF0A3871AB9EEFF458392F462F495487387F685B7472FC\"\n \"6C29E293F0A0\"),\n b\"hello\",\n hb(\"9290F727ED06C38BA4549EF7DE25CF5642659211B7FC076F2D28FEFD71\"\n \"784BB8D8F6FB244A8CC5C06240631B97008565A120764C0EE9C2CB0073\"\n \"994D79080136\"),\n 10000,64,\"sha512\"\n ),\n \n \n \n \n (\n hb('55ac046e56e3089fec1691c22544b605f94185216dde0465e68b9d57c20dacbc'\n '49ca9cccf179b645991664b39d77ef317c71b845b1e30bd509112041d3a19783'),\n b'passwd',b'salt',1,64,'sha256',\n ),\n \n (\n hb('4ddcd8f60b98be21830cee5ef22701f9641a4418d04c0414aeff08876b34ab56'\n 'a1d425a1225833549adb841b51c9b3176a272bdebba1d078478f62b397f33c8d'),\n b'Password',b'NaCl',80000,64,'sha256',\n ),\n \n (\n hb('120fb6cffcf8b32c43e7225256c4f837a86548c92ccc35480805987cb70be17b'),\n b'password',b'salt',1,32,'sha256',\n ),\n \n (\n hb('ae4d0c95af6b46d32d0adff928f06dd02a303f8ef3c251dfd6e2d85a95474c43'),\n b'password',b'salt',2,32,'sha256',\n ),\n \n (\n hb('c5e478d59288c841aa530db6845c4c8d962893a001ce4e11a4963873aa98134a'),\n b'password',b'salt',4096,32,'sha256',\n ),\n \n (\n hb('348c89dbcbd32b2f32d814b8116e84cf2b17347ebc1800181c4e2a1fb8dd53e1c'\n '635518c7dac47e9'),\n b'passwordPASSWORDpassword',b'saltSALTsaltSALTsaltSALTsaltSALTsalt',\n 4096,40,'sha256',\n ),\n \n (\n hb('9e83f279c040f2a11aa4a02b24c418f2d3cb39560c9627fa4f47e3bcc2897c3d'),\n b'',b'salt',1024,32,'sha256',\n ),\n \n (\n hb('ea5808411eb0c7e830deab55096cee582761e22a9bc034e3ece925225b07bf46'),\n b'password',b'',1024,32,'sha256',\n ),\n \n (\n hb('89b69d0516f829893c696226650a8687'),\n b'pass\\x00word',b'sa\\x00lt',4096,16,'sha256',\n ),\n \n (\n hb('867f70cf1ade02cff3752599a3a53dc4af34c7a669815ae5d513554e1c8cf252'),\n b'password',b'salt',1,32,'sha512',\n ),\n \n (\n hb('e1d9c16aa681708a45f5c7c4e215ceb66e011a2e9f0040713f18aefdb866d53c'),\n b'password',b'salt',2,32,'sha512',\n ),\n \n (\n hb('d197b1b33db0143e018b12f3d1d1479e6cdebdcc97c5c0f87f6902e072f457b5'),\n b'password',b'salt',4096,32,'sha512',\n ),\n \n (\n hb('6e23f27638084b0f7ea1734e0d9841f55dd29ea60a834466f3396bac801fac1eeb'\n '63802f03a0b4acd7603e3699c8b74437be83ff01ad7f55dac1ef60f4d56480c35e'\n 'e68fd52c6936'),\n b'passwordPASSWORDpassword',b'saltSALTsaltSALTsaltSALTsaltSALTsalt',\n 1,72,'sha512',\n ),\n \n (\n hb('0c60c80f961f0e71f3a9b524af6012062fe037a6'),\n b'password',b'salt',1,20,'sha1',\n ),\n \n \n \n \n (\n hb('e248fb6b13365146f8ac6307cc222812'),\n b\"secret\",b\"salt\",10,16,\"sha1\",\n ),\n (\n hb('e248fb6b13365146f8ac6307cc2228127872da6d'),\n b\"secret\",b\"salt\",10,None ,\"sha1\",\n ),\n (\n hb('b1d5485772e6f76d5ebdc11b38d3eff0a5b2bd50dc11f937e86ecacd0cd40d1b'\n '9113e0734e3b76a3'),\n b\"secret\",b\"salt\",62,40,\"md5\",\n ),\n (\n hb('ea014cc01f78d3883cac364bb5d054e2be238fb0b6081795a9d84512126e3129'\n '062104d2183464c4'),\n b\"secret\",b\"salt\",62,40,\"md4\",\n ),\n ]\n \n def test_known(self):\n  ''\n  for row in self.pbkdf2_test_vectors:\n   correct,secret,salt,rounds,keylen=row[:5]\n   digest=row[5]if len(row)==6 else \"sha1\"\n   result=pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n   self.assertEqual(result,correct)\n   \n def test_backends(self):\n  ''\n  from passlib.crypto.digest import PBKDF2_BACKENDS\n  \n  \n  try :\n   import fastpbkdf2\n   has_fastpbkdf2=True\n  except ImportError:\n   has_fastpbkdf2=False\n  self.assertEqual(\"fastpbkdf2\"in PBKDF2_BACKENDS,has_fastpbkdf2)\n  \n  \n  try :\n   from hashlib import pbkdf2_hmac\n   has_hashlib_ssl=pbkdf2_hmac.__module__ !=\"hashlib\"\n  except ImportError:\n   has_hashlib_ssl=False\n  self.assertEqual(\"hashlib-ssl\"in PBKDF2_BACKENDS,has_hashlib_ssl)\n  \n  \n  from passlib.utils.compat import PY3\n  if PY3:\n   self.assertIn(\"builtin-from-bytes\",PBKDF2_BACKENDS)\n  else :\n  \n   self.assertIn(\"builtin-unpack\",PBKDF2_BACKENDS)\n   \n def test_border(self):\n  ''\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,digest=\"sha1\"):\n   return pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n  helper()\n  \n  \n  self.assertRaises(ValueError,helper,rounds=-1)\n  self.assertRaises(ValueError,helper,rounds=0)\n  self.assertRaises(TypeError,helper,rounds='x')\n  \n  \n  helper(keylen=1)\n  self.assertRaises(ValueError,helper,keylen=-1)\n  self.assertRaises(ValueError,helper,keylen=0)\n  \n  \n  self.assertRaises(OverflowError,helper,keylen=20 *(2 **32 -1)+1)\n  self.assertRaises(TypeError,helper,keylen='x')\n  \n  \n  self.assertRaises(TypeError,helper,salt=5)\n  self.assertRaises(TypeError,helper,secret=5)\n  \n  \n  self.assertRaises(ValueError,helper,digest='foo')\n  self.assertRaises(TypeError,helper,digest=5)\n  \n def test_default_keylen(self):\n  ''\n  def helper(secret=b'password',salt=b'salt',rounds=1,keylen=None ,digest=\"sha1\"):\n   return pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n  self.assertEqual(len(helper(digest='sha1')),20)\n  self.assertEqual(len(helper(digest='sha256')),32)\n  \n  \n  \n  \n", ["__future__", "binascii", "fastpbkdf2", "hashlib", "itertools", "passlib.crypto._md4", "passlib.crypto.digest", "passlib.exc", "passlib.tests.utils", "passlib.utils.compat", "warnings"]], "passlib.Lib.site-packages.passlib.tests.backports": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\nimport re\nimport sys\n\n\n\nfrom passlib.utils.compat import PY26\n\n__all__=[\n\"TestCase\",\n\"unittest\",\n\n\"skip\",\"skipIf\",\"skipUnless\",\n]\n\n\n\n\ntry :\n import unittest2 as unittest\nexcept ImportError:\n if PY26:\n  raise ImportError(\"Passlib's tests require 'unittest2' under Python 2.6 (as of Passlib 1.7)\")\n  \n import unittest\n \n \n \n \nskip=unittest.skip\nskipIf=unittest.skipIf\nskipUnless=unittest.skipUnless\nSkipTest=unittest.SkipTest\n\n\n\n\nclass TestCase(unittest.TestCase):\n ''\n \n \n \n \n \n \n \n \n \n if not hasattr(unittest.TestCase,\"assertRegex\"):\n  assertRegex=unittest.TestCase.assertRegexpMatches\n  \n if not hasattr(unittest.TestCase,\"assertRaisesRegex\"):\n  assertRaisesRegex=unittest.TestCase.assertRaisesRegexp\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "passlib.utils.compat", "re", "sys", "unittest", "unittest2"]], "passlib.Lib.site-packages.passlib.tests.test_context": [".py", "''\n\n\n\n\nfrom __future__ import with_statement\nfrom passlib.utils.compat import PY3\nif PY3:\n from configparser import NoSectionError\nelse :\n from ConfigParser import NoSectionError\nimport datetime\nfrom functools import partial\nimport logging ;log=logging.getLogger(__name__)\nimport os\nimport warnings\n\n\nfrom passlib import hash\nfrom passlib.context import CryptContext,LazyCryptContext\nfrom passlib.exc import PasslibConfigWarning,PasslibHashWarning\nfrom passlib.utils import tick,to_unicode\nfrom passlib.utils.compat import irange,u,unicode,str_to_uascii,PY2,PY26\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import (TestCase,set_file,TICK_RESOLUTION,\nquicksleep,time_call,handler_derived_from)\nfrom passlib.registry import (register_crypt_handler_path,\n_has_crypt_handler as has_crypt_handler,\n_unload_handler_name as unload_handler_name,\nget_crypt_handler,\n)\n\n\n\n\nhere=os.path.abspath(os.path.dirname(__file__))\n\ndef merge_dicts(first,*args,**kwds):\n target=first.copy()\n for arg in args:\n  target.update(arg)\n if kwds:\n  target.update(kwds)\n return target\n \n \n \n \nclass CryptContextTest(TestCase):\n descriptionPrefix=\"CryptContext\"\n \n \n \n \n \n \n \n \n \n \n \n sample_1_schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"]\n sample_1_handlers=[get_crypt_handler(name)for name in sample_1_schemes]\n \n sample_1_dict=dict(\n schemes=sample_1_schemes,\n default=\"md5_crypt\",\n all__vary_rounds=0.1,\n bsdi_crypt__max_rounds=30001,\n bsdi_crypt__default_rounds=25001,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=40000,\n )\n \n sample_1_resolved_dict=merge_dicts(sample_1_dict,\n schemes=sample_1_handlers)\n \n sample_1_unnormalized=u(\"\"\"\\\n[passlib]\nschemes = des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\ndefault = md5_crypt\n; this is using %...\nall__vary_rounds = 10%%\nbsdi_crypt__default_rounds = 25001\nbsdi_crypt__max_rounds = 30001\nsha512_crypt__max_rounds = 50000\nsha512_crypt__min_rounds = 40000\n\"\"\")\n \n sample_1_unicode=u(\"\"\"\\\n[passlib]\nschemes = des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\ndefault = md5_crypt\nall__vary_rounds = 0.1\nbsdi_crypt__default_rounds = 25001\nbsdi_crypt__max_rounds = 30001\nsha512_crypt__max_rounds = 50000\nsha512_crypt__min_rounds = 40000\n\n\"\"\")\n \n \n \n \n \n \n sample_1_path=os.path.join(here,\"sample1.cfg\")\n \n \n sample_1b_unicode=sample_1_unicode.replace(u(\"\\n\"),u(\"\\r\\n\"))\n sample_1b_path=os.path.join(here,\"sample1b.cfg\")\n \n \n sample_1c_bytes=sample_1_unicode.replace(u(\"[passlib]\"),\n u(\"[mypolicy]\")).encode(\"utf-16\")\n sample_1c_path=os.path.join(here,\"sample1c.cfg\")\n \n \n if False :\n  set_file(sample_1_path,sample_1_unicode)\n  set_file(sample_1b_path,sample_1b_unicode)\n  set_file(sample_1c_path,sample_1c_bytes)\n  \n  \n  \n  \n sample_2_dict=dict(\n \n bsdi_crypt__min_rounds=29001,\n bsdi_crypt__max_rounds=35001,\n bsdi_crypt__default_rounds=31001,\n \n sha512_crypt__min_rounds=45000,\n )\n \n sample_2_unicode=\"\"\"\\\n[passlib]\nbsdi_crypt__min_rounds = 29001\nbsdi_crypt__max_rounds = 35001\nbsdi_crypt__default_rounds = 31001\nsha512_crypt__min_rounds = 45000\n\"\"\"\n \n \n sample_12_dict=merge_dicts(sample_1_dict,sample_2_dict)\n \n \n \n \n sample_3_dict=dict(\n default=\"sha512_crypt\",\n )\n \n \n sample_123_dict=merge_dicts(sample_12_dict,sample_3_dict)\n \n \n \n \n sample_4_dict=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"phpass\",\"bsdi_crypt\",\n \"sha256_crypt\"],\n deprecated=[\"des_crypt\",],\n default=\"sha256_crypt\",\n bsdi_crypt__max_rounds=31,\n bsdi_crypt__default_rounds=25,\n bsdi_crypt__vary_rounds=0,\n sha256_crypt__max_rounds=3000,\n sha256_crypt__min_rounds=2000,\n sha256_crypt__default_rounds=3000,\n phpass__ident=\"H\",\n phpass__default_rounds=7,\n )\n \n \n \n \n def setUp(self):\n  super(CryptContextTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\"The 'all' scheme is deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\".*'scheme' keyword is deprecated as of Passlib 1.7.*\")\n  \n  \n  \n  \n def test_01_constructor(self):\n  ''\n  \n  \n  ctx=CryptContext()\n  self.assertEqual(ctx.to_dict(),{})\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_resolved_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext(**self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_2_dict)\n  \n  \n  ctx=CryptContext(**self.sample_3_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_3_dict)\n  \n  \n  ctx=CryptContext(schemes=[u(\"sha256_crypt\")])\n  self.assertEqual(ctx.schemes(),(\"sha256_crypt\",))\n  \n def test_02_from_string(self):\n  ''\n  \n  ctx=CryptContext.from_string(self.sample_1_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1_unnormalized)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1_unicode.encode(\"utf-8\"))\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1b_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_string(self.sample_1c_bytes,section=\"mypolicy\",\n  encoding=\"utf-16\")\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  self.assertRaises(TypeError,CryptContext.from_string,None )\n  \n  \n  self.assertRaises(NoSectionError,CryptContext.from_string,\n  self.sample_1_unicode,section=\"fakesection\")\n  \n def test_03_from_path(self):\n  ''\n  \n  if not os.path.exists(self.sample_1_path):\n   raise RuntimeError(\"can't find data file: %r\"%self.sample_1_path)\n   \n   \n  ctx=CryptContext.from_path(self.sample_1_path)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_path(self.sample_1b_path)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext.from_path(self.sample_1c_path,section=\"mypolicy\",\n  encoding=\"utf-16\")\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  self.assertRaises(EnvironmentError,CryptContext.from_path,\n  os.path.join(here,\"sample1xxx.cfg\"))\n  \n  \n  self.assertRaises(NoSectionError,CryptContext.from_path,\n  self.sample_1_path,section=\"fakesection\")\n  \n def test_04_copy(self):\n  ''\n  cc1=CryptContext(**self.sample_1_dict)\n  \n  \n  cc2=cc1.copy(**self.sample_2_dict)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc2.to_dict(),self.sample_12_dict)\n  \n  \n  cc2b=cc2.copy(**self.sample_2_dict)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc2b.to_dict(),self.sample_12_dict)\n  \n  \n  cc3=cc2.copy(**self.sample_3_dict)\n  self.assertEqual(cc3.to_dict(),self.sample_123_dict)\n  \n  \n  cc4=cc1.copy()\n  self.assertIsNot(cc4,cc1)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc4.to_dict(),self.sample_1_dict)\n  \n  \n  cc4.update(**self.sample_2_dict)\n  self.assertEqual(cc1.to_dict(),self.sample_1_dict)\n  self.assertEqual(cc4.to_dict(),self.sample_12_dict)\n  \n def test_09_repr(self):\n  ''\n  cc1=CryptContext(**self.sample_1_dict)\n  \n  self.assertRegex(repr(cc1),\"^<CryptContext at 0x-?[0-9a-f]+>$\")\n  \n  \n  \n  \n def test_10_load(self):\n  ''\n  \n  \n  \n  \n  \n  \n  ctx=CryptContext()\n  \n  \n  ctx.load(self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx.load(self.sample_1_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx.load(self.sample_1_unicode.encode(\"utf-8\"))\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  self.assertRaises(TypeError,ctx.load,None )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.load({},update=True )\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext()\n  ctx.load(self.sample_1_dict)\n  ctx.load(self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_2_dict)\n  \n def test_11_load_rollback(self):\n  ''\n  \n  cc=CryptContext([\"des_crypt\",\"sha256_crypt\"],\n  sha256_crypt__default_rounds=5000,\n  all__vary_rounds=0.1,\n  )\n  result=cc.to_string()\n  \n  \n  \n  self.assertRaises(TypeError,cc.update,too__many__key__parts=True )\n  self.assertEqual(cc.to_string(),result)\n  \n  \n  \n  \n  self.assertRaises(KeyError,cc.update,fake_context_option=True )\n  self.assertEqual(cc.to_string(),result)\n  \n  \n  self.assertRaises(ValueError,cc.update,sha256_crypt__min_rounds=10000)\n  self.assertEqual(cc.to_string(),result)\n  \n def test_12_update(self):\n  ''\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update()\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update(**self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_12_dict)\n  \n  \n  ctx.update(**self.sample_3_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_123_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update(self.sample_2_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_12_dict)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  ctx.update(self.sample_2_unicode)\n  self.assertEqual(ctx.to_dict(),self.sample_12_dict)\n  \n  \n  self.assertRaises(TypeError,ctx.update,{},{})\n  self.assertRaises(TypeError,ctx.update,{},schemes=['des_crypt'])\n  \n  \n  self.assertRaises(TypeError,ctx.update,None )\n  \n  \n  \n  \n def test_20_options(self):\n  ''\n  def parse(**kwds):\n   return CryptContext(**kwds).to_dict()\n   \n   \n   \n   \n   \n   \n   \n  self.assertRaises(TypeError,CryptContext,__=0.1)\n  self.assertRaises(TypeError,CryptContext,default__scheme__='x')\n  \n  \n  self.assertRaises(TypeError,CryptContext,__option='x')\n  self.assertRaises(TypeError,CryptContext,default____option='x')\n  \n  \n  self.assertRaises(TypeError,CryptContext,__scheme__option='x')\n  \n  \n  self.assertRaises(TypeError,CryptContext,\n  category__scheme__option__invalid=30000)\n  \n  \n  \n  self.assertRaises(KeyError,parse,\n  **{\"admin.context__schemes\":\"md5_crypt\"})\n  ctx=CryptContext(**{\"schemes\":\"md5_crypt,des_crypt\",\n  \"admin.context__default\":\"des_crypt\"})\n  self.assertEqual(ctx.default_scheme(\"admin\"),\"des_crypt\")\n  \n  \n  \n  \n  \n  \n  result=dict(default=\"md5_crypt\")\n  self.assertEqual(parse(default=\"md5_crypt\"),result)\n  self.assertEqual(parse(context__default=\"md5_crypt\"),result)\n  self.assertEqual(parse(default__context__default=\"md5_crypt\"),result)\n  self.assertEqual(parse(**{\"context.default\":\"md5_crypt\"}),result)\n  self.assertEqual(parse(**{\"default.context.default\":\"md5_crypt\"}),result)\n  \n  \n  result=dict(admin__context__default=\"md5_crypt\")\n  self.assertEqual(parse(admin__context__default=\"md5_crypt\"),result)\n  self.assertEqual(parse(**{\"admin.context.default\":\"md5_crypt\"}),result)\n  \n  \n  \n  \n  \n  \n  result=dict(all__vary_rounds=0.1)\n  self.assertEqual(parse(all__vary_rounds=0.1),result)\n  self.assertEqual(parse(default__all__vary_rounds=0.1),result)\n  self.assertEqual(parse(**{\"all.vary_rounds\":0.1}),result)\n  self.assertEqual(parse(**{\"default.all.vary_rounds\":0.1}),result)\n  \n  \n  result=dict(admin__all__vary_rounds=0.1)\n  self.assertEqual(parse(admin__all__vary_rounds=0.1),result)\n  self.assertEqual(parse(**{\"admin.all.vary_rounds\":0.1}),result)\n  \n  \n  ctx=CryptContext([\"phpass\",\"md5_crypt\"],phpass__ident=\"P\")\n  self.assertRaises(KeyError,ctx.copy,md5_crypt__ident=\"P\")\n  \n  \n  self.assertRaises(KeyError,CryptContext,schemes=[\"des_crypt\"],\n  des_crypt__salt=\"xx\")\n  self.assertRaises(KeyError,CryptContext,schemes=[\"des_crypt\"],\n  all__salt=\"xx\")\n  \n def test_21_schemes(self):\n  ''\n  \n  \n  cc=CryptContext(schemes=None )\n  self.assertEqual(cc.schemes(),())\n  \n  \n  cc=CryptContext(schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(cc.schemes(),(\"des_crypt\",\"md5_crypt\"))\n  \n  \n  cc=CryptContext(schemes=\" des_crypt, md5_crypt, \")\n  self.assertEqual(cc.schemes(),(\"des_crypt\",\"md5_crypt\"))\n  \n  \n  cc=CryptContext(schemes=[hash.des_crypt,hash.md5_crypt])\n  self.assertEqual(cc.schemes(),(\"des_crypt\",\"md5_crypt\"))\n  \n  \n  self.assertRaises(TypeError,CryptContext,schemes=[uh.StaticHandler])\n  \n  \n  class nameless(uh.StaticHandler):\n   name=None\n  self.assertRaises(ValueError,CryptContext,schemes=[nameless])\n  \n  \n  class dummy_1(uh.StaticHandler):\n   name='dummy_1'\n  self.assertRaises(KeyError,CryptContext,schemes=[dummy_1,dummy_1])\n  \n  \n  self.assertRaises(KeyError,CryptContext,\n  admin__context__schemes=[\"md5_crypt\"])\n  \n def test_22_deprecated(self):\n  ''\n  def getdep(ctx,category=None ):\n   return [name for name in ctx.schemes()\n   if ctx.handler(name,category).deprecated]\n   \n   \n  cc=CryptContext(deprecated=[\"md5_crypt\"])\n  cc.update(schemes=[\"md5_crypt\",\"des_crypt\"])\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  \n  \n  cc=CryptContext(deprecated=[\"md5_crypt\"],schemes=[\"md5_crypt\",\"des_crypt\"])\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  \n  \n  \n  self.assertRaises(TypeError,CryptContext,deprecated=[hash.md5_crypt],\n  schemes=[\"md5_crypt\",\"des_crypt\"])\n  \n  \n  \n  \n  cc=CryptContext(deprecated=\"md5_crypt,des_crypt\",schemes=[\"md5_crypt\",\"des_crypt\",\"sha256_crypt\"])\n  self.assertEqual(getdep(cc),[\"md5_crypt\",\"des_crypt\"])\n  \n  \n  self.assertRaises(KeyError,CryptContext,schemes=['des_crypt'],\n  deprecated=['md5_crypt'])\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt'],\n  deprecated=['des_crypt'])\n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  admin__context__deprecated=['des_crypt','md5_crypt'])\n  \n  \n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  default=\"md5_crypt\",\n  deprecated=\"md5_crypt\")\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  default=\"md5_crypt\",\n  admin__context__deprecated=\"md5_crypt\")\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  admin__context__default=\"md5_crypt\",\n  deprecated=\"md5_crypt\")\n  \n  \n  self.assertRaises(ValueError,CryptContext,\n  schemes=['des_crypt','md5_crypt'],\n  admin__context__default=\"md5_crypt\",\n  admin__context__deprecated=\"md5_crypt\")\n  \n  \n  CryptContext(\n  schemes=['des_crypt','md5_crypt'],\n  deprecated=\"md5_crypt\",\n  admin__context__default=\"md5_crypt\",\n  admin__context__deprecated=[])\n  \n  \n  self.assertRaises(TypeError,CryptContext,deprecated=123)\n  \n  \n  cc=CryptContext(deprecated=[\"md5_crypt\"],\n  schemes=[\"md5_crypt\",\"des_crypt\"],\n  admin__context__deprecated=[\"des_crypt\"],\n  )\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"user\"),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"admin\"),[\"des_crypt\"])\n  \n  \n  cc=CryptContext(deprecated=[\"md5_crypt\"],\n  schemes=[\"md5_crypt\",\"des_crypt\"],\n  admin__context__deprecated=[],\n  )\n  self.assertEqual(getdep(cc),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"user\"),[\"md5_crypt\"])\n  self.assertEqual(getdep(cc,\"admin\"),[])\n  \n def test_23_default(self):\n  ''\n  \n  \n  self.assertEqual(CryptContext(default=\"md5_crypt\").to_dict(),\n  dict(default=\"md5_crypt\"))\n  \n  \n  ctx=CryptContext(default=\"md5_crypt\",schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  \n  \n  \n  ctx=CryptContext(default=hash.md5_crypt,schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  \n  \n  ctx=CryptContext(schemes=[\"des_crypt\",\"md5_crypt\"])\n  self.assertEqual(ctx.default_scheme(),\"des_crypt\")\n  ctx.update(deprecated=\"des_crypt\")\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  \n  \n  self.assertRaises(KeyError,CryptContext,schemes=['des_crypt'],\n  default='md5_crypt')\n  \n  \n  self.assertRaises(TypeError,CryptContext,default=1)\n  \n  \n  ctx=CryptContext(default=\"des_crypt\",\n  schemes=[\"des_crypt\",\"md5_crypt\"],\n  admin__context__default=\"md5_crypt\")\n  self.assertEqual(ctx.default_scheme(),\"des_crypt\")\n  self.assertEqual(ctx.default_scheme(\"user\"),\"des_crypt\")\n  self.assertEqual(ctx.default_scheme(\"admin\"),\"md5_crypt\")\n  \n def test_24_vary_rounds(self):\n  ''\n  def parse(v):\n   return CryptContext(all__vary_rounds=v).to_dict()['all__vary_rounds']\n   \n   \n  self.assertEqual(parse(0.1),0.1)\n  self.assertEqual(parse('0.1'),0.1)\n  \n  \n  self.assertEqual(parse('10%'),0.1)\n  \n  \n  self.assertEqual(parse(1000),1000)\n  self.assertEqual(parse('1000'),1000)\n  \n  \n  \n  \n  \n def assertHandlerDerivedFrom(self,handler,base,msg=None ):\n  self.assertTrue(handler_derived_from(handler,base),msg=msg)\n  \n def test_30_schemes(self):\n  ''\n  \n  \n  \n  ctx=CryptContext()\n  self.assertEqual(ctx.schemes(),())\n  self.assertEqual(ctx.schemes(resolve=True ),())\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.schemes(),tuple(self.sample_1_schemes))\n  self.assertEqual(ctx.schemes(resolve=True ,unconfigured=True ),tuple(self.sample_1_handlers))\n  for result,correct in zip(ctx.schemes(resolve=True ),self.sample_1_handlers):\n   self.assertTrue(handler_derived_from(result,correct))\n   \n   \n  ctx=CryptContext(**self.sample_2_dict)\n  self.assertEqual(ctx.schemes(),())\n  \n def test_31_default_scheme(self):\n  ''\n  \n  \n  \n  ctx=CryptContext()\n  self.assertRaises(KeyError,ctx.default_scheme)\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.default_scheme(),\"md5_crypt\")\n  self.assertEqual(ctx.default_scheme(resolve=True ,unconfigured=True ),hash.md5_crypt)\n  self.assertHandlerDerivedFrom(ctx.default_scheme(resolve=True ),hash.md5_crypt)\n  \n  \n  ctx=CryptContext(**self.sample_2_dict)\n  self.assertRaises(KeyError,ctx.default_scheme)\n  \n  \n  ctx=CryptContext(schemes=self.sample_1_schemes)\n  self.assertEqual(ctx.default_scheme(),\"des_crypt\")\n  \n  \n  \n def test_32_handler(self):\n  ''\n  \n  \n  ctx=CryptContext()\n  self.assertRaises(KeyError,ctx.handler)\n  self.assertRaises(KeyError,ctx.handler,\"md5_crypt\")\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.handler(unconfigured=True ),hash.md5_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(),hash.md5_crypt)\n  \n  \n  self.assertEqual(ctx.handler(\"des_crypt\",unconfigured=True ),hash.des_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(\"des_crypt\"),hash.des_crypt)\n  \n  \n  self.assertRaises(KeyError,ctx.handler,\"mysql323\")\n  \n  \n  ctx=CryptContext(\"sha256_crypt,md5_crypt\",admin__context__default=\"md5_crypt\")\n  self.assertEqual(ctx.handler(unconfigured=True ),hash.sha256_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(),hash.sha256_crypt)\n  \n  self.assertEqual(ctx.handler(category=\"staff\",unconfigured=True ),hash.sha256_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(category=\"staff\"),hash.sha256_crypt)\n  \n  self.assertEqual(ctx.handler(category=\"admin\",unconfigured=True ),hash.md5_crypt)\n  self.assertHandlerDerivedFrom(ctx.handler(category=\"staff\"),hash.sha256_crypt)\n  \n  \n  if PY2:\n   self.assertEqual(ctx.handler(category=u(\"staff\"),unconfigured=True ),hash.sha256_crypt)\n   self.assertEqual(ctx.handler(category=u(\"admin\"),unconfigured=True ),hash.md5_crypt)\n   \n def test_33_options(self):\n  ''\n  \n  def options(ctx,scheme,category=None ):\n   return ctx._config._get_record_options_with_flag(scheme,category)[0]\n   \n   \n   \n  cc4=CryptContext(\n  truncate_error=True ,\n  schemes=[\"sha512_crypt\",\"des_crypt\",\"bsdi_crypt\"],\n  deprecated=[\"sha512_crypt\",\"des_crypt\"],\n  all__vary_rounds=0.1,\n  bsdi_crypt__vary_rounds=0.2,\n  sha512_crypt__max_rounds=20000,\n  admin__context__deprecated=[\"des_crypt\",\"bsdi_crypt\"],\n  admin__all__vary_rounds=0.05,\n  admin__bsdi_crypt__vary_rounds=0.3,\n  admin__sha512_crypt__max_rounds=40000,\n  )\n  self.assertEqual(cc4._config.categories,(\"admin\",))\n  \n  \n  \n  \n  \n  self.assertEqual(options(cc4,\"sha512_crypt\"),dict(\n  deprecated=True ,\n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(options(cc4,\"sha512_crypt\",\"user\"),dict(\n  deprecated=True ,\n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(options(cc4,\"sha512_crypt\",\"admin\"),dict(\n  \n  vary_rounds=0.05,\n  max_rounds=40000,\n  ))\n  \n  \n  \n  \n  \n  self.assertEqual(options(cc4,\"des_crypt\"),dict(\n  deprecated=True ,\n  truncate_error=True ,\n  ))\n  \n  self.assertEqual(options(cc4,\"des_crypt\",\"user\"),dict(\n  deprecated=True ,\n  truncate_error=True ,\n  ))\n  \n  self.assertEqual(options(cc4,\"des_crypt\",\"admin\"),dict(\n  deprecated=True ,\n  truncate_error=True ,\n  ))\n  \n  \n  \n  \n  self.assertEqual(options(cc4,\"bsdi_crypt\"),dict(\n  vary_rounds=0.2,\n  ))\n  \n  self.assertEqual(options(cc4,\"bsdi_crypt\",\"user\"),dict(\n  vary_rounds=0.2,\n  ))\n  \n  self.assertEqual(options(cc4,\"bsdi_crypt\",\"admin\"),dict(\n  vary_rounds=0.3,\n  deprecated=True ,\n  ))\n  \n def test_34_to_dict(self):\n  ''\n  \n  ctx=CryptContext(**self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(),self.sample_1_dict)\n  self.assertEqual(ctx.to_dict(resolve=True ),self.sample_1_resolved_dict)\n  \n def test_35_to_string(self):\n  ''\n  \n  \n  ctx=CryptContext(**self.sample_1_dict)\n  dump=ctx.to_string()\n  \n  \n  \n  \n  \n  if not PY26:\n   self.assertEqual(dump,self.sample_1_unicode)\n   \n   \n  ctx2=CryptContext.from_string(dump)\n  self.assertEqual(ctx2.to_dict(),self.sample_1_dict)\n  \n  \n  other=ctx.to_string(section=\"password-security\")\n  self.assertEqual(other,dump.replace(\"[passlib]\",\"[password-security]\"))\n  \n  \n  from passlib.tests.test_utils_handlers import UnsaltedHash\n  ctx3=CryptContext([UnsaltedHash,\"md5_crypt\"])\n  dump=ctx3.to_string()\n  self.assertRegex(dump,r\"# NOTE: the 'unsalted_test_hash' handler\\(s\\)\"\n  r\" are not registered with Passlib\")\n  \n  \n  \n  \n nonstring_vectors=[\n (None ,{}),\n (None ,{\"scheme\":\"des_crypt\"}),\n (1,{}),\n ((),{}),\n ]\n \n def test_40_basic(self):\n  ''\n  handlers=[hash.md5_crypt,hash.des_crypt,hash.bsdi_crypt]\n  cc=CryptContext(handlers,bsdi_crypt__default_rounds=5)\n  \n  \n  for crypt in handlers:\n   h=cc.hash(\"test\",scheme=crypt.name)\n   self.assertEqual(cc.identify(h),crypt.name)\n   self.assertEqual(cc.identify(h,resolve=True ,unconfigured=True ),crypt)\n   self.assertHandlerDerivedFrom(cc.identify(h,resolve=True ),crypt)\n   self.assertTrue(cc.verify('test',h))\n   self.assertFalse(cc.verify('notest',h))\n   \n   \n  h=cc.hash(\"test\")\n  self.assertEqual(cc.identify(h),\"md5_crypt\")\n  \n  \n  h=cc.genhash('secret',cc.genconfig())\n  self.assertEqual(cc.identify(h),'md5_crypt')\n  \n  h=cc.genhash('secret',cc.genconfig(),scheme='md5_crypt')\n  self.assertEqual(cc.identify(h),'md5_crypt')\n  \n  self.assertRaises(ValueError,cc.genhash,'secret',cc.genconfig(),scheme=\"des_crypt\")\n  \n def test_41_genconfig(self):\n  ''\n  cc=CryptContext(schemes=[\"md5_crypt\",\"phpass\"],\n  phpass__ident=\"H\",\n  phpass__default_rounds=7,\n  admin__phpass__ident=\"P\",\n  )\n  \n  \n  self.assertTrue(cc.genconfig().startswith(\"$1$\"))\n  \n  \n  self.assertTrue(cc.genconfig(scheme=\"phpass\").startswith(\"$H$5\"))\n  \n  \n  self.assertTrue(cc.genconfig(scheme=\"phpass\",category=\"admin\").startswith(\"$P$5\"))\n  self.assertTrue(cc.genconfig(scheme=\"phpass\",category=\"staff\").startswith(\"$H$5\"))\n  \n  \n  self.assertEqual(\n  cc.genconfig(scheme=\"phpass\",salt='.'*8,rounds=8,ident='P'),\n  '$P$6........22zGEuacuPOqEpYPDeR0R/',\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n  if PY2:\n   c2=cc.copy(default=\"phpass\")\n   self.assertTrue(c2.genconfig(category=u(\"admin\")).startswith(\"$P$5\"))\n   self.assertTrue(c2.genconfig(category=u(\"staff\")).startswith(\"$H$5\"))\n   \n   \n  self.assertRaises(KeyError,CryptContext().genconfig)\n  self.assertRaises(KeyError,CryptContext().genconfig,scheme='md5_crypt')\n  \n  \n  self.assertRaises(KeyError,cc.genconfig,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.genconfig,scheme=1,category='staff')\n  self.assertRaises(TypeError,cc.genconfig,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.genconfig,category=1)\n  \n  \n def test_42_genhash(self):\n  ''\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  hash=cc.hash('stub')\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.genhash,secret,hash,**kwds)\n   \n   \n  cc=CryptContext([\"des_crypt\"])\n  for config,kwds in self.nonstring_vectors:\n   if hash is None :\n   \n   \n    continue\n   self.assertRaises(TypeError,cc.genhash,'secret',config,**kwds)\n   \n   \n  cc=CryptContext([\"mysql323\"])\n  self.assertRaises(TypeError,cc.genhash,\"stub\",None )\n  \n  \n  self.assertRaises(KeyError,CryptContext().genhash,'secret','hash')\n  \n  \n  self.assertRaises(KeyError,cc.genhash,'secret',hash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.genhash,'secret',hash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.genconfig,'secret',hash,category=1)\n  \n def test_43_hash(self,):\n  ''\n  \n  \n  \n  \n  cc=CryptContext(**self.sample_4_dict)\n  hash=cc.hash(\"password\")\n  self.assertTrue(hash.startswith(\"$5$rounds=3000$\"))\n  self.assertTrue(cc.verify(\"password\",hash))\n  self.assertFalse(cc.verify(\"passwordx\",hash))\n  \n  \n  \n  self.assertRaises(ValueError,cc.copy,\n  sha256_crypt__default_rounds=4000)\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.hash,secret,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().hash,'secret')\n  \n  \n  self.assertRaises(TypeError,cc.hash,'secret',category=1)\n  \n def test_43_hash_legacy(self,use_16_legacy=False ):\n  ''\n  cc=CryptContext(**self.sample_4_dict)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",scheme=\"phpass\",salt='.'*8),\n   '$H$5........De04R5Egz0aq8Tf.1eVhY/',\n   )\n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",scheme=\"phpass\",salt='.'*8,ident=\"P\"),\n   '$P$5........De04R5Egz0aq8Tf.1eVhY/',\n   )\n   \n   \n   \n   \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",rounds=1999,salt=\"nacl\"),\n   '$5$rounds=1999$nacl$nmfwJIxqj0csloAAvSER0B8LU0ERCAbhmMug4Twl609',\n   )\n   \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertEqual(\n   cc.hash(\"password\",rounds=2001,salt=\"nacl\"),\n   '$5$rounds=2001$nacl$8PdeoPL4aXQnJ0woHhqgIw/efyfCKC2WHneOpnvF.31'\n   )\n   \n   \n   \n  self.assertRaises(KeyError,cc.hash,'secret',scheme=\"fake\")\n  self.assertRaises(TypeError,cc.hash,'secret',scheme=1)\n  \n def test_44_identify(self):\n  ''\n  handlers=[\"md5_crypt\",\"des_crypt\",\"bsdi_crypt\"]\n  cc=CryptContext(handlers,bsdi_crypt__default_rounds=5)\n  \n  \n  self.assertEqual(cc.identify('$9$232323123$1287319827'),None )\n  self.assertRaises(ValueError,cc.identify,'$9$232323123$1287319827',required=True )\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.identify,hash,**kwds)\n   \n   \n  cc=CryptContext()\n  self.assertIs(cc.identify('hash'),None )\n  self.assertRaises(KeyError,cc.identify,'hash',required=True )\n  \n  \n  self.assertRaises(TypeError,cc.identify,None ,category=1)\n  \n def test_45_verify(self):\n  ''\n  handlers=[\"md5_crypt\",\"des_crypt\",\"bsdi_crypt\"]\n  cc=CryptContext(handlers,bsdi_crypt__default_rounds=5)\n  \n  h=hash.md5_crypt.hash(\"test\")\n  \n  \n  self.assertTrue(cc.verify(\"test\",h))\n  self.assertTrue(not cc.verify(\"notest\",h))\n  \n  \n  self.assertTrue(cc.verify('test',h,scheme='md5_crypt'))\n  self.assertTrue(not cc.verify('notest',h,scheme='md5_crypt'))\n  \n  \n  self.assertRaises(ValueError,cc.verify,'test',h,scheme='bsdi_crypt')\n  \n  \n  \n  \n  \n  \n  self.assertRaises(ValueError,cc.verify,'stub','$6$232323123$1287319827')\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  h=refhash=cc.hash('stub')\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.verify,secret,h,**kwds)\n   \n   \n  self.assertFalse(cc.verify(secret,None ))\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for h,kwds in self.nonstring_vectors:\n   if h is None :\n    continue\n   self.assertRaises(TypeError,cc.verify,'secret',h,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().verify,'secret','hash')\n  \n  \n  self.assertRaises(KeyError,cc.verify,'secret',refhash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.verify,'secret',refhash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.verify,'secret',refhash,category=1)\n  \n def test_46_needs_update(self):\n  ''\n  cc=CryptContext(**self.sample_4_dict)\n  \n  \n  self.assertTrue(cc.needs_update('9XXD4trGYeGJA'))\n  self.assertFalse(cc.needs_update('$1$J8HC2RCr$HcmM.7NxB2weSvlw2FgzU0'))\n  \n  \n  self.assertTrue(cc.needs_update('$5$rounds=1999$jD81UCoo.zI.UETs$Y7qSTQ6mTiU9qZB4fRr43wRgQq4V.5AAf7F97Pzxey/'))\n  self.assertFalse(cc.needs_update('$5$rounds=2000$228SSRje04cnNCaQ$YGV4RYu.5sNiBvorQDlO0WWQjyJVGKBcJXz3OtyQ2u8'))\n  \n  \n  self.assertFalse(cc.needs_update('$5$rounds=3000$fS9iazEwTKi7QPW4$VasgBC8FqlOvD7x2HhABaMXCTh9jwHclPA9j5YQdns.'))\n  self.assertTrue(cc.needs_update('$5$rounds=3001$QlFHHifXvpFX4PLs$/0ekt7lSs/lOikSerQ0M/1porEHxYq7W/2hdFpxA3fA'))\n  \n  \n  \n  \n  check_state=[]\n  class dummy(uh.StaticHandler):\n   name='dummy'\n   _hash_prefix='@'\n   \n   @classmethod\n   def needs_update(cls,hash,secret=None ):\n    check_state.append((hash,secret))\n    return secret ==\"nu\"\n    \n   def _calc_checksum(self,secret):\n    from hashlib import md5\n    if isinstance(secret,unicode):\n     secret=secret.encode(\"utf-8\")\n    return str_to_uascii(md5(secret).hexdigest())\n    \n    \n  ctx=CryptContext([dummy])\n  hash=refhash=dummy.hash(\"test\")\n  self.assertFalse(ctx.needs_update(hash))\n  self.assertEqual(check_state,[(hash,None )])\n  del check_state[:]\n  \n  \n  self.assertFalse(ctx.needs_update(hash,secret='bob'))\n  self.assertEqual(check_state,[(hash,'bob')])\n  del check_state[:]\n  \n  \n  self.assertTrue(ctx.needs_update(hash,secret='nu'))\n  self.assertEqual(check_state,[(hash,'nu')])\n  del check_state[:]\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.needs_update,hash,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().needs_update,'hash')\n  \n  \n  self.assertRaises(KeyError,cc.needs_update,refhash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.needs_update,refhash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.needs_update,refhash,category=1)\n  \n def test_47_verify_and_update(self):\n  ''\n  cc=CryptContext(**self.sample_4_dict)\n  \n  \n  h1=cc.handler(\"des_crypt\").hash(\"password\")\n  h2=cc.handler(\"sha256_crypt\").hash(\"password\")\n  \n  \n  ok,new_hash=cc.verify_and_update(\"wrongpass\",h1)\n  self.assertFalse(ok)\n  self.assertIs(new_hash,None )\n  \n  \n  ok,new_hash=cc.verify_and_update(\"wrongpass\",h2)\n  self.assertFalse(ok)\n  self.assertIs(new_hash,None )\n  \n  \n  ok,new_hash=cc.verify_and_update(\"password\",h1)\n  self.assertTrue(ok)\n  self.assertTrue(cc.identify(new_hash),\"sha256_crypt\")\n  \n  \n  ok,new_hash=cc.verify_and_update(\"password\",h2)\n  self.assertTrue(ok)\n  self.assertIs(new_hash,None )\n  \n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  hash=refhash=cc.hash('stub')\n  for secret,kwds in self.nonstring_vectors:\n   self.assertRaises(TypeError,cc.verify_and_update,secret,hash,**kwds)\n   \n   \n  self.assertEqual(cc.verify_and_update(secret,None ),(False ,None ))\n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in self.nonstring_vectors:\n   if hash is None :\n    continue\n   self.assertRaises(TypeError,cc.verify_and_update,'secret',hash,**kwds)\n   \n   \n  self.assertRaises(KeyError,CryptContext().verify_and_update,'secret','hash')\n  \n  \n  self.assertRaises(KeyError,cc.verify_and_update,'secret',refhash,scheme=\"fake\")\n  self.assertRaises(TypeError,cc.verify_and_update,'secret',refhash,scheme=1)\n  \n  \n  self.assertRaises(TypeError,cc.verify_and_update,'secret',refhash,category=1)\n  \n def test_48_context_kwds(self):\n  ''\n  \n  \n  \n  from passlib.hash import des_crypt,md5_crypt,postgres_md5\n  des_hash=des_crypt.hash(\"stub\")\n  pg_root_hash=postgres_md5.hash(\"stub\",user=\"root\")\n  pg_admin_hash=postgres_md5.hash(\"stub\",user=\"admin\")\n  \n  \n  \n  \n  cc1=CryptContext([des_crypt,md5_crypt])\n  self.assertEqual(cc1.context_kwds,set())\n  \n  \n  self.assertTrue(des_crypt.identify(cc1.hash(\"stub\")),\"des_crypt\")\n  self.assertTrue(cc1.verify(\"stub\",des_hash))\n  self.assertEqual(cc1.verify_and_update(\"stub\",des_hash),(True ,None ))\n  \n  \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertRaises(TypeError,cc1.hash,\"stub\",user=\"root\")\n  self.assertRaises(TypeError,cc1.verify,\"stub\",des_hash,user=\"root\")\n  self.assertRaises(TypeError,cc1.verify_and_update,\"stub\",des_hash,user=\"root\")\n  \n  \n  \n  \n  cc2=CryptContext([des_crypt,postgres_md5])\n  self.assertEqual(cc2.context_kwds,set([\"user\"]))\n  \n  \n  self.assertTrue(des_crypt.identify(cc2.hash(\"stub\")),\"des_crypt\")\n  self.assertTrue(cc2.verify(\"stub\",des_hash))\n  self.assertEqual(cc2.verify_and_update(\"stub\",des_hash),(True ,None ))\n  \n  \n  self.assertTrue(des_crypt.identify(cc2.hash(\"stub\",user=\"root\")),\"des_crypt\")\n  self.assertTrue(cc2.verify(\"stub\",des_hash,user=\"root\"))\n  self.assertEqual(cc2.verify_and_update(\"stub\",des_hash,user=\"root\"),(True ,None ))\n  \n  \n  with self.assertWarningList([\"passing settings to.*is deprecated\"]):\n   self.assertRaises(TypeError,cc2.hash,\"stub\",badkwd=\"root\")\n  self.assertRaises(TypeError,cc2.verify,\"stub\",des_hash,badkwd=\"root\")\n  self.assertRaises(TypeError,cc2.verify_and_update,\"stub\",des_hash,badkwd=\"root\")\n  \n  \n  \n  \n  cc3=CryptContext([postgres_md5,des_crypt],deprecated=\"auto\")\n  self.assertEqual(cc3.context_kwds,set([\"user\"]))\n  \n  \n  self.assertRaises(TypeError,cc3.hash,\"stub\")\n  self.assertRaises(TypeError,cc3.verify,\"stub\",pg_root_hash)\n  self.assertRaises(TypeError,cc3.verify_and_update,\"stub\",pg_root_hash)\n  \n  \n  self.assertEqual(cc3.hash(\"stub\",user=\"root\"),pg_root_hash)\n  self.assertTrue(cc3.verify(\"stub\",pg_root_hash,user=\"root\"))\n  self.assertEqual(cc3.verify_and_update(\"stub\",pg_root_hash,user=\"root\"),(True ,None ))\n  \n  \n  self.assertEqual(cc3.verify_and_update(\"stub\",pg_root_hash,user=\"admin\"),(False ,None ))\n  \n  \n  self.assertEqual(cc3.verify_and_update(\"stub\",des_hash,user=\"root\"),\n  (True ,pg_root_hash))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def test_50_rounds_limits(self):\n  ''\n  cc=CryptContext(schemes=[\"sha256_crypt\"],\n  sha256_crypt__min_rounds=2000,\n  sha256_crypt__max_rounds=3000,\n  sha256_crypt__default_rounds=2500,\n  )\n  \n  \n  STUB='...........................................'\n  \n  \n  \n  \n  \n  custom_handler=cc._get_record(\"sha256_crypt\",None )\n  self.assertEqual(custom_handler.min_desired_rounds,2000)\n  self.assertEqual(custom_handler.max_desired_rounds,3000)\n  self.assertEqual(custom_handler.default_rounds,2500)\n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([PasslibHashWarning]*2):\n   c2=cc.copy(sha256_crypt__min_rounds=500,sha256_crypt__max_rounds=None ,\n   sha256_crypt__default_rounds=500)\n  self.assertEqual(c2.genconfig(salt=\"nacl\"),\"$5$rounds=1000$nacl$\"+STUB)\n  \n  \n  \n  with self.assertWarningList([]):\n   self.assertEqual(\n   cc.genconfig(rounds=1999,salt=\"nacl\"),'$5$rounds=1999$nacl$'+STUB)\n   \n   \n  self.assertEqual(\n  cc.genconfig(rounds=2000,salt=\"nacl\"),'$5$rounds=2000$nacl$'+STUB)\n  \n  \n  self.assertEqual(\n  cc.genconfig(rounds=2001,salt=\"nacl\"),'$5$rounds=2001$nacl$'+STUB)\n  \n  \n  \n  \n  \n  \n  with self.assertWarningList([PasslibHashWarning]*2):\n   c2=cc.copy(sha256_crypt__max_rounds=int(1e9)+500,sha256_crypt__min_rounds=None ,\n   sha256_crypt__default_rounds=int(1e9)+500)\n   \n  self.assertEqual(c2.genconfig(salt=\"nacl\"),\"$5$rounds=999999999$nacl$\"+STUB)\n  \n  \n  \n  with self.assertWarningList([]):\n   self.assertEqual(\n   cc.genconfig(rounds=3001,salt=\"nacl\"),'$5$rounds=3001$nacl$'+STUB)\n   \n   \n  self.assertEqual(\n  cc.genconfig(rounds=3000,salt=\"nacl\"),'$5$rounds=3000$nacl$'+STUB)\n  \n  \n  self.assertEqual(\n  cc.genconfig(rounds=2999,salt=\"nacl\"),'$5$rounds=2999$nacl$'+STUB)\n  \n  \n  \n  \n  \n  \n  self.assertEqual(cc.genconfig(salt=\"nacl\"),'$5$rounds=2500$nacl$'+STUB)\n  \n  \n  df=hash.sha256_crypt.default_rounds\n  c2=cc.copy(sha256_crypt__default_rounds=None ,sha256_crypt__max_rounds=df <<1)\n  self.assertEqual(c2.genconfig(salt=\"nacl\"),'$5$rounds=%d$nacl$%s'%(df,STUB))\n  \n  \n  c2=cc.copy(sha256_crypt__default_rounds=None ,sha256_crypt__max_rounds=3000)\n  self.assertEqual(c2.genconfig(salt=\"nacl\"),'$5$rounds=3000$nacl$'+STUB)\n  \n  \n  \n  \n  self.assertRaises(ValueError,cc.copy,sha256_crypt__default_rounds=1999)\n  cc.copy(sha256_crypt__default_rounds=2000)\n  cc.copy(sha256_crypt__default_rounds=3000)\n  self.assertRaises(ValueError,cc.copy,sha256_crypt__default_rounds=3001)\n  \n  \n  \n  \n  \n  \n  c2=CryptContext(schemes=[\"sha256_crypt\"])\n  \n  \n  \n  self.assertRaises(ValueError,c2.copy,sha256_crypt__min_rounds=2000,\n  sha256_crypt__max_rounds=1999)\n  \n  \n  self.assertRaises(ValueError,CryptContext,sha256_crypt__min_rounds='x')\n  self.assertRaises(ValueError,CryptContext,sha256_crypt__max_rounds='x')\n  self.assertRaises(ValueError,CryptContext,all__vary_rounds='x')\n  self.assertRaises(ValueError,CryptContext,sha256_crypt__default_rounds='x')\n  \n  \n  bad=datetime.datetime.now()\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",sha256_crypt__min_rounds=bad)\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",sha256_crypt__max_rounds=bad)\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",all__vary_rounds=bad)\n  self.assertRaises(TypeError,CryptContext,\"sha256_crypt\",sha256_crypt__default_rounds=bad)\n  \n def test_51_linear_vary_rounds(self):\n  ''\n  cc=CryptContext(schemes=[\"sha256_crypt\"],\n  sha256_crypt__min_rounds=1995,\n  sha256_crypt__max_rounds=2005,\n  sha256_crypt__default_rounds=2000,\n  )\n  \n  \n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=-1)\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"-1%\")\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"101%\")\n  \n  \n  c2=cc.copy(all__vary_rounds=0)\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"sha256_crypt\",2000,2000)\n  \n  c2=cc.copy(all__vary_rounds=\"0%\")\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"sha256_crypt\",2000,2000)\n  \n  \n  c2=cc.copy(all__vary_rounds=1)\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,1)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1999,2001)\n  c2=cc.copy(all__vary_rounds=100)\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,100)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1995,2005)\n  \n  \n  c2=cc.copy(all__vary_rounds=\"0.1%\")\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,0.001)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1998,2002)\n  c2=cc.copy(all__vary_rounds=\"100%\")\n  self.assertEqual(c2._get_record(\"sha256_crypt\",None ).vary_rounds,1.0)\n  self.assert_rounds_range(c2,\"sha256_crypt\",1995,2005)\n  \n def test_52_log2_vary_rounds(self):\n  ''\n  cc=CryptContext(schemes=[\"bcrypt\"],\n  bcrypt__min_rounds=15,\n  bcrypt__max_rounds=25,\n  bcrypt__default_rounds=20,\n  )\n  \n  \n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=-1)\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"-1%\")\n  self.assertRaises(ValueError,cc.copy,all__vary_rounds=\"101%\")\n  \n  \n  c2=cc.copy(all__vary_rounds=0)\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  c2=cc.copy(all__vary_rounds=\"0%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  \n  c2=cc.copy(all__vary_rounds=1)\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,1)\n  self.assert_rounds_range(c2,\"bcrypt\",19,21)\n  c2=cc.copy(all__vary_rounds=100)\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,100)\n  self.assert_rounds_range(c2,\"bcrypt\",15,25)\n  \n  \n  c2=cc.copy(all__vary_rounds=\"1%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0.01)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  c2=cc.copy(all__vary_rounds=\"49%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0.49)\n  self.assert_rounds_range(c2,\"bcrypt\",20,20)\n  \n  c2=cc.copy(all__vary_rounds=\"50%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,0.5)\n  self.assert_rounds_range(c2,\"bcrypt\",19,20)\n  \n  c2=cc.copy(all__vary_rounds=\"100%\")\n  self.assertEqual(c2._get_record(\"bcrypt\",None ).vary_rounds,1.0)\n  self.assert_rounds_range(c2,\"bcrypt\",15,21)\n  \n def assert_rounds_range(self,context,scheme,lower,upper):\n  ''\n  \n  \n  handler=context.handler(scheme)\n  salt=handler.default_salt_chars[0:1]*handler.max_salt_size\n  seen=set()\n  for i in irange(300):\n   h=context.genconfig(scheme,salt=salt)\n   r=handler.from_string(h).rounds\n   seen.add(r)\n  self.assertEqual(min(seen),lower,\"vary_rounds had wrong lower limit:\")\n  self.assertEqual(max(seen),upper,\"vary_rounds had wrong upper limit:\")\n  \n  \n  \n  \n def test_harden_verify_parsing(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\".*harden_verify.*\",\n  category=DeprecationWarning)\n  \n  \n  ctx=CryptContext(schemes=[\"sha256_crypt\"])\n  self.assertEqual(ctx.harden_verify,None )\n  self.assertEqual(ctx.using(harden_verify=\"\").harden_verify,None )\n  self.assertEqual(ctx.using(harden_verify=\"true\").harden_verify,None )\n  self.assertEqual(ctx.using(harden_verify=\"false\").harden_verify,None )\n  \n def test_dummy_verify(self):\n  ''\n\n  \n  \n  expected=0.05\n  accuracy=0.2\n  handler=DelayHash.using()\n  handler.delay=expected\n  ctx=CryptContext(schemes=[handler])\n  ctx.dummy_verify()\n  elapsed,_=time_call(ctx.dummy_verify)\n  self.assertAlmostEqual(elapsed,expected,delta=expected *accuracy)\n  \n  \n  \n  \n  \n  \n  \n def test_61_autodeprecate(self):\n  ''\n  \n  def getstate(ctx,category=None ):\n   return [ctx.handler(scheme,category).deprecated for scheme in ctx.schemes()]\n   \n   \n  ctx=CryptContext(\"sha256_crypt,md5_crypt,des_crypt\",deprecated=\"auto\")\n  self.assertEqual(getstate(ctx,None ),[False ,True ,True ])\n  self.assertEqual(getstate(ctx,\"admin\"),[False ,True ,True ])\n  \n  \n  ctx.update(default=\"md5_crypt\")\n  self.assertEqual(getstate(ctx,None ),[True ,False ,True ])\n  self.assertEqual(getstate(ctx,\"admin\"),[True ,False ,True ])\n  \n  \n  ctx.update(admin__context__default=\"des_crypt\")\n  self.assertEqual(getstate(ctx,None ),[True ,False ,True ])\n  self.assertEqual(getstate(ctx,\"admin\"),[True ,True ,False ])\n  \n  \n  ctx=CryptContext([\"sha256_crypt\"],deprecated=\"auto\")\n  self.assertEqual(getstate(ctx,None ),[False ])\n  self.assertEqual(getstate(ctx,\"admin\"),[False ])\n  \n  \n  self.assertRaises(ValueError,CryptContext,\"sha256_crypt,md5_crypt\",\n  deprecated=\"auto,md5_crypt\")\n  self.assertRaises(ValueError,CryptContext,\"sha256_crypt,md5_crypt\",\n  deprecated=\"md5_crypt,auto\")\n  \n def test_disabled_hashes(self):\n  ''\n  \n  \n  \n  from passlib.exc import UnknownHashError\n  from passlib.hash import md5_crypt,unix_disabled\n  \n  ctx=CryptContext([\"des_crypt\"])\n  ctx2=CryptContext([\"des_crypt\",\"unix_disabled\"])\n  h_ref=ctx.hash(\"foo\")\n  h_other=md5_crypt.hash('foo')\n  \n  \n  \n  \n  \n  \n  self.assertRaisesRegex(RuntimeError,\"no disabled hasher present\",\n  ctx.disable)\n  self.assertRaisesRegex(RuntimeError,\"no disabled hasher present\",\n  ctx.disable,h_ref)\n  self.assertRaisesRegex(RuntimeError,\"no disabled hasher present\",\n  ctx.disable,h_other)\n  \n  \n  h_dis=ctx2.disable()\n  self.assertEqual(h_dis,unix_disabled.default_marker)\n  h_dis_ref=ctx2.disable(h_ref)\n  self.assertEqual(h_dis_ref,unix_disabled.default_marker+h_ref)\n  \n  h_dis_other=ctx2.disable(h_other)\n  self.assertEqual(h_dis_other,unix_disabled.default_marker+h_other)\n  \n  \n  self.assertEqual(ctx2.disable(h_dis_ref),h_dis_ref)\n  \n  \n  \n  \n  \n  \n  self.assertTrue(ctx.is_enabled(h_ref))\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_other)\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_dis)\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_dis_ref)\n  \n  \n  self.assertTrue(ctx2.is_enabled(h_ref))\n  self.assertRaises(UnknownHashError,ctx.is_enabled,h_other)\n  self.assertFalse(ctx2.is_enabled(h_dis))\n  self.assertFalse(ctx2.is_enabled(h_dis_ref))\n  \n  \n  \n  \n  \n  \n  self.assertRaises(UnknownHashError,ctx.enable,\"\")\n  self.assertRaises(TypeError,ctx.enable,None )\n  self.assertEqual(ctx.enable(h_ref),h_ref)\n  self.assertRaises(UnknownHashError,ctx.enable,h_other)\n  self.assertRaises(UnknownHashError,ctx.enable,h_dis)\n  self.assertRaises(UnknownHashError,ctx.enable,h_dis_ref)\n  \n  \n  self.assertRaises(UnknownHashError,ctx.enable,\"\")\n  self.assertRaises(TypeError,ctx2.enable,None )\n  self.assertEqual(ctx2.enable(h_ref),h_ref)\n  self.assertRaises(UnknownHashError,ctx2.enable,h_other)\n  self.assertRaisesRegex(ValueError,\"cannot restore original hash\",\n  ctx2.enable,h_dis)\n  self.assertEqual(ctx2.enable(h_dis_ref),h_ref)\n  \n  \n  \n  \n  \nimport hashlib,time\n\nclass DelayHash(uh.StaticHandler):\n ''\n name=\"delay_hash\"\n checksum_chars=uh.LOWER_HEX_CHARS\n checksum_size=40\n delay=0\n _hash_prefix=u(\"$x$\")\n \n def _calc_checksum(self,secret):\n  time.sleep(self.delay)\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(hashlib.sha1(b\"prefix\"+secret).hexdigest())\n  \n  \n  \n  \nclass dummy_2(uh.StaticHandler):\n name=\"dummy_2\"\n \nclass LazyCryptContextTest(TestCase):\n descriptionPrefix=\"LazyCryptContext\"\n \n def setUp(self):\n \n  unload_handler_name(\"dummy_2\")\n  self.addCleanup(unload_handler_name,\"dummy_2\")\n  \n def test_kwd_constructor(self):\n  ''\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  cc=LazyCryptContext(iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertEqual(cc.schemes(),(\"dummy_2\",\"des_crypt\"))\n  self.assertTrue(cc.handler(\"des_crypt\").deprecated)\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n def test_callable_constructor(self):\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  def onload(flag=False ):\n   self.assertTrue(flag)\n   return dict(schemes=iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n   \n  cc=LazyCryptContext(onload=onload,flag=True )\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertEqual(cc.schemes(),(\"dummy_2\",\"des_crypt\"))\n  self.assertTrue(cc.handler(\"des_crypt\").deprecated)\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n  \n  \n  \n", ["ConfigParser", "__future__", "configparser", "datetime", "functools", "hashlib", "logging", "os", "passlib", "passlib.context", "passlib.exc", "passlib.hash", "passlib.registry", "passlib.tests.test_utils_handlers", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "time", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_context_deprecated": [".py", "''\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement\n\nfrom logging import getLogger\nimport os\nimport warnings\n\ntry :\n from pkg_resources import resource_filename\nexcept ImportError:\n resource_filename=None\n \nfrom passlib import hash\nfrom passlib.context import CryptContext,CryptPolicy,LazyCryptContext\nfrom passlib.utils import to_bytes,to_unicode\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import TestCase,set_file\nfrom passlib.registry import (register_crypt_handler_path,\n_has_crypt_handler as has_crypt_handler,\n_unload_handler_name as unload_handler_name,\n)\n\nlog=getLogger(__name__)\n\n\n\n\nclass CryptPolicyTest(TestCase):\n ''\n \n \n \n descriptionPrefix=\"CryptPolicy\"\n \n \n \n \n \n \n \n \n \n sample_config_1s=\"\"\"\\\n[passlib]\nschemes = des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\ndefault = md5_crypt\nall.vary_rounds = 10%%\nbsdi_crypt.max_rounds = 30000\nbsdi_crypt.default_rounds = 25000\nsha512_crypt.max_rounds = 50000\nsha512_crypt.min_rounds = 40000\n\"\"\"\n sample_config_1s_path=os.path.abspath(os.path.join(\n os.path.dirname(__file__),\"sample_config_1s.cfg\"))\n if not os.path.exists(sample_config_1s_path)and resource_filename:\n \n  sample_config_1s_path=resource_filename(\"passlib.tests\",\n  \"sample_config_1s.cfg\")\n  \n  \n assert sample_config_1s.startswith(\"[passlib]\\nschemes\")\n \n sample_config_1pd=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n default=\"md5_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__max_rounds=30000,\n bsdi_crypt__default_rounds=25000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=40000,\n )\n \n sample_config_1pid={\n \"schemes\":\"des_crypt, md5_crypt, bsdi_crypt, sha512_crypt\",\n \"default\":\"md5_crypt\",\n \n \"all.vary_rounds\":0.1,\n \"bsdi_crypt.max_rounds\":30000,\n \"bsdi_crypt.default_rounds\":25000,\n \"sha512_crypt.max_rounds\":50000,\n \"sha512_crypt.min_rounds\":40000,\n }\n \n sample_config_1prd=dict(\n schemes=[hash.des_crypt,hash.md5_crypt,hash.bsdi_crypt,hash.sha512_crypt],\n default=\"md5_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__max_rounds=30000,\n bsdi_crypt__default_rounds=25000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=40000,\n )\n \n \n \n \n sample_config_2s=\"\"\"\\\n[passlib]\nbsdi_crypt.min_rounds = 29000\nbsdi_crypt.max_rounds = 35000\nbsdi_crypt.default_rounds = 31000\nsha512_crypt.min_rounds = 45000\n\"\"\"\n \n sample_config_2pd=dict(\n \n bsdi_crypt__min_rounds=29000,\n bsdi_crypt__max_rounds=35000,\n bsdi_crypt__default_rounds=31000,\n \n sha512_crypt__min_rounds=45000,\n )\n \n sample_config_12pd=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n default=\"md5_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__min_rounds=29000,\n bsdi_crypt__max_rounds=35000,\n bsdi_crypt__default_rounds=31000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=45000,\n )\n \n \n \n \n sample_config_3pd=dict(\n default=\"sha512_crypt\",\n )\n \n sample_config_123pd=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n default=\"sha512_crypt\",\n \n all__vary_rounds=0.1,\n bsdi_crypt__min_rounds=29000,\n bsdi_crypt__max_rounds=35000,\n bsdi_crypt__default_rounds=31000,\n sha512_crypt__max_rounds=50000,\n sha512_crypt__min_rounds=45000,\n )\n \n \n \n \n sample_config_4s=\"\"\"\n[passlib]\nschemes = sha512_crypt\nall.vary_rounds = 10%%\ndefault.sha512_crypt.max_rounds = 20000\nadmin.all.vary_rounds = 5%%\nadmin.sha512_crypt.max_rounds = 40000\n\"\"\"\n \n sample_config_4pd=dict(\n schemes=[\"sha512_crypt\"],\n \n all__vary_rounds=0.1,\n sha512_crypt__max_rounds=20000,\n \n admin__all__vary_rounds=0.05,\n admin__sha512_crypt__max_rounds=40000,\n )\n \n \n \n \n sample_config_5s=sample_config_1s+\"\"\"\\\ndeprecated = des_crypt\nadmin__context__deprecated = des_crypt, bsdi_crypt\n\"\"\"\n \n sample_config_5pd=sample_config_1pd.copy()\n sample_config_5pd.update(\n deprecated=[\"des_crypt\"],\n admin__context__deprecated=[\"des_crypt\",\"bsdi_crypt\"],\n )\n \n sample_config_5pid=sample_config_1pid.copy()\n sample_config_5pid.update({\n \"deprecated\":\"des_crypt\",\n \"admin.context.deprecated\":\"des_crypt, bsdi_crypt\",\n })\n \n sample_config_5prd=sample_config_1prd.copy()\n sample_config_5prd.update({\n \n \n \"deprecated\":[\"des_crypt\"],\n \"admin__context__deprecated\":[\"des_crypt\",\"bsdi_crypt\"],\n })\n \n \n \n \n def setUp(self):\n  TestCase.setUp(self)\n  warnings.filterwarnings(\"ignore\",\n  r\"The CryptPolicy class has been deprecated\")\n  warnings.filterwarnings(\"ignore\",\n  r\"the method.*hash_needs_update.*is deprecated\")\n  warnings.filterwarnings(\"ignore\",\"The 'all' scheme is deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\"bsdi_crypt rounds should be odd\")\n  \n def test_00_constructor(self):\n  ''\n  policy=CryptPolicy(**self.sample_config_1pd)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  policy=CryptPolicy(self.sample_config_1pd)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  self.assertRaises(TypeError,CryptPolicy,{},{})\n  self.assertRaises(TypeError,CryptPolicy,{},dummy=1)\n  \n  \n  self.assertRaises(TypeError,CryptPolicy,\n  schemes=[\"des_crypt\",\"md5_crypt\",\"bsdi_crypt\",\"sha512_crypt\"],\n  bad__key__bsdi_crypt__max_rounds=30000,\n  )\n  \n  \n  class nameless(uh.StaticHandler):\n   name=None\n  self.assertRaises(ValueError,CryptPolicy,schemes=[nameless])\n  \n  \n  self.assertRaises(TypeError,CryptPolicy,schemes=[uh.StaticHandler])\n  \n  \n  class dummy_1(uh.StaticHandler):\n   name='dummy_1'\n  self.assertRaises(KeyError,CryptPolicy,schemes=[dummy_1,dummy_1])\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=['des_crypt'],\n  deprecated=['md5_crypt'])\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=['des_crypt'],\n  default='md5_crypt')\n  \n def test_01_from_path_simple(self):\n  ''\n  \n  \n  \n  path=self.sample_config_1s_path\n  policy=CryptPolicy.from_path(path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  self.assertRaises(EnvironmentError,CryptPolicy.from_path,path+'xxx')\n  \n def test_01_from_path(self):\n  ''\n  path=self.mktemp()\n  \n  \n  set_file(path,self.sample_config_1s)\n  policy=CryptPolicy.from_path(path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  set_file(path,self.sample_config_1s.replace(\"\\n\",\"\\r\\n\"))\n  policy=CryptPolicy.from_path(path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  uc2=to_bytes(self.sample_config_1s,\"utf-16\",source_encoding=\"utf-8\")\n  set_file(path,uc2)\n  policy=CryptPolicy.from_path(path,encoding=\"utf-16\")\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n def test_02_from_string(self):\n  ''\n  \n  policy=CryptPolicy.from_string(self.sample_config_1s)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_string(\n  self.sample_config_1s.replace(\"\\n\",\"\\r\\n\"))\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  data=to_unicode(self.sample_config_1s)\n  policy=CryptPolicy.from_string(data)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  uc2=to_bytes(self.sample_config_1s,\"utf-16\",source_encoding=\"utf-8\")\n  policy=CryptPolicy.from_string(uc2,encoding=\"utf-16\")\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_string(self.sample_config_4s)\n  self.assertEqual(policy.to_dict(),self.sample_config_4pd)\n  \n def test_03_from_source(self):\n  ''\n  \n  policy=CryptPolicy.from_source(self.sample_config_1s_path)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_source(self.sample_config_1s)\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_source(self.sample_config_1pd.copy())\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  p2=CryptPolicy.from_source(policy)\n  self.assertIs(policy,p2)\n  \n  \n  self.assertRaises(TypeError,CryptPolicy.from_source,1)\n  self.assertRaises(TypeError,CryptPolicy.from_source,[])\n  \n def test_04_from_sources(self):\n  ''\n  \n  \n  self.assertRaises(ValueError,CryptPolicy.from_sources,[])\n  \n  \n  policy=CryptPolicy.from_sources([self.sample_config_1s])\n  self.assertEqual(policy.to_dict(),self.sample_config_1pd)\n  \n  \n  policy=CryptPolicy.from_sources(\n  [\n  self.sample_config_1s_path,\n  self.sample_config_2s,\n  self.sample_config_3pd,\n  ])\n  self.assertEqual(policy.to_dict(),self.sample_config_123pd)\n  \n def test_05_replace(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  \n  \n  p2=p1.replace(**self.sample_config_2pd)\n  self.assertEqual(p2.to_dict(),self.sample_config_12pd)\n  \n  \n  p2b=p2.replace(**self.sample_config_2pd)\n  self.assertEqual(p2b.to_dict(),self.sample_config_12pd)\n  \n  \n  p3=p2.replace(self.sample_config_3pd)\n  self.assertEqual(p3.to_dict(),self.sample_config_123pd)\n  \n def test_06_forbidden(self):\n  ''\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=[\"des_crypt\"],\n  des_crypt__salt=\"xx\",\n  )\n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=[\"des_crypt\"],\n  all__salt=\"xx\",\n  )\n  \n  \n  self.assertRaises(KeyError,CryptPolicy,\n  schemes=[\"des_crypt\"],\n  user__context__schemes=[\"md5_crypt\"],\n  )\n  \n  \n  \n  \n def test_10_has_schemes(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  self.assertTrue(p1.has_schemes())\n  \n  p3=CryptPolicy(**self.sample_config_3pd)\n  self.assertTrue(not p3.has_schemes())\n  \n def test_11_iter_handlers(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  s=self.sample_config_1prd['schemes']\n  self.assertEqual(list(p1.iter_handlers()),s)\n  \n  p3=CryptPolicy(**self.sample_config_3pd)\n  self.assertEqual(list(p3.iter_handlers()),[])\n  \n def test_12_get_handler(self):\n  ''\n  \n  p1=CryptPolicy(**self.sample_config_1pd)\n  \n  \n  self.assertIs(p1.get_handler(\"bsdi_crypt\"),hash.bsdi_crypt)\n  \n  \n  self.assertIs(p1.get_handler(\"sha256_crypt\"),None )\n  self.assertRaises(KeyError,p1.get_handler,\"sha256_crypt\",required=True )\n  \n  \n  self.assertIs(p1.get_handler(),hash.md5_crypt)\n  \n def test_13_get_options(self):\n  ''\n  \n  p12=CryptPolicy(**self.sample_config_12pd)\n  \n  self.assertEqual(p12.get_options(\"bsdi_crypt\"),dict(\n  \n  vary_rounds=0.1,\n  min_rounds=29000,\n  max_rounds=35000,\n  default_rounds=31000,\n  ))\n  \n  self.assertEqual(p12.get_options(\"sha512_crypt\"),dict(\n  \n  vary_rounds=0.1,\n  min_rounds=45000,\n  max_rounds=50000,\n  ))\n  \n  p4=CryptPolicy.from_string(self.sample_config_4s)\n  self.assertEqual(p4.get_options(\"sha512_crypt\"),dict(\n  \n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(p4.get_options(\"sha512_crypt\",\"user\"),dict(\n  \n  vary_rounds=0.1,\n  max_rounds=20000,\n  ))\n  \n  self.assertEqual(p4.get_options(\"sha512_crypt\",\"admin\"),dict(\n  \n  vary_rounds=0.05,\n  max_rounds=40000,\n  ))\n  \n def test_14_handler_is_deprecated(self):\n  ''\n  pa=CryptPolicy(**self.sample_config_1pd)\n  pb=CryptPolicy(**self.sample_config_5pd)\n  \n  self.assertFalse(pa.handler_is_deprecated(\"des_crypt\"))\n  self.assertFalse(pa.handler_is_deprecated(hash.bsdi_crypt))\n  self.assertFalse(pa.handler_is_deprecated(\"sha512_crypt\"))\n  \n  self.assertTrue(pb.handler_is_deprecated(\"des_crypt\"))\n  self.assertFalse(pb.handler_is_deprecated(hash.bsdi_crypt))\n  self.assertFalse(pb.handler_is_deprecated(\"sha512_crypt\"))\n  \n  \n  self.assertTrue(pb.handler_is_deprecated(\"des_crypt\",\"user\"))\n  self.assertFalse(pb.handler_is_deprecated(\"bsdi_crypt\",\"user\"))\n  self.assertTrue(pb.handler_is_deprecated(\"des_crypt\",\"admin\"))\n  self.assertTrue(pb.handler_is_deprecated(\"bsdi_crypt\",\"admin\"))\n  \n  \n  pc=CryptPolicy(\n  schemes=[\"md5_crypt\",\"des_crypt\"],\n  deprecated=[\"md5_crypt\"],\n  user__context__deprecated=[\"des_crypt\"],\n  )\n  self.assertTrue(pc.handler_is_deprecated(\"md5_crypt\"))\n  self.assertFalse(pc.handler_is_deprecated(\"des_crypt\"))\n  self.assertFalse(pc.handler_is_deprecated(\"md5_crypt\",\"user\"))\n  self.assertTrue(pc.handler_is_deprecated(\"des_crypt\",\"user\"))\n  \n def test_15_min_verify_time(self):\n  ''\n  \n  warnings.filterwarnings(\"ignore\",category=DeprecationWarning)\n  \n  pa=CryptPolicy()\n  self.assertEqual(pa.get_min_verify_time(),0)\n  self.assertEqual(pa.get_min_verify_time('admin'),0)\n  \n  pb=pa.replace(min_verify_time=.1)\n  self.assertEqual(pb.get_min_verify_time(),0)\n  self.assertEqual(pb.get_min_verify_time('admin'),0)\n  \n  \n  \n  \n def test_20_iter_config(self):\n  ''\n  p5=CryptPolicy(**self.sample_config_5pd)\n  self.assertEqual(dict(p5.iter_config()),self.sample_config_5pd)\n  self.assertEqual(dict(p5.iter_config(resolve=True )),self.sample_config_5prd)\n  self.assertEqual(dict(p5.iter_config(ini=True )),self.sample_config_5pid)\n  \n def test_21_to_dict(self):\n  ''\n  p5=CryptPolicy(**self.sample_config_5pd)\n  self.assertEqual(p5.to_dict(),self.sample_config_5pd)\n  self.assertEqual(p5.to_dict(resolve=True ),self.sample_config_5prd)\n  \n def test_22_to_string(self):\n  ''\n  pa=CryptPolicy(**self.sample_config_5pd)\n  s=pa.to_string()\n  pb=CryptPolicy.from_string(s)\n  self.assertEqual(pb.to_dict(),self.sample_config_5pd)\n  \n  s=pa.to_string(encoding=\"latin-1\")\n  self.assertIsInstance(s,bytes)\n  \n  \n  \n  \n  \n  \n  \n  \nclass CryptContextTest(TestCase):\n ''\n descriptionPrefix=\"CryptContext\"\n \n def setUp(self):\n  TestCase.setUp(self)\n  warnings.filterwarnings(\"ignore\",\n  r\"CryptContext\\(\\)\\.replace\\(\\) has been deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\n  r\"The CryptContext ``policy`` keyword has been deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\".*(CryptPolicy|context\\.policy).*(has|have) been deprecated.*\")\n  warnings.filterwarnings(\"ignore\",\n  r\"the method.*hash_needs_update.*is deprecated\")\n  \n  \n  \n  \n def test_00_constructor(self):\n  ''\n  \n  cc=CryptContext([hash.md5_crypt,hash.bsdi_crypt,hash.des_crypt])\n  c,b,a=cc.policy.iter_handlers()\n  self.assertIs(a,hash.des_crypt)\n  self.assertIs(b,hash.bsdi_crypt)\n  self.assertIs(c,hash.md5_crypt)\n  \n  \n  cc=CryptContext([\"md5_crypt\",\"bsdi_crypt\",\"des_crypt\"])\n  c,b,a=cc.policy.iter_handlers()\n  self.assertIs(a,hash.des_crypt)\n  self.assertIs(b,hash.bsdi_crypt)\n  self.assertIs(c,hash.md5_crypt)\n  \n  \n  policy=cc.policy\n  cc=CryptContext(policy=policy)\n  self.assertEqual(cc.to_dict(),policy.to_dict())\n  \n  cc=CryptContext(policy=policy,default=\"bsdi_crypt\")\n  self.assertNotEqual(cc.to_dict(),policy.to_dict())\n  self.assertEqual(cc.to_dict(),dict(schemes=[\"md5_crypt\",\"bsdi_crypt\",\"des_crypt\"],\n  default=\"bsdi_crypt\"))\n  \n  self.assertRaises(TypeError,setattr,cc,'policy',None )\n  self.assertRaises(TypeError,CryptContext,policy='x')\n  \n def test_01_replace(self):\n  ''\n  \n  cc=CryptContext([\"md5_crypt\",\"bsdi_crypt\",\"des_crypt\"])\n  self.assertIs(cc.policy.get_handler(),hash.md5_crypt)\n  \n  cc2=cc.replace()\n  self.assertIsNot(cc2,cc)\n  \n  \n  \n  cc3=cc.replace(default=\"bsdi_crypt\")\n  self.assertIsNot(cc3,cc)\n  \n  \n  self.assertIs(cc3.policy.get_handler(),hash.bsdi_crypt)\n  \n def test_02_no_handlers(self):\n  ''\n  \n  \n  cc=CryptContext()\n  self.assertRaises(KeyError,cc.identify,'hash',required=True )\n  self.assertRaises(KeyError,cc.hash,'secret')\n  self.assertRaises(KeyError,cc.verify,'secret','hash')\n  \n  \n  cc=CryptContext(['md5_crypt'])\n  p=CryptPolicy(schemes=[])\n  cc.policy=p\n  \n  self.assertRaises(KeyError,cc.identify,'hash',required=True )\n  self.assertRaises(KeyError,cc.hash,'secret')\n  self.assertRaises(KeyError,cc.verify,'secret','hash')\n  \n  \n  \n  \n sample_policy_1=dict(\n schemes=[\"des_crypt\",\"md5_crypt\",\"phpass\",\"bsdi_crypt\",\n \"sha256_crypt\"],\n deprecated=[\"des_crypt\",],\n default=\"sha256_crypt\",\n bsdi_crypt__max_rounds=30,\n bsdi_crypt__default_rounds=25,\n bsdi_crypt__vary_rounds=0,\n sha256_crypt__max_rounds=3000,\n sha256_crypt__min_rounds=2000,\n sha256_crypt__default_rounds=3000,\n phpass__ident=\"H\",\n phpass__default_rounds=7,\n )\n \n def test_12_hash_needs_update(self):\n  ''\n  cc=CryptContext(**self.sample_policy_1)\n  \n  \n  self.assertTrue(cc.hash_needs_update('9XXD4trGYeGJA'))\n  self.assertFalse(cc.hash_needs_update('$1$J8HC2RCr$HcmM.7NxB2weSvlw2FgzU0'))\n  \n  \n  self.assertTrue(cc.hash_needs_update('$5$rounds=1999$jD81UCoo.zI.UETs$Y7qSTQ6mTiU9qZB4fRr43wRgQq4V.5AAf7F97Pzxey/'))\n  self.assertFalse(cc.hash_needs_update('$5$rounds=2000$228SSRje04cnNCaQ$YGV4RYu.5sNiBvorQDlO0WWQjyJVGKBcJXz3OtyQ2u8'))\n  \n  \n  self.assertFalse(cc.hash_needs_update('$5$rounds=3000$fS9iazEwTKi7QPW4$VasgBC8FqlOvD7x2HhABaMXCTh9jwHclPA9j5YQdns.'))\n  self.assertTrue(cc.hash_needs_update('$5$rounds=3001$QlFHHifXvpFX4PLs$/0ekt7lSs/lOikSerQ0M/1porEHxYq7W/2hdFpxA3fA'))\n  \n  \n  \n  \n def test_30_nonstring_hash(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\".*needs_update.*'scheme' keyword is deprecated.*\")\n  \n  \n  \n  \n  \n  cc=CryptContext([\"des_crypt\"])\n  for hash,kwds in [\n  (None ,{}),\n  \n  (None ,{\"scheme\":\"des_crypt\"}),\n  (1,{}),\n  ((),{}),\n  ]:\n  \n   self.assertRaises(TypeError,cc.hash_needs_update,hash,**kwds)\n   \n  cc2=CryptContext([\"mysql323\"])\n  self.assertRaises(TypeError,cc2.hash_needs_update,None )\n  \n  \n  \n  \n  \n  \n  \n  \nclass dummy_2(uh.StaticHandler):\n name=\"dummy_2\"\n \nclass LazyCryptContextTest(TestCase):\n descriptionPrefix=\"LazyCryptContext\"\n \n def setUp(self):\n  TestCase.setUp(self)\n  \n  \n  unload_handler_name(\"dummy_2\")\n  self.addCleanup(unload_handler_name,\"dummy_2\")\n  \n  \n  warnings.filterwarnings(\"ignore\",\n  r\"CryptContext\\(\\)\\.replace\\(\\) has been deprecated\")\n  warnings.filterwarnings(\"ignore\",\".*(CryptPolicy|context\\.policy).*(has|have) been deprecated.*\")\n  \n def test_kwd_constructor(self):\n  ''\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  cc=LazyCryptContext(iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertTrue(cc.policy.handler_is_deprecated(\"des_crypt\"))\n  self.assertEqual(cc.policy.schemes(),[\"dummy_2\",\"des_crypt\"])\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n def test_callable_constructor(self):\n  ''\n  self.assertFalse(has_crypt_handler(\"dummy_2\"))\n  register_crypt_handler_path(\"dummy_2\",\"passlib.tests.test_context\")\n  \n  def create_policy(flag=False ):\n   self.assertTrue(flag)\n   return CryptPolicy(schemes=iter([\"dummy_2\",\"des_crypt\"]),deprecated=[\"des_crypt\"])\n   \n  cc=LazyCryptContext(create_policy=create_policy,flag=True )\n  \n  self.assertFalse(has_crypt_handler(\"dummy_2\",True ))\n  \n  self.assertTrue(cc.policy.handler_is_deprecated(\"des_crypt\"))\n  self.assertEqual(cc.policy.schemes(),[\"dummy_2\",\"des_crypt\"])\n  \n  self.assertTrue(has_crypt_handler(\"dummy_2\",True ))\n  \n  \n  \n  \n", ["__future__", "logging", "os", "passlib", "passlib.context", "passlib.registry", "passlib.tests.utils", "passlib.utils", "passlib.utils.handlers", "pkg_resources", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_crypto_scrypt": [".py", "''\n\n\n\n\nfrom binascii import hexlify\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\nimport struct\nimport warnings\nwarnings.filterwarnings(\"ignore\",\".*using builtin scrypt backend.*\")\n\n\nfrom passlib import exc\nfrom passlib.utils import getrandbytes\nfrom passlib.utils.compat import PYPY,u,bascii_to_str\nfrom passlib.utils.decor import classproperty\nfrom passlib.tests.utils import TestCase,skipUnless,TEST_MODE,hb\n\nfrom passlib.crypto import scrypt as scrypt_mod\n\n__all__=[\n\"ScryptEngineTest\",\n\"BuiltinScryptTest\",\n\"FastScryptTest\",\n]\n\n\n\n\ndef hexstr(data):\n ''\n return bascii_to_str(hexlify(data))\n \ndef unpack_uint32_list(data,check_count=None ):\n ''\n count=len(data)//4\n assert check_count is None or check_count ==count\n return struct.unpack(\"<%dI\"%count,data)\n \ndef seed_bytes(seed,count):\n ''\n\n\n \n if hasattr(seed,\"encode\"):\n  seed=seed.encode(\"ascii\")\n buf=b''\n i=0\n while len(buf)<count:\n  buf +=hashlib.sha256(seed+struct.pack(\"<I\",i)).digest()\n  i +=1\n return buf[:count]\n \n \n \n \nclass ScryptEngineTest(TestCase):\n descriptionPrefix=\"passlib.crypto.scrypt._builtin\"\n \n def test_smix(self):\n  ''\n  from passlib.crypto.scrypt._builtin import ScryptEngine\n  rng=self.getRandom()\n  \n  \n  \n  \n  \n  \n  input=hb(\"\"\"\n            f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd\n            77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad\n            89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29\n            09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7\n            89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb\n            cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0\n            67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b\n            7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89\n            \"\"\")\n  \n  output=hb(\"\"\"\n            79 cc c1 93 62 9d eb ca 04 7f 0b 70 60 4b f6 b6\n            2c e3 dd 4a 96 26 e3 55 fa fc 61 98 e6 ea 2b 46\n            d5 84 13 67 3b 99 b0 29 d6 65 c3 57 60 1f b4 26\n            a0 b2 f4 bb a2 00 ee 9f 0a 43 d1 9b 57 1a 9c 71\n            ef 11 42 e6 5d 5a 26 6f dd ca 83 2c e5 9f aa 7c\n            ac 0b 9c f1 be 2b ff ca 30 0d 01 ee 38 76 19 c4\n            ae 12 fd 44 38 f2 03 a0 e4 e1 c4 7e c3 14 86 1f\n            4e 90 87 cb 33 39 6a 68 73 e8 f9 d2 53 9a 4b 8e\n            \"\"\")\n  \n  \n  engine=ScryptEngine(n=16,r=1,p=rng.randint(1,1023))\n  self.assertEqual(engine.smix(input),output)\n  \n def test_bmix(self):\n  ''\n  from passlib.crypto.scrypt._builtin import ScryptEngine\n  rng=self.getRandom()\n  \n  \n  \n  \n  def check_bmix(r,input,output):\n   ''\n   \n   \n   engine=ScryptEngine(r=r,n=1 <<rng.randint(1,32),p=rng.randint(1,1023))\n   target=[rng.randint(0,1 <<32)for _ in range((2 *r)*16)]\n   engine.bmix(input,target)\n   self.assertEqual(target,list(output))\n   \n   \n   \n   if r ==1:\n    del engine.bmix\n    target=[rng.randint(0,1 <<32)for _ in range((2 *r)*16)]\n    engine.bmix(input,target)\n    self.assertEqual(target,list(output))\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  input=unpack_uint32_list(hb(\"\"\"\n                f7 ce 0b 65 3d 2d 72 a4 10 8c f5 ab e9 12 ff dd\n                77 76 16 db bb 27 a7 0e 82 04 f3 ae 2d 0f 6f ad\n                89 f6 8f 48 11 d1 e8 7b cc 3b d7 40 0a 9f fd 29\n                09 4f 01 84 63 95 74 f3 9a e5 a1 31 52 17 bc d7\n\n                89 49 91 44 72 13 bb 22 6c 25 b5 4d a8 63 70 fb\n                cd 98 43 80 37 46 66 bb 8f fc b5 bf 40 c2 54 b0\n                67 d2 7c 51 ce 4a d5 fe d8 29 c9 0b 50 5a 57 1b\n                7f 4d 1c ad 6a 52 3c da 77 0e 67 bc ea af 7e 89\n            \"\"\"),32)\n  \n  output=unpack_uint32_list(hb(\"\"\"\n                a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05\n                04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29\n                b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba\n                e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81\n\n                20 ed c9 75 32 38 81 a8 05 40 f6 4c 16 2d cd 3c\n                21 07 7c fe 5f 8d 5f e2 b1 a4 16 8f 95 36 78 b7\n                7d 3b 3d 80 3b 60 e4 ab 92 09 96 e5 9b 4d 53 b6\n                5d 2a 22 58 77 d5 ed f5 84 2c b9 f1 4e ef e4 25\n            \"\"\"),32)\n  \n  \n  \n  \n  \n  \n  \n  \n  r=2\n  input=unpack_uint32_list(seed_bytes(\"bmix with r=2\",128 *r))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            ba240854954f4585f3d0573321f10beee96f12acdc1feb498131e40512934fd7\n            43e8139c17d0743c89d09ac8c3582c273c60ab85db63e410d049a9e17a42c6a1\n\n            6c7831b11bf370266afdaff997ae1286920dea1dedf0f4a1795ba710ba9017f1\n            a374400766f13ebd8969362de2d153965e9941bdde0768fa5b53e8522f116ce0\n\n            d14774afb88f46cd919cba4bc64af7fca0ecb8732d1fc2191e0d7d1b6475cb2e\n            e3db789ee478d056c4eb6c6e28b99043602dbb8dfb60c6e048bf90719da8d57d\n\n            3c42250e40ab79a1ada6aae9299b9790f767f54f388d024a1465b30cbbe9eb89\n            002d4f5c215c4259fac4d083bac5fb0b47463747d568f40bb7fa87c42f0a1dc1\n            \"\"\"),32 *r)\n  \n  check_bmix(r,input,output)\n  \n  \n  \n  \n  \n  \n  r=3\n  input=unpack_uint32_list(seed_bytes(\"bmix with r=3\",128 *r))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            11ddd8cf60c61f59a6e5b128239bdc77b464101312c88bd1ccf6be6e75461b29\n            7370d4770c904d0b09c402573cf409bf2db47b91ba87d5a3de469df8fb7a003c\n\n            95a66af96dbdd88beddc8df51a2f72a6f588d67e7926e9c2b676c875da13161e\n            b6262adac39e6b3003e9a6fbc8c1a6ecf1e227c03bc0af3e5f8736c339b14f84\n\n            c7ae5b89f5e16d0faf8983551165f4bb712d97e4f81426e6b78eb63892d3ff54\n            80bf406c98e479496d0f76d23d728e67d2a3d2cdbc4a932be6db36dc37c60209\n\n            a5ca76ca2d2979f995f73fe8182eefa1ce0ba0d4fc27d5b827cb8e67edd6552f\n            00a5b3ab6b371bd985a158e728011314eb77f32ade619b3162d7b5078a19886c\n\n            06f12bc8ae8afa46489e5b0239954d5216967c928982984101e4a88bae1f60ae\n            3f8a456e169a8a1c7450e7955b8a13a202382ae19d41ce8ef8b6a15eeef569a7\n\n            20f54c48e44cb5543dda032c1a50d5ddf2919030624978704eb8db0290052a1f\n            5d88989b0ef931b6befcc09e9d5162320e71e80b89862de7e2f0b6c67229b93f\n            \"\"\"),32 *r)\n  \n  check_bmix(r,input,output)\n  \n  \n  \n  \n  \n  \n  r=4\n  input=unpack_uint32_list(seed_bytes(\"bmix with r=4\",128 *r))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            803fcf7362702f30ef43250f20bc6b1b8925bf5c4a0f5a14bbfd90edce545997\n            3047bd81655f72588ca93f5c2f4128adaea805e0705a35e14417101fdb1c498c\n\n            33bec6f4e5950d66098da8469f3fe633f9a17617c0ea21275185697c0e4608f7\n            e6b38b7ec71704a810424637e2c296ca30d9cbf8172a71a266e0393deccf98eb\n\n            abc430d5f144eb0805308c38522f2973b7b6a48498851e4c762874497da76b88\n            b769b471fbfc144c0e8e859b2b3f5a11f51604d268c8fd28db55dff79832741a\n\n            1ac0dfdaff10f0ada0d93d3b1f13062e4107c640c51df05f4110bdda15f51b53\n            3a75bfe56489a6d8463440c78fb8c0794135e38591bdc5fa6cec96a124178a4a\n\n            d1a976e985bfe13d2b4af51bd0fc36dd4cfc3af08efe033b2323a235205dc43d\n            e57778a492153f9527338b3f6f5493a03d8015cd69737ee5096ad4cbe660b10f\n\n            b75b1595ddc96e3748f5c9f61fba1ef1f0c51b6ceef8bbfcc34b46088652e6f7\n            edab61521cbad6e69b77be30c9c97ea04a4af359dafc205c7878cc9a6c5d122f\n\n            8d77f3cbe65ab14c3c491ef94ecb3f5d2c2dd13027ea4c3606262bb3c9ce46e7\n            dc424729dc75f6e8f06096c0ad8ad4d549c42f0cad9b33cb95d10fb3cadba27c\n\n            5f4bf0c1ac677c23ba23b64f56afc3546e62d96f96b58d7afc5029f8168cbab4\n            533fd29fc83c8d2a32b81923992e4938281334e0c3694f0ee56f8ff7df7dc4ae\n            \"\"\"),32 *r)\n  \n  check_bmix(r,input,output)\n  \n def test_salsa(self):\n  ''\n  from passlib.crypto.scrypt._builtin import salsa20\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  input=unpack_uint32_list(hb(\"\"\"\n            7e 87 9a 21 4f 3e c9 86 7c a9 40 e6 41 71 8f 26\n            ba ee 55 5b 8c 61 c1 b5 0d f8 46 11 6d cd 3b 1d\n            ee 24 f3 19 df 9b 3d 85 14 12 1e 4b 5a c5 aa 32\n            76 02 1d 29 09 c7 48 29 ed eb c6 8d b8 b8 c2 5e\n            \"\"\"))\n  \n  output=unpack_uint32_list(hb(\"\"\"\n            a4 1f 85 9c 66 08 cc 99 3b 81 ca cb 02 0c ef 05\n            04 4b 21 81 a2 fd 33 7d fd 7b 1c 63 96 68 2f 29\n            b4 39 31 68 e3 c9 e6 bc fe 6b c5 b7 a0 6d 96 ba\n            e4 24 cc 10 2c 91 74 5c 24 ad 67 3d c7 61 8f 81\n            \"\"\"))\n  self.assertEqual(salsa20(input),output)\n  \n  \n  \n  \n  \n  input=list(range(16))\n  output=unpack_uint32_list(hb(\"\"\"\n            f518dd4fb98883e0a87954c05cab867083bb8808552810752285a05822f56c16\n            9d4a2a0fd2142523d758c60b36411b682d53860514b871d27659042a5afa475d\n            \"\"\"))\n  self.assertEqual(salsa20(input),output)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CommonScryptTest(TestCase):\n ''\n\n \n \n \n \n \n @classproperty\n def descriptionPrefix(cls):\n  return \"passlib.utils.scrypt.scrypt() <%s backend>\"%cls.backend\n backend=None\n \n \n \n \n def setUp(self):\n  assert self.backend\n  scrypt_mod._set_backend(self.backend)\n  super(_CommonScryptTest,self).setUp()\n  \n  \n  \n  \n  \n reference_vectors=[\n \n \n \n \n \n \n \n \n \n (\"\",\"\",16,1,1,64,hb(\"\"\"\n        77 d6 57 62 38 65 7b 20 3b 19 ca 42 c1 8a 04 97\n        f1 6b 48 44 e3 07 4a e8 df df fa 3f ed e2 14 42\n        fc d0 06 9d ed 09 48 f8 32 6a 75 3a 0f c8 1f 17\n        e8 d3 e0 fb 2e 0d 36 28 cf 35 e2 0c 38 d1 89 06\n        \"\"\")),\n \n (\"password\",\"NaCl\",1024,8,16,64,hb(\"\"\"\n        fd ba be 1c 9d 34 72 00 78 56 e7 19 0d 01 e9 fe\n        7c 6a d7 cb c8 23 78 30 e7 73 76 63 4b 37 31 62\n        2e af 30 d9 2e 22 a3 88 6f f1 09 27 9d 98 30 da\n        c7 27 af b9 4a 83 ee 6d 83 60 cb df a2 cc 06 40\n        \"\"\")),\n \n \n \n (\"pleaseletmein\",\"SodiumChloride\",16384,8,1,64,hb(\"\"\"\n        70 23 bd cb 3a fd 73 48 46 1c 06 cd 81 fd 38 eb\n        fd a8 fb ba 90 4f 8e 3e a9 b5 43 f6 54 5d a1 f2\n        d5 43 29 55 61 3f 0f cf 62 d4 97 05 24 2a 9a f9\n        e6 1e 85 dc 0d 65 1e 40 df cf 01 7b 45 57 58 87\n        \"\"\")),\n \n \n \n \n (\"pleaseletmein\",\"SodiumChloride\",1048576,8,1,64,hb(\"\"\"\n        21 01 cb 9b 6a 51 1a ae ad db be 09 cf 70 f8 81\n        ec 56 8d 57 4a 2f fd 4d ab e5 ee 98 20 ad aa 47\n        8e 56 fd 8f 4b a5 d0 9f fa 1c 6d 92 7c 40 f4 c3\n        37 30 40 49 e8 a9 52 fb cb f4 5c 6f a7 7a 41 a4\n        \"\"\")),\n ]\n \n def test_reference_vectors(self):\n  ''\n  for secret,salt,n,r,p,keylen,result in self.reference_vectors:\n   if n >=1024 and TEST_MODE(max=\"default\"):\n   \n    continue\n   if n >16384 and self.backend ==\"builtin\":\n   \n   \n    continue\n   log.debug(\"scrypt reference vector: %r %r n=%r r=%r p=%r\",secret,salt,n,r,p)\n   self.assertEqual(scrypt_mod.scrypt(secret,salt,n,r,p,keylen),result)\n   \n   \n   \n   \n   \n _already_tested_others=None\n \n def test_other_backends(self):\n  ''\n  \n  \n  if self._already_tested_others:\n   raise self.skipTest(\"already run under %r backend test\"%self._already_tested_others)\n  self._already_tested_others=self.backend\n  rng=self.getRandom()\n  \n  \n  orig=scrypt_mod.backend\n  available=set(name for name in scrypt_mod.backend_values\n  if scrypt_mod._has_backend(name))\n  scrypt_mod._set_backend(orig)\n  available.discard(self.backend)\n  if not available:\n   raise self.skipTest(\"no other backends found\")\n   \n  warnings.filterwarnings(\"ignore\",\"(?i)using builtin scrypt backend\",\n  category=exc.PasslibSecurityWarning)\n  \n  \n  for _ in range(10):\n  \n   secret=getrandbytes(rng,rng.randint(0,64))\n   salt=getrandbytes(rng,rng.randint(0,64))\n   n=1 <<rng.randint(1,10)\n   r=rng.randint(1,8)\n   p=rng.randint(1,3)\n   ks=rng.randint(1,64)\n   previous=None\n   backends=set()\n   for name in available:\n    scrypt_mod._set_backend(name)\n    self.assertNotIn(scrypt_mod._scrypt,backends)\n    backends.add(scrypt_mod._scrypt)\n    result=hexstr(scrypt_mod.scrypt(secret,salt,n,r,p,ks))\n    self.assertEqual(len(result),2 *ks)\n    if previous is not None :\n     self.assertEqual(result,previous,\n     msg=\"%r output differs from others %r: %r\"%\n     (name,available,[secret,salt,n,r,p,ks]))\n     \n     \n     \n     \n def test_backend(self):\n  ''\n  \n  scrypt_mod.backend=None\n  scrypt_mod._scrypt=None\n  self.assertRaises(TypeError,scrypt_mod.scrypt,'s','s',2,2,2,16)\n  \n  \n  scrypt_mod._set_backend(self.backend)\n  self.assertEqual(scrypt_mod.backend,self.backend)\n  scrypt_mod.scrypt('s','s',2,2,2,16)\n  \n  \n  self.assertRaises(ValueError,scrypt_mod._set_backend,'xxx')\n  self.assertEqual(scrypt_mod.backend,self.backend)\n  \n def test_secret_param(self):\n  ''\n  \n  def run_scrypt(secret):\n   return hexstr(scrypt_mod.scrypt(secret,\"salt\",2,2,2,16))\n   \n   \n  TEXT=u(\"abc\\u00defg\")\n  self.assertEqual(run_scrypt(TEXT),'05717106997bfe0da42cf4779a2f8bd8')\n  \n  \n  TEXT_UTF8=b'abc\\xc3\\x9efg'\n  self.assertEqual(run_scrypt(TEXT_UTF8),'05717106997bfe0da42cf4779a2f8bd8')\n  \n  \n  TEXT_LATIN1=b'abc\\xdefg'\n  self.assertEqual(run_scrypt(TEXT_LATIN1),'770825d10eeaaeaf98e8a3c40f9f441d')\n  \n  \n  self.assertEqual(run_scrypt(\"\"),'ca1399e5fae5d3b9578dcd2b1faff6e2')\n  \n  \n  self.assertRaises(TypeError,run_scrypt,None )\n  self.assertRaises(TypeError,run_scrypt,1)\n  \n def test_salt_param(self):\n  ''\n  \n  def run_scrypt(salt):\n   return hexstr(scrypt_mod.scrypt(\"secret\",salt,2,2,2,16))\n   \n   \n  TEXT=u(\"abc\\u00defg\")\n  self.assertEqual(run_scrypt(TEXT),'a748ec0f4613929e9e5f03d1ab741d88')\n  \n  \n  TEXT_UTF8=b'abc\\xc3\\x9efg'\n  self.assertEqual(run_scrypt(TEXT_UTF8),'a748ec0f4613929e9e5f03d1ab741d88')\n  \n  \n  TEXT_LATIN1=b'abc\\xdefg'\n  self.assertEqual(run_scrypt(TEXT_LATIN1),'91d056fb76fb6e9a7d1cdfffc0a16cd1')\n  \n  \n  self.assertRaises(TypeError,run_scrypt,None )\n  self.assertRaises(TypeError,run_scrypt,1)\n  \n def test_n_param(self):\n  ''\n  \n  def run_scrypt(n):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",n,2,2,16))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertRaises(ValueError,run_scrypt,1)\n  self.assertEqual(run_scrypt(2),'dacf2bca255e2870e6636fa8c8957a66')\n  self.assertRaises(ValueError,run_scrypt,3)\n  self.assertRaises(ValueError,run_scrypt,15)\n  self.assertEqual(run_scrypt(16),'0272b8fc72bc54b1159340ed99425233')\n  \n def test_r_param(self):\n  ''\n  def run_scrypt(r,n=2,p=2):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",n,r,p,16))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertEqual(run_scrypt(1),'3d630447d9f065363b8a79b0b3670251')\n  self.assertEqual(run_scrypt(2),'dacf2bca255e2870e6636fa8c8957a66')\n  self.assertEqual(run_scrypt(5),'114f05e985a903c27237b5578e763736')\n  \n  \n  self.assertRaises(ValueError,run_scrypt,(1 <<30),p=1)\n  self.assertRaises(ValueError,run_scrypt,(1 <<30)/2,p=2)\n  \n def test_p_param(self):\n  ''\n  def run_scrypt(p,n=2,r=2):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",n,r,p,16))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertEqual(run_scrypt(1),'f2960ea8b7d48231fcec1b89b784a6fa')\n  self.assertEqual(run_scrypt(2),'dacf2bca255e2870e6636fa8c8957a66')\n  self.assertEqual(run_scrypt(5),'848a0eeb2b3543e7f543844d6ca79782')\n  \n  \n  self.assertRaises(ValueError,run_scrypt,(1 <<30),r=1)\n  self.assertRaises(ValueError,run_scrypt,(1 <<30)/2,r=2)\n  \n def test_keylen_param(self):\n  ''\n  rng=self.getRandom()\n  \n  def run_scrypt(keylen):\n   return hexstr(scrypt_mod.scrypt(\"secret\",\"salt\",2,2,2,keylen))\n   \n   \n  self.assertRaises(ValueError,run_scrypt,-1)\n  self.assertRaises(ValueError,run_scrypt,0)\n  self.assertEqual(run_scrypt(1),'da')\n  \n  \n  ksize=rng.randint(1,1 <<10)\n  self.assertEqual(len(run_scrypt(ksize)),2 *ksize)\n  \n  \n  self.assertRaises(ValueError,run_scrypt,((2 **32)-1)*32+1)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef _can_import_cffi_scrypt():\n try :\n  import scrypt\n except ImportError as err:\n  if \"scrypt\"in str(err):\n   return False\n  raise\n return True\n \nhas_cffi_scrypt=_can_import_cffi_scrypt()\n\n\ndef _can_import_stdlib_scrypt():\n try :\n  from hashlib import scrypt\n  return True\n except ImportError:\n  return False\n  \nhas_stdlib_scrypt=_can_import_stdlib_scrypt()\n\n\n\n\n\n\n\n@skipUnless(PYPY or TEST_MODE(min=\"default\"),\"skipped under current test mode\")\nclass BuiltinScryptTest(_CommonScryptTest):\n backend=\"builtin\"\n \n def setUp(self):\n  super(BuiltinScryptTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\"(?i)using builtin scrypt backend\",\n  category=exc.PasslibSecurityWarning)\n  \n def test_missing_backend(self):\n  ''\n  if has_stdlib_scrypt or has_cffi_scrypt:\n   raise self.skipTest(\"non-builtin backend is present\")\n  self.assertRaises(exc.MissingBackendError,scrypt_mod._set_backend,'scrypt')\n  \n  \n@skipUnless(has_cffi_scrypt,\"'scrypt' package not found\")\nclass ScryptPackageTest(_CommonScryptTest):\n backend=\"scrypt\"\n \n def test_default_backend(self):\n  ''\n  if has_stdlib_scrypt:\n   raise self.skipTest(\"higher priority backend present\")\n  scrypt_mod._set_backend(\"default\")\n  self.assertEqual(scrypt_mod.backend,\"scrypt\")\n  \n  \n@skipUnless(has_stdlib_scrypt,\"'hashlib.scrypt()' not found\")\nclass StdlibScryptTest(_CommonScryptTest):\n backend=\"stdlib\"\n \n def test_default_backend(self):\n  ''\n  scrypt_mod._set_backend(\"default\")\n  self.assertEqual(scrypt_mod.backend,\"stdlib\")\n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib", "passlib.crypto", "passlib.crypto.scrypt._builtin", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "scrypt", "struct", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_pwd": [".py", "''\n\n\n\n\nimport itertools\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.tests.utils import TestCase\n\n__all__=[\n\"UtilsTest\",\n\"GenerateTest\",\n\"StrengthTest\",\n]\n\n\n\n\nclass UtilsTest(TestCase):\n ''\n descriptionPrefix=\"passlib.pwd\"\n \n def test_self_info_rate(self):\n  ''\n  from passlib.pwd import _self_info_rate\n  \n  self.assertEqual(_self_info_rate(\"\"),0)\n  \n  self.assertEqual(_self_info_rate(\"a\"*8),0)\n  \n  self.assertEqual(_self_info_rate(\"ab\"),1)\n  self.assertEqual(_self_info_rate(\"ab\"*8),1)\n  \n  self.assertEqual(_self_info_rate(\"abcd\"),2)\n  self.assertEqual(_self_info_rate(\"abcd\"*8),2)\n  self.assertAlmostEqual(_self_info_rate(\"abcdaaaa\"),1.5488,places=4)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nfrom passlib.pwd import genword,default_charsets\nascii_62=default_charsets['ascii_62']\nhex=default_charsets['hex']\n\nclass WordGeneratorTest(TestCase):\n ''\n descriptionPrefix=\"passlib.pwd.genword()\"\n \n def setUp(self):\n  super(WordGeneratorTest,self).setUp()\n  \n  \n  from passlib.pwd import SequenceGenerator\n  self.patchAttr(SequenceGenerator,\"rng\",\n  self.getRandom(\"pwd generator\"))\n  \n def assertResultContents(self,results,count,chars,unique=True ):\n  ''\n  self.assertEqual(len(results),count)\n  if unique:\n   if unique is True :\n    unique=count\n   self.assertEqual(len(set(results)),unique)\n  self.assertEqual(set(\"\".join(results)),set(chars))\n  \n def test_general(self):\n  ''\n  \n  \n  result=genword()\n  self.assertEqual(len(result),9)\n  \n  \n  self.assertRaisesRegex(TypeError,\"(?i)unexpected keyword.*badkwd\",genword,badkwd=True )\n  \n def test_returns(self):\n  ''\n  \n  results=genword(returns=5000)\n  self.assertResultContents(results,5000,ascii_62)\n  \n  \n  gen=genword(returns=iter)\n  results=[next(gen)for _ in range(5000)]\n  self.assertResultContents(results,5000,ascii_62)\n  \n  \n  self.assertRaises(TypeError,genword,returns='invalid-type')\n  \n def test_charset(self):\n  ''\n  \n  results=genword(charset=\"hex\",returns=5000)\n  self.assertResultContents(results,5000,hex)\n  \n  \n  \n  results=genword(length=3,chars=\"abc\",returns=5000)\n  self.assertResultContents(results,5000,\"abc\",unique=27)\n  \n  \n  self.assertRaises(TypeError,genword,chars='abc',charset='hex')\n  \n  \n  \n  \n  \n  \n  \n  \nfrom passlib.pwd import genphrase\nsimple_words=[\"alpha\",\"beta\",\"gamma\"]\n\nclass PhraseGeneratorTest(TestCase):\n ''\n descriptionPrefix=\"passlib.pwd.genphrase()\"\n \n def assertResultContents(self,results,count,words,unique=True ,sep=\" \"):\n  ''\n  self.assertEqual(len(results),count)\n  if unique:\n   if unique is True :\n    unique=count\n   self.assertEqual(len(set(results)),unique)\n  out=set(itertools.chain.from_iterable(elem.split(sep)for elem in results))\n  self.assertEqual(out,set(words))\n  \n def test_general(self):\n  ''\n  \n  \n  result=genphrase()\n  self.assertEqual(len(result.split(\" \")),4)\n  \n  \n  self.assertRaisesRegex(TypeError,\"(?i)unexpected keyword.*badkwd\",genphrase,badkwd=True )\n  \n def test_entropy(self):\n  ''\n  \n  \n  result=genphrase(entropy=70)\n  self.assertEqual(len(result.split(\" \")),6)\n  \n  \n  result=genphrase(length=3)\n  self.assertEqual(len(result.split(\" \")),3)\n  \n  \n  result=genphrase(length=3,entropy=48)\n  self.assertEqual(len(result.split(\" \")),4)\n  \n  \n  result=genphrase(length=4,entropy=12)\n  self.assertEqual(len(result.split(\" \")),4)\n  \n def test_returns(self):\n  ''\n  \n  results=genphrase(returns=1000,words=simple_words)\n  self.assertResultContents(results,1000,simple_words)\n  \n  \n  gen=genphrase(returns=iter,words=simple_words)\n  results=[next(gen)for _ in range(1000)]\n  self.assertResultContents(results,1000,simple_words)\n  \n  \n  self.assertRaises(TypeError,genphrase,returns='invalid-type')\n  \n def test_wordset(self):\n  ''\n  \n  results=genphrase(words=simple_words,returns=5000)\n  self.assertResultContents(results,5000,simple_words)\n  \n  \n  results=genphrase(length=3,words=simple_words,returns=5000)\n  self.assertResultContents(results,5000,simple_words,unique=3 **3)\n  \n  \n  self.assertRaises(TypeError,genphrase,words=simple_words,wordset='bip39')\n  \n  \n  \n  \n", ["itertools", "logging", "passlib.pwd", "passlib.tests.utils"]], "passlib.Lib.site-packages.passlib.tests.test_utils_md4": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport warnings\n\n\n\nfrom passlib.tests.test_crypto_builtin_md4 import _Common_MD4_Test\n\n__all__=[\n\"Legacy_MD4_Test\",\n]\n\n\n\nclass Legacy_MD4_Test(_Common_MD4_Test):\n descriptionPrefix=\"passlib.utils.md4.md4()\"\n \n def setUp(self):\n  super(Legacy_MD4_Test,self).setUp()\n  warnings.filterwarnings(\"ignore\",\".*passlib.utils.md4.*deprecated\",DeprecationWarning)\n  \n def get_md4_const(self):\n  from passlib.utils.md4 import md4\n  return md4\n  \n  \n  \n  \n", ["passlib.tests.test_crypto_builtin_md4", "passlib.utils.md4", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_apache": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nfrom logging import getLogger\nimport os\nimport subprocess\n\n\nfrom passlib import apache,registry\nfrom passlib.exc import MissingBackendError\nfrom passlib.utils.compat import irange\nfrom passlib.tests.backports import unittest\nfrom passlib.tests.utils import TestCase,get_file,set_file,ensure_mtime_changed\nfrom passlib.utils.compat import u\nfrom passlib.utils import to_bytes\nfrom passlib.utils.handlers import to_unicode_for_identify\n\nlog=getLogger(__name__)\n\n\n\n\n\ndef backdate_file_mtime(path,offset=10):\n ''\n \n \n atime=os.path.getatime(path)\n mtime=os.path.getmtime(path)-offset\n os.utime(path,(atime,mtime))\n \n \n \n \n \n \nhtpasswd_path=os.environ.get(\"PASSLIB_TEST_HTPASSWD_PATH\")or \"htpasswd\"\n\n\ndef _call_htpasswd(args,stdin=None ):\n ''\n\n \n if stdin is not None :\n  stdin=stdin.encode(\"utf-8\")\n proc=subprocess.Popen([htpasswd_path]+args,stdout=subprocess.PIPE,\n stderr=subprocess.STDOUT,stdin=subprocess.PIPE if stdin else None )\n out,err=proc.communicate(stdin)\n rc=proc.wait()\n out=to_unicode_for_identify(out or \"\")\n return out,rc\n \n \ndef _call_htpasswd_verify(path,user,password):\n ''\n\n \n out,rc=_call_htpasswd([\"-vi\",path,user],password)\n return not rc\n \n \ndef _detect_htpasswd():\n ''\n\n \n try :\n  out,rc=_call_htpasswd([])\n except OSError:\n \n \n  return False ,False\n  \n if not rc:\n  log.warning(\"htpasswd test returned with rc=0\")\n have_bcrypt=\" -B \"in out\n return True ,have_bcrypt\n \n \nHAVE_HTPASSWD,HAVE_HTPASSWD_BCRYPT=_detect_htpasswd()\n\nrequires_htpasswd_cmd=unittest.skipUnless(HAVE_HTPASSWD,\"requires `htpasswd` cmdline tool\")\n\n\n\n\n\nclass HtpasswdFileTest(TestCase):\n ''\n descriptionPrefix=\"HtpasswdFile\"\n \n \n sample_01=(b'user2:2CHkkwa2AtqGs\\n'\n b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\n'\n b'user4:pass4\\n'\n b'user1:$apr1$t4tc7jTh$GPIWVUo8sQKJlUdV8V5vu0\\n')\n \n \n sample_02=b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\nuser4:pass4\\n'\n \n \n sample_03=(b'user2:pass2x\\n'\n b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\n'\n b'user4:pass4\\n'\n b'user1:$apr1$t4tc7jTh$GPIWVUo8sQKJlUdV8V5vu0\\n'\n b'user5:pass5\\n')\n \n \n sample_04_utf8=b'user\\xc3\\xa6:2CHkkwa2AtqGs\\n'\n sample_04_latin1=b'user\\xe6:2CHkkwa2AtqGs\\n'\n \n sample_dup=b'user1:pass1\\nuser1:pass2\\n'\n \n \n sample_05=(b'user2:2CHkkwa2AtqGs\\n'\n b'user3:{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\\n'\n b'user4:pass4\\n'\n b'user1:$apr1$t4tc7jTh$GPIWVUo8sQKJlUdV8V5vu0\\n'\n b'user5:$2a$12$yktDxraxijBZ360orOyCOePFGhuis/umyPNJoL5EbsLk.s6SWdrRO\\n'\n b'user6:$5$rounds=110000$cCRp/xUUGVgwR4aP$'\n b'p0.QKFS5qLNRqw1/47lXYiAcgIjJK.WjCO8nrEKuUK.\\n')\n \n def test_00_constructor_autoload(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtpasswdFile(path)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  self.assertEqual(ht.path,path)\n  self.assertTrue(ht.mtime)\n  \n  \n  ht.path=path+\"x\"\n  self.assertEqual(ht.path,path+\"x\")\n  self.assertFalse(ht.mtime)\n  \n  \n  ht=apache.HtpasswdFile(path,new=True )\n  self.assertEqual(ht.to_string(),b\"\")\n  self.assertEqual(ht.path,path)\n  self.assertFalse(ht.mtime)\n  \n  \n  with self.assertWarningList(\"``autoload=False`` is deprecated\"):\n   ht=apache.HtpasswdFile(path,autoload=False )\n  self.assertEqual(ht.to_string(),b\"\")\n  self.assertEqual(ht.path,path)\n  self.assertFalse(ht.mtime)\n  \n  \n  os.remove(path)\n  self.assertRaises(IOError,apache.HtpasswdFile,path)\n  \n  \n  \n def test_00_from_path(self):\n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtpasswdFile.from_path(path)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  self.assertEqual(ht.path,None )\n  self.assertFalse(ht.mtime)\n  \n def test_01_delete(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  self.assertTrue(ht.delete(\"user1\"))\n  self.assertTrue(ht.delete(\"user2\"))\n  self.assertFalse(ht.delete(\"user5\"))\n  self.assertEqual(ht.to_string(),self.sample_02)\n  \n  \n  self.assertRaises(ValueError,ht.delete,\"user:\")\n  \n def test_01_delete_autosave(self):\n  path=self.mktemp()\n  sample=b'user1:pass1\\nuser2:pass2\\n'\n  set_file(path,sample)\n  \n  ht=apache.HtpasswdFile(path)\n  ht.delete(\"user1\")\n  self.assertEqual(get_file(path),sample)\n  \n  ht=apache.HtpasswdFile(path,autosave=True )\n  ht.delete(\"user1\")\n  self.assertEqual(get_file(path),b\"user2:pass2\\n\")\n  \n def test_02_set_password(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(\n  self.sample_01,default_scheme=\"plaintext\")\n  self.assertTrue(ht.set_password(\"user2\",\"pass2x\"))\n  self.assertFalse(ht.set_password(\"user5\",\"pass5\"))\n  self.assertEqual(ht.to_string(),self.sample_03)\n  \n  \n  with self.assertWarningList(\"``default`` is deprecated\"):\n   ht=apache.HtpasswdFile.from_string(self.sample_01,default=\"plaintext\")\n  self.assertTrue(ht.set_password(\"user2\",\"pass2x\"))\n  self.assertFalse(ht.set_password(\"user5\",\"pass5\"))\n  self.assertEqual(ht.to_string(),self.sample_03)\n  \n  \n  self.assertRaises(ValueError,ht.set_password,\"user:\",\"pass\")\n  \n  \n  with self.assertWarningList(\"update\\(\\) is deprecated\"):\n   ht.update(\"user2\",\"test\")\n  self.assertTrue(ht.check_password(\"user2\",\"test\"))\n  \n def test_02_set_password_autosave(self):\n  path=self.mktemp()\n  sample=b'user1:pass1\\n'\n  set_file(path,sample)\n  \n  ht=apache.HtpasswdFile(path)\n  ht.set_password(\"user1\",\"pass2\")\n  self.assertEqual(get_file(path),sample)\n  \n  ht=apache.HtpasswdFile(path,default_scheme=\"plaintext\",autosave=True )\n  ht.set_password(\"user1\",\"pass2\")\n  self.assertEqual(get_file(path),b\"user1:pass2\\n\")\n  \n def test_02_set_password_default_scheme(self):\n  ''\n  \n  def check(scheme):\n   ht=apache.HtpasswdFile(default_scheme=scheme)\n   ht.set_password(\"user1\",\"pass1\")\n   return ht.context.identify(ht.get_hash(\"user1\"))\n   \n   \n  self.assertEqual(check(\"sha256_crypt\"),\"sha256_crypt\")\n  self.assertEqual(check(\"des_crypt\"),\"des_crypt\")\n  \n  \n  self.assertRaises(KeyError,check,\"xxx\")\n  \n  \n  self.assertEqual(check(\"portable\"),apache.htpasswd_defaults[\"portable\"])\n  self.assertEqual(check(\"portable_apache_22\"),apache.htpasswd_defaults[\"portable_apache_22\"])\n  self.assertEqual(check(\"host_apache_22\"),apache.htpasswd_defaults[\"host_apache_22\"])\n  \n  \n  self.assertEqual(check(None ),apache.htpasswd_defaults[\"portable_apache_22\"])\n  \n def test_03_users(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  ht.set_password(\"user5\",\"pass5\")\n  ht.delete(\"user3\")\n  ht.set_password(\"user3\",\"pass3\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user3\",\"user4\",\"user5\"])\n  \n def test_04_check_password(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_05)\n  self.assertRaises(TypeError,ht.check_password,1,'pass9')\n  self.assertTrue(ht.check_password(\"user9\",\"pass9\")is None )\n  \n  \n  \n  for i in irange(1,7):\n   i=str(i)\n   try :\n    self.assertTrue(ht.check_password(\"user\"+i,\"pass\"+i))\n    self.assertTrue(ht.check_password(\"user\"+i,\"pass9\")is False )\n   except MissingBackendError:\n    if i ==\"5\":\n    \n     continue\n    raise\n    \n  self.assertRaises(ValueError,ht.check_password,\"user:\",\"pass\")\n  \n  \n  with self.assertWarningList([\"verify\\(\\) is deprecated\"]*2):\n   self.assertTrue(ht.verify(\"user1\",\"pass1\"))\n   self.assertFalse(ht.verify(\"user1\",\"pass2\"))\n   \n def test_05_load(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,\"\")\n  backdate_file_mtime(path,5)\n  ha=apache.HtpasswdFile(path,default_scheme=\"plaintext\")\n  self.assertEqual(ha.to_string(),b\"\")\n  \n  \n  ha.set_password(\"user1\",\"pass1\")\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),b\"user1:pass1\\n\")\n  \n  \n  set_file(path,self.sample_01)\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  ha.set_password(\"user5\",\"pass5\")\n  ha.load()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  hb=apache.HtpasswdFile()\n  self.assertRaises(RuntimeError,hb.load)\n  self.assertRaises(RuntimeError,hb.load_if_changed)\n  \n  \n  set_file(path,self.sample_dup)\n  hc=apache.HtpasswdFile()\n  hc.load(path)\n  self.assertTrue(hc.check_password('user1','pass1'))\n  \n  \n  \n def test_06_save(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtpasswdFile(path)\n  \n  \n  ht.delete(\"user1\")\n  ht.delete(\"user2\")\n  ht.save()\n  self.assertEqual(get_file(path),self.sample_02)\n  \n  \n  hb=apache.HtpasswdFile(default_scheme=\"plaintext\")\n  hb.set_password(\"user1\",\"pass1\")\n  self.assertRaises(RuntimeError,hb.save)\n  \n  \n  hb.save(path)\n  self.assertEqual(get_file(path),b\"user1:pass1\\n\")\n  \n def test_07_encodings(self):\n  ''\n  \n  self.assertRaises(ValueError,apache.HtpasswdFile,encoding=\"utf-16\")\n  \n  \n  ht=apache.HtpasswdFile.from_string(self.sample_04_utf8,encoding=\"utf-8\",\n  return_unicode=True )\n  self.assertEqual(ht.users(),[u(\"user\\u00e6\")])\n  \n  \n  with self.assertWarningList(\"``encoding=None`` is deprecated\"):\n   ht=apache.HtpasswdFile.from_string(self.sample_04_utf8,encoding=None )\n  self.assertEqual(ht.users(),[b'user\\xc3\\xa6'])\n  \n  \n  ht=apache.HtpasswdFile.from_string(self.sample_04_latin1,\n  encoding=\"latin-1\",return_unicode=True )\n  self.assertEqual(ht.users(),[u(\"user\\u00e6\")])\n  \n def test_08_get_hash(self):\n  ''\n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  self.assertEqual(ht.get_hash(\"user3\"),b\"{SHA}3ipNV1GrBtxPmHFC21fCbVCSXIo=\")\n  self.assertEqual(ht.get_hash(\"user4\"),b\"pass4\")\n  self.assertEqual(ht.get_hash(\"user5\"),None )\n  \n  with self.assertWarningList(\"find\\(\\) is deprecated\"):\n   self.assertEqual(ht.find(\"user4\"),b\"pass4\")\n   \n def test_09_to_string(self):\n  ''\n  \n  \n  ht=apache.HtpasswdFile.from_string(self.sample_01)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  \n  \n  ht=apache.HtpasswdFile()\n  self.assertEqual(ht.to_string(),b\"\")\n  \n def test_10_repr(self):\n  ht=apache.HtpasswdFile(\"fakepath\",autosave=True ,new=True ,encoding=\"latin-1\")\n  repr(ht)\n  \n def test_11_malformed(self):\n  self.assertRaises(ValueError,apache.HtpasswdFile.from_string,\n  b'realm:user1:pass1\\n')\n  self.assertRaises(ValueError,apache.HtpasswdFile.from_string,\n  b'pass1\\n')\n  \n def test_12_from_string(self):\n \n  self.assertRaises(TypeError,apache.HtpasswdFile.from_string,\n  b'',path=None )\n  \n def test_13_whitespace(self):\n  ''\n  \n  \n  \n  source=to_bytes(\n  '\\n'\n  'user2:pass2\\n'\n  'user4:pass4\\n'\n  'user7:pass7\\r\\n'\n  ' \\t \\n'\n  'user1:pass1\\n'\n  ' # legacy users\\n'\n  '#user6:pass6\\n'\n  'user5:pass5\\n\\n'\n  )\n  \n  \n  ht=apache.HtpasswdFile.from_string(source)\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user7\"])\n  \n  \n  ht.set_hash(\"user4\",\"althash4\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user7\"])\n  \n  \n  ht.set_hash(\"user6\",\"althash6\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user6\",\"user7\"])\n  \n  \n  ht.delete(\"user7\")\n  self.assertEqual(sorted(ht.users()),[\"user1\",\"user2\",\"user4\",\"user5\",\"user6\"])\n  \n  \n  target=to_bytes(\n  '\\n'\n  'user2:pass2\\n'\n  'user4:althash4\\n'\n  ' \\t \\n'\n  'user1:pass1\\n'\n  ' # legacy users\\n'\n  '#user6:pass6\\n'\n  'user5:pass5\\n'\n  'user6:althash6\\n'\n  )\n  self.assertEqual(ht.to_string(),target)\n  \n @requires_htpasswd_cmd\n def test_htpasswd_cmd_verify(self):\n  ''\n\n  \n  path=self.mktemp()\n  ht=apache.HtpasswdFile(path=path,new=True )\n  \n  def hash_scheme(pwd,scheme):\n   return ht.context.handler(scheme).hash(pwd)\n   \n   \n  ht.set_hash(\"user1\",hash_scheme(\"password\",\"apr_md5_crypt\"))\n  \n  \n  host_no_bcrypt=apache.htpasswd_defaults[\"host_apache_22\"]\n  ht.set_hash(\"user2\",hash_scheme(\"password\",host_no_bcrypt))\n  \n  \n  host_best=apache.htpasswd_defaults[\"host\"]\n  ht.set_hash(\"user3\",hash_scheme(\"password\",host_best))\n  \n  \n  ht.set_hash(\"user4\",\"$xxx$foo$bar$baz\")\n  \n  \n  ht.save()\n  \n  self.assertFalse(_call_htpasswd_verify(path,\"user1\",\"wrong\"))\n  self.assertFalse(_call_htpasswd_verify(path,\"user2\",\"wrong\"))\n  self.assertFalse(_call_htpasswd_verify(path,\"user3\",\"wrong\"))\n  self.assertFalse(_call_htpasswd_verify(path,\"user4\",\"wrong\"))\n  \n  self.assertTrue(_call_htpasswd_verify(path,\"user1\",\"password\"))\n  self.assertTrue(_call_htpasswd_verify(path,\"user2\",\"password\"))\n  self.assertTrue(_call_htpasswd_verify(path,\"user3\",\"password\"))\n  \n @requires_htpasswd_cmd\n @unittest.skipUnless(registry.has_backend(\"bcrypt\"),\"bcrypt support required\")\n def test_htpasswd_cmd_verify_bcrypt(self):\n  ''\n\n\n\n\n  \n  path=self.mktemp()\n  ht=apache.HtpasswdFile(path=path,new=True )\n  def hash_scheme(pwd,scheme):\n   return ht.context.handler(scheme).hash(pwd)\n  ht.set_hash(\"user1\",hash_scheme(\"password\",\"bcrypt\"))\n  ht.save()\n  self.assertFalse(_call_htpasswd_verify(path,\"user1\",\"wrong\"))\n  if HAVE_HTPASSWD_BCRYPT:\n   self.assertTrue(_call_htpasswd_verify(path,\"user1\",\"password\"))\n  else :\n  \n   self.assertFalse(_call_htpasswd_verify(path,\"user1\",\"password\"))\n   \n   \n   \n   \n   \n   \n   \n   \nclass HtdigestFileTest(TestCase):\n ''\n descriptionPrefix=\"HtdigestFile\"\n \n \n sample_01=(b'user2:realm:549d2a5f4659ab39a80dac99e159ab19\\n'\n b'user3:realm:a500bb8c02f6a9170ae46af10c898744\\n'\n b'user4:realm:ab7b5d5f28ccc7666315f508c7358519\\n'\n b'user1:realm:2a6cf53e7d8f8cf39d946dc880b14128\\n')\n \n \n sample_02=(b'user3:realm:a500bb8c02f6a9170ae46af10c898744\\n'\n b'user4:realm:ab7b5d5f28ccc7666315f508c7358519\\n')\n \n \n sample_03=(b'user2:realm:5ba6d8328943c23c64b50f8b29566059\\n'\n b'user3:realm:a500bb8c02f6a9170ae46af10c898744\\n'\n b'user4:realm:ab7b5d5f28ccc7666315f508c7358519\\n'\n b'user1:realm:2a6cf53e7d8f8cf39d946dc880b14128\\n'\n b'user5:realm:03c55fdc6bf71552356ad401bdb9af19\\n')\n \n \n sample_04_utf8=b'user\\xc3\\xa6:realm\\xc3\\xa6:549d2a5f4659ab39a80dac99e159ab19\\n'\n sample_04_latin1=b'user\\xe6:realm\\xe6:549d2a5f4659ab39a80dac99e159ab19\\n'\n \n def test_00_constructor_autoload(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtdigestFile(path)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  \n  \n  ht=apache.HtdigestFile(path,new=True )\n  self.assertEqual(ht.to_string(),b\"\")\n  \n  \n  os.remove(path)\n  self.assertRaises(IOError,apache.HtdigestFile,path)\n  \n  \n  \n def test_01_delete(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertTrue(ht.delete(\"user1\",\"realm\"))\n  self.assertTrue(ht.delete(\"user2\",\"realm\"))\n  self.assertFalse(ht.delete(\"user5\",\"realm\"))\n  self.assertFalse(ht.delete(\"user3\",\"realm5\"))\n  self.assertEqual(ht.to_string(),self.sample_02)\n  \n  \n  self.assertRaises(ValueError,ht.delete,\"user:\",\"realm\")\n  \n  \n  self.assertRaises(ValueError,ht.delete,\"user\",\"realm:\")\n  \n def test_01_delete_autosave(self):\n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  \n  ht=apache.HtdigestFile(path)\n  self.assertTrue(ht.delete(\"user1\",\"realm\"))\n  self.assertFalse(ht.delete(\"user3\",\"realm5\"))\n  self.assertFalse(ht.delete(\"user5\",\"realm\"))\n  self.assertEqual(get_file(path),self.sample_01)\n  \n  ht.autosave=True\n  self.assertTrue(ht.delete(\"user2\",\"realm\"))\n  self.assertEqual(get_file(path),self.sample_02)\n  \n def test_02_set_password(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertTrue(ht.set_password(\"user2\",\"realm\",\"pass2x\"))\n  self.assertFalse(ht.set_password(\"user5\",\"realm\",\"pass5\"))\n  self.assertEqual(ht.to_string(),self.sample_03)\n  \n  \n  self.assertRaises(TypeError,ht.set_password,\"user2\",\"pass3\")\n  ht.default_realm=\"realm2\"\n  ht.set_password(\"user2\",\"pass3\")\n  ht.check_password(\"user2\",\"realm2\",\"pass3\")\n  \n  \n  self.assertRaises(ValueError,ht.set_password,\"user:\",\"realm\",\"pass\")\n  self.assertRaises(ValueError,ht.set_password,\"u\"*256,\"realm\",\"pass\")\n  \n  \n  self.assertRaises(ValueError,ht.set_password,\"user\",\"realm:\",\"pass\")\n  self.assertRaises(ValueError,ht.set_password,\"user\",\"r\"*256,\"pass\")\n  \n  \n  with self.assertWarningList(\"update\\(\\) is deprecated\"):\n   ht.update(\"user2\",\"realm2\",\"test\")\n  self.assertTrue(ht.check_password(\"user2\",\"test\"))\n  \n  \n  \n def test_03_users(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  ht.set_password(\"user5\",\"realm\",\"pass5\")\n  ht.delete(\"user3\",\"realm\")\n  ht.set_password(\"user3\",\"realm\",\"pass3\")\n  self.assertEqual(sorted(ht.users(\"realm\")),[\"user1\",\"user2\",\"user3\",\"user4\",\"user5\"])\n  \n  self.assertRaises(TypeError,ht.users,1)\n  \n def test_04_check_password(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertRaises(TypeError,ht.check_password,1,'realm','pass5')\n  self.assertRaises(TypeError,ht.check_password,'user',1,'pass5')\n  self.assertIs(ht.check_password(\"user5\",\"realm\",\"pass5\"),None )\n  for i in irange(1,5):\n   i=str(i)\n   self.assertTrue(ht.check_password(\"user\"+i,\"realm\",\"pass\"+i))\n   self.assertIs(ht.check_password(\"user\"+i,\"realm\",\"pass5\"),False )\n   \n   \n  self.assertRaises(TypeError,ht.check_password,\"user5\",\"pass5\")\n  ht.default_realm=\"realm\"\n  self.assertTrue(ht.check_password(\"user1\",\"pass1\"))\n  self.assertIs(ht.check_password(\"user5\",\"pass5\"),None )\n  \n  \n  with self.assertWarningList([\"verify\\(\\) is deprecated\"]*2):\n   self.assertTrue(ht.verify(\"user1\",\"realm\",\"pass1\"))\n   self.assertFalse(ht.verify(\"user1\",\"realm\",\"pass2\"))\n   \n   \n  self.assertRaises(ValueError,ht.check_password,\"user:\",\"realm\",\"pass\")\n  \n def test_05_load(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,\"\")\n  backdate_file_mtime(path,5)\n  ha=apache.HtdigestFile(path)\n  self.assertEqual(ha.to_string(),b\"\")\n  \n  \n  ha.set_password(\"user1\",\"realm\",\"pass1\")\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),b'user1:realm:2a6cf53e7d8f8cf39d946dc880b14128\\n')\n  \n  \n  set_file(path,self.sample_01)\n  ha.load_if_changed()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  ha.set_password(\"user5\",\"realm\",\"pass5\")\n  ha.load()\n  self.assertEqual(ha.to_string(),self.sample_01)\n  \n  \n  hb=apache.HtdigestFile()\n  self.assertRaises(RuntimeError,hb.load)\n  self.assertRaises(RuntimeError,hb.load_if_changed)\n  \n  \n  hc=apache.HtdigestFile()\n  hc.load(path)\n  self.assertEqual(hc.to_string(),self.sample_01)\n  \n  \n  ensure_mtime_changed(path)\n  set_file(path,\"\")\n  with self.assertWarningList(r\"load\\(force=False\\) is deprecated\"):\n   ha.load(force=False )\n  self.assertEqual(ha.to_string(),b\"\")\n  \n def test_06_save(self):\n  ''\n  \n  path=self.mktemp()\n  set_file(path,self.sample_01)\n  ht=apache.HtdigestFile(path)\n  \n  \n  ht.delete(\"user1\",\"realm\")\n  ht.delete(\"user2\",\"realm\")\n  ht.save()\n  self.assertEqual(get_file(path),self.sample_02)\n  \n  \n  hb=apache.HtdigestFile()\n  hb.set_password(\"user1\",\"realm\",\"pass1\")\n  self.assertRaises(RuntimeError,hb.save)\n  \n  \n  hb.save(path)\n  self.assertEqual(get_file(path),hb.to_string())\n  \n def test_07_realms(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  \n  self.assertEqual(ht.delete_realm(\"x\"),0)\n  self.assertEqual(ht.realms(),['realm'])\n  \n  self.assertEqual(ht.delete_realm(\"realm\"),4)\n  self.assertEqual(ht.realms(),[])\n  self.assertEqual(ht.to_string(),b\"\")\n  \n def test_08_get_hash(self):\n  ''\n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertEqual(ht.get_hash(\"user3\",\"realm\"),\"a500bb8c02f6a9170ae46af10c898744\")\n  self.assertEqual(ht.get_hash(\"user4\",\"realm\"),\"ab7b5d5f28ccc7666315f508c7358519\")\n  self.assertEqual(ht.get_hash(\"user5\",\"realm\"),None )\n  \n  with self.assertWarningList(\"find\\(\\) is deprecated\"):\n   self.assertEqual(ht.find(\"user4\",\"realm\"),\"ab7b5d5f28ccc7666315f508c7358519\")\n   \n def test_09_encodings(self):\n  ''\n  \n  self.assertRaises(ValueError,apache.HtdigestFile,encoding=\"utf-16\")\n  \n  \n  ht=apache.HtdigestFile.from_string(self.sample_04_utf8,encoding=\"utf-8\",return_unicode=True )\n  self.assertEqual(ht.realms(),[u(\"realm\\u00e6\")])\n  self.assertEqual(ht.users(u(\"realm\\u00e6\")),[u(\"user\\u00e6\")])\n  \n  \n  ht=apache.HtdigestFile.from_string(self.sample_04_latin1,encoding=\"latin-1\",return_unicode=True )\n  self.assertEqual(ht.realms(),[u(\"realm\\u00e6\")])\n  self.assertEqual(ht.users(u(\"realm\\u00e6\")),[u(\"user\\u00e6\")])\n  \n def test_10_to_string(self):\n  ''\n  \n  \n  ht=apache.HtdigestFile.from_string(self.sample_01)\n  self.assertEqual(ht.to_string(),self.sample_01)\n  \n  \n  ht=apache.HtdigestFile()\n  self.assertEqual(ht.to_string(),b\"\")\n  \n def test_11_malformed(self):\n  self.assertRaises(ValueError,apache.HtdigestFile.from_string,\n  b'realm:user1:pass1:other\\n')\n  self.assertRaises(ValueError,apache.HtdigestFile.from_string,\n  b'user1:pass1\\n')\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "os", "passlib", "passlib.exc", "passlib.tests.backports", "passlib.tests.utils", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "subprocess"]], "passlib.Lib.site-packages.passlib.tests.test_handlers_cisco": [".py", "''\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\n\nimport logging\nlog=logging.getLogger(__name__)\n\n\nfrom passlib import hash,exc\nfrom passlib.utils.compat import u\nfrom .utils import UserHandlerMixin,HandlerCase,repeat_string\nfrom .test_handlers import UPASS_TABLE\n\n__all__=[\n\"cisco_pix_test\",\n\"cisco_asa_test\",\n\"cisco_type7_test\",\n]\n\n\n\n\nclass _PixAsaSharedTest(UserHandlerMixin,HandlerCase):\n ''\n\n \n __unittest_skip=True\n requires_user=False\n \n \n \n pix_asa_shared_hashes=[\n \n \n \n ((\"cisco\",\"\"),\"2KFQnbNIdI.2KYOU\"),\n \n \n \n \n ((\"hsc\",\"\"),\"YtT8/k6Np8F1yz2c\"),\n \n \n \n \n ((\"\",\"\"),\"8Ry2YjIyt7RRXU24\"),\n ((\"cisco\",\"john\"),\"hN7LzeyYjw12FSIU\"),\n ((\"cisco\",\"jack\"),\"7DrfeZ7cyOj/PslD\"),\n \n \n \n \n ((\"ripper\",\"alex\"),\"h3mJrcH0901pqX/m\"),\n ((\"cisco\",\"cisco\"),\"3USUcOPFUiMCO4Jk\"),\n ((\"cisco\",\"cisco1\"),\"3USUcOPFUiMCO4Jk\"),\n ((\"CscFw-ITC!\",\"admcom\"),\"lZt7HSIXw3.QP7.R\"),\n (\"cangetin\",\"TynyB./ftknE77QP\"),\n ((\"cangetin\",\"rramsey\"),\"jgBZqYtsWfGcUKDi\"),\n \n \n \n \n ((\"phonehome\",\"rharris\"),\"zyIIMSYjiPm0L7a6\"),\n \n \n \n \n ((\"cangetin\",\"\"),\"TynyB./ftknE77QP\"),\n ((\"cangetin\",\"rramsey\"),\"jgBZqYtsWfGcUKDi\"),\n \n \n \n \n (\"test1\",\"TRPEas6f/aa6JSPL\"),\n (\"test2\",\"OMT6mXmAvGyzrCtp\"),\n (\"test3\",\"gTC7RIy1XJzagmLm\"),\n (\"test4\",\"oWC1WRwqlBlbpf/O\"),\n (\"password\",\"NuLKvvWGg.x9HEKO\"),\n (\"0123456789abcdef\",\".7nfVBEIEu4KbF/1\"),\n \n \n \n \n ((\"1234567890123456\",\"\"),\"feCkwUGktTCAgIbD\"),\n ((\"watag00s1am\",\"\"),\"jMorNbK0514fadBh\"),\n \n \n \n \n ((\"cisco1\",\"cisco1\"),\"jmINXNH6p1BxUppp\"),\n \n \n (UPASS_TABLE,'CaiIvkLMu2TOHXGT'),\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n (('1234',''),'RLPMUQ26KL4blgFN'),\n \n \n (('01234567',''),'0T52THgnYdV1tlOF'),\n (('01234567','3'),'.z0dT9Alkdc7EIGS'),\n (('01234567','36'),'CC3Lam53t/mHhoE7'),\n (('01234567','365'),'8xPrWpNnBdD2DzdZ'),\n (('01234567','3333'),'.z0dT9Alkdc7EIGS'),\n (('01234567','3636'),'CC3Lam53t/mHhoE7'),\n (('01234567','3653'),'8xPrWpNnBdD2DzdZ'),\n (('01234567','adm'),'dfWs2qiao6KD/P2L'),\n (('01234567','adma'),'dfWs2qiao6KD/P2L'),\n (('01234567','admad'),'dfWs2qiao6KD/P2L'),\n (('01234567','user'),'PNZ4ycbbZ0jp1.j1'),\n (('01234567','user1234'),'PNZ4ycbbZ0jp1.j1'),\n \n \n (('0123456789ab',''),'S31BxZOGlAigndcJ'),\n (('0123456789ab','36'),'wFqSX91X5.YaRKsi'),\n (('0123456789ab','365'),'qjgo3kNgTVxExbno'),\n (('0123456789ab','3333'),'mcXPL/vIZcIxLUQs'),\n (('0123456789ab','3636'),'wFqSX91X5.YaRKsi'),\n (('0123456789ab','3653'),'qjgo3kNgTVxExbno'),\n (('0123456789ab','user'),'f.T4BKdzdNkjxQl7'),\n (('0123456789ab','user1234'),'f.T4BKdzdNkjxQl7'),\n \n \n \n \n \n \n \n \n \n \n ((u(\"t\\xe1ble\").encode(\"utf-8\"),'user'),'Og8fB4NyF0m5Ed9c'),\n ((u(\"t\\xe1ble\").encode(\"utf-8\").decode(\"latin-1\").encode(\"utf-8\"),\n 'user'),'cMvFC2XVBmK/68yB'),\n ]\n \n def test_calc_digest_spoiler(self):\n  ''\n\n\n\n\n\n  \n  def calc(secret,for_hash=False ):\n   return self.handler(use_defaults=for_hash)._calc_checksum(secret)\n   \n   \n  short_secret=repeat_string(\"1234\",self.handler.truncate_size)\n  short_hash=calc(short_secret)\n  \n  \n  \n  long_secret=short_secret+\"X\"\n  long_hash=calc(long_secret)\n  self.assertNotEqual(long_hash,short_hash)\n  \n  \n  \n  alt_long_secret=short_secret+\"Y\"\n  alt_long_hash=calc(alt_long_secret)\n  self.assertNotEqual(alt_long_hash,short_hash)\n  self.assertNotEqual(alt_long_hash,long_hash)\n  \n  \n  calc(short_secret,for_hash=True )\n  self.assertRaises(exc.PasswordSizeError,calc,long_secret,for_hash=True )\n  self.assertRaises(exc.PasswordSizeError,calc,alt_long_secret,for_hash=True )\n  \n  \n  \n  \nclass cisco_pix_test(_PixAsaSharedTest):\n handler=hash.cisco_pix\n \n \n known_correct_hashes=_PixAsaSharedTest.pix_asa_shared_hashes+[\n \n \n \n \n \n \n \n \n \n \n \n \n \n (('0123456789abc',''),'eacOpB7vE7ZDukSF'),\n (('0123456789abc','3'),'ylJTd/qei66WZe3w'),\n (('0123456789abc','36'),'hDx8QRlUhwd6bU8N'),\n (('0123456789abc','365'),'vYOOtnkh1HXcMrM7'),\n (('0123456789abc','3333'),'ylJTd/qei66WZe3w'),\n (('0123456789abc','3636'),'hDx8QRlUhwd6bU8N'),\n (('0123456789abc','3653'),'vYOOtnkh1HXcMrM7'),\n (('0123456789abc','user'),'f4/.SALxqDo59mfV'),\n (('0123456789abc','user1234'),'f4/.SALxqDo59mfV'),\n \n \n (('0123456789abcd',''),'6r8888iMxEoPdLp4'),\n (('0123456789abcd','3'),'f5lvmqWYj9gJqkIH'),\n (('0123456789abcd','36'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','365'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','3333'),'f5lvmqWYj9gJqkIH'),\n (('0123456789abcd','3636'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','3653'),'OJJ1Khg5HeAYBH1c'),\n (('0123456789abcd','adm'),'DbPLCFIkHc2SiyDk'),\n (('0123456789abcd','adma'),'DbPLCFIkHc2SiyDk'),\n (('0123456789abcd','user'),'WfO2UiTapPkF/FSn'),\n (('0123456789abcd','user1234'),'WfO2UiTapPkF/FSn'),\n \n \n (('0123456789abcde',''),'al1e0XFIugTYLai3'),\n (('0123456789abcde','3'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','36'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','365'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','3333'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','3636'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','3653'),'lYbwBu.f82OIApQB'),\n (('0123456789abcde','adm'),'KgKx1UQvdR/09i9u'),\n (('0123456789abcde','adma'),'KgKx1UQvdR/09i9u'),\n (('0123456789abcde','user'),'qLopkenJ4WBqxaZN'),\n (('0123456789abcde','user1234'),'qLopkenJ4WBqxaZN'),\n \n \n (('0123456789abcdef',''),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','36'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','365'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','3333'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','3636'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','3653'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','user'),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','user1234'),'.7nfVBEIEu4KbF/1'),\n ]\n \n \n \n \n \nclass cisco_asa_test(_PixAsaSharedTest):\n handler=hash.cisco_asa\n \n known_correct_hashes=_PixAsaSharedTest.pix_asa_shared_hashes+[\n \n \n \n \n \n \n \n \n \n \n \n \n (('0123456789abc',''),'eacOpB7vE7ZDukSF'),\n (('0123456789abc','36'),'FRV9JG18UBEgX0.O'),\n (('0123456789abc','365'),'NIwkusG9hmmMy6ZQ'),\n (('0123456789abc','3333'),'NmrkP98nT7RAeKZz'),\n (('0123456789abc','3636'),'FRV9JG18UBEgX0.O'),\n (('0123456789abc','3653'),'NIwkusG9hmmMy6ZQ'),\n (('0123456789abc','user'),'8Q/FZeam5ai1A47p'),\n (('0123456789abc','user1234'),'8Q/FZeam5ai1A47p'),\n \n \n (('0123456789abcd',''),'6r8888iMxEoPdLp4'),\n (('0123456789abcd','3'),'yxGoujXKPduTVaYB'),\n (('0123456789abcd','36'),'W0jckhnhjnr/DiT/'),\n (('0123456789abcd','365'),'HuVOxfMQNahaoF8u'),\n (('0123456789abcd','3333'),'yxGoujXKPduTVaYB'),\n (('0123456789abcd','3636'),'W0jckhnhjnr/DiT/'),\n (('0123456789abcd','3653'),'HuVOxfMQNahaoF8u'),\n (('0123456789abcd','adm'),'RtOmSeoCs4AUdZqZ'),\n (('0123456789abcd','adma'),'RtOmSeoCs4AUdZqZ'),\n (('0123456789abcd','user'),'rrucwrcM0h25pr.m'),\n (('0123456789abcd','user1234'),'rrucwrcM0h25pr.m'),\n \n \n (('0123456789abcde',''),'al1e0XFIugTYLai3'),\n (('0123456789abcde','3'),'nAZrQoHaL.fgrIqt'),\n (('0123456789abcde','36'),'2GxIQ6ICE795587X'),\n (('0123456789abcde','365'),'QmDsGwCRBbtGEKqM'),\n (('0123456789abcde','3333'),'nAZrQoHaL.fgrIqt'),\n (('0123456789abcde','3636'),'2GxIQ6ICE795587X'),\n (('0123456789abcde','3653'),'QmDsGwCRBbtGEKqM'),\n (('0123456789abcde','adm'),'Aj2aP0d.nk62wl4m'),\n (('0123456789abcde','adma'),'Aj2aP0d.nk62wl4m'),\n (('0123456789abcde','user'),'etxiXfo.bINJcXI7'),\n (('0123456789abcde','user1234'),'etxiXfo.bINJcXI7'),\n \n \n (('0123456789abcdef',''),'.7nfVBEIEu4KbF/1'),\n (('0123456789abcdef','36'),'GhI8.yFSC5lwoafg'),\n (('0123456789abcdef','365'),'KFBI6cNQauyY6h/G'),\n (('0123456789abcdef','3333'),'Ghdi1IlsswgYzzMH'),\n (('0123456789abcdef','3636'),'GhI8.yFSC5lwoafg'),\n (('0123456789abcdef','3653'),'KFBI6cNQauyY6h/G'),\n (('0123456789abcdef','user'),'IneB.wc9sfRzLPoh'),\n (('0123456789abcdef','user1234'),'IneB.wc9sfRzLPoh'),\n \n \n \n \n \n (('0123456789abcdefq',''),'bKshl.EN.X3CVFRQ'),\n (('0123456789abcdefq','36'),'JAeTXHs0n30svlaG'),\n (('0123456789abcdefq','365'),'4fKSSUBHT1ChGqHp'),\n (('0123456789abcdefq','3333'),'USEJbxI6.VY4ecBP'),\n (('0123456789abcdefq','3636'),'JAeTXHs0n30svlaG'),\n (('0123456789abcdefq','3653'),'4fKSSUBHT1ChGqHp'),\n (('0123456789abcdefq','user'),'/dwqyD7nGdwSrDwk'),\n (('0123456789abcdefq','user1234'),'/dwqyD7nGdwSrDwk'),\n \n \n (('0123456789abcdefqwertyuiopa',''),'4wp19zS3OCe.2jt5'),\n (('0123456789abcdefqwertyuiopa','36'),'PjUoGqWBKPyV9qOe'),\n (('0123456789abcdefqwertyuiopa','365'),'bfCy6xFAe5O/gzvM'),\n (('0123456789abcdefqwertyuiopa','3333'),'rd/ZMuGTJFIb2BNG'),\n (('0123456789abcdefqwertyuiopa','3636'),'PjUoGqWBKPyV9qOe'),\n (('0123456789abcdefqwertyuiopa','3653'),'bfCy6xFAe5O/gzvM'),\n (('0123456789abcdefqwertyuiopa','user'),'zynfWw3UtszxLMgL'),\n (('0123456789abcdefqwertyuiopa','user1234'),'zynfWw3UtszxLMgL'),\n \n \n \n \n (('0123456789abcdefqwertyuiopas',''),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','36'),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','365'),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','user'),'W6nbOddI0SutTK7m'),\n (('0123456789abcdefqwertyuiopas','user1234'),'W6nbOddI0SutTK7m'),\n \n \n \n (('0123456789abcdefqwertyuiopasdfgh',''),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','36'),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','365'),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','user'),'5hPT/iC6DnoBxo6a'),\n (('0123456789abcdefqwertyuiopasdfgh','user1234'),'5hPT/iC6DnoBxo6a'),\n ]\n \n \n \n \n \nclass cisco_type7_test(HandlerCase):\n handler=hash.cisco_type7\n salt_bits=4\n salt_type=int\n \n known_correct_hashes=[\n \n \n \n (\"secure \",\"04480E051A33490E\"),\n \n \n \n \n (\"Its time to go to lunch!\",\n \"153B1F1F443E22292D73212D5300194315591954465A0D0B59\"),\n \n \n \n \n (\"t35t:pa55w0rd\",\"08351F1B1D431516475E1B54382F\"),\n \n \n \n \n (\"hiImTesting:)\",\"020E0D7206320A325847071E5F5E\"),\n \n \n \n \n (\"cisco123\",\"060506324F41584B56\"),\n (\"cisco123\",\"1511021F07257A767B\"),\n \n \n \n \n ('Supe&8ZUbeRp4SS',\"06351A3149085123301517391C501918\"),\n \n \n \n \n \n \n (UPASS_TABLE,'0958EDC8A9F495F6F8A5FD'),\n ]\n \n known_unidentified_hashes=[\n \n \"0A480E051A33490E\",\n \n \n \n '99400E4812',\n ]\n \n def test_90_decode(self):\n  ''\n  from passlib.utils import to_unicode,to_bytes\n  \n  handler=self.handler\n  for secret,hash in self.known_correct_hashes:\n   usecret=to_unicode(secret)\n   bsecret=to_bytes(secret)\n   self.assertEqual(handler.decode(hash),usecret)\n   self.assertEqual(handler.decode(hash,None ),bsecret)\n   \n  self.assertRaises(UnicodeDecodeError,handler.decode,\n  '0958EDC8A9F495F6F8A5FD','ascii')\n  \n def test_91_salt(self):\n  ''\n  handler=self.handler\n  self.assertRaises(TypeError,handler,salt=None )\n  handler(salt=None ,use_defaults=True )\n  self.assertRaises(TypeError,handler,salt='abc')\n  self.assertRaises(ValueError,handler,salt=-10)\n  self.assertRaises(ValueError,handler,salt=100)\n  \n  self.assertRaises(TypeError,handler.using,salt='abc')\n  self.assertRaises(ValueError,handler.using,salt=-10)\n  self.assertRaises(ValueError,handler.using,salt=100)\n  with self.assertWarningList(\"salt/offset must be.*\"):\n   subcls=handler.using(salt=100,relaxed=True )\n  self.assertEqual(subcls(use_defaults=True ).salt,52)\n  \n  \n  \n  \n", ["__future__", "logging", "passlib", "passlib.Lib.site-packages.passlib.tests.test_handlers", "passlib.Lib.site-packages.passlib.tests.utils", "passlib.utils", "passlib.utils.compat"]], "passlib.Lib.site-packages.passlib.tests.test_utils_handlers": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport re\nimport hashlib\nfrom logging import getLogger\nimport warnings\n\n\nfrom passlib.hash import ldap_md5,sha256_crypt\nfrom passlib.exc import MissingBackendError,PasslibHashWarning\nfrom passlib.utils.compat import str_to_uascii,\\\nuascii_to_str,unicode\nimport passlib.utils.handlers as uh\nfrom passlib.tests.utils import HandlerCase,TestCase\nfrom passlib.utils.compat import u\n\nlog=getLogger(__name__)\n\n\n\n\ndef _makelang(alphabet,size):\n ''\n def helper(size):\n  if size <2:\n   for char in alphabet:\n    yield char\n  else :\n   for char in alphabet:\n    for tail in helper(size -1):\n     yield char+tail\n return set(helper(size))\n \n \n \n \nclass SkeletonTest(TestCase):\n ''\n \n \n \n \n def test_00_static_handler(self):\n  ''\n  \n  class d1(uh.StaticHandler):\n   name=\"d1\"\n   context_kwds=(\"flag\",)\n   _hash_prefix=u(\"_\")\n   checksum_chars=u(\"ab\")\n   checksum_size=1\n   \n   def __init__(self,flag=False ,**kwds):\n    super(d1,self).__init__(**kwds)\n    self.flag=flag\n    \n   def _calc_checksum(self,secret):\n    return u('b')if self.flag else u('a')\n    \n    \n  self.assertTrue(d1.identify(u('_a')))\n  self.assertTrue(d1.identify(b'_a'))\n  self.assertTrue(d1.identify(u('_b')))\n  \n  self.assertFalse(d1.identify(u('_c')))\n  self.assertFalse(d1.identify(b'_c'))\n  self.assertFalse(d1.identify(u('a')))\n  self.assertFalse(d1.identify(u('b')))\n  self.assertFalse(d1.identify(u('c')))\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  \n  \n  self.assertEqual(d1.genconfig(),d1.hash(\"\"))\n  \n  \n  self.assertTrue(d1.verify('s',b'_a'))\n  self.assertTrue(d1.verify('s',u('_a')))\n  self.assertFalse(d1.verify('s',b'_b'))\n  self.assertFalse(d1.verify('s',u('_b')))\n  self.assertTrue(d1.verify('s',b'_b',flag=True ))\n  self.assertRaises(ValueError,d1.verify,'s',b'_c')\n  self.assertRaises(ValueError,d1.verify,'s',u('_c'))\n  \n  \n  self.assertEqual(d1.hash('s'),'_a')\n  self.assertEqual(d1.hash('s',flag=True ),'_b')\n  \n def test_01_calc_checksum_hack(self):\n  ''\n  \n  \n  \n  \n  class d1(uh.StaticHandler):\n   name=\"d1\"\n   \n   @classmethod\n   def identify(cls,hash):\n    if not hash or len(hash)!=40:\n     return False\n    try :\n     int(hash,16)\n    except ValueError:\n     return False\n    return True\n    \n   @classmethod\n   def genhash(cls,secret,hash):\n    if secret is None :\n     raise TypeError(\"no secret provided\")\n    if isinstance(secret,unicode):\n     secret=secret.encode(\"utf-8\")\n     \n    if hash is not None and not cls.identify(hash):\n     raise ValueError(\"invalid hash\")\n    return hashlib.sha1(b\"xyz\"+secret).hexdigest()\n    \n   @classmethod\n   def verify(cls,secret,hash):\n    if hash is None :\n     raise ValueError(\"no hash specified\")\n    return cls.genhash(secret,hash)==hash.lower()\n    \n    \n  with self.assertWarningList(\"d1.*should be updated.*_calc_checksum\"):\n   hash=d1.hash(\"test\")\n  self.assertEqual(hash,'7c622762588a0e5cc786ad0a143156f9fd38eea3')\n  \n  self.assertTrue(d1.verify(\"test\",hash))\n  self.assertFalse(d1.verify(\"xtest\",hash))\n  \n  \n  del d1.genhash\n  self.assertRaises(NotImplementedError,d1.hash,'test')\n  \n  \n  \n  \n def test_10_identify(self):\n  ''\n  class d1(uh.GenericHandler):\n   @classmethod\n   def from_string(cls,hash):\n    if isinstance(hash,bytes):\n     hash=hash.decode(\"ascii\")\n    if hash ==u('a'):\n     return cls(checksum=hash)\n    else :\n     raise ValueError\n     \n     \n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  self.assertFalse(d1.identify(''))\n  self.assertTrue(d1.identify('a'))\n  self.assertFalse(d1.identify('b'))\n  \n  \n  d1._hash_regex=re.compile(u('@.'))\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  self.assertTrue(d1.identify('@a'))\n  self.assertFalse(d1.identify('a'))\n  del d1._hash_regex\n  \n  \n  d1.ident=u('!')\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  self.assertTrue(d1.identify('!a'))\n  self.assertFalse(d1.identify('a'))\n  del d1.ident\n  \n def test_11_norm_checksum(self):\n  ''\n  \n  class d1(uh.GenericHandler):\n   name='d1'\n   checksum_size=4\n   checksum_chars=u('xz')\n   \n  def norm_checksum(checksum=None ,**k):\n   return d1(checksum=checksum,**k).checksum\n   \n   \n  self.assertRaises(ValueError,norm_checksum,u('xxx'))\n  \n  \n  self.assertEqual(norm_checksum(u('xxxx')),u('xxxx'))\n  self.assertEqual(norm_checksum(u('xzxz')),u('xzxz'))\n  \n  \n  self.assertRaises(ValueError,norm_checksum,u('xxxxx'))\n  \n  \n  self.assertRaises(ValueError,norm_checksum,u('xxyx'))\n  \n  \n  self.assertRaises(TypeError,norm_checksum,b'xxyx')\n  \n  \n  \n  \n  \n  \n  \n  \n  self.assertEqual(d1()._stub_checksum,u('xxxx'))\n  \n def test_12_norm_checksum_raw(self):\n  ''\n  class d1(uh.HasRawChecksum,uh.GenericHandler):\n   name='d1'\n   checksum_size=4\n   \n  def norm_checksum(*a,**k):\n   return d1(*a,**k).checksum\n   \n   \n  self.assertEqual(norm_checksum(b'1234'),b'1234')\n  \n  \n  self.assertRaises(TypeError,norm_checksum,u('xxyx'))\n  \n  \n  \n  \n  \n  self.assertEqual(d1()._stub_checksum,b'\\x00'*4)\n  \n def test_20_norm_salt(self):\n  ''\n  \n  class d1(uh.HasSalt,uh.GenericHandler):\n   name='d1'\n   setting_kwds=('salt',)\n   min_salt_size=2\n   max_salt_size=4\n   default_salt_size=3\n   salt_chars='ab'\n   \n  def norm_salt(**k):\n   return d1(**k).salt\n   \n  def gen_salt(sz,**k):\n   return d1.using(salt_size=sz,**k)(use_defaults=True ).salt\n   \n  salts2=_makelang('ab',2)\n  salts3=_makelang('ab',3)\n  salts4=_makelang('ab',4)\n  \n  \n  self.assertRaises(TypeError,norm_salt)\n  self.assertRaises(TypeError,norm_salt,salt=None )\n  self.assertIn(norm_salt(use_defaults=True ),salts3)\n  \n  \n  with warnings.catch_warnings(record=True )as wlog:\n  \n  \n   self.assertRaises(ValueError,norm_salt,salt='')\n   self.assertRaises(ValueError,norm_salt,salt='a')\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertEqual(norm_salt(salt='ab'),'ab')\n   self.assertEqual(norm_salt(salt='aba'),'aba')\n   self.assertEqual(norm_salt(salt='abba'),'abba')\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertRaises(ValueError,norm_salt,salt='aaaabb')\n   self.consumeWarningList(wlog)\n   \n   \n  with warnings.catch_warnings(record=True )as wlog:\n  \n  \n   self.assertRaises(ValueError,gen_salt,0)\n   self.assertRaises(ValueError,gen_salt,1)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertIn(gen_salt(2),salts2)\n   self.assertIn(gen_salt(3),salts3)\n   self.assertIn(gen_salt(4),salts4)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertRaises(ValueError,gen_salt,5)\n   self.consumeWarningList(wlog)\n   \n   self.assertIn(gen_salt(5,relaxed=True ),salts4)\n   self.consumeWarningList(wlog,[\"salt_size.*above max_salt_size\"])\n   \n   \n  del d1.max_salt_size\n  with self.assertWarningList([]):\n   self.assertEqual(len(gen_salt(None )),3)\n   self.assertEqual(len(gen_salt(5)),5)\n   \n   \n   \n def test_30_init_rounds(self):\n  ''\n  \n  class d1(uh.HasRounds,uh.GenericHandler):\n   name='d1'\n   setting_kwds=('rounds',)\n   min_rounds=1\n   max_rounds=3\n   default_rounds=2\n   \n   \n  def norm_rounds(**k):\n   return d1(**k).rounds\n   \n   \n  self.assertRaises(TypeError,norm_rounds)\n  self.assertRaises(TypeError,norm_rounds,rounds=None )\n  self.assertEqual(norm_rounds(use_defaults=True ),2)\n  \n  \n  self.assertRaises(TypeError,norm_rounds,rounds=1.5)\n  \n  \n  with warnings.catch_warnings(record=True )as wlog:\n  \n   self.assertRaises(ValueError,norm_rounds,rounds=0)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertEqual(norm_rounds(rounds=1),1)\n   self.assertEqual(norm_rounds(rounds=2),2)\n   self.assertEqual(norm_rounds(rounds=3),3)\n   self.consumeWarningList(wlog)\n   \n   \n   self.assertRaises(ValueError,norm_rounds,rounds=4)\n   self.consumeWarningList(wlog)\n   \n   \n  d1.default_rounds=None\n  self.assertRaises(TypeError,norm_rounds,use_defaults=True )\n  \n def test_40_backends(self):\n  ''\n  class d1(uh.HasManyBackends,uh.GenericHandler):\n   name='d1'\n   setting_kwds=()\n   \n   backends=(\"a\",\"b\")\n   \n   _enable_a=False\n   _enable_b=False\n   \n   @classmethod\n   def _load_backend_a(cls):\n    if cls._enable_a:\n     cls._set_calc_checksum_backend(cls._calc_checksum_a)\n     return True\n    else :\n     return False\n     \n   @classmethod\n   def _load_backend_b(cls):\n    if cls._enable_b:\n     cls._set_calc_checksum_backend(cls._calc_checksum_b)\n     return True\n    else :\n     return False\n     \n   def _calc_checksum_a(self,secret):\n    return 'a'\n    \n   def _calc_checksum_b(self,secret):\n    return 'b'\n    \n    \n  self.assertRaises(MissingBackendError,d1.get_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend,'any')\n  self.assertRaises(MissingBackendError,d1.set_backend,'default')\n  self.assertFalse(d1.has_backend())\n  \n  \n  d1._enable_b=True\n  \n  \n  obj=d1()\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  d1.set_backend('b')\n  d1.set_backend('any')\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  self.assertRaises(MissingBackendError,d1.set_backend,'a')\n  self.assertTrue(d1.has_backend('b'))\n  self.assertFalse(d1.has_backend('a'))\n  \n  \n  d1._enable_a=True\n  \n  \n  self.assertTrue(d1.has_backend())\n  d1.set_backend('a')\n  self.assertEqual(obj._calc_checksum('s'),'a')\n  \n  \n  self.assertRaises(ValueError,d1.set_backend,'c')\n  self.assertRaises(ValueError,d1.has_backend,'c')\n  \n  \n  d1.set_backend(\"b\")\n  class d2(d1):\n   _has_backend_a=True\n  self.assertRaises(AssertionError,d2.has_backend,\"a\")\n  \n def test_41_backends(self):\n  ''\n  warnings.filterwarnings(\"ignore\",\n  category=DeprecationWarning,\n  message=r\".* support for \\._has_backend_.* is deprecated.*\",\n  )\n  \n  class d1(uh.HasManyBackends,uh.GenericHandler):\n   name='d1'\n   setting_kwds=()\n   \n   backends=(\"a\",\"b\")\n   \n   _has_backend_a=False\n   _has_backend_b=False\n   \n   def _calc_checksum_a(self,secret):\n    return 'a'\n    \n   def _calc_checksum_b(self,secret):\n    return 'b'\n    \n    \n  self.assertRaises(MissingBackendError,d1.get_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend)\n  self.assertRaises(MissingBackendError,d1.set_backend,'any')\n  self.assertRaises(MissingBackendError,d1.set_backend,'default')\n  self.assertFalse(d1.has_backend())\n  \n  \n  d1._has_backend_b=True\n  \n  \n  obj=d1()\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  d1.set_backend('b')\n  d1.set_backend('any')\n  self.assertEqual(obj._calc_checksum('s'),'b')\n  \n  \n  self.assertRaises(MissingBackendError,d1.set_backend,'a')\n  self.assertTrue(d1.has_backend('b'))\n  self.assertFalse(d1.has_backend('a'))\n  \n  \n  d1._has_backend_a=True\n  \n  \n  self.assertTrue(d1.has_backend())\n  d1.set_backend('a')\n  self.assertEqual(obj._calc_checksum('s'),'a')\n  \n  \n  self.assertRaises(ValueError,d1.set_backend,'c')\n  self.assertRaises(ValueError,d1.has_backend,'c')\n  \n def test_50_norm_ident(self):\n  ''\n  \n  class d1(uh.HasManyIdents,uh.GenericHandler):\n   name='d1'\n   setting_kwds=('ident',)\n   default_ident=u(\"!A\")\n   ident_values=(u(\"!A\"),u(\"!B\"))\n   ident_aliases={u(\"A\"):u(\"!A\")}\n   \n  def norm_ident(**k):\n   return d1(**k).ident\n   \n   \n  self.assertRaises(TypeError,norm_ident)\n  self.assertRaises(TypeError,norm_ident,ident=None )\n  self.assertEqual(norm_ident(use_defaults=True ),u('!A'))\n  \n  \n  self.assertEqual(norm_ident(ident=u('!A')),u('!A'))\n  self.assertEqual(norm_ident(ident=u('!B')),u('!B'))\n  self.assertRaises(ValueError,norm_ident,ident=u('!C'))\n  \n  \n  self.assertEqual(norm_ident(ident=u('A')),u('!A'))\n  \n  \n  self.assertRaises(ValueError,norm_ident,ident=u('B'))\n  \n  \n  self.assertTrue(d1.identify(u(\"!Axxx\")))\n  self.assertTrue(d1.identify(u(\"!Bxxx\")))\n  self.assertFalse(d1.identify(u(\"!Cxxx\")))\n  self.assertFalse(d1.identify(u(\"A\")))\n  self.assertFalse(d1.identify(u(\"\")))\n  self.assertRaises(TypeError,d1.identify,None )\n  self.assertRaises(TypeError,d1.identify,1)\n  \n  \n  d1.default_ident=None\n  self.assertRaises(AssertionError,norm_ident,use_defaults=True )\n  \n  \n  \n  \n  \n def test_91_parsehash(self):\n  ''\n  \n  from passlib import hash\n  \n  \n  \n  \n  \n  \n  result=hash.des_crypt.parsehash(\"OgAwTx2l6NADI\")\n  self.assertEqual(result,{'checksum':u('AwTx2l6NADI'),'salt':u('Og')})\n  \n  \n  h='$5$LKO/Ute40T3FNF95$U0prpBQd4PloSGU0pnpM4z9wKn4vZ1.jsrzQfPqxph9'\n  s=u('LKO/Ute40T3FNF95')\n  c=u('U0prpBQd4PloSGU0pnpM4z9wKn4vZ1.jsrzQfPqxph9')\n  result=hash.sha256_crypt.parsehash(h)\n  self.assertEqual(result,dict(salt=s,rounds=5000,\n  implicit_rounds=True ,checksum=c))\n  \n  \n  result=hash.sha256_crypt.parsehash(h,checksum=False )\n  self.assertEqual(result,dict(salt=s,rounds=5000,implicit_rounds=True ))\n  \n  \n  result=hash.sha256_crypt.parsehash(h,sanitize=True )\n  self.assertEqual(result,dict(rounds=5000,implicit_rounds=True ,\n  salt=u('LK**************'),\n  checksum=u('U0pr***************************************')))\n  \n  \n  result=hash.sha256_crypt.parsehash('$5$rounds=10428$uy/jIAhCetNCTtb0$YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3')\n  self.assertEqual(result,dict(\n  checksum=u('YWvUOXbkqlqhyoPMpN8BMe.ZGsGx2aBvxTvDFI613c3'),\n  salt=u('uy/jIAhCetNCTtb0'),\n  rounds=10428,\n  ))\n  \n  \n  h1='$pbkdf2$60000$DoEwpvQeA8B4T.k951yLUQ$O26Y3/NJEiLCVaOVPxGXshyjW8k'\n  result=hash.pbkdf2_sha1.parsehash(h1)\n  self.assertEqual(result,dict(\n  checksum=b';n\\x98\\xdf\\xf3I\\x12\"\\xc2U\\xa3\\x95?\\x11\\x97\\xb2\\x1c\\xa3[\\xc9',\n  rounds=60000,\n  salt=b'\\x0e\\x810\\xa6\\xf4\\x1e\\x03\\xc0xO\\xe9=\\xe7\\\\\\x8bQ',\n  ))\n  \n  \n  result=hash.pbkdf2_sha1.parsehash(h1,sanitize=True )\n  self.assertEqual(result,dict(\n  checksum=u('O26************************'),\n  rounds=60000,\n  salt=u('Do********************'),\n  ))\n  \n def test_92_bitsize(self):\n  ''\n  \n  from passlib import hash\n  \n  \n  self.assertEqual(hash.des_crypt.bitsize(),\n  {'checksum':66,'salt':12})\n  \n  \n  self.assertEqual(hash.bcrypt.bitsize(),\n  {'checksum':186,'salt':132})\n  \n  \n  \n  \n  self.patchAttr(hash.sha256_crypt,\"default_rounds\",1 <<(14+3))\n  self.assertEqual(hash.sha256_crypt.bitsize(),\n  {'checksum':258,'rounds':14,'salt':96})\n  \n  \n  self.patchAttr(hash.pbkdf2_sha1,\"default_rounds\",1 <<(13+3))\n  self.assertEqual(hash.pbkdf2_sha1.bitsize(),\n  {'checksum':160,'rounds':13,'salt':128})\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass dummy_handler_in_registry(object):\n ''\n def __init__(self,name):\n  self.name=name\n  self.dummy=type('dummy_'+name,(uh.GenericHandler,),dict(\n  name=name,\n  setting_kwds=(),\n  ))\n  \n def __enter__(self):\n  from passlib import registry\n  registry._unload_handler_name(self.name,locations=False )\n  registry.register_crypt_handler(self.dummy)\n  assert registry.get_crypt_handler(self.name)is self.dummy\n  return self.dummy\n  \n def __exit__(self,*exc_info):\n  from passlib import registry\n  registry._unload_handler_name(self.name,locations=False )\n  \nclass PrefixWrapperTest(TestCase):\n ''\n \n def test_00_lazy_loading(self):\n  ''\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\",lazy=True )\n  \n  \n  self.assertEqual(d1._wrapped_name,\"ldap_md5\")\n  self.assertIs(d1._wrapped_handler,None )\n  \n  \n  self.assertIs(d1.wrapped,ldap_md5)\n  self.assertIs(d1._wrapped_handler,ldap_md5)\n  \n  \n  with dummy_handler_in_registry(\"ldap_md5\")as dummy:\n   self.assertIs(d1.wrapped,ldap_md5)\n   \n def test_01_active_loading(self):\n  ''\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  \n  \n  self.assertEqual(d1._wrapped_name,\"ldap_md5\")\n  self.assertIs(d1._wrapped_handler,ldap_md5)\n  self.assertIs(d1.wrapped,ldap_md5)\n  \n  \n  with dummy_handler_in_registry(\"ldap_md5\")as dummy:\n   self.assertIs(d1.wrapped,ldap_md5)\n   \n def test_02_explicit(self):\n  ''\n  \n  d1=uh.PrefixWrapper(\"d1\",ldap_md5,\"{XXX}\",\"{MD5}\")\n  \n  \n  self.assertEqual(d1._wrapped_name,None )\n  self.assertIs(d1._wrapped_handler,ldap_md5)\n  self.assertIs(d1.wrapped,ldap_md5)\n  \n  \n  with dummy_handler_in_registry(\"ldap_md5\")as dummy:\n   self.assertIs(d1.wrapped,ldap_md5)\n   \n def test_10_wrapped_attributes(self):\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  self.assertEqual(d1.name,\"d1\")\n  self.assertIs(d1.setting_kwds,ldap_md5.setting_kwds)\n  self.assertFalse('max_rounds'in dir(d1))\n  \n  d2=uh.PrefixWrapper(\"d2\",\"sha256_crypt\",\"{XXX}\")\n  self.assertIs(d2.setting_kwds,sha256_crypt.setting_kwds)\n  self.assertTrue('max_rounds'in dir(d2))\n  \n def test_11_wrapped_methods(self):\n  d1=uh.PrefixWrapper(\"d1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  dph=\"{XXX}X03MO1qnZdYdgyfeuILPmQ==\"\n  lph=\"{MD5}X03MO1qnZdYdgyfeuILPmQ==\"\n  \n  \n  self.assertEqual(d1.genconfig(),'{XXX}1B2M2Y8AsgTpgAmY7PhCfg==')\n  \n  \n  self.assertRaises(TypeError,d1.genhash,\"password\",None )\n  self.assertEqual(d1.genhash(\"password\",dph),dph)\n  self.assertRaises(ValueError,d1.genhash,\"password\",lph)\n  \n  \n  self.assertEqual(d1.hash(\"password\"),dph)\n  \n  \n  self.assertTrue(d1.identify(dph))\n  self.assertFalse(d1.identify(lph))\n  \n  \n  self.assertRaises(ValueError,d1.verify,\"password\",lph)\n  self.assertTrue(d1.verify(\"password\",dph))\n  \n def test_12_ident(self):\n \n  h=uh.PrefixWrapper(\"h2\",\"ldap_md5\",\"{XXX}\")\n  self.assertEqual(h.ident,u(\"{XXX}{MD5}\"))\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h2\",\"des_crypt\",\"{XXX}\")\n  self.assertIs(h.ident,None )\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h1\",\"ldap_md5\",\"{XXX}\",\"{MD5}\")\n  self.assertIs(h.ident,None )\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h3\",\"ldap_md5\",\"{XXX}\",ident=\"{X\")\n  self.assertEqual(h.ident,u(\"{X\"))\n  self.assertIs(h.ident_values,None )\n  \n  \n  h=uh.PrefixWrapper(\"h3\",\"ldap_md5\",\"{XXX}\",ident=\"{XXX}A\")\n  self.assertRaises(ValueError,uh.PrefixWrapper,\"h3\",\"ldap_md5\",\n  \"{XXX}\",ident=\"{XY\")\n  self.assertRaises(ValueError,uh.PrefixWrapper,\"h3\",\"ldap_md5\",\n  \"{XXX}\",ident=\"{XXXX\")\n  \n  \n  h=uh.PrefixWrapper(\"h4\",\"phpass\",\"{XXX}\")\n  self.assertIs(h.ident,None )\n  self.assertEqual(h.ident_values,(u(\"{XXX}$P$\"),u(\"{XXX}$H$\")))\n  \n  \n  h=uh.PrefixWrapper(\"h5\",\"des_crypt\",\"{XXX}\",ident=True )\n  self.assertEqual(h.ident,u(\"{XXX}\"))\n  self.assertIs(h.ident_values,None )\n  \n  \n  self.assertRaises(ValueError,uh.PrefixWrapper,\"h6\",\"des_crypt\",ident=True )\n  \n  \n  with self.assertWarningList(\"orig_prefix.*may not work correctly\"):\n   h=uh.PrefixWrapper(\"h7\",\"phpass\",orig_prefix=\"$\",prefix=\"?\")\n  self.assertEqual(h.ident_values,None )\n  self.assertEqual(h.ident,None )\n  \n def test_13_repr(self):\n  ''\n  h=uh.PrefixWrapper(\"h2\",\"md5_crypt\",\"{XXX}\",orig_prefix=\"$1$\")\n  self.assertRegex(repr(h),\n  r\"\"\"(?x)^PrefixWrapper\\(\n                ['\"]h2['\"],\\s+\n                ['\"]md5_crypt['\"],\\s+\n                prefix=u?[\"']{XXX}['\"],\\s+\n                orig_prefix=u?[\"']\\$1\\$['\"]\n            \\)$\"\"\")\n  \n def test_14_bad_hash(self):\n  ''\n  \n  \n  h=uh.PrefixWrapper(\"h2\",\"md5_crypt\",orig_prefix=\"$6$\")\n  self.assertRaises(ValueError,h.hash,'test')\n  \n  \n  \n  \n  \n  \nclass UnsaltedHash(uh.StaticHandler):\n ''\n name=\"unsalted_test_hash\"\n checksum_chars=uh.LOWER_HEX_CHARS\n checksum_size=40\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  data=b\"boblious\"+secret\n  return str_to_uascii(hashlib.sha1(data).hexdigest())\n  \nclass SaltedHash(uh.HasSalt,uh.GenericHandler):\n ''\n name=\"salted_test_hash\"\n setting_kwds=(\"salt\",)\n \n min_salt_size=2\n max_salt_size=4\n checksum_size=40\n salt_chars=checksum_chars=uh.LOWER_HEX_CHARS\n \n _hash_regex=re.compile(u(\"^@salt[0-9a-f]{42,44}$\"))\n \n @classmethod\n def from_string(cls,hash):\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  return cls(salt=hash[5:-40],checksum=hash[-40:])\n  \n def to_string(self):\n  hash=u(\"@salt%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  data=self.salt.encode(\"ascii\")+secret+self.salt.encode(\"ascii\")\n  return str_to_uascii(hashlib.sha1(data).hexdigest())\n  \n  \n  \n  \n  \n  \n  \n  \nUPASS_TEMP=u('\\u0399\\u03c9\\u03b1\\u03bd\\u03bd\\u03b7\\u03c2')\n\nclass UnsaltedHashTest(HandlerCase):\n handler=UnsaltedHash\n \n known_correct_hashes=[\n (\"password\",\"61cfd32684c47de231f1f982c214e884133762c0\"),\n (UPASS_TEMP,'96b329d120b97ff81ada770042e44ba87343ad2b'),\n ]\n \n def test_bad_kwds(self):\n  self.assertRaises(TypeError,UnsaltedHash,salt='x')\n  self.assertRaises(TypeError,UnsaltedHash.genconfig,rounds=1)\n  \nclass SaltedHashTest(HandlerCase):\n handler=SaltedHash\n \n known_correct_hashes=[\n (\"password\",'@salt77d71f8fe74f314dac946766c1ac4a2a58365482c0'),\n (UPASS_TEMP,'@salt9f978a9bfe360d069b0c13f2afecd570447407fa7e48'),\n ]\n \n def test_bad_kwds(self):\n  stub=SaltedHash(use_defaults=True )._stub_checksum\n  self.assertRaises(TypeError,SaltedHash,checksum=stub,salt=None )\n  self.assertRaises(ValueError,SaltedHash,checksum=stub,salt='xxx')\n  \n  \n  \n  \n", ["__future__", "hashlib", "logging", "passlib", "passlib.exc", "passlib.hash", "passlib.tests.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.Lib.site-packages.passlib.tests.test_hosts": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib import hosts,hash as hashmod\nfrom passlib.utils import unix_crypt_schemes\nfrom passlib.tests.utils import TestCase\n\n\n\n\n\nclass HostsTest(TestCase):\n ''\n \n \n \n \n \n \n \n def check_unix_disabled(self,ctx):\n  for hash in [\n  \"\",\n  \"!\",\n  \"*\",\n  \"!$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0\",\n  ]:\n   self.assertEqual(ctx.identify(hash),'unix_disabled')\n   self.assertFalse(ctx.verify('test',hash))\n   \n def test_linux_context(self):\n  ctx=hosts.linux_context\n  for hash in [\n  ('$6$rounds=41128$VoQLvDjkaZ6L6BIE$4pt.1Ll1XdDYduEwEYPCMOBiR6W6'\n  'znsyUEoNlcVXpv2gKKIbQolgmTGe6uEEVJ7azUxuc8Tf7zV9SD2z7Ij751'),\n  ('$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0itGny'\n  'xDGgMlDcOsfaI17'),\n  '$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0',\n  'kAJJz.Rwp0A/I',\n  ]:\n   self.assertTrue(ctx.verify(\"test\",hash))\n  self.check_unix_disabled(ctx)\n  \n def test_bsd_contexts(self):\n  for ctx in [\n  hosts.freebsd_context,\n  hosts.openbsd_context,\n  hosts.netbsd_context,\n  ]:\n   for hash in [\n   '$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0',\n   'kAJJz.Rwp0A/I',\n   ]:\n    self.assertTrue(ctx.verify(\"test\",hash))\n   h1=\"$2a$04$yjDgE74RJkeqC0/1NheSSOrvKeu9IbKDpcQf/Ox3qsrRS/Kw42qIS\"\n   if hashmod.bcrypt.has_backend():\n    self.assertTrue(ctx.verify(\"test\",h1))\n   else :\n    self.assertEqual(ctx.identify(h1),\"bcrypt\")\n   self.check_unix_disabled(ctx)\n   \n def test_host_context(self):\n  ctx=getattr(hosts,\"host_context\",None )\n  if not ctx:\n   return self.skipTest(\"host_context not available on this platform\")\n   \n   \n   \n  schemes=list(ctx.schemes())\n  self.assertTrue(schemes,\"appears to be unix system, but no known schemes supported by crypt\")\n  self.assertTrue('unix_disabled'in schemes)\n  schemes.remove(\"unix_disabled\")\n  self.assertTrue(schemes,\"should have schemes beside fallback scheme\")\n  self.assertTrue(set(unix_crypt_schemes).issuperset(schemes))\n  \n  \n  self.check_unix_disabled(ctx)\n  for scheme,hash in [\n  (\"sha512_crypt\",('$6$rounds=41128$VoQLvDjkaZ6L6BIE$4pt.1Ll1XdDYduEwEYPCMOBiR6W6'\n  'znsyUEoNlcVXpv2gKKIbQolgmTGe6uEEVJ7azUxuc8Tf7zV9SD2z7Ij751')),\n  (\"sha256_crypt\",('$5$rounds=31817$iZGmlyBQ99JSB5n6$p4E.pdPBWx19OajgjLRiOW0itGny'\n  'xDGgMlDcOsfaI17')),\n  (\"md5_crypt\",'$1$TXl/FX/U$BZge.lr.ux6ekjEjxmzwz0'),\n  (\"des_crypt\",'kAJJz.Rwp0A/I'),\n  ]:\n   if scheme in schemes:\n    self.assertTrue(ctx.verify(\"test\",hash))\n    \n    \n    \n    \n", ["__future__", "logging", "passlib", "passlib.tests.utils", "passlib.utils"]], "passlib.Lib.site-packages.passlib.tests.test_crypto_builtin_md4": [".py", "''\n\n\n\nfrom __future__ import with_statement,division\n\nfrom binascii import hexlify\nimport hashlib\n\n\n\nfrom passlib.utils.compat import bascii_to_str,PY3,u\nfrom passlib.crypto.digest import lookup_hash\nfrom passlib.tests.utils import TestCase,skipUnless\n\n__all__=[\n\"_Common_MD4_Test\",\n\"MD4_Builtin_Test\",\n\"MD4_SSL_Test\",\n]\n\n\n\nclass _Common_MD4_Test(TestCase):\n ''\n \n vectors=[\n \n \n (b\"\",\"31d6cfe0d16ae931b73c59d7e0c089c0\"),\n (b\"a\",\"bde52cb31de33e46245e05fbdbd6fb24\"),\n (b\"abc\",\"a448017aaf21d8525fc10ae87aa6729d\"),\n (b\"message digest\",\"d9130a8164549fe818874806e1c7014b\"),\n (b\"abcdefghijklmnopqrstuvwxyz\",\"d79e1c308aa5bbcdeea8ed63df412da9\"),\n (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\"043f8582f241db351ce627e153e7f0e4\"),\n (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\"e33b4ddc9c38f2199c3e7b164fcc0536\"),\n ]\n \n def get_md4_const(self):\n  ''\n\n\n  \n  return lookup_hash(\"md4\").const\n  \n def test_attrs(self):\n  ''\n  h=self.get_md4_const()()\n  self.assertEqual(h.name,\"md4\")\n  self.assertEqual(h.digest_size,16)\n  self.assertEqual(h.block_size,64)\n  \n def test_md4_update(self):\n  ''\n  md4=self.get_md4_const()\n  h=md4(b'')\n  self.assertEqual(h.hexdigest(),\"31d6cfe0d16ae931b73c59d7e0c089c0\")\n  \n  h.update(b'a')\n  self.assertEqual(h.hexdigest(),\"bde52cb31de33e46245e05fbdbd6fb24\")\n  \n  h.update(b'bcdefghijklmnopqrstuvwxyz')\n  self.assertEqual(h.hexdigest(),\"d79e1c308aa5bbcdeea8ed63df412da9\")\n  \n  if PY3:\n  \n   h=md4()\n   self.assertRaises(TypeError,h.update,u('a'))\n   self.assertEqual(h.hexdigest(),\"31d6cfe0d16ae931b73c59d7e0c089c0\")\n  else :\n  \n   h=md4()\n   h.update(u('a'))\n   self.assertEqual(h.hexdigest(),\"bde52cb31de33e46245e05fbdbd6fb24\")\n   \n def test_md4_hexdigest(self):\n  ''\n  md4=self.get_md4_const()\n  for input,hex in self.vectors:\n   out=md4(input).hexdigest()\n   self.assertEqual(out,hex)\n   \n def test_md4_digest(self):\n  ''\n  md4=self.get_md4_const()\n  for input,hex in self.vectors:\n   out=bascii_to_str(hexlify(md4(input).digest()))\n   self.assertEqual(out,hex)\n   \n def test_md4_copy(self):\n  ''\n  md4=self.get_md4_const()\n  h=md4(b'abc')\n  \n  h2=h.copy()\n  h2.update(b'def')\n  self.assertEqual(h2.hexdigest(),'804e7f1c2586e50b49ac65db5b645131')\n  \n  h.update(b'ghi')\n  self.assertEqual(h.hexdigest(),'c5225580bfe176f6deeee33dee98732c')\n  \n  \n  \n  \n  \n  \ndef has_native_md4():\n ''\n\n \n try :\n  hashlib.new(\"md4\")\n  return True\n except ValueError:\n \n  return False\n  \n  \n@skipUnless(has_native_md4(),\"hashlib lacks ssl/md4 support\")\nclass MD4_SSL_Test(_Common_MD4_Test):\n descriptionPrefix=\"hashlib.new('md4')\"\n \n \n \n \n def setUp(self):\n  super(MD4_SSL_Test,self).setUp()\n  \n  \n  self.assertEqual(self.get_md4_const().__module__,\"hashlib\")\n  \n  \nclass MD4_Builtin_Test(_Common_MD4_Test):\n descriptionPrefix=\"passlib.crypto._md4.md4()\"\n \n def setUp(self):\n  super(MD4_Builtin_Test,self).setUp()\n  \n  if has_native_md4():\n  \n  \n  \n   orig=hashlib.new\n   def wrapper(name,*args):\n    if name ==\"md4\":\n     raise ValueError(\"md4 disabled for testing\")\n    return orig(name,*args)\n   self.patchAttr(hashlib,\"new\",wrapper)\n   \n   \n   lookup_hash.clear_cache()\n   self.addCleanup(lookup_hash.clear_cache)\n   \n   \n  self.assertEqual(self.get_md4_const().__module__,\"passlib.crypto._md4\")\n  \n  \n  \n  \n  \n", ["__future__", "binascii", "hashlib", "passlib.crypto.digest", "passlib.tests.utils", "passlib.utils.compat"]], "passlib.Lib.site-packages.passlib.tests.__main__": [".py", "import os\nfrom nose import run\nrun(\ndefaultTest=os.path.dirname(__file__),\n)\n\n", ["nose", "os"]], "passlib.Lib.site-packages.passlib.tests.test_win32": [".py", "''\n\n\n\n\nimport warnings\n\n\nfrom passlib.tests.utils import TestCase\n\nfrom passlib.utils.compat import u\n\n\n\n\nclass UtilTest(TestCase):\n ''\n \n \n \n \n def setUp(self):\n  super(UtilTest,self).setUp()\n  warnings.filterwarnings(\"ignore\",\n  \"the 'passlib.win32' module is deprecated\")\n  \n def test_lmhash(self):\n  from passlib.win32 import raw_lmhash\n  for secret,hash in [\n  (\"OLDPASSWORD\",u(\"c9b81d939d6fd80cd408e6b105741864\")),\n  (\"NEWPASSWORD\",u('09eeab5aa415d6e4d408e6b105741864')),\n  (\"welcome\",u(\"c23413a8a1e7665faad3b435b51404ee\")),\n  ]:\n   result=raw_lmhash(secret,hex=True )\n   self.assertEqual(result,hash)\n   \n def test_nthash(self):\n  warnings.filterwarnings(\"ignore\",\n  r\"nthash\\.raw_nthash\\(\\) is deprecated\")\n  from passlib.win32 import raw_nthash\n  for secret,hash in [\n  (\"OLDPASSWORD\",u(\"6677b2c394311355b54f25eec5bfacf5\")),\n  (\"NEWPASSWORD\",u(\"256781a62031289d3c2c98c14f1efc8c\")),\n  ]:\n   result=raw_nthash(secret,hex=True )\n   self.assertEqual(result,hash)\n   \n   \n   \n   \n", ["passlib.tests.utils", "passlib.utils.compat", "passlib.win32", "warnings"]], "passlib.Lib.site-packages.passlib.utils.binary": [".py", "''\n\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\nfrom base64 import (\nb64encode,\nb64decode,\nb32decode as _b32decode,\nb32encode as _b32encode,\n)\nfrom binascii import b2a_base64,a2b_base64,Error as _BinAsciiError\nimport logging\nlog=logging.getLogger(__name__)\n\n\nfrom passlib import exc\nfrom passlib.utils.compat import (\nPY3,bascii_to_str,\nirange,imap,iter_byte_chars,join_byte_values,join_byte_elems,\nnextgetter,suppress_cause,\nu,unicode,unicode_or_bytes_types,\n)\nfrom passlib.utils.decor import memoized_property\n\n\n__all__=[\n\n\"BASE64_CHARS\",\"PADDED_BASE64_CHARS\",\n\"AB64_CHARS\",\n\"HASH64_CHARS\",\n\"BCRYPT_CHARS\",\n\"HEX_CHARS\",\"LOWER_HEX_CHARS\",\"UPPER_HEX_CHARS\",\n\n\"ALL_BYTE_VALUES\",\n\n\n\"compile_byte_translation\",\n\n\n'ab64_encode','ab64_decode',\n'b64s_encode','b64s_decode',\n\n\n\"b32encode\",\"b32decode\",\n\n\n'Base64Engine',\n'LazyBase64Engine',\n'h64',\n'h64big',\n'bcrypt64',\n]\n\n\n\n\n\n\n\n\n\n\nBASE64_CHARS=u(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n\n\nAB64_CHARS=u(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789./\")\n\n\nHASH64_CHARS=u(\"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\")\n\n\nBCRYPT_CHARS=u(\"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\")\n\n\nPADDED_BASE64_CHARS=BASE64_CHARS+u(\"=\")\n\n\nHEX_CHARS=u(\"0123456789abcdefABCDEF\")\n\n\nUPPER_HEX_CHARS=u(\"0123456789ABCDEF\")\n\n\nLOWER_HEX_CHARS=u(\"0123456789abcdef\")\n\n\n\n\n\n\n\nALL_BYTE_VALUES=join_byte_values(irange(256))\n\n\nB_EMPTY=b''\nB_NULL=b'\\x00'\nB_EQUAL=b'='\n\n\n\n\n\n\n_TRANSLATE_SOURCE=list(iter_byte_chars(ALL_BYTE_VALUES))\n\ndef compile_byte_translation(mapping,source=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n if source is None :\n  target=_TRANSLATE_SOURCE[:]\n else :\n  assert isinstance(source,bytes)and len(source)==255\n  target=list(iter_byte_chars(source))\n for k,v in mapping.items():\n  if isinstance(k,unicode_or_bytes_types):\n   k=ord(k)\n  assert isinstance(k,int)and 0 <=k <256\n  if isinstance(v,unicode):\n   v=v.encode(\"ascii\")\n  assert isinstance(v,bytes)and len(v)==1\n  target[k]=v\n return B_EMPTY.join(target)\n \n \n \n \ndef b64s_encode(data):\n ''\n\n\n \n return b2a_base64(data).rstrip(_BASE64_STRIP)\n \ndef b64s_decode(data):\n ''\n\n\n \n if isinstance(data,unicode):\n \n  try :\n   data=data.encode(\"ascii\")\n  except UnicodeEncodeError:\n   raise suppress_cause(ValueError(\"string argument should contain only ASCII characters\"))\n off=len(data)&3\n if off ==0:\n  pass\n elif off ==2:\n  data +=_BASE64_PAD2\n elif off ==3:\n  data +=_BASE64_PAD1\n else :\n  raise ValueError(\"invalid base64 input\")\n try :\n  return a2b_base64(data)\n except _BinAsciiError as err:\n  raise suppress_cause(TypeError(err))\n  \n  \n  \n  \n_BASE64_STRIP=b\"=\\n\"\n_BASE64_PAD1=b\"=\"\n_BASE64_PAD2=b\"==\"\n\n\n\n\ndef ab64_encode(data):\n ''\n\n\n\n\n \n return b64s_encode(data).replace(b\"+\",b\".\")\n \ndef ab64_decode(data):\n ''\n\n\n\n\n \n if isinstance(data,unicode):\n \n  try :\n   data=data.encode(\"ascii\")\n  except UnicodeEncodeError:\n   raise suppress_cause(ValueError(\"string argument should contain only ASCII characters\"))\n return b64s_decode(data.replace(b\".\",b\"+\"))\n \n \n \n \n \ndef b32encode(source):\n ''\n\n\n \n \n \n return bascii_to_str(_b32encode(source).rstrip(B_EQUAL))\n \n \n \n_b32_translate=compile_byte_translation({\"8\":\"B\",\"0\":\"O\"})\n\n\n_b32_decode_pad=B_EQUAL *8\n\ndef b32decode(source):\n ''\n\n\n\n \n \n if isinstance(source,unicode):\n  source=source.encode(\"ascii\")\n source=source.translate(_b32_translate)\n \n \n remainder=len(source)&0x7\n if remainder:\n  source +=_b32_decode_pad[:-remainder]\n  \n  \n  \n return _b32decode(source,True )\n \n \n \n \n \nclass Base64Engine(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n bytemap=None\n big=None\n \n \n \n _encode64=None\n _decode64=None\n \n \n _encode_bytes=None\n _decode_bytes=None\n \n \n \n \n def __init__(self,charmap,big=False ):\n \n  if isinstance(charmap,unicode):\n   charmap=charmap.encode(\"latin-1\")\n  elif not isinstance(charmap,bytes):\n   raise exc.ExpectedStringError(charmap,\"charmap\")\n  if len(charmap)!=64:\n   raise ValueError(\"charmap must be 64 characters in length\")\n  if len(set(charmap))!=64:\n   raise ValueError(\"charmap must not contain duplicate characters\")\n  self.bytemap=charmap\n  self._encode64=charmap.__getitem__\n  lookup=dict((value,idx)for idx,value in enumerate(charmap))\n  self._decode64=lookup.__getitem__\n  \n  \n  self.big=big\n  if big:\n   self._encode_bytes=self._encode_bytes_big\n   self._decode_bytes=self._decode_bytes_big\n  else :\n   self._encode_bytes=self._encode_bytes_little\n   self._decode_bytes=self._decode_bytes_little\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n @property\n def charmap(self):\n  ''\n  return self.bytemap.decode(\"latin-1\")\n  \n  \n  \n  \n def encode_bytes(self,source):\n  ''\n\n\n\n  \n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  chunks,tail=divmod(len(source),3)\n  if PY3:\n   next_value=nextgetter(iter(source))\n  else :\n   next_value=nextgetter(ord(elem)for elem in source)\n  gen=self._encode_bytes(next_value,chunks,tail)\n  out=join_byte_elems(imap(self._encode64,gen))\n  \n  \n  \n  \n  return out\n  \n def _encode_bytes_little(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   yield v1&0x3f\n   yield ((v2&0x0f)<<2)|(v1 >>6)\n   yield ((v3&0x03)<<4)|(v2 >>4)\n   yield v3 >>2\n   idx +=1\n  if tail:\n   v1=next_value()\n   if tail ==1:\n   \n    yield v1&0x3f\n    yield v1 >>6\n   else :\n    assert tail ==2\n    \n    v2=next_value()\n    yield v1&0x3f\n    yield ((v2&0x0f)<<2)|(v1 >>6)\n    yield v2 >>4\n    \n def _encode_bytes_big(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   yield v1 >>2\n   yield ((v1&0x03)<<4)|(v2 >>4)\n   yield ((v2&0x0f)<<2)|(v3 >>6)\n   yield v3&0x3f\n   idx +=1\n  if tail:\n   v1=next_value()\n   if tail ==1:\n   \n    yield v1 >>2\n    yield (v1&0x03)<<4\n   else :\n    assert tail ==2\n    \n    v2=next_value()\n    yield v1 >>2\n    yield ((v1&0x03)<<4)|(v2 >>4)\n    yield ((v2&0x0f)<<2)\n    \n    \n    \n    \n    \n def decode_bytes(self,source):\n  ''\n\n\n\n  \n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n   \n   \n   \n   \n  chunks,tail=divmod(len(source),4)\n  if tail ==1:\n  \n   raise ValueError(\"input string length cannot be == 1 mod 4\")\n  next_value=nextgetter(imap(self._decode64,source))\n  try :\n   return join_byte_values(self._decode_bytes(next_value,chunks,tail))\n  except KeyError as err:\n   raise ValueError(\"invalid character: %r\"%(err.args[0],))\n   \n def _decode_bytes_little(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   v4=next_value()\n   yield v1 |((v2&0x3)<<6)\n   yield (v2 >>2)|((v3&0xF)<<4)\n   yield (v3 >>4)|(v4 <<2)\n   idx +=1\n  if tail:\n  \n   v1=next_value()\n   v2=next_value()\n   yield v1 |((v2&0x3)<<6)\n   \n   if tail ==3:\n   \n    v3=next_value()\n    yield (v2 >>2)|((v3&0xF)<<4)\n    \n def _decode_bytes_big(self,next_value,chunks,tail):\n  ''\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  idx=0\n  while idx <chunks:\n   v1=next_value()\n   v2=next_value()\n   v3=next_value()\n   v4=next_value()\n   yield (v1 <<2)|(v2 >>4)\n   yield ((v2&0xF)<<4)|(v3 >>2)\n   yield ((v3&0x3)<<6)|v4\n   idx +=1\n  if tail:\n  \n   v1=next_value()\n   v2=next_value()\n   yield (v1 <<2)|(v2 >>4)\n   \n   if tail ==3:\n   \n    v3=next_value()\n    yield ((v2&0xF)<<4)|(v3 >>2)\n    \n    \n    \n    \n    \n    \n    \n    \n def __make_padset(self,bits):\n  ''\n  pset=set(c for i,c in enumerate(self.bytemap)if not i&bits)\n  pset.update(c for i,c in enumerate(self.charmap)if not i&bits)\n  return frozenset(pset)\n  \n @memoized_property\n def _padinfo2(self):\n  ''\n  \n  bits=15 if self.big else (15 <<2)\n  return ~bits,self.__make_padset(bits)\n  \n @memoized_property\n def _padinfo3(self):\n  ''\n  \n  bits=3 if self.big else (3 <<4)\n  return ~bits,self.__make_padset(bits)\n  \n def check_repair_unused(self,source):\n  ''\n\n\n\n\n\n\n\n  \n  \n  tail=len(source)&3\n  if tail ==2:\n   mask,padset=self._padinfo2\n  elif tail ==3:\n   mask,padset=self._padinfo3\n  elif not tail:\n   return False ,source\n  else :\n   raise ValueError(\"source length must != 1 mod 4\")\n   \n   \n  last=source[-1]\n  if last in padset:\n   return False ,source\n   \n   \n   \n  if isinstance(source,unicode):\n   cm=self.charmap\n   last=cm[cm.index(last)&mask]\n   assert last in padset,\"failed to generate valid padding char\"\n  else :\n  \n  \n   last=self._encode64(self._decode64(last)&mask)\n   assert last in padset,\"failed to generate valid padding char\"\n   if PY3:\n    last=bytes([last])\n  return True ,source[:-1]+last\n  \n def repair_unused(self,source):\n  return self.check_repair_unused(source)[1]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def encode_transposed_bytes(self,source,offsets):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  tmp=join_byte_elems(source[off]for off in offsets)\n  return self.encode_bytes(tmp)\n  \n def decode_transposed_bytes(self,source,offsets):\n  ''\n  \n  \n  \n  tmp=self.decode_bytes(source)\n  buf=[None ]*len(offsets)\n  for off,char in zip(offsets,tmp):\n   buf[off]=char\n  return join_byte_elems(buf)\n  \n  \n  \n  \n def _decode_int(self,source,bits):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  big=self.big\n  pad=-bits %6\n  chars=(bits+pad)/6\n  if len(source)!=chars:\n   raise ValueError(\"source must be %d chars\"%(chars,))\n  decode=self._decode64\n  out=0\n  try :\n   for c in source if big else reversed(source):\n    out=(out <<6)+decode(c)\n  except KeyError:\n   raise ValueError(\"invalid character in string: %r\"%(c,))\n  if pad:\n  \n   if big:\n    out >>=pad\n   else :\n    out &=(1 <<bits)-1\n  return out\n  \n  \n  \n  \n  \n def decode_int6(self,source):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  if len(source)!=1:\n   raise ValueError(\"source must be exactly 1 byte\")\n  if PY3:\n  \n   source=source[0]\n  try :\n   return self._decode64(source)\n  except KeyError:\n   raise ValueError(\"invalid character\")\n   \n def decode_int12(self,source):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  if len(source)!=2:\n   raise ValueError(\"source must be exactly 2 bytes\")\n  decode=self._decode64\n  try :\n   if self.big:\n    return decode(source[1])+(decode(source[0])<<6)\n   else :\n    return decode(source[0])+(decode(source[1])<<6)\n  except KeyError:\n   raise ValueError(\"invalid character\")\n   \n def decode_int24(self,source):\n  ''\n  if not isinstance(source,bytes):\n   raise TypeError(\"source must be bytes, not %s\"%(type(source),))\n  if len(source)!=4:\n   raise ValueError(\"source must be exactly 4 bytes\")\n  decode=self._decode64\n  try :\n   if self.big:\n    return decode(source[3])+(decode(source[2])<<6)+\\\n    (decode(source[1])<<12)+(decode(source[0])<<18)\n   else :\n    return decode(source[0])+(decode(source[1])<<6)+\\\n    (decode(source[2])<<12)+(decode(source[3])<<18)\n  except KeyError:\n   raise ValueError(\"invalid character\")\n   \n def decode_int30(self,source):\n  ''\n  return self._decode_int(source,30)\n  \n def decode_int64(self,source):\n  ''\n\n\n\n  \n  return self._decode_int(source,64)\n  \n  \n  \n  \n def _encode_int(self,value,bits):\n  ''\n\n\n\n\n\n\n  \n  assert value >=0,\"caller did not sanitize input\"\n  pad=-bits %6\n  bits +=pad\n  if self.big:\n   itr=irange(bits -6,-6,-6)\n   \n   value <<=pad\n  else :\n   itr=irange(0,bits,6)\n   \n  return join_byte_elems(imap(self._encode64,\n  ((value >>off)&0x3f for off in itr)))\n  \n  \n  \n  \n  \n def encode_int6(self,value):\n  ''\n  if value <0 or value >63:\n   raise ValueError(\"value out of range\")\n  if PY3:\n   return self.bytemap[value:value+1]\n  else :\n   return self._encode64(value)\n   \n def encode_int12(self,value):\n  ''\n  if value <0 or value >0xFFF:\n   raise ValueError(\"value out of range\")\n  raw=[value&0x3f,(value >>6)&0x3f]\n  if self.big:\n   raw=reversed(raw)\n  return join_byte_elems(imap(self._encode64,raw))\n  \n def encode_int24(self,value):\n  ''\n  if value <0 or value >0xFFFFFF:\n   raise ValueError(\"value out of range\")\n  raw=[value&0x3f,(value >>6)&0x3f,\n  (value >>12)&0x3f,(value >>18)&0x3f]\n  if self.big:\n   raw=reversed(raw)\n  return join_byte_elems(imap(self._encode64,raw))\n  \n def encode_int30(self,value):\n  ''\n  if value <0 or value >0x3fffffff:\n   raise ValueError(\"value out of range\")\n  return self._encode_int(value,30)\n  \n def encode_int64(self,value):\n  ''\n\n\n\n  \n  if value <0 or value >0xffffffffffffffff:\n   raise ValueError(\"value out of range\")\n  return self._encode_int(value,64)\n  \n  \n  \n  \n  \nclass LazyBase64Engine(Base64Engine):\n ''\n _lazy_opts=None\n \n def __init__(self,*args,**kwds):\n  self._lazy_opts=(args,kwds)\n  \n def _lazy_init(self):\n  args,kwds=self._lazy_opts\n  super(LazyBase64Engine,self).__init__(*args,**kwds)\n  del self._lazy_opts\n  self.__class__=Base64Engine\n  \n def __getattribute__(self,attr):\n  if not attr.startswith(\"_\"):\n   self._lazy_init()\n  return object.__getattribute__(self,attr)\n  \n  \n  \n  \n  \nh64=LazyBase64Engine(HASH64_CHARS)\nh64big=LazyBase64Engine(HASH64_CHARS,big=True )\nbcrypt64=LazyBase64Engine(BCRYPT_CHARS,big=True )\n\n\n\n\n", ["__future__", "base64", "binascii", "logging", "passlib", "passlib.utils.compat", "passlib.utils.decor"]], "passlib.Lib.site-packages.passlib.utils.handlers": [".py", "''\n\n\n\nfrom __future__ import with_statement\n\nimport inspect\nimport logging ;log=logging.getLogger(__name__)\nimport math\nimport threading\nfrom warnings import warn\n\n\nimport passlib.exc as exc,passlib.ifc as ifc\nfrom passlib.exc import MissingBackendError,PasslibConfigWarning,\\\nPasslibHashWarning\nfrom passlib.ifc import PasswordHash\nfrom passlib.registry import get_crypt_handler\nfrom passlib.utils import (\nconsteq,getrandstr,getrandbytes,\nrng,to_native_str,\nis_crypt_handler,to_unicode,\nMAX_PASSWORD_SIZE,accepts_keyword,as_bool,\nupdate_mixin_classes)\nfrom passlib.utils.binary import (\nBASE64_CHARS,HASH64_CHARS,PADDED_BASE64_CHARS,\nHEX_CHARS,UPPER_HEX_CHARS,LOWER_HEX_CHARS,\nALL_BYTE_VALUES,\n)\nfrom passlib.utils.compat import join_byte_values,irange,u,native_string_types,\\\nuascii_to_str,join_unicode,unicode,str_to_uascii,\\\njoin_unicode,unicode_or_bytes_types,PY2,int_types\nfrom passlib.utils.decor import classproperty,deprecated_method\n\n__all__=[\n\n'parse_mc2',\n'parse_mc3',\n'render_mc2',\n'render_mc3',\n\n\n'GenericHandler',\n'StaticHandler',\n'HasUserContext',\n'HasRawChecksum',\n'HasManyIdents',\n'HasSalt',\n'HasRawSalt',\n'HasRounds',\n'HasManyBackends',\n\n\n'PrefixWrapper',\n\n\n\n]\n\n\n\n\n\n\nH64_CHARS=HASH64_CHARS\nB64_CHARS=BASE64_CHARS\nPADDED_B64_CHARS=PADDED_BASE64_CHARS\nUC_HEX_CHARS=UPPER_HEX_CHARS\nLC_HEX_CHARS=LOWER_HEX_CHARS\n\n\n\n\ndef _bitsize(count,chars):\n ''\n if chars and count:\n  import math\n  return int(count *math.log(len(chars),2))\n else :\n  return 0\n  \ndef guess_app_stacklevel(start=1):\n ''\n\n\n \n frame=inspect.currentframe()\n count=-start\n try :\n  while frame:\n   name=frame.f_globals.get('__name__',\"\")\n   if name.startswith(\"passlib.tests.\")or not name.startswith(\"passlib.\"):\n    return max(1,count)\n   count +=1\n   frame=frame.f_back\n  return start\n finally :\n  del frame\n  \ndef warn_hash_settings_deprecation(handler,kwds):\n warn(\"passing settings to %(handler)s.hash() is deprecated, and won't be supported in Passlib 2.0; \"\n \"use '%(handler)s.using(**settings).hash(secret)' instead\"%dict(handler=handler.name),\n DeprecationWarning,stacklevel=guess_app_stacklevel(2))\n \ndef extract_settings_kwds(handler,kwds):\n ''\n\n\n \n context_keys=set(handler.context_kwds)\n return dict((key,kwds.pop(key))for key in list(kwds)if key not in context_keys)\n \n \n \n \n_UDOLLAR=u(\"$\")\n_UZERO=u(\"0\")\n\ndef validate_secret(secret):\n ''\n if not isinstance(secret,unicode_or_bytes_types):\n  raise exc.ExpectedStringError(secret,\"secret\")\n if len(secret)>MAX_PASSWORD_SIZE:\n  raise exc.PasswordSizeError(MAX_PASSWORD_SIZE)\n  \ndef to_unicode_for_identify(hash):\n ''\n if isinstance(hash,unicode):\n  return hash\n elif isinstance(hash,bytes):\n \n \n \n  try :\n   return hash.decode(\"utf-8\")\n  except UnicodeDecodeError:\n   return hash.decode(\"latin-1\")\n else :\n  raise exc.ExpectedStringError(hash,\"hash\")\n  \ndef parse_mc2(hash,prefix,sep=_UDOLLAR,handler=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n hash=to_unicode(hash,\"ascii\",\"hash\")\n assert isinstance(prefix,unicode)\n if not hash.startswith(prefix):\n  raise exc.InvalidHashError(handler)\n  \n  \n assert isinstance(sep,unicode)\n parts=hash[len(prefix):].split(sep)\n if len(parts)==2:\n  salt,chk=parts\n  return salt,chk or None\n elif len(parts)==1:\n  return parts[0],None\n else :\n  raise exc.MalformedHashError(handler)\n  \ndef parse_mc3(hash,prefix,sep=_UDOLLAR,rounds_base=10,\ndefault_rounds=None ,handler=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n hash=to_unicode(hash,\"ascii\",\"hash\")\n assert isinstance(prefix,unicode)\n if not hash.startswith(prefix):\n  raise exc.InvalidHashError(handler)\n  \n  \n assert isinstance(sep,unicode)\n parts=hash[len(prefix):].split(sep)\n if len(parts)==3:\n  rounds,salt,chk=parts\n elif len(parts)==2:\n  rounds,salt=parts\n  chk=None\n else :\n  raise exc.MalformedHashError(handler)\n  \n  \n if rounds.startswith(_UZERO)and rounds !=_UZERO:\n  raise exc.ZeroPaddedRoundsError(handler)\n elif rounds:\n  rounds=int(rounds,rounds_base)\n elif default_rounds is None :\n  raise exc.MalformedHashError(handler,\"empty rounds field\")\n else :\n  rounds=default_rounds\n  \n  \n return rounds,salt,chk or None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef parse_int(source,base=10,default=None ,param=\"value\",handler=None ):\n ''\n\n\n\n\n\n\n\n \n if source.startswith(_UZERO)and source !=_UZERO:\n  raise exc.MalformedHashError(handler,\"zero-padded %s field\"%param)\n elif source:\n  return int(source,base)\n elif default is None :\n  raise exc.MalformedHashError(handler,\"empty %s field\"%param)\n else :\n  return default\n  \n  \n  \n  \ndef render_mc2(ident,salt,checksum,sep=u(\"$\")):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if checksum:\n  parts=[ident,salt,sep,checksum]\n else :\n  parts=[ident,salt]\n return uascii_to_str(join_unicode(parts))\n \ndef render_mc3(ident,rounds,salt,checksum,sep=u(\"$\"),rounds_base=10):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if rounds is None :\n  rounds=u('')\n elif rounds_base ==16:\n  rounds=u(\"%x\")%rounds\n else :\n  assert rounds_base ==10\n  rounds=unicode(rounds)\n if checksum:\n  parts=[ident,rounds,sep,salt,sep,checksum]\n else :\n  parts=[ident,rounds,sep,salt]\n return uascii_to_str(join_unicode(parts))\n \n \ndef mask_value(value,show=4,pct=0.125,char=u\"*\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if value is None :\n  return None\n if not isinstance(value,unicode):\n  if isinstance(value,bytes):\n   from passlib.utils.binary import ab64_encode\n   value=ab64_encode(value).decode(\"ascii\")\n  else :\n   value=unicode(value)\n size=len(value)\n show=min(show,int(size *pct))\n return value[:show]+char *(size -show)\n \n \n \n \n \ndef validate_default_value(handler,default,norm,param=\"value\"):\n ''\n\n\n \n assert default is not None ,\"%s lacks default %s\"%(handler.name,param)\n assert norm(default)==default,\"%s: invalid default %s: %r\"%(handler.name,param,default)\n return True\n \ndef norm_integer(handler,value,min=1,max=None ,\nparam=\"value\",relaxed=False ):\n ''\n\n\n\n\n\n\n\n\n \n \n if not isinstance(value,int_types):\n  raise exc.ExpectedTypeError(value,\"integer\",param)\n  \n  \n if value <min:\n  msg=\"%s: %s (%d) is too low, must be at least %d\"%(handler.name,param,value,min)\n  if relaxed:\n   warn(msg,exc.PasslibHashWarning)\n   value=min\n  else :\n   raise ValueError(msg)\n   \n   \n if max and value >max:\n  msg=\"%s: %s (%d) is too large, cannot be more than %d\"%(handler.name,param,value,max)\n  if relaxed:\n   warn(msg,exc.PasslibHashWarning)\n   value=max\n  else :\n   raise ValueError(msg)\n   \n return value\n \n \n \n \nclass MinimalHandler(PasswordHash):\n ''\n\n\n \n \n \n \n \n \n _configured=False\n \n \n \n \n \n @classmethod\n def using(cls,relaxed=False ):\n \n \n \n \n \n  name=cls.__name__\n  if not cls._configured:\n  \n   name=\"<customized %s hasher>\"%name\n  return type(name,(cls,),dict(__module__=cls.__module__,_configured=True ))\n  \n  \n  \n  \n  \nclass TruncateMixin(MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n truncate_error=False\n truncate_verify_reject=False\n \n @classmethod\n def using(cls,truncate_error=None ,**kwds):\n  subcls=super(TruncateMixin,cls).using(**kwds)\n  if truncate_error is not None :\n   truncate_error=as_bool(truncate_error,param=\"truncate_error\")\n   if truncate_error is not None :\n    subcls.truncate_error=truncate_error\n  return subcls\n  \n @classmethod\n def _check_truncate_policy(cls,secret):\n  ''\n\n\n\n  \n  assert cls.truncate_size is not None ,\"truncate_size must be set by subclass\"\n  if cls.truncate_error and len(secret)>cls.truncate_size:\n   raise exc.PasswordTruncateError(cls)\n   \n   \n   \n   \nclass GenericHandler(MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n setting_kwds=None\n \n \n context_kwds=()\n \n \n ident=None\n \n \n \n _hash_regex=None\n \n \n checksum_size=None\n \n \n checksum_chars=None\n \n \n _checksum_is_bytes=False\n \n \n \n \n checksum=None\n \n \n \n \n \n \n def __init__(self,checksum=None ,use_defaults=False ,**kwds):\n  self.use_defaults=use_defaults\n  super(GenericHandler,self).__init__(**kwds)\n  if checksum is not None :\n  \n   self.checksum=self._norm_checksum(checksum)\n   \n   \n   \n def _norm_checksum(self,checksum,relaxed=False ):\n  ''\n\n  \n  \n  \n  \n  \n  \n  raw=self._checksum_is_bytes\n  if raw:\n  \n  \n   if not isinstance(checksum,bytes):\n    raise exc.ExpectedTypeError(checksum,\"bytes\",\"checksum\")\n    \n  elif not isinstance(checksum,unicode):\n   if isinstance(checksum,bytes)and relaxed:\n    warn(\"checksum should be unicode, not bytes\",PasslibHashWarning)\n    checksum=checksum.decode(\"ascii\")\n   else :\n    raise exc.ExpectedTypeError(checksum,\"unicode\",\"checksum\")\n    \n    \n  cc=self.checksum_size\n  if cc and len(checksum)!=cc:\n   raise exc.ChecksumSizeError(self,raw=raw)\n   \n   \n  if not raw:\n   cs=self.checksum_chars\n   if cs and any(c not in cs for c in checksum):\n    raise ValueError(\"invalid characters in %s checksum\"%(self.name,))\n    \n  return checksum\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n \n \n \n  hash=to_unicode_for_identify(hash)\n  if not hash:\n   return False\n   \n   \n  ident=cls.ident\n  if ident is not None :\n   return hash.startswith(ident)\n   \n   \n  pat=cls._hash_regex\n  if pat is not None :\n   return pat.match(hash)is not None\n   \n   \n   \n  try :\n   cls.from_string(hash)\n   return True\n  except ValueError:\n   return False\n   \n @classmethod\n def from_string(cls,hash,**context):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"%s must implement from_string()\"%(cls,))\n  \n def to_string(self):\n  ''\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"%s must implement from_string()\"%(self.__class__,))\n  \n  \n  \n  \n  \n  \n @property\n def _stub_checksum(self):\n  ''\n\n  \n  \n  if self.checksum_size:\n   if self._checksum_is_bytes:\n    return b'\\x00'*self.checksum_size\n   if self.checksum_chars:\n    return self.checksum_chars[0]*self.checksum_size\n    \n    \n  if isinstance(self,HasRounds):\n   orig=self.rounds\n   self.rounds=self.min_rounds or 1\n   try :\n    return self._calc_checksum(\"\")\n   finally :\n    self.rounds=orig\n    \n    \n  return self._calc_checksum(\"\")\n  \n def _calc_checksum(self,secret):\n  ''\n\n\n\n\n  \n  raise NotImplementedError(\"%s must implement _calc_checksum()\"%\n  (self.__class__,))\n  \n  \n  \n  \n  \n @classmethod\n def hash(cls,secret,**kwds):\n  if kwds:\n  \n  \n  \n  \n  \n   settings=extract_settings_kwds(cls,kwds)\n   if settings:\n    warn_hash_settings_deprecation(cls,settings)\n    return cls.using(**settings).hash(secret,**kwds)\n    \n  validate_secret(secret)\n  self=cls(use_defaults=True ,**kwds)\n  self.checksum=self._calc_checksum(secret)\n  return self.to_string()\n  \n @classmethod\n def verify(cls,secret,hash,**context):\n \n \n \n  validate_secret(secret)\n  self=cls.from_string(hash,**context)\n  chk=self.checksum\n  if chk is None :\n   raise exc.MissingDigestError(cls)\n  return consteq(self._calc_checksum(secret),chk)\n  \n  \n  \n  \n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls,**kwds):\n \n  settings=extract_settings_kwds(cls,kwds)\n  if settings:\n   return cls.using(**settings).genconfig(**kwds)\n   \n   \n  self=cls(use_defaults=True ,**kwds)\n  self.checksum=self._stub_checksum\n  return self.to_string()\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,**context):\n  if config is None :\n   raise TypeError(\"config must be string\")\n  validate_secret(secret)\n  self=cls.from_string(config,**context)\n  self.checksum=self._calc_checksum(secret)\n  return self.to_string()\n  \n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,secret=None ,**kwds):\n \n \n  self=cls.from_string(hash)\n  assert isinstance(self,cls)\n  return self._calc_needs_update(secret=secret,**kwds)\n  \n def _calc_needs_update(self,secret=None ):\n  ''\n\n  \n  \n  \n  return False\n  \n  \n  \n  \n  \n  \n  \n _always_parse_settings=()\n \n \n _unparsed_settings=(\"salt_size\",\"relaxed\")\n \n \n _unsafe_settings=(\"salt\",\"checksum\")\n \n @classproperty\n def _parsed_settings(cls):\n  ''\n\n\n\n\n  \n  return tuple(key for key in cls.setting_kwds if key not in cls._unparsed_settings)\n  \n @classmethod\n def parsehash(cls,hash,checksum=True ,sanitize=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  self=cls.from_string(hash)\n  \n  \n  \n  \n  \n  UNSET=object()\n  always=self._always_parse_settings\n  kwds=dict((key,getattr(self,key))for key in self._parsed_settings\n  if key in always or getattr(self,key)!=getattr(cls,key,UNSET))\n  if checksum and self.checksum is not None :\n   kwds['checksum']=self.checksum\n  if sanitize:\n   if sanitize is True :\n    sanitize=mask_value\n   for key in cls._unsafe_settings:\n    if key in kwds:\n     kwds[key]=sanitize(kwds[key])\n  return kwds\n  \n @classmethod\n def bitsize(cls,**kwds):\n  ''\n  try :\n   info=super(GenericHandler,cls).bitsize(**kwds)\n  except AttributeError:\n   info={}\n  cc=ALL_BYTE_VALUES if cls._checksum_is_bytes else cls.checksum_chars\n  if cls.checksum_size and cc:\n  \n  \n   info['checksum']=_bitsize(cls.checksum_size,cc)\n  return info\n  \n  \n  \n  \n  \nclass StaticHandler(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n setting_kwds=()\n \n \n _hash_prefix=u(\"\")\n \n @classmethod\n def from_string(cls,hash,**context):\n \n \n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  hash=cls._norm_hash(hash)\n  \n  \n  \n  \n  prefix=cls._hash_prefix\n  if prefix:\n   if hash.startswith(prefix):\n    hash=hash[len(prefix):]\n   else :\n    raise exc.InvalidHashError(cls)\n  return cls(checksum=hash,**context)\n  \n @classmethod\n def _norm_hash(cls,hash):\n  ''\n  return hash\n  \n def to_string(self):\n  return uascii_to_str(self._hash_prefix+self.checksum)\n  \n  \n __cc_compat_hack=None\n \n def _calc_checksum(self,secret):\n  ''\n\n  \n  \n  \n  \n  \n  \n  \n  cls=self.__class__\n  assert cls.__module__ !=__name__\n  wrapper_cls=cls.__cc_compat_hack\n  if wrapper_cls is None :\n   def inner(self,secret):\n    raise NotImplementedError(\"%s must implement _calc_checksum()\"%\n    (cls,))\n   wrapper_cls=cls.__cc_compat_hack=type(cls.__name__+\"_wrapper\",\n   (cls,),dict(_calc_checksum=inner,__module__=cls.__module__))\n  context=dict((k,getattr(self,k))for k in self.context_kwds)\n  \n  \n  try :\n   hash=wrapper_cls.genhash(secret,None ,**context)\n  except TypeError as err:\n   if str(err)==\"config must be string\":\n    raise NotImplementedError(\"%s must implement _calc_checksum()\"%\n    (cls,))\n   else :\n    raise\n  warn(\"%r should be updated to implement StaticHandler._calc_checksum() \"\n  \"instead of StaticHandler.genhash(), support for the latter \"\n  \"style will be removed in Passlib 1.8\"%cls,\n  DeprecationWarning)\n  return str_to_uascii(hash)\n  \n  \n  \n  \nclass HasEncodingContext(GenericHandler):\n ''\n context_kwds=(\"encoding\",)\n default_encoding=\"utf-8\"\n \n def __init__(self,encoding=None ,**kwds):\n  super(HasEncodingContext,self).__init__(**kwds)\n  self.encoding=encoding or self.default_encoding\n  \nclass HasUserContext(GenericHandler):\n ''\n context_kwds=(\"user\",)\n \n def __init__(self,user=None ,**kwds):\n  super(HasUserContext,self).__init__(**kwds)\n  self.user=user\n  \n  \n  \n  \n  \n @classmethod\n def hash(cls,secret,user=None ,**context):\n  return super(HasUserContext,cls).hash(secret,user=user,**context)\n  \n @classmethod\n def verify(cls,secret,hash,user=None ,**context):\n  return super(HasUserContext,cls).verify(secret,hash,user=user,**context)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,user=None ,**context):\n  return super(HasUserContext,cls).genhash(secret,config,user=user,**context)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass HasRawChecksum(GenericHandler):\n ''\n\n\n\n\n \n \n \n \n \n \n _checksum_is_bytes=True\n \n \n \n \nclass HasManyIdents(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n default_ident=None\n ident_values=None\n ident_aliases=None\n \n \n \n \n \n \n \n \n \n \n ident=None\n \n \n \n \n @classmethod\n def using(cls,\n default_ident=None ,ident=None ,**kwds):\n  ''\n\n\n\n\n\n\n\n  \n  \n  if ident is not None :\n   if default_ident is not None :\n    raise TypeError(\"'default_ident' and 'ident' are mutually exclusive\")\n   default_ident=ident\n   \n   \n  subcls=super(HasManyIdents,cls).using(**kwds)\n  \n  \n  \n  if default_ident is not None :\n   subcls.default_ident=cls(ident=default_ident,use_defaults=True ).ident\n  return subcls\n  \n  \n  \n  \n def __init__(self,ident=None ,**kwds):\n  super(HasManyIdents,self).__init__(**kwds)\n  \n  \n  if ident is not None :\n   ident=self._norm_ident(ident)\n  elif self.use_defaults:\n   ident=self.default_ident\n   assert validate_default_value(self,ident,self._norm_ident,param=\"default_ident\")\n  else :\n   raise TypeError(\"no ident specified\")\n  self.ident=ident\n  \n @classmethod\n def _norm_ident(cls,ident):\n  ''\n\n  \n  \n  assert ident is not None\n  if isinstance(ident,bytes):\n   ident=ident.decode('ascii')\n   \n   \n  iv=cls.ident_values\n  if ident in iv:\n   return ident\n   \n   \n  ia=cls.ident_aliases\n  if ia:\n   try :\n    value=ia[ident]\n   except KeyError:\n    pass\n   else :\n    if value in iv:\n     return value\n     \n     \n     \n  raise ValueError(\"invalid ident: %r\"%(ident,))\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n  hash=to_unicode_for_identify(hash)\n  return hash.startswith(cls.ident_values)\n  \n @classmethod\n def _parse_ident(cls,hash):\n  ''\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  for ident in cls.ident_values:\n   if hash.startswith(ident):\n    return ident,hash[len(ident):]\n  raise exc.InvalidHashError(cls)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass HasSalt(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n min_salt_size=0\n max_salt_size=None\n salt_chars=None\n \n @classproperty\n def default_salt_size(cls):\n  ''\n  return cls.max_salt_size\n  \n @classproperty\n def default_salt_chars(cls):\n  ''\n  return cls.salt_chars\n  \n  \n _salt_is_bytes=False\n _salt_unit=\"chars\"\n \n \n \n \n \n \n salt=None\n \n \n \n \n @classmethod\n def using(cls,\n default_salt_size=None ,\n salt_size=None ,\n salt=None ,\n **kwds):\n \n \n  if salt_size is not None :\n   if default_salt_size is not None :\n    raise TypeError(\"'salt_size' and 'default_salt_size' aliases are mutually exclusive\")\n   default_salt_size=salt_size\n   \n   \n  subcls=super(HasSalt,cls).using(**kwds)\n  \n  \n  relaxed=kwds.get(\"relaxed\")\n  if default_salt_size is not None :\n   if isinstance(default_salt_size,native_string_types):\n    default_salt_size=int(default_salt_size)\n   subcls.default_salt_size=subcls._clip_to_valid_salt_size(default_salt_size,\n   param=\"salt_size\",\n   relaxed=relaxed)\n   \n   \n   \n  if salt is not None :\n   salt=subcls._norm_salt(salt,relaxed=relaxed)\n   subcls._generate_salt=staticmethod(lambda :salt)\n   \n  return subcls\n  \n  \n @classmethod\n def _clip_to_valid_salt_size(cls,salt_size,param=\"salt_size\",relaxed=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  mn=cls.min_salt_size\n  mx=cls.max_salt_size\n  \n  \n  if mn ==mx:\n   if salt_size !=mn:\n    msg=\"%s: %s (%d) must be exactly %d\"%(cls.name,param,salt_size,mn)\n    if relaxed:\n     warn(msg,PasslibHashWarning)\n    else :\n     raise ValueError(msg)\n   return mn\n   \n   \n  if salt_size <mn:\n   msg=\"%s: %s (%r) below min_salt_size (%d)\"%(cls.name,param,salt_size,mn)\n   if relaxed:\n    warn(msg,PasslibHashWarning)\n    salt_size=mn\n   else :\n    raise ValueError(msg)\n    \n    \n  if mx and salt_size >mx:\n   msg=\"%s: %s (%r) above max_salt_size (%d)\"%(cls.name,param,salt_size,mx)\n   if relaxed:\n    warn(msg,PasslibHashWarning)\n    salt_size=mx\n   else :\n    raise ValueError(msg)\n    \n  return salt_size\n  \n  \n  \n  \n def __init__(self,salt=None ,**kwds):\n  super(HasSalt,self).__init__(**kwds)\n  if salt is not None :\n   salt=self._parse_salt(salt)\n  elif self.use_defaults:\n   salt=self._generate_salt()\n   assert self._norm_salt(salt)==salt,\"generated invalid salt: %r\"%(salt,)\n  else :\n   raise TypeError(\"no salt specified\")\n  self.salt=salt\n  \n  \n def _parse_salt(self,salt):\n  return self._norm_salt(salt)\n  \n @classmethod\n def _norm_salt(cls,salt,relaxed=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if cls._salt_is_bytes:\n   if not isinstance(salt,bytes):\n    raise exc.ExpectedTypeError(salt,\"bytes\",\"salt\")\n  else :\n   if not isinstance(salt,unicode):\n   \n    if isinstance(salt,bytes)and (PY2 or relaxed):\n     salt=salt.decode(\"ascii\")\n    else :\n     raise exc.ExpectedTypeError(salt,\"unicode\",\"salt\")\n     \n     \n   sc=cls.salt_chars\n   if sc is not None and any(c not in sc for c in salt):\n    raise ValueError(\"invalid characters in %s salt\"%cls.name)\n    \n    \n  mn=cls.min_salt_size\n  if mn and len(salt)<mn:\n   msg=\"salt too small (%s requires %s %d %s)\"%(cls.name,\n   \"exactly\"if mn ==cls.max_salt_size else \">=\",mn,cls._salt_unit)\n   raise ValueError(msg)\n   \n   \n  mx=cls.max_salt_size\n  if mx and len(salt)>mx:\n   msg=\"salt too large (%s requires %s %d %s)\"%(cls.name,\n   \"exactly\"if mx ==mn else \"<=\",mx,cls._salt_unit)\n   if relaxed:\n    warn(msg,PasslibHashWarning)\n    salt=cls._truncate_salt(salt,mx)\n   else :\n    raise ValueError(msg)\n    \n  return salt\n  \n @staticmethod\n def _truncate_salt(salt,mx):\n \n \n \n  return salt[:mx]\n  \n @classmethod\n def _generate_salt(cls):\n  ''\n\n  \n  return getrandstr(rng,cls.default_salt_chars,cls.default_salt_size)\n  \n @classmethod\n def bitsize(cls,salt_size=None ,**kwds):\n  ''\n  info=super(HasSalt,cls).bitsize(**kwds)\n  if salt_size is None :\n   salt_size=cls.default_salt_size\n   \n   \n  info['salt']=_bitsize(salt_size,cls.default_salt_chars)\n  return info\n  \n  \n  \n  \n  \nclass HasRawSalt(HasSalt):\n ''\n\n\n\n\n\n\n \n \n salt_chars=ALL_BYTE_VALUES\n \n \n \n _salt_is_bytes=True\n _salt_unit=\"bytes\"\n \n @classmethod\n def _generate_salt(cls):\n  assert cls.salt_chars in [None ,ALL_BYTE_VALUES]\n  return getrandbytes(rng,cls.default_salt_size)\n  \n  \n  \n  \nclass HasRounds(GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n min_rounds=0\n max_rounds=None\n rounds_cost=\"linear\"\n \n \n using_rounds_kwds=(\"min_desired_rounds\",\"max_desired_rounds\",\n \"min_rounds\",\"max_rounds\",\n \"default_rounds\",\"vary_rounds\")\n \n \n \n \n min_desired_rounds=None\n max_desired_rounds=None\n default_rounds=None\n vary_rounds=None\n \n \n \n \n rounds=None\n \n \n \n \n @classmethod\n def using(cls,\n min_desired_rounds=None ,max_desired_rounds=None ,\n default_rounds=None ,vary_rounds=None ,\n min_rounds=None ,max_rounds=None ,rounds=None ,\n **kwds):\n \n \n  if min_rounds is not None :\n   if min_desired_rounds is not None :\n    raise TypeError(\"'min_rounds' and 'min_desired_rounds' aliases are mutually exclusive\")\n   min_desired_rounds=min_rounds\n   \n  if max_rounds is not None :\n   if max_desired_rounds is not None :\n    raise TypeError(\"'max_rounds' and 'max_desired_rounds' aliases are mutually exclusive\")\n   max_desired_rounds=max_rounds\n   \n   \n   \n   \n  if rounds is not None :\n   if min_desired_rounds is None :\n    min_desired_rounds=rounds\n   if max_desired_rounds is None :\n    max_desired_rounds=rounds\n   if default_rounds is None :\n    default_rounds=rounds\n    \n    \n  subcls=super(HasRounds,cls).using(**kwds)\n  \n  \n  relaxed=kwds.get(\"relaxed\")\n  if min_desired_rounds is None :\n   explicit_min_rounds=False\n   min_desired_rounds=cls.min_desired_rounds\n  else :\n   explicit_min_rounds=True\n   if isinstance(min_desired_rounds,native_string_types):\n    min_desired_rounds=int(min_desired_rounds)\n   subcls.min_desired_rounds=subcls._norm_rounds(min_desired_rounds,\n   param=\"min_desired_rounds\",\n   relaxed=relaxed)\n   \n   \n  if max_desired_rounds is None :\n   max_desired_rounds=cls.max_desired_rounds\n  else :\n   if isinstance(max_desired_rounds,native_string_types):\n    max_desired_rounds=int(max_desired_rounds)\n   if min_desired_rounds and max_desired_rounds <min_desired_rounds:\n    msg=\"%s: max_desired_rounds (%r) below min_desired_rounds (%r)\"%\\\n    (subcls.name,max_desired_rounds,min_desired_rounds)\n    if explicit_min_rounds:\n     raise ValueError(msg)\n    else :\n     warn(msg,PasslibConfigWarning)\n     max_desired_rounds=min_desired_rounds\n   subcls.max_desired_rounds=subcls._norm_rounds(max_desired_rounds,\n   param=\"max_desired_rounds\",\n   relaxed=relaxed)\n   \n   \n  if default_rounds is not None :\n   if isinstance(default_rounds,native_string_types):\n    default_rounds=int(default_rounds)\n   if min_desired_rounds and default_rounds <min_desired_rounds:\n    raise ValueError(\"%s: default_rounds (%r) below min_desired_rounds (%r)\"%\n    (subcls.name,default_rounds,min_desired_rounds))\n   elif max_desired_rounds and default_rounds >max_desired_rounds:\n    raise ValueError(\"%s: default_rounds (%r) above max_desired_rounds (%r)\"%\n    (subcls.name,default_rounds,max_desired_rounds))\n   subcls.default_rounds=subcls._norm_rounds(default_rounds,\n   param=\"default_rounds\",\n   relaxed=relaxed)\n   \n   \n  if subcls.default_rounds is not None :\n   subcls.default_rounds=subcls._clip_to_desired_rounds(subcls.default_rounds)\n   \n   \n  if vary_rounds is not None :\n   if isinstance(vary_rounds,native_string_types):\n    if vary_rounds.endswith(\"%\"):\n     vary_rounds=float(vary_rounds[:-1])*0.01\n    elif \".\"in vary_rounds:\n     vary_rounds=float(vary_rounds)\n    else :\n     vary_rounds=int(vary_rounds)\n   if vary_rounds <0:\n    raise ValueError(\"%s: vary_rounds (%r) below 0\"%\n    (subcls.name,vary_rounds))\n   elif isinstance(vary_rounds,float):\n   \n    if vary_rounds >1:\n     raise ValueError(\"%s: vary_rounds (%r) above 1.0\"%\n     (subcls.name,vary_rounds))\n   elif not isinstance(vary_rounds,int):\n    raise TypeError(\"vary_rounds must be int or float\")\n   if vary_rounds:\n    warn(\"The 'vary_rounds' option is deprecated as of Passlib 1.7, \"\n    \"and will be removed in Passlib 2.0\",PasslibConfigWarning)\n   subcls.vary_rounds=vary_rounds\n   \n   \n  return subcls\n  \n @classmethod\n def _clip_to_desired_rounds(cls,rounds):\n  ''\n\n\n  \n  \n  \n  mnd=cls.min_desired_rounds or 0\n  if rounds <mnd:\n   return mnd\n   \n   \n  mxd=cls.max_desired_rounds\n  if mxd and rounds >mxd:\n   return mxd\n   \n  return rounds\n  \n @classmethod\n def _calc_vary_rounds_range(cls,default_rounds):\n  ''\n\n\n\n\n\n  \n  \n  \n  assert default_rounds\n  vary_rounds=cls.vary_rounds\n  \n  \n  def linear_to_native(value,upper):\n   return value\n  if isinstance(vary_rounds,float):\n   assert 0 <=vary_rounds <=1\n   if cls.rounds_cost ==\"log2\":\n   \n   \n   \n    default_rounds=1 <<default_rounds\n    def linear_to_native(value,upper):\n     if value <=0:\n      return 0\n     elif upper:\n      return int(math.log(value,2))\n     else :\n      return int(math.ceil(math.log(value,2)))\n      \n   vary_rounds=int(default_rounds *vary_rounds)\n   \n   \n  assert vary_rounds >=0 and isinstance(vary_rounds,int_types)\n  lower=linear_to_native(default_rounds -vary_rounds,False )\n  upper=linear_to_native(default_rounds+vary_rounds,True )\n  return cls._clip_to_desired_rounds(lower),cls._clip_to_desired_rounds(upper)\n  \n  \n  \n  \n def __init__(self,rounds=None ,**kwds):\n  super(HasRounds,self).__init__(**kwds)\n  if rounds is not None :\n   rounds=self._parse_rounds(rounds)\n  elif self.use_defaults:\n   rounds=self._generate_rounds()\n   assert self._norm_rounds(rounds)==rounds,\"generated invalid rounds: %r\"%(rounds,)\n  else :\n   raise TypeError(\"no rounds specified\")\n  self.rounds=rounds\n  \n  \n def _parse_rounds(self,rounds):\n  return self._norm_rounds(rounds)\n  \n @classmethod\n def _norm_rounds(cls,rounds,relaxed=False ,param=\"rounds\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return norm_integer(cls,rounds,cls.min_rounds,cls.max_rounds,\n  param=param,relaxed=relaxed)\n  \n @classmethod\n def _generate_rounds(cls):\n  ''\n\n\n\n  \n  \n  rounds=cls.default_rounds\n  if rounds is None :\n   raise TypeError(\"%s rounds value must be specified explicitly\"%(cls.name,))\n   \n   \n   \n  if cls.vary_rounds:\n   lower,upper=cls._calc_vary_rounds_range(rounds)\n   assert lower <=rounds <=upper\n   if lower <upper:\n    rounds=rng.randint(lower,upper)\n    \n  return rounds\n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  min_desired_rounds=self.min_desired_rounds\n  if min_desired_rounds and self.rounds <min_desired_rounds:\n   return True\n  max_desired_rounds=self.max_desired_rounds\n  if max_desired_rounds and self.rounds >max_desired_rounds:\n   return True\n  return super(HasRounds,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n @classmethod\n def bitsize(cls,rounds=None ,vary_rounds=.1,**kwds):\n  ''\n  info=super(HasRounds,cls).bitsize(**kwds)\n  \n  \n  if cls.rounds_cost !=\"log2\":\n  \n  \n  \n  \n  \n  \n   import math\n   if rounds is None :\n    rounds=cls.default_rounds\n   info['rounds']=max(0,int(1+math.log(rounds *vary_rounds,2)))\n   \n   \n   \n  return info\n  \n  \n  \n  \n  \n  \n  \n  \nclass ParallelismMixin(GenericHandler):\n ''\n\n \n \n \n \n \n \n \n \n \n \n \n \n parallelism=1\n \n \n \n \n \n @classmethod\n def using(cls,parallelism=None ,**kwds):\n  subcls=super(ParallelismMixin,cls).using(**kwds)\n  if parallelism is not None :\n   if isinstance(parallelism,native_string_types):\n    parallelism=int(parallelism)\n   subcls.parallelism=subcls._norm_parallelism(parallelism,relaxed=kwds.get(\"relaxed\"))\n  return subcls\n  \n  \n  \n  \n def __init__(self,parallelism=None ,**kwds):\n  super(ParallelismMixin,self).__init__(**kwds)\n  \n  \n  if parallelism is None :\n   assert validate_default_value(self,self.parallelism,self._norm_parallelism,\n   param=\"parallelism\")\n  else :\n   self.parallelism=self._norm_parallelism(parallelism)\n   \n @classmethod\n def _norm_parallelism(cls,parallelism,relaxed=False ):\n  return norm_integer(cls,parallelism,min=1,param=\"parallelism\",relaxed=relaxed)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  \n  if self.parallelism !=type(self).parallelism:\n   return True\n  return super(ParallelismMixin,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_backend_lock=threading.RLock()\n\nclass BackendMixin(PasswordHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n backends=None\n \n \n __backend=None\n \n \n \n _no_backend_suggestion=None\n \n \n \n _pending_backend=None\n \n \n \n _pending_dry_run=False\n \n \n \n \n \n @classmethod\n def get_backend(cls):\n  ''\n\n\n\n\n\n\n\n\n  \n  if not cls.__backend:\n   cls.set_backend()\n   assert cls.__backend,\"set_backend() failed to load a default backend\"\n  return cls.__backend\n  \n @classmethod\n def has_backend(cls,name=\"any\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   cls.set_backend(name,dryrun=True )\n   return True\n  except (exc.MissingBackendError,exc.PasslibSecurityError):\n   return False\n   \n @classmethod\n def set_backend(cls,name=\"any\",dryrun=False ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if (name ==\"any\"and cls.__backend)or (name and name ==cls.__backend):\n   return cls.__backend\n   \n   \n   \n  owner=cls._get_backend_owner()\n  if owner is not cls:\n   return owner.set_backend(name,dryrun=dryrun)\n   \n   \n  if name ==\"any\"or name ==\"default\":\n   default_error=None\n   for name in cls.backends:\n    try :\n     return cls.set_backend(name,dryrun=dryrun)\n    except exc.MissingBackendError:\n     continue\n    except exc.PasslibSecurityError as err:\n    \n     if default_error is None :\n      default_error=err\n     continue\n   if default_error is None :\n    msg=\"%s: no backends available\"%cls.name\n    if cls._no_backend_suggestion:\n     msg +=cls._no_backend_suggestion\n    default_error=exc.MissingBackendError(msg)\n   raise default_error\n   \n   \n  if name not in cls.backends:\n   raise exc.UnknownBackendError(cls,name)\n   \n   \n  with _backend_lock:\n   orig=cls._pending_backend,cls._pending_dry_run\n   try :\n    cls._pending_backend=name\n    cls._pending_dry_run=dryrun\n    cls._set_backend(name,dryrun)\n   finally :\n    cls._pending_backend,cls._pending_dry_run=orig\n   if not dryrun:\n    cls.__backend=name\n   return name\n   \n   \n   \n   \n   \n @classmethod\n def _get_backend_owner(cls):\n  ''\n\n\n  \n  return cls\n  \n @classmethod\n def _set_backend(cls,name,dryrun):\n  ''\n\n\n\n\n\n\n\n  \n  loader=cls._get_backend_loader(name)\n  kwds={}\n  if accepts_keyword(loader,\"name\"):\n   kwds['name']=name\n  if accepts_keyword(loader,\"dryrun\"):\n   kwds['dryrun']=dryrun\n  ok=loader(**kwds)\n  if ok is False :\n   raise exc.MissingBackendError(\"%s: backend not available: %s\"%\n   (cls.name,name))\n  elif ok is not True :\n   raise AssertionError(\"backend loaders must return True or False\"\n   \": %r\"%(ok,))\n   \n @classmethod\n def _get_backend_loader(cls,name):\n  ''\n\n\n\n\n\n\n\n\n  \n  raise NotImplementedError(\"implement in subclass\")\n  \n @classmethod\n def _stub_requires_backend(cls):\n  ''\n\n  \n  if cls.__backend:\n   raise AssertionError(\"%s: _finalize_backend(%r) failed to replace lazy loader\"%\n   (cls.name,cls.__backend))\n  cls.set_backend()\n  if not cls.__backend:\n   raise AssertionError(\"%s: set_backend() failed to load a default backend\"%\n   (cls.name))\n   \n   \n   \n   \n   \nclass SubclassBackendMixin(BackendMixin):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n _backend_mixin_target=False\n \n \n _backend_mixin_map=None\n \n \n \n \n \n @classmethod\n def _get_backend_owner(cls):\n  ''\n\n\n\n  \n  if not cls._backend_mixin_target:\n   raise AssertionError(\"_backend_mixin_target not set\")\n  for base in cls.__mro__:\n   if base.__dict__.get(\"_backend_mixin_target\"):\n    return base\n  raise AssertionError(\"expected to find class w/ '_backend_mixin_target' set\")\n  \n @classmethod\n def _set_backend(cls,name,dryrun):\n \n  super(SubclassBackendMixin,cls)._set_backend(name,dryrun)\n  \n  \n  \n  assert cls is cls._get_backend_owner(),\"_finalize_backend() not invoked on owner\"\n  \n  \n  mixin_map=cls._backend_mixin_map\n  assert mixin_map,\"_backend_mixin_map not specified\"\n  mixin_cls=mixin_map[name]\n  assert issubclass(mixin_cls,SubclassBackendMixin),\"invalid mixin class\"\n  \n  \n  update_mixin_classes(cls,\n  add=mixin_cls,\n  remove=mixin_map.values(),\n  append=True ,before=SubclassBackendMixin,\n  dryrun=dryrun,\n  )\n  \n @classmethod\n def _get_backend_loader(cls,name):\n  assert cls._backend_mixin_map,\"_backend_mixin_map not specified\"\n  return cls._backend_mixin_map[name]._load_backend_mixin\n  \n  \n  \n  \n  \n  \nclass HasManyBackends(BackendMixin,GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n def _calc_checksum(self,secret):\n  ''''\n  \n  \n  \n  return self._calc_checksum_backend(secret)\n  \n def _calc_checksum_backend(self,secret):\n  ''\n\n\n\n  \n  self._stub_requires_backend()\n  return self._calc_checksum_backend(secret)\n  \n  \n  \n  \n @classmethod\n def _get_backend_loader(cls,name):\n  ''\n\n\n  \n  \n  loader=getattr(cls,\"_load_backend_\"+name,None )\n  if loader is None :\n  \n   def loader():\n    return cls.__load_legacy_backend(name)\n  else :\n  \n   assert not hasattr(cls,\"_has_backend_\"+name),(\n   \"%s: can't specify both ._load_backend_%s() \"\n   \"and ._has_backend_%s\"%(cls.name,name,name)\n   )\n  return loader\n  \n @classmethod\n def __load_legacy_backend(cls,name):\n  value=getattr(cls,\"_has_backend_\"+name)\n  warn(\"%s: support for ._has_backend_%s is deprecated as of Passlib 1.7, \"\n  \"and will be removed in Passlib 1.9/2.0, please implement \"\n  \"._load_backend_%s() instead\"%(cls.name,name,name),\n  DeprecationWarning,\n  )\n  if value:\n   func=getattr(cls,\"_calc_checksum_\"+name)\n   cls._set_calc_checksum_backend(func)\n   return True\n  else :\n   return False\n   \n @classmethod\n def _set_calc_checksum_backend(cls,func):\n  ''\n\n\n  \n  backend=cls._pending_backend\n  assert backend,\"should only be called during set_backend()\"\n  if not callable(func):\n   raise RuntimeError(\"%s: backend %r returned invalid callable: %r\"%\n   (cls.name,backend,func))\n  if not cls._pending_dry_run:\n   cls._calc_checksum_backend=func\n   \n   \n   \n   \n   \n   \n   \n   \n   \nclass PrefixWrapper(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n _using_clone_attrs=()\n \n def __init__(self,name,wrapped,prefix=u(''),orig_prefix=u(''),lazy=False ,\n doc=None ,ident=None ):\n  self.name=name\n  if isinstance(prefix,bytes):\n   prefix=prefix.decode(\"ascii\")\n  self.prefix=prefix\n  if isinstance(orig_prefix,bytes):\n   orig_prefix=orig_prefix.decode(\"ascii\")\n  self.orig_prefix=orig_prefix\n  if doc:\n   self.__doc__=doc\n  if hasattr(wrapped,\"name\"):\n   self._set_wrapped(wrapped)\n  else :\n   self._wrapped_name=wrapped\n   if not lazy:\n    self._get_wrapped()\n    \n  if ident is not None :\n   if ident is True :\n   \n    if prefix:\n     ident=prefix\n    else :\n     raise ValueError(\"no prefix specified\")\n   if isinstance(ident,bytes):\n    ident=ident.decode(\"ascii\")\n    \n   if ident[:len(prefix)]!=prefix[:len(ident)]:\n    raise ValueError(\"ident must agree with prefix\")\n   self._ident=ident\n   \n _wrapped_name=None\n _wrapped_handler=None\n \n def _set_wrapped(self,handler):\n \n  if 'ident'in handler.setting_kwds and self.orig_prefix:\n  \n   warn(\"PrefixWrapper: 'orig_prefix' option may not work correctly \"\n   \"for handlers which have multiple identifiers: %r\"%\n   (handler.name,),exc.PasslibRuntimeWarning)\n   \n   \n  self._wrapped_handler=handler\n  \n def _get_wrapped(self):\n  handler=self._wrapped_handler\n  if handler is None :\n   handler=get_crypt_handler(self._wrapped_name)\n   self._set_wrapped(handler)\n  return handler\n  \n wrapped=property(_get_wrapped)\n \n _ident=False\n \n @property\n def ident(self):\n  value=self._ident\n  if value is False :\n   value=None\n   \n   \n   if not self.orig_prefix:\n    wrapped=self.wrapped\n    ident=getattr(wrapped,\"ident\",None )\n    if ident is not None :\n     value=self._wrap_hash(ident)\n   self._ident=value\n  return value\n  \n _ident_values=False\n \n @property\n def ident_values(self):\n  value=self._ident_values\n  if value is False :\n   value=None\n   \n   \n   if not self.orig_prefix:\n    wrapped=self.wrapped\n    idents=getattr(wrapped,\"ident_values\",None )\n    if idents:\n     value=tuple(self._wrap_hash(ident)for ident in idents)\n     \n     \n     \n     \n   self._ident_values=value\n  return value\n  \n  \n  \n _proxy_attrs=(\n \"setting_kwds\",\"context_kwds\",\n \"default_rounds\",\"min_rounds\",\"max_rounds\",\"rounds_cost\",\n \"min_desired_rounds\",\"max_desired_rounds\",\"vary_rounds\",\n \"default_salt_size\",\"min_salt_size\",\"max_salt_size\",\n \"salt_chars\",\"default_salt_chars\",\n \"backends\",\"has_backend\",\"get_backend\",\"set_backend\",\n \"is_disabled\",\"truncate_size\",\"truncate_error\",\n \"truncate_verify_reject\",\n \n \n \"_salt_is_bytes\",\n )\n \n def __repr__(self):\n  args=[repr(self._wrapped_name or self._wrapped_handler)]\n  if self.prefix:\n   args.append(\"prefix=%r\"%self.prefix)\n  if self.orig_prefix:\n   args.append(\"orig_prefix=%r\"%self.orig_prefix)\n  args=\", \".join(args)\n  return 'PrefixWrapper(%r, %s)'%(self.name,args)\n  \n def __dir__(self):\n  attrs=set(dir(self.__class__))\n  attrs.update(self.__dict__)\n  wrapped=self.wrapped\n  attrs.update(\n  attr for attr in self._proxy_attrs\n  if hasattr(wrapped,attr)\n  )\n  return list(attrs)\n  \n def __getattr__(self,attr):\n  ''\n  if attr in self._proxy_attrs:\n   return getattr(self.wrapped,attr)\n  raise AttributeError(\"missing attribute: %r\"%(attr,))\n  \n def __setattr__(self,attr,value):\n \n \n \n \n \n  if attr in self._proxy_attrs and self._derived_from:\n   wrapped=self.wrapped\n   if hasattr(wrapped,attr):\n    setattr(wrapped,attr,value)\n    return\n  return object.__setattr__(self,attr,value)\n  \n def _unwrap_hash(self,hash):\n  ''\n  \n  prefix=self.prefix\n  if not hash.startswith(prefix):\n   raise exc.InvalidHashError(self)\n   \n  return self.orig_prefix+hash[len(prefix):]\n  \n def _wrap_hash(self,hash):\n  ''\n  \n  \n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  orig_prefix=self.orig_prefix\n  if not hash.startswith(orig_prefix):\n   raise exc.InvalidHashError(self.wrapped)\n  wrapped=self.prefix+hash[len(orig_prefix):]\n  return uascii_to_str(wrapped)\n  \n  \n _derived_from=None\n \n def using(self,**kwds):\n \n  subcls=self.wrapped.using(**kwds)\n  assert subcls is not self.wrapped\n  \n  wrapper=PrefixWrapper(self.name,subcls,prefix=self.prefix,orig_prefix=self.orig_prefix)\n  wrapper._derived_from=self\n  for attr in self._using_clone_attrs:\n   setattr(wrapper,attr,getattr(self,attr))\n  return wrapper\n  \n def needs_update(self,hash,**kwds):\n  hash=self._unwrap_hash(hash)\n  return self.wrapped.needs_update(hash,**kwds)\n  \n def identify(self,hash):\n  hash=to_unicode_for_identify(hash)\n  if not hash.startswith(self.prefix):\n   return False\n  hash=self._unwrap_hash(hash)\n  return self.wrapped.identify(hash)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genconfig(self,**kwds):\n  config=self.wrapped.genconfig(**kwds)\n  if config is None :\n   raise RuntimeError(\".genconfig() must return a string, not None\")\n  return self._wrap_hash(config)\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n def genhash(self,secret,config,**kwds):\n \n  if config is not None :\n   config=to_unicode(config,\"ascii\",\"config/hash\")\n   config=self._unwrap_hash(config)\n  return self._wrap_hash(self.wrapped.genhash(secret,config,**kwds))\n  \n @deprecated_method(deprecated=\"1.7\",removed=\"2.0\",replacement=\".hash()\")\n def encrypt(self,secret,**kwds):\n  return self.hash(secret,**kwds)\n  \n def hash(self,secret,**kwds):\n  return self._wrap_hash(self.wrapped.hash(secret,**kwds))\n  \n def verify(self,secret,hash,**kwds):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  hash=self._unwrap_hash(hash)\n  return self.wrapped.verify(secret,hash,**kwds)\n  \n  \n  \n  \n", ["__future__", "inspect", "logging", "math", "passlib.exc", "passlib.ifc", "passlib.registry", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "threading", "warnings"]], "passlib.Lib.site-packages.passlib.utils": [".py", "''\n\n\n\nfrom passlib.utils.compat import JYTHON\n\nfrom binascii import b2a_base64,a2b_base64,Error as _BinAsciiError\nfrom base64 import b64encode,b64decode\ntry :\n from collections.abc import Sequence\n from collections.abc import Iterable\nexcept ImportError:\n\n from collections import Sequence\n from collections import Iterable\nfrom codecs import lookup as _lookup_codec\nfrom functools import update_wrapper\nimport itertools\nimport inspect\nimport logging ;log=logging.getLogger(__name__)\nimport math\nimport os\nimport sys\nimport random\nimport re\nif JYTHON:\n\n\n try :\n  import stringprep\n except ImportError:\n  stringprep=None\n  _stringprep_missing_reason=\"not present under Jython\"\nelse :\n import stringprep\nimport time\nif stringprep:\n import unicodedata\ntry :\n import threading\nexcept ImportError:\n\n threading=None\nimport timeit\nimport types\nfrom warnings import warn\n\n\nfrom passlib.utils.binary import (\n\nBASE64_CHARS,AB64_CHARS,HASH64_CHARS,BCRYPT_CHARS,\nBase64Engine,LazyBase64Engine,h64,h64big,bcrypt64,\nab64_encode,ab64_decode,b64s_encode,b64s_decode\n)\nfrom passlib.utils.decor import (\n\ndeprecated_function,\ndeprecated_method,\nmemoized_property,\nclassproperty,\nhybrid_method,\n)\nfrom passlib.exc import ExpectedStringError,ExpectedTypeError\nfrom passlib.utils.compat import (add_doc,join_bytes,join_byte_values,\njoin_byte_elems,irange,imap,PY3,u,\njoin_unicode,unicode,byte_elem_value,nextgetter,\nunicode_or_str,unicode_or_bytes_types,\nget_method_function,suppress_cause,PYPY)\n\n__all__=[\n\n'JYTHON',\n'sys_bits',\n'unix_crypt_schemes',\n'rounds_cost_values',\n\n\n'consteq',\n'saslprep',\n\n\n\"xor_bytes\",\n\"render_bytes\",\n\n\n'is_same_codec',\n'is_ascii_safe',\n'to_bytes',\n'to_unicode',\n'to_native_str',\n\n\n'has_crypt',\n'test_crypt',\n'safe_crypt',\n'tick',\n\n\n'rng',\n'getrandbytes',\n'getrandstr',\n'generate_password',\n\n\n'is_crypt_handler',\n'is_crypt_context',\n'has_rounds_info',\n'has_salt_info',\n]\n\n\n\n\n\n\nsys_bits=int(math.log(sys.maxsize if PY3 else sys.maxint,2)+1.5)\n\n\n\nunix_crypt_schemes=[\n\"sha512_crypt\",\"sha256_crypt\",\n\"sha1_crypt\",\"bcrypt\",\n\"md5_crypt\",\n\n\"bsdi_crypt\",\"des_crypt\",\n]\n\n\nrounds_cost_values=[\"linear\",\"log2\"]\n\n\nfrom passlib.exc import MissingBackendError\n\n\n_BEMPTY=b''\n_UEMPTY=u(\"\")\n_USPACE=u(\" \")\n\n\nMAX_PASSWORD_SIZE=int(os.environ.get(\"PASSLIB_MAX_PASSWORD_SIZE\")or 4096)\n\n\n\n\n\nclass SequenceMixin(object):\n ''\n\n\n \n def _as_tuple(self):\n  raise NotImplementedError(\"implement in subclass\")\n  \n def __repr__(self):\n  return repr(self._as_tuple())\n  \n def __getitem__(self,idx):\n  return self._as_tuple()[idx]\n  \n def __iter__(self):\n  return iter(self._as_tuple())\n  \n def __len__(self):\n  return len(self._as_tuple())\n  \n def __eq__(self,other):\n  return self._as_tuple()==other\n  \n def __ne__(self,other):\n  return not self.__eq__(other)\n  \nif PY3:\n\n\n\n _VAR_KEYWORD=inspect.Parameter.VAR_KEYWORD\n _VAR_ANY_SET=set([_VAR_KEYWORD,inspect.Parameter.VAR_POSITIONAL])\n \n def accepts_keyword(func,key):\n  ''\n  params=inspect.signature(get_method_function(func)).parameters\n  if not params:\n   return False\n  arg=params.get(key)\n  if arg and arg.kind not in _VAR_ANY_SET:\n   return True\n   \n  return params[list(params)[-1]].kind ==_VAR_KEYWORD\n  \nelse :\n\n def accepts_keyword(func,key):\n  ''\n  spec=inspect.getargspec(get_method_function(func))\n  return key in spec.args or spec.keywords is not None\n  \ndef update_mixin_classes(target,add=None ,remove=None ,append=False ,\nbefore=None ,after=None ,dryrun=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(add,type):\n  add=[add]\n  \n bases=list(target.__bases__)\n \n \n if remove:\n  if isinstance(remove,type):\n   remove=[remove]\n  for mixin in remove:\n   if add and mixin in add:\n    continue\n   if mixin in bases:\n    bases.remove(mixin)\n    \n    \n if add:\n  for mixin in add:\n  \n   if any(issubclass(base,mixin)for base in bases):\n    continue\n    \n    \n   if append:\n    for idx,base in enumerate(bases):\n     if issubclass(mixin,base):\n     \n      break\n     if before and issubclass(base,before):\n     \n      break\n    else :\n    \n     idx=len(bases)\n   elif after:\n    for end_idx,base in enumerate(reversed(bases)):\n     if issubclass(base,after):\n     \n      idx=len(bases)-end_idx\n      assert bases[idx -1]==base\n      break\n    else :\n     idx=0\n   else :\n   \n    idx=0\n    \n    \n   bases.insert(idx,mixin)\n   \n   \n if not dryrun:\n  target.__bases__=tuple(bases)\n  \n  \n  \n  \ndef batch(source,size):\n ''\n\n \n if size <1:\n  raise ValueError(\"size must be positive integer\")\n if isinstance(source,Sequence):\n  end=len(source)\n  i=0\n  while i <end:\n   n=i+size\n   yield source[i:n]\n   i=n\n elif isinstance(source,Iterable):\n  itr=iter(source)\n  while True :\n   chunk_itr=itertools.islice(itr,size)\n   try :\n    first=next(chunk_itr)\n   except StopIteration:\n    break\n   yield itertools.chain((first,),chunk_itr)\n else :\n  raise TypeError(\"source must be iterable\")\n  \n  \n  \n  \n  \n  \n  \ndef consteq(left,right):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n if isinstance(left,unicode):\n  if not isinstance(right,unicode):\n   raise TypeError(\"inputs must be both unicode or both bytes\")\n  is_py3_bytes=False\n elif isinstance(left,bytes):\n  if not isinstance(right,bytes):\n   raise TypeError(\"inputs must be both unicode or both bytes\")\n  is_py3_bytes=PY3\n else :\n  raise TypeError(\"inputs must be both unicode or both bytes\")\n  \n  \n  \n  \n  \n same_size=(len(left)==len(right))\n if same_size:\n \n  tmp=left\n  result=0\n if not same_size:\n \n \n \n  tmp=right\n  result=1\n  \n  \n  \n if is_py3_bytes:\n  for l,r in zip(tmp,right):\n   result |=l ^r\n else :\n  for l,r in zip(tmp,right):\n   result |=ord(l)^ord(r)\n return result ==0\n \n \n \n \n \nstr_consteq=consteq\n\ntry :\n\n from hmac import compare_digest as consteq\nexcept ImportError:\n pass\n \n \n \n \n \n \ndef splitcomma(source,sep=\",\"):\n ''\n\n \n source=source.strip()\n if source.endswith(sep):\n  source=source[:-1]\n if not source:\n  return []\n return [elem.strip()for elem in source.split(sep)]\n \ndef saslprep(source,param=\"value\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n if not isinstance(source,unicode):\n  raise TypeError(\"input must be unicode string, not %s\"%\n  (type(source),))\n  \n  \n  \n  \n in_table_c12=stringprep.in_table_c12\n in_table_b1=stringprep.in_table_b1\n data=join_unicode(\n _USPACE if in_table_c12(c)else c\n for c in source\n if not in_table_b1(c)\n )\n \n \n data=unicodedata.normalize('NFKC',data)\n if not data:\n  return _UEMPTY\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n is_ral_char=stringprep.in_table_d1\n if is_ral_char(data[0]):\n  if not is_ral_char(data[-1]):\n   raise ValueError(\"malformed bidi sequence in \"+param)\n   \n  is_forbidden_bidi_char=stringprep.in_table_d2\n else :\n \n  is_forbidden_bidi_char=is_ral_char\n  \n  \n in_table_a1=stringprep.in_table_a1\n in_table_c21_c22=stringprep.in_table_c21_c22\n in_table_c3=stringprep.in_table_c3\n in_table_c4=stringprep.in_table_c4\n in_table_c5=stringprep.in_table_c5\n in_table_c6=stringprep.in_table_c6\n in_table_c7=stringprep.in_table_c7\n in_table_c8=stringprep.in_table_c8\n in_table_c9=stringprep.in_table_c9\n for c in data:\n \n  assert not in_table_b1(c),\"failed to strip B.1 in mapping stage\"\n  assert not in_table_c12(c),\"failed to replace C.1.2 in mapping stage\"\n  \n  \n  if in_table_a1(c):\n   raise ValueError(\"unassigned code points forbidden in \"+param)\n  if in_table_c21_c22(c):\n   raise ValueError(\"control characters forbidden in \"+param)\n  if in_table_c3(c):\n   raise ValueError(\"private use characters forbidden in \"+param)\n  if in_table_c4(c):\n   raise ValueError(\"non-char code points forbidden in \"+param)\n  if in_table_c5(c):\n   raise ValueError(\"surrogate codes forbidden in \"+param)\n  if in_table_c6(c):\n   raise ValueError(\"non-plaintext chars forbidden in \"+param)\n  if in_table_c7(c):\n  \n  \n   raise ValueError(\"non-canonical chars forbidden in \"+param)\n  if in_table_c8(c):\n   raise ValueError(\"display-modifying / deprecated chars \"\n   \"forbidden in\"+param)\n  if in_table_c9(c):\n   raise ValueError(\"tagged characters forbidden in \"+param)\n   \n   \n  if is_forbidden_bidi_char(c):\n   raise ValueError(\"forbidden bidi character in \"+param)\n   \n return data\n \n \nif stringprep is None :\n def saslprep(source,param=\"value\"):\n  ''\n  raise NotImplementedError(\"saslprep() support requires the 'stringprep' \"\n  \"module, which is \"+_stringprep_missing_reason)\n  \n  \n  \n  \ndef render_bytes(source,*args):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(source,bytes):\n  source=source.decode(\"latin-1\")\n result=source %tuple(arg.decode(\"latin-1\")if isinstance(arg,bytes)\n else arg for arg in args)\n return result.encode(\"latin-1\")\n \nif PY3:\n\n def bytes_to_int(value):\n  return int.from_bytes(value,'big')\n def int_to_bytes(value,count):\n  return value.to_bytes(count,'big')\nelse :\n\n from binascii import hexlify,unhexlify\n def bytes_to_int(value):\n  return int(hexlify(value),16)\n def int_to_bytes(value,count):\n  return unhexlify(('%%0%dx'%(count <<1))%value)\n  \nadd_doc(bytes_to_int,\"decode byte string as single big-endian integer\")\nadd_doc(int_to_bytes,\"encode integer as single big-endian byte string\")\n\ndef xor_bytes(left,right):\n ''\n return int_to_bytes(bytes_to_int(left)^bytes_to_int(right),len(left))\n \ndef repeat_string(source,size):\n ''\n\n \n mult=1+(size -1)//len(source)\n return (source *mult)[:size]\n \n \ndef utf8_repeat_string(source,size):\n ''\n\n \n mult=1+(size -1)//len(source)\n return utf8_truncate(source *mult,size)\n \n \n_BNULL=b\"\\x00\"\n_UNULL=u(\"\\x00\")\n\ndef right_pad_string(source,size,pad=None ):\n ''\n cur=len(source)\n if size >cur:\n  if pad is None :\n   pad=_UNULL if isinstance(source,unicode)else _BNULL\n  return source+pad *(size -cur)\n else :\n  return source[:size]\n  \n  \ndef utf8_truncate(source,index):\n ''\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n if not isinstance(source,bytes):\n  raise ExpectedTypeError(source,bytes,\"source\")\n  \n  \n end=len(source)\n if index <0:\n  index=max(0,index+end)\n if index >=end:\n  return source\n  \n  \n end=min(index+3,end)\n \n \n while index <end:\n  if byte_elem_value(source[index])&0xC0 !=0x80:\n  \n   break\n   \n  index +=1\n else :\n  assert index ==end\n  \n  \n result=source[:index]\n \n def sanity_check():\n \n  try :\n   text=source.decode(\"utf-8\")\n  except UnicodeDecodeError:\n  \n   return True\n   \n   \n  assert text.startswith(result.decode(\"utf-8\"))\n  return True\n  \n assert sanity_check()\n \n return result\n \n \n \n \n_ASCII_TEST_BYTES=b\"\\x00\\n aA:#!\\x7f\"\n_ASCII_TEST_UNICODE=_ASCII_TEST_BYTES.decode(\"ascii\")\n\ndef is_ascii_codec(codec):\n ''\n return _ASCII_TEST_UNICODE.encode(codec)==_ASCII_TEST_BYTES\n \ndef is_same_codec(left,right):\n ''\n if left ==right:\n  return True\n if not (left and right):\n  return False\n return _lookup_codec(left).name ==_lookup_codec(right).name\n \n_B80=b'\\x80'[0]\n_U80=u('\\x80')\ndef is_ascii_safe(source):\n ''\n r=_B80 if isinstance(source,bytes)else _U80\n return all(c <r for c in source)\n \ndef to_bytes(source,encoding=\"utf-8\",param=\"value\",source_encoding=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n assert encoding\n if isinstance(source,bytes):\n  if source_encoding and not is_same_codec(source_encoding,encoding):\n   return source.decode(source_encoding).encode(encoding)\n  else :\n   return source\n elif isinstance(source,unicode):\n  return source.encode(encoding)\n else :\n  raise ExpectedStringError(source,param)\n  \ndef to_unicode(source,encoding=\"utf-8\",param=\"value\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n assert encoding\n if isinstance(source,unicode):\n  return source\n elif isinstance(source,bytes):\n  return source.decode(encoding)\n else :\n  raise ExpectedStringError(source,param)\n  \nif PY3:\n def to_native_str(source,encoding=\"utf-8\",param=\"value\"):\n  if isinstance(source,bytes):\n   return source.decode(encoding)\n  elif isinstance(source,unicode):\n   return source\n  else :\n   raise ExpectedStringError(source,param)\nelse :\n def to_native_str(source,encoding=\"utf-8\",param=\"value\"):\n  if isinstance(source,bytes):\n   return source\n  elif isinstance(source,unicode):\n   return source.encode(encoding)\n  else :\n   raise ExpectedStringError(source,param)\n   \nadd_doc(to_native_str,\n\"\"\"Take in unicode or bytes, return native string.\n\n    Python 2: encodes unicode using specified encoding, leaves bytes alone.\n    Python 3: leaves unicode alone, decodes bytes using specified encoding.\n\n    :raises TypeError: if source is not unicode or bytes.\n\n    :arg source:\n        source unicode or bytes string.\n\n    :arg encoding:\n        encoding to use when encoding unicode or decoding bytes.\n        this defaults to ``\"utf-8\"``.\n\n    :param param:\n        optional name of variable/noun to reference when raising errors.\n\n    :returns: :class:`str` instance\n    \"\"\")\n\n@deprecated_function(deprecated=\"1.6\",removed=\"1.7\")\ndef to_hash_str(source,encoding=\"ascii\"):\n ''\n return to_native_str(source,encoding,param=\"hash\")\n \n_true_set=set(\"true t yes y on 1 enable enabled\".split())\n_false_set=set(\"false f no n off 0 disable disabled\".split())\n_none_set=set([\"\",\"none\"])\n\ndef as_bool(value,none=None ,param=\"boolean\"):\n ''\n\n\n \n assert none in [True ,False ,None ]\n if isinstance(value,unicode_or_bytes_types):\n  clean=value.lower().strip()\n  if clean in _true_set:\n   return True\n  if clean in _false_set:\n   return False\n  if clean in _none_set:\n   return none\n  raise ValueError(\"unrecognized %s value: %r\"%(param,value))\n elif isinstance(value,bool):\n  return value\n elif value is None :\n  return none\n else :\n  return bool(value)\n  \n  \n  \n  \n  \ndef is_safe_crypt_input(value):\n ''\n\n\n\n \n if crypt_accepts_bytes or not isinstance(value,bytes):\n  return True\n try :\n  value.decode(\"utf-8\")\n  return True\n except UnicodeDecodeError:\n  return False\n  \ntry :\n from crypt import crypt as _crypt\nexcept ImportError:\n _crypt=None\n has_crypt=False\n crypt_accepts_bytes=False\n crypt_needs_lock=False\n _safe_crypt_lock=None\n def safe_crypt(secret,hash):\n  return None\nelse :\n has_crypt=True\n _NULL='\\x00'\n \n \n if threading and PYPY and (7,2,0)<=sys.pypy_version_info <=(7,3,3):\n \n \n  _safe_crypt_lock=threading.Lock()\n  \n  \n  crypt_needs_lock=True\n  \n else :\n  from passlib.utils.compat import nullcontext\n  _safe_crypt_lock=nullcontext()\n  crypt_needs_lock=False\n  \n  \n  \n  \n  \n  \n _invalid_prefixes=u(\"*:!\")\n \n if PY3:\n \n \n \n \n  crypt_accepts_bytes=True\n  try :\n   _crypt(b\"\\xEE\",\"xx\")\n  except TypeError:\n  \n   crypt_accepts_bytes=False\n  except :\n  \n  \n   pass\n   \n  def safe_crypt(secret,hash):\n   if crypt_accepts_bytes:\n   \n   \n    if isinstance(secret,unicode):\n     secret=secret.encode(\"utf-8\")\n    if _BNULL in secret:\n     raise ValueError(\"null character in secret\")\n    if isinstance(hash,unicode):\n     hash=hash.encode(\"ascii\")\n   else :\n   \n   \n   \n    if isinstance(secret,bytes):\n     orig=secret\n     try :\n      secret=secret.decode(\"utf-8\")\n     except UnicodeDecodeError:\n      return None\n      \n      \n     assert secret.encode(\"utf-8\")==orig,\\\n     \"utf-8 spec says this can't happen!\"\n    if _NULL in secret:\n     raise ValueError(\"null character in secret\")\n    if isinstance(hash,bytes):\n     hash=hash.decode(\"ascii\")\n   try :\n    with _safe_crypt_lock:\n     result=_crypt(secret,hash)\n   except OSError:\n   \n   \n   \n    return None\n    \n    \n    \n   if isinstance(result,bytes):\n    result=result.decode(\"ascii\")\n   if not result or result[0]in _invalid_prefixes:\n    return None\n   return result\n else :\n \n \n  crypt_accepts_bytes=True\n  \n  \n  def safe_crypt(secret,hash):\n   if isinstance(secret,unicode):\n    secret=secret.encode(\"utf-8\")\n   if _NULL in secret:\n    raise ValueError(\"null character in secret\")\n   if isinstance(hash,unicode):\n    hash=hash.encode(\"ascii\")\n   with _safe_crypt_lock:\n    result=_crypt(secret,hash)\n   if not result:\n    return None\n   result=result.decode(\"ascii\")\n   if result[0]in _invalid_prefixes:\n    return None\n   return result\n   \nadd_doc(safe_crypt,\"\"\"Wrapper around stdlib's crypt.\n\n    This is a wrapper around stdlib's :func:`!crypt.crypt`, which attempts\n    to provide uniform behavior across Python 2 and 3.\n\n    :arg secret:\n        password, as bytes or unicode (unicode will be encoded as ``utf-8``).\n\n    :arg hash:\n        hash or config string, as ascii bytes or unicode.\n\n    :returns:\n        resulting hash as ascii unicode; or ``None`` if the password\n        couldn't be hashed due to one of the issues:\n\n        * :func:`crypt()` not available on platform.\n\n        * Under Python 3, if *secret* is specified as bytes,\n          it must be use ``utf-8`` or it can't be passed\n          to :func:`crypt()`.\n\n        * Some OSes will return ``None`` if they don't recognize\n          the algorithm being used (though most will simply fall\n          back to des-crypt).\n\n        * Some OSes will return an error string if the input config\n          is recognized but malformed; current code converts these to ``None``\n          as well.\n    \"\"\")\n\ndef test_crypt(secret,hash):\n ''\n\n\n\n \n \n \n \n \n assert isinstance(hash,unicode_or_str),\\\n \"hash must be unicode_or_str, got %s\"%type(hash)\n assert hash,\"hash must be non-empty\"\n return safe_crypt(secret,hash)==hash\n \ntimer=timeit.default_timer\n\ntick=timer\n\ndef parse_version(source):\n ''\n m=re.search(r\"(\\d+(?:\\.\\d+)+)\",source)\n if m:\n  return tuple(int(elem)for elem in m.group(1).split(\".\"))\n return None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ntry :\n os.urandom(1)\n has_urandom=True\nexcept NotImplementedError:\n has_urandom=False\n \ndef genseed(value=None ):\n ''\n from hashlib import sha512\n if hasattr(value,\"getstate\")and hasattr(value,\"getrandbits\"):\n \n  try :\n   value=value.getstate()\n  except NotImplementedError:\n  \n  \n   value=value.getrandbits(1 <<15)\n text=u(\"%s %s %s %.15f %.15f %s\")%(\n \n value,\n \n \n \n os.getpid()if hasattr(os,\"getpid\")else None ,\n \n \n \n id(object()),\n \n \n time.time(),\n tick(),\n \n \n os.urandom(32).decode(\"latin-1\")if has_urandom else 0,\n )\n \n return int(sha512(text.encode(\"utf-8\")).hexdigest(),16)\n \nif has_urandom:\n rng=random.SystemRandom()\nelse :\n\n\n rng=random.Random(genseed())\n \n \n \n \ndef getrandbytes(rng,count):\n ''\n \n \n \n \n \n \n \n if not count:\n  return _BEMPTY\n def helper():\n \n  value=rng.getrandbits(count <<3)\n  i=0\n  while i <count:\n   yield value&0xff\n   value >>=3\n   i +=1\n return join_byte_values(helper())\n \ndef getrandstr(rng,charset,count):\n ''\n \n \n \n \n if count <0:\n  raise ValueError(\"count must be >= 0\")\n letters=len(charset)\n if letters ==0:\n  raise ValueError(\"alphabet must not be empty\")\n if letters ==1:\n  return charset *count\n  \n  \n def helper():\n \n  value=rng.randrange(0,letters **count)\n  i=0\n  while i <count:\n   yield charset[value %letters]\n   value //=letters\n   i +=1\n   \n if isinstance(charset,unicode):\n  return join_unicode(helper())\n else :\n  return join_byte_elems(helper())\n  \n_52charset='2346789ABCDEFGHJKMNPQRTUVWXYZabcdefghjkmnpqrstuvwxyz'\n\n@deprecated_function(deprecated=\"1.7\",removed=\"2.0\",\nreplacement=\"passlib.pwd.genword() / passlib.pwd.genphrase()\")\ndef generate_password(size=10,charset=_52charset):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return getrandstr(rng,charset,size)\n \n \n \n \n_handler_attrs=(\n\"name\",\n\"setting_kwds\",\"context_kwds\",\n\"verify\",\"hash\",\"identify\",\n)\n\ndef is_crypt_handler(obj):\n ''\n \n return all(hasattr(obj,name)for name in _handler_attrs)\n \n_context_attrs=(\n\"needs_update\",\n\"genconfig\",\"genhash\",\n\"verify\",\"encrypt\",\"identify\",\n)\n\ndef is_crypt_context(obj):\n ''\n \n return all(hasattr(obj,name)for name in _context_attrs)\n \n \n \n \n \n \ndef has_rounds_info(handler):\n ''\n return ('rounds'in handler.setting_kwds and\n getattr(handler,\"min_rounds\",None )is not None )\n \ndef has_salt_info(handler):\n ''\n return ('salt'in handler.setting_kwds and\n getattr(handler,\"min_salt_size\",None )is not None )\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n", ["base64", "binascii", "codecs", "collections", "collections.abc", "crypt", "functools", "hashlib", "hmac", "inspect", "itertools", "logging", "math", "os", "passlib.exc", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "random", "re", "stringprep", "sys", "threading", "time", "timeit", "types", "unicodedata", "warnings"], 1], "passlib.Lib.site-packages.passlib.utils.pbkdf2": [".py", "''\n\n\n\n\n\n\n\nfrom __future__ import division\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.exc import ExpectedTypeError\nfrom passlib.utils.decor import deprecated_function\nfrom passlib.utils.compat import native_string_types\nfrom passlib.crypto.digest import norm_hash_name,lookup_hash,pbkdf1 as _pbkdf1,pbkdf2_hmac,compile_hmac\n\n__all__=[\n\n\"norm_hash_name\",\n\n\n\"get_prf\",\n\n\n\"pbkdf1\",\n\"pbkdf2\",\n]\n\n\n\n\nfrom warnings import warn\n\nwarn(\"the module 'passlib.utils.pbkdf2' is deprecated as of Passlib 1.7, \"\n\"and will be removed in Passlib 2.0, please use 'passlib.crypto' instead\",\nDeprecationWarning)\n\n\n\n\n\nnorm_hash_name=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",func_module=__name__,\nreplacement=\"passlib.crypto.digest.norm_hash_name\")(norm_hash_name)\n\n\n\n\n\n\n_prf_cache={}\n\n\n_HMAC_PREFIXES=(\"hmac_\",\"hmac-\")\n\ndef get_prf(name):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _prf_cache\n if name in _prf_cache:\n  return _prf_cache[name]\n if isinstance(name,native_string_types):\n  if not name.startswith(_HMAC_PREFIXES):\n   raise ValueError(\"unknown prf algorithm: %r\"%(name,))\n  digest=lookup_hash(name[5:]).name\n  def hmac(key,msg):\n   return compile_hmac(digest,key)(msg)\n  record=(hmac,hmac.digest_info.digest_size)\n elif callable(name):\n \n  digest_size=len(name(b'x',b'y'))\n  record=(name,digest_size)\n else :\n  raise ExpectedTypeError(name,\"str or callable\",\"prf name\")\n _prf_cache[name]=record\n return record\n \n \n \n \ndef pbkdf1(secret,salt,rounds,keylen=None ,hash=\"sha1\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return _pbkdf1(hash,secret,salt,rounds,keylen)\n \n \n \n \ndef pbkdf2(secret,salt,rounds,keylen=None ,prf=\"hmac-sha1\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if callable(prf)or (isinstance(prf,native_string_types)and not prf.startswith(_HMAC_PREFIXES)):\n  raise NotImplementedError(\"non-HMAC prfs are not supported as of Passlib 1.7\")\n digest=prf[5:]\n return pbkdf2_hmac(digest,secret,salt,rounds,keylen)\n \n \n \n \n", ["__future__", "logging", "passlib.crypto.digest", "passlib.exc", "passlib.utils.compat", "passlib.utils.decor", "warnings"]], "passlib.Lib.site-packages.passlib.utils.md4": [".py", "''\n\n\n\n\n\n\n\n\nfrom warnings import warn\nwarn(\"the module 'passlib.utils.md4' is deprecated as of Passlib 1.7, \"\n\"and will be removed in Passlib 2.0, please use \"\n\"'lookup_hash(\\\"md4\\\").const()' from 'passlib.crypto' instead\",\nDeprecationWarning)\n\n\n\n\n__all__=[\"md4\"]\n\n\n\nfrom passlib.crypto.digest import lookup_hash\nmd4=lookup_hash(\"md4\").const\ndel lookup_hash\n\n\n\n\n", ["passlib.crypto.digest", "warnings"]], "passlib.Lib.site-packages.passlib.utils.decor": [".py", "''\n\n\n\n\n\n\nfrom __future__ import absolute_import,division,print_function\nimport logging\nlog=logging.getLogger(__name__)\nfrom functools import wraps,update_wrapper\nimport types\nfrom warnings import warn\n\n\nfrom passlib.utils.compat import PY3\n\n__all__=[\n\"classproperty\",\n\"hybrid_method\",\n\n\"memoize_single_value\",\n\"memoized_property\",\n\n\"deprecated_function\",\n\"deprecated_method\",\n]\n\n\n\n\nclass classproperty(object):\n ''\n \n def __init__(self,func):\n  self.im_func=func\n  \n def __get__(self,obj,cls):\n  return self.im_func(cls)\n  \n @property\n def __func__(self):\n  ''\n  return self.im_func\n  \nclass hybrid_method(object):\n ''\n\n\n \n \n def __init__(self,func):\n  self.func=func\n  update_wrapper(self,func)\n  \n def __get__(self,obj,cls):\n  if obj is None :\n   obj=cls\n  if PY3:\n   return types.MethodType(self.func,obj)\n  else :\n   return types.MethodType(self.func,obj,cls)\n   \n   \n   \n   \n   \ndef memoize_single_value(func):\n ''\n\n\n\n \n cache={}\n \n @wraps(func)\n def wrapper():\n  try :\n   return cache[True ]\n  except KeyError:\n   pass\n  value=cache[True ]=func()\n  return value\n  \n def clear_cache():\n  cache.pop(True ,None )\n wrapper.clear_cache=clear_cache\n \n return wrapper\n \nclass memoized_property(object):\n ''\n\n \n def __init__(self,func):\n  self.__func__=func\n  self.__name__=func.__name__\n  self.__doc__=func.__doc__\n  \n def __get__(self,obj,cls):\n  if obj is None :\n   return self\n  value=self.__func__(obj)\n  setattr(obj,self.__name__,value)\n  return value\n  \n if not PY3:\n \n  @property\n  def im_func(self):\n   ''\n   return self.__func__\n   \n def clear_cache(self,obj):\n  ''\n\n\n\n  \n  obj.__dict__.pop(self.__name__,None )\n  \n def peek_cache(self,obj,default=None ):\n  ''\n\n\n\n  \n  return obj.__dict__.get(self.__name__,default)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef deprecated_function(msg=None ,deprecated=None ,removed=None ,updoc=True ,\nreplacement=None ,_is_method=False ,\nfunc_module=None ):\n ''\n\n\n\n\n\n\n \n if msg is None :\n  if _is_method:\n   msg=\"the method %(mod)s.%(klass)s.%(name)s() is deprecated\"\n  else :\n   msg=\"the function %(mod)s.%(name)s() is deprecated\"\n  if deprecated:\n   msg +=\" as of Passlib %(deprecated)s\"\n  if removed:\n   msg +=\", and will be removed in Passlib %(removed)s\"\n  if replacement:\n   msg +=\", use %s instead\"%replacement\n  msg +=\".\"\n def build(func):\n  is_classmethod=_is_method and isinstance(func,classmethod)\n  if is_classmethod:\n  \n   func=func.__get__(None ,type).__func__\n  opts=dict(\n  mod=func_module or func.__module__,\n  name=func.__name__,\n  deprecated=deprecated,\n  removed=removed,\n  )\n  if _is_method:\n   def wrapper(*args,**kwds):\n    tmp=opts.copy()\n    klass=args[0]if is_classmethod else args[0].__class__\n    tmp.update(klass=klass.__name__,mod=klass.__module__)\n    warn(msg %tmp,DeprecationWarning,stacklevel=2)\n    return func(*args,**kwds)\n  else :\n   text=msg %opts\n   def wrapper(*args,**kwds):\n    warn(text,DeprecationWarning,stacklevel=2)\n    return func(*args,**kwds)\n  update_wrapper(wrapper,func)\n  if updoc and (deprecated or removed)and\\\n  wrapper.__doc__ and \".. deprecated::\"not in wrapper.__doc__:\n   txt=deprecated or ''\n   if removed or replacement:\n    txt +=\"\\n    \"\n    if removed:\n     txt +=\"and will be removed in version %s\"%(removed,)\n    if replacement:\n     if removed:\n      txt +=\", \"\n     txt +=\"use %s instead\"%replacement\n    txt +=\".\"\n   if not wrapper.__doc__.strip(\" \").endswith(\"\\n\"):\n    wrapper.__doc__ +=\"\\n\"\n   wrapper.__doc__ +=\"\\n.. deprecated:: %s\\n\"%(txt,)\n  if is_classmethod:\n   wrapper=classmethod(wrapper)\n  return wrapper\n return build\n \ndef deprecated_method(msg=None ,deprecated=None ,removed=None ,updoc=True ,\nreplacement=None ):\n ''\n\n\n\n\n\n\n \n return deprecated_function(msg,deprecated,removed,updoc,replacement,\n _is_method=True )\n \n \n \n \n", ["__future__", "functools", "logging", "passlib.utils.compat", "types", "warnings"]], "passlib.Lib.site-packages.passlib.utils.des": [".py", "''\n\n\n\n\n\n\n\nfrom warnings import warn\nwarn(\"the 'passlib.utils.des' module has been relocated to 'passlib.crypto.des' \"\n\"as of passlib 1.7, and the old location will be removed in passlib 2.0\",\nDeprecationWarning)\n\n\n\n\nfrom passlib.utils.decor import deprecated_function\nfrom passlib.crypto.des import expand_des_key,des_encrypt_block,des_encrypt_int_block\n\nexpand_des_key=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.expand_des_key\")(expand_des_key)\n\ndes_encrypt_block=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.des_encrypt_block\")(des_encrypt_block)\n\ndes_encrypt_int_block=deprecated_function(deprecated=\"1.7\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.des_encrypt_int_block\")(des_encrypt_int_block)\n\n\n\n\nimport struct\n_unpack_uint64=struct.Struct(\">Q\").unpack\n\n@deprecated_function(deprecated=\"1.6\",removed=\"1.8\",\nreplacement=\"passlib.crypto.des.des_encrypt_int_block()\")\ndef mdes_encrypt_int_block(key,input,salt=0,rounds=1):\n if isinstance(key,bytes):\n  if len(key)==7:\n   key=expand_des_key(key)\n  key=_unpack_uint64(key)[0]\n return des_encrypt_int_block(key,input,salt,rounds)\n \n \n \n \n", ["passlib.crypto.des", "passlib.utils.decor", "struct", "warnings"]], "passlib.Lib.site-packages.passlib.utils.compat._ordered_dict": [".py", "''\n\n\n\n\n\n\ntry :\n from thread import get_ident as _get_ident\nexcept ImportError:\n from dummy_thread import get_ident as _get_ident\n \nclass OrderedDict(dict):\n ''\n \n \n \n \n \n \n \n \n \n \n def __init__(self,*args,**kwds):\n  ''\n\n\n\n  \n  if len(args)>1:\n   raise TypeError('expected at most 1 arguments, got %d'%len(args))\n  try :\n   self.__root\n  except AttributeError:\n   self.__root=root=[]\n   root[:]=[root,root,None ]\n   self.__map={}\n  self.__update(*args,**kwds)\n  \n def __setitem__(self,key,value,dict_setitem=dict.__setitem__):\n  ''\n  \n  \n  if key not in self:\n   root=self.__root\n   last=root[0]\n   last[1]=root[0]=self.__map[key]=[last,root,key]\n  dict_setitem(self,key,value)\n  \n def __delitem__(self,key,dict_delitem=dict.__delitem__):\n  ''\n  \n  \n  dict_delitem(self,key)\n  link_prev,link_next,key=self.__map.pop(key)\n  link_prev[1]=link_next\n  link_next[0]=link_prev\n  \n def __iter__(self):\n  ''\n  root=self.__root\n  curr=root[1]\n  while curr is not root:\n   yield curr[2]\n   curr=curr[1]\n   \n def __reversed__(self):\n  ''\n  root=self.__root\n  curr=root[0]\n  while curr is not root:\n   yield curr[2]\n   curr=curr[0]\n   \n def clear(self):\n  ''\n  try :\n   for node in self.__map.itervalues():\n    del node[:]\n   root=self.__root\n   root[:]=[root,root,None ]\n   self.__map.clear()\n  except AttributeError:\n   pass\n  dict.clear(self)\n  \n def popitem(self,last=True ):\n  ''\n\n\n  \n  if not self:\n   raise KeyError('dictionary is empty')\n  root=self.__root\n  if last:\n   link=root[0]\n   link_prev=link[0]\n   link_prev[1]=root\n   root[0]=link_prev\n  else :\n   link=root[1]\n   link_next=link[1]\n   root[1]=link_next\n   link_next[0]=root\n  key=link[2]\n  del self.__map[key]\n  value=dict.pop(self,key)\n  return key,value\n  \n  \n  \n def keys(self):\n  ''\n  return list(self)\n  \n def values(self):\n  ''\n  return [self[key]for key in self]\n  \n def items(self):\n  ''\n  return [(key,self[key])for key in self]\n  \n def iterkeys(self):\n  ''\n  return iter(self)\n  \n def itervalues(self):\n  ''\n  for k in self:\n   yield self[k]\n   \n def iteritems(self):\n  ''\n  for k in self:\n   yield (k,self[k])\n   \n def update(*args,**kwds):\n  ''\n\n\n\n\n\n\n  \n  if len(args)>2:\n   raise TypeError('update() takes at most 2 positional '\n   'arguments (%d given)'%(len(args),))\n  elif not args:\n   raise TypeError('update() takes at least 1 argument (0 given)')\n  self=args[0]\n  \n  other=()\n  if len(args)==2:\n   other=args[1]\n  if isinstance(other,dict):\n   for key in other:\n    self[key]=other[key]\n  elif hasattr(other,'keys'):\n   for key in other.keys():\n    self[key]=other[key]\n  else :\n   for key,value in other:\n    self[key]=value\n  for key,value in kwds.items():\n   self[key]=value\n   \n __update=update\n \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n\n  \n  if key in self:\n   result=self[key]\n   del self[key]\n   return result\n  if default is self.__marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self,key,default=None ):\n  ''\n  if key in self:\n   return self[key]\n  self[key]=default\n  return default\n  \n def __repr__(self,_repr_running={}):\n  ''\n  call_key=id(self),_get_ident()\n  if call_key in _repr_running:\n   return '...'\n  _repr_running[call_key]=1\n  try :\n   if not self:\n    return '%s()'%(self.__class__.__name__,)\n   return '%s(%r)'%(self.__class__.__name__,self.items())\n  finally :\n   del _repr_running[call_key]\n   \n def __reduce__(self):\n  ''\n  items=[[k,self[k]]for k in self]\n  inst_dict=vars(self).copy()\n  for k in vars(OrderedDict()):\n   inst_dict.pop(k,None )\n  if inst_dict:\n   return (self.__class__,(items,),inst_dict)\n  return self.__class__,(items,)\n  \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  ''\n\n\n  \n  d=cls()\n  for key in iterable:\n   d[key]=value\n  return d\n  \n def __eq__(self,other):\n  ''\n\n\n  \n  if isinstance(other,OrderedDict):\n   return len(self)==len(other)and self.items()==other.items()\n  return dict.__eq__(self,other)\n  \n def __ne__(self,other):\n  return not self ==other\n", ["dummy_thread", "thread"]], "passlib.Lib.site-packages.passlib.utils.compat": [".py", "''\n\n\n\n\n\n\n\nimport sys\nPY2=sys.version_info <(3,0)\nPY3=sys.version_info >=(3,0)\n\n\nif sys.version_info <(2,6)or (3,0)<=sys.version_info <(3,2):\n raise RuntimeError(\"Passlib requires Python 2.6, 2.7, or >= 3.2 (as of passlib 1.7)\")\n \nPY26=sys.version_info <(2,7)\n\n\n\n\nJYTHON=sys.platform.startswith('java')\n\nPYPY=hasattr(sys,\"pypy_version_info\")\n\nif PYPY and sys.pypy_version_info <(2,0):\n raise RuntimeError(\"passlib requires pypy >= 2.0 (as of passlib 1.7)\")\n \n \n \nPYSTON=\"Pyston\"in sys.version\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\nif PY3:\n import builtins\nelse :\n import __builtin__ as builtins\n \ndef add_doc(obj,doc):\n ''\n obj.__doc__=doc\n \n \n \n \n__all__=[\n\n'PY2','PY3','PY26',\n\n\n'BytesIO','StringIO','NativeStringIO','SafeConfigParser',\n'print_',\n\n\n\n'int_types',\n'num_types',\n'unicode_or_bytes_types',\n'native_string_types',\n\n\n'u',\n'unicode',\n'uascii_to_str','bascii_to_str',\n'str_to_uascii','str_to_bascii',\n'join_unicode','join_bytes',\n'join_byte_values','join_byte_elems',\n'byte_elem_value',\n'iter_byte_values',\n\n\n'irange',\n'imap','lmap',\n'iteritems','itervalues',\n'next',\n\n\n'OrderedDict',\n\n\n'nullcontext',\n\n\n'get_method_function','add_doc',\n]\n\n\n\n_lazy_attrs=dict()\n\n\n\n\nif PY3:\n unicode=str\n \n \n def u(s):\n  assert isinstance(s,str)\n  return s\n  \n unicode_or_bytes_types=(str,bytes)\n native_string_types=(unicode,)\n \nelse :\n unicode=builtins.unicode\n \n def u(s):\n  assert isinstance(s,str)\n  return s.decode(\"unicode_escape\")\n  \n unicode_or_bytes_types=(basestring,)\n native_string_types=(basestring,)\n \n \nunicode_or_bytes=unicode_or_bytes_types\nunicode_or_str=native_string_types\n\n\n\n\n\n\n\n\n\n\njoin_unicode=u('').join\n\n\njoin_bytes=b''.join\n\nif PY3:\n def uascii_to_str(s):\n  assert isinstance(s,unicode)\n  return s\n  \n def bascii_to_str(s):\n  assert isinstance(s,bytes)\n  return s.decode(\"ascii\")\n  \n def str_to_uascii(s):\n  assert isinstance(s,str)\n  return s\n  \n def str_to_bascii(s):\n  assert isinstance(s,str)\n  return s.encode(\"ascii\")\n  \n join_byte_values=join_byte_elems=bytes\n \n def byte_elem_value(elem):\n  assert isinstance(elem,int)\n  return elem\n  \n def iter_byte_values(s):\n  assert isinstance(s,bytes)\n  return s\n  \n def iter_byte_chars(s):\n  assert isinstance(s,bytes)\n  \n  return (bytes([c])for c in s)\n  \nelse :\n def uascii_to_str(s):\n  assert isinstance(s,unicode)\n  return s.encode(\"ascii\")\n  \n def bascii_to_str(s):\n  assert isinstance(s,bytes)\n  return s\n  \n def str_to_uascii(s):\n  assert isinstance(s,str)\n  return s.decode(\"ascii\")\n  \n def str_to_bascii(s):\n  assert isinstance(s,str)\n  return s\n  \n def join_byte_values(values):\n  return join_bytes(chr(v)for v in values)\n  \n join_byte_elems=join_bytes\n \n byte_elem_value=ord\n \n def iter_byte_values(s):\n  assert isinstance(s,bytes)\n  return (ord(c)for c in s)\n  \n def iter_byte_chars(s):\n  assert isinstance(s,bytes)\n  return s\n  \nadd_doc(uascii_to_str,\"helper to convert ascii unicode -> native str\")\nadd_doc(bascii_to_str,\"helper to convert ascii bytes -> native str\")\nadd_doc(str_to_uascii,\"helper to convert ascii native str -> unicode\")\nadd_doc(str_to_bascii,\"helper to convert ascii native str -> bytes\")\n\n\n\n\n\n\n\n\n\nadd_doc(iter_byte_values,\"iterate over byte string as sequence of ints 0-255\")\nadd_doc(iter_byte_chars,\"iterate over byte string as sequence of 1-byte strings\")\n\n\n\n\nif PY3:\n int_types=(int,)\n num_types=(int,float)\nelse :\n int_types=(int,long)\n num_types=(int,long,float)\n \n \n \n \n \n \n \n \n \n \nif PY3:\n irange=range\n \n \n \n def lmap(*a,**k):\n  return list(map(*a,**k))\n imap=map\n \n def iteritems(d):\n  return d.items()\n def itervalues(d):\n  return d.values()\n  \n def nextgetter(obj):\n  return obj.__next__\n  \n izip=zip\n \nelse :\n irange=xrange\n \n \n lmap=map\n from itertools import imap,izip\n \n def iteritems(d):\n  return d.iteritems()\n def itervalues(d):\n  return d.itervalues()\n  \n def nextgetter(obj):\n  return obj.next\n  \nadd_doc(nextgetter,\"return function that yields successive values from iterable\")\n\n\n\n\n\n\n\n\n\n\n\nif PY3:\n method_function_attr=\"__func__\"\nelse :\n method_function_attr=\"im_func\"\n \ndef get_method_function(func):\n ''\n return getattr(func,method_function_attr,func)\n \ndef get_unbound_method_function(func):\n ''\n return func if PY3 else func.__func__\n \ndef error_from(exc,\ncause=None ):\n ''\n\n\n\n \n exc.__cause__=cause\n exc.__suppress_context__=True\n return exc\n \n \nsuppress_cause=error_from\n\n\n\n\nif PY3:\n _lazy_attrs=dict(\n BytesIO=\"io.BytesIO\",\n UnicodeIO=\"io.StringIO\",\n NativeStringIO=\"io.StringIO\",\n SafeConfigParser=\"configparser.ConfigParser\",\n )\n \n print_=getattr(builtins,\"print\")\n \nelse :\n _lazy_attrs=dict(\n BytesIO=\"cStringIO.StringIO\",\n UnicodeIO=\"StringIO.StringIO\",\n NativeStringIO=\"cStringIO.StringIO\",\n SafeConfigParser=\"ConfigParser.SafeConfigParser\",\n )\n \n def print_(*args,**kwds):\n  ''\n  \n  fp=kwds.pop(\"file\",sys.stdout)\n  sep=kwds.pop(\"sep\",None )\n  end=kwds.pop(\"end\",None )\n  if kwds:\n   raise TypeError(\"invalid keyword arguments\")\n   \n   \n  if fp is None :\n   return\n   \n   \n  want_unicode=isinstance(sep,unicode)or isinstance(end,unicode)or\\\n  any(isinstance(arg,unicode)for arg in args)\n  \n  \n  if end is None :\n   end=u(\"\\n\")if want_unicode else \"\\n\"\n  elif not isinstance(end,unicode_or_bytes_types):\n   raise TypeError(\"end must be None or a string\")\n   \n   \n  if sep is None :\n   sep=u(\" \")if want_unicode else \" \"\n  elif not isinstance(sep,unicode_or_bytes_types):\n   raise TypeError(\"sep must be None or a string\")\n   \n   \n  first=True\n  write=fp.write\n  for arg in args:\n   if first:\n    first=False\n   else :\n    write(sep)\n   if not isinstance(arg,basestring):\n    arg=str(arg)\n   write(arg)\n  write(end)\n  \n  \n  \n  \nif PY26:\n _lazy_attrs['OrderedDict']='passlib.utils.compat._ordered_dict.OrderedDict'\nelse :\n _lazy_attrs['OrderedDict']='collections.OrderedDict'\n \n \n \n \n \ntry :\n\n from contextlib import nullcontext\nexcept ImportError:\n\n class nullcontext(object):\n  ''\n\n  \n  def __init__(self,enter_result=None ):\n   self.enter_result=enter_result\n   \n  def __enter__(self):\n   return self.enter_result\n   \n  def __exit__(self,*exc_info):\n   pass\n   \n   \n   \n   \nfrom types import ModuleType\n\ndef _import_object(source):\n ''\n modname,modattr=source.rsplit(\".\",1)\n mod=__import__(modname,fromlist=[modattr],level=0)\n return getattr(mod,modattr)\n \nclass _LazyOverlayModule(ModuleType):\n ''\n\n\n\n\n\n\n\n\n \n \n @classmethod\n def replace_module(cls,name,attrmap):\n  orig=sys.modules[name]\n  self=cls(name,attrmap,orig)\n  sys.modules[name]=self\n  return self\n  \n def __init__(self,name,attrmap,proxy=None ):\n  ModuleType.__init__(self,name)\n  self.__attrmap=attrmap\n  self.__proxy=proxy\n  self.__log=logging.getLogger(name)\n  \n def __getattr__(self,attr):\n  proxy=self.__proxy\n  if proxy and hasattr(proxy,attr):\n   return getattr(proxy,attr)\n  attrmap=self.__attrmap\n  if attr in attrmap:\n   source=attrmap[attr]\n   if callable(source):\n    value=source()\n   else :\n    value=_import_object(source)\n   setattr(self,attr,value)\n   self.__log.debug(\"loaded lazy attr %r: %r\",attr,value)\n   return value\n  raise AttributeError(\"'module' object has no attribute '%s'\"%(attr,))\n  \n def __repr__(self):\n  proxy=self.__proxy\n  if proxy:\n   return repr(proxy)\n  else :\n   return ModuleType.__repr__(self)\n   \n def __dir__(self):\n  attrs=set(dir(self.__class__))\n  attrs.update(self.__dict__)\n  attrs.update(self.__attrmap)\n  proxy=self.__proxy\n  if proxy is not None :\n   attrs.update(dir(proxy))\n  return list(attrs)\n  \n  \n_LazyOverlayModule.replace_module(__name__,_lazy_attrs)\n\n\n\n\n", ["__builtin__", "builtins", "contextlib", "itertools", "logging", "sys", "types"], 1], "passlib.Lib.site-packages.passlib.handlers.django": [".py", "''\n\n\n\n\nfrom base64 import b64encode\nfrom binascii import hexlify\nfrom hashlib import md5,sha1,sha256\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.handlers.bcrypt import _wrapped_bcrypt\nfrom passlib.hash import argon2,bcrypt,pbkdf2_sha1,pbkdf2_sha256\nfrom passlib.utils import to_unicode,rng,getrandstr\nfrom passlib.utils.binary import BASE64_CHARS\nfrom passlib.utils.compat import str_to_uascii,uascii_to_str,unicode,u\nfrom passlib.crypto.digest import pbkdf2_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"django_salted_sha1\",\n\"django_salted_md5\",\n\"django_bcrypt\",\n\"django_pbkdf2_sha1\",\n\"django_pbkdf2_sha256\",\n\"django_argon2\",\n\"django_des_crypt\",\n\"django_disabled\",\n]\n\n\n\n\n\n\ndes_crypt=None\n\ndef _import_des_crypt():\n global des_crypt\n if des_crypt is None :\n  from passlib.hash import des_crypt\n return des_crypt\n \n \nSALT_CHARS='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n\n\n\nclass DjangoSaltedHash(uh.HasSalt,uh.GenericHandler):\n ''\n \n \n setting_kwds=(\"salt\",\"salt_size\")\n \n \n \n \n \n default_salt_size=12\n max_salt_size=None\n salt_chars=SALT_CHARS\n \n checksum_chars=uh.LOWER_HEX_CHARS\n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc2(self.ident,self.salt,self.checksum)\n  \n  \nclass DjangoVariableHash(uh.HasRounds,DjangoSaltedHash):\n ''\n setting_kwds=DjangoSaltedHash.setting_kwds+(\"rounds\",)\n \n min_rounds=1\n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc3(self.ident,self.rounds,self.salt,self.checksum)\n  \nclass django_salted_sha1(DjangoSaltedHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_salted_sha1\"\n django_name=\"sha1\"\n ident=u(\"sha1$\")\n checksum_size=40\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(sha1(self.salt.encode(\"ascii\")+secret).hexdigest())\n  \nclass django_salted_md5(DjangoSaltedHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_salted_md5\"\n django_name=\"md5\"\n ident=u(\"md5$\")\n checksum_size=32\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(md5(self.salt.encode(\"ascii\")+secret).hexdigest())\n  \n  \n  \n  \n  \ndjango_bcrypt=uh.PrefixWrapper(\"django_bcrypt\",bcrypt,\nprefix=u('bcrypt$'),ident=u(\"bcrypt$\"),\n\n\ndoc=\"\"\"This class implements Django 1.4's BCrypt wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!bcrypt` itself, but with\n    the Django-specific prefix ``\"bcrypt$\"`` prepended.\n\n    See :doc:`/lib/passlib.hash.bcrypt` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.4's :class:`!BCryptPasswordHasher` class.\n\n    .. versionadded:: 1.6\n    \"\"\")\ndjango_bcrypt.django_name=\"bcrypt\"\ndjango_bcrypt._using_clone_attrs +=(\"django_name\",)\n\n\n\n\n\nclass django_bcrypt_sha256(_wrapped_bcrypt):\n ''\n\n\n\n\n\n\n\n\n \n name=\"django_bcrypt_sha256\"\n django_name=\"bcrypt_sha256\"\n _digest=sha256\n \n \n \n \n \n \n django_prefix=u('bcrypt_sha256$')\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  if not hash:\n   return False\n  return hash.startswith(cls.django_prefix)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if not hash.startswith(cls.django_prefix):\n   raise uh.exc.InvalidHashError(cls)\n  bhash=hash[len(cls.django_prefix):]\n  if not bhash.startswith(\"$2\"):\n   raise uh.exc.MalformedHashError(cls)\n  return super(django_bcrypt_sha256,cls).from_string(bhash)\n  \n def to_string(self):\n  bhash=super(django_bcrypt_sha256,self).to_string()\n  return uascii_to_str(self.django_prefix)+bhash\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  secret=hexlify(self._digest(secret).digest())\n  return super(django_bcrypt_sha256,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \nclass django_pbkdf2_sha256(DjangoVariableHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_pbkdf2_sha256\"\n django_name=\"pbkdf2_sha256\"\n ident=u('pbkdf2_sha256$')\n min_salt_size=1\n max_rounds=0xffffffff\n checksum_chars=uh.PADDED_BASE64_CHARS\n checksum_size=44\n default_rounds=pbkdf2_sha256.default_rounds\n _digest=\"sha256\"\n \n def _calc_checksum(self,secret):\n \n  hash=pbkdf2_hmac(self._digest,secret,self.salt,self.rounds)\n  return b64encode(hash).rstrip().decode(\"ascii\")\n  \nclass django_pbkdf2_sha1(django_pbkdf2_sha256):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_pbkdf2_sha1\"\n django_name=\"pbkdf2_sha1\"\n ident=u('pbkdf2_sha1$')\n checksum_size=28\n default_rounds=pbkdf2_sha1.default_rounds\n _digest=\"sha1\"\n \n \n \n \n \n \n \n \ndjango_argon2=uh.PrefixWrapper(\nname=\"django_argon2\",\nwrapped=argon2.using(type=\"I\"),\nprefix=u('argon2'),\nident=u('argon2$argon2i$'),\n\n\ndoc=\"\"\"This class implements Django 1.10's Argon2 wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!argon2` itself, but with\n    the Django-specific prefix ``\"argon2$\"`` prepended.\n\n    See :doc:`argon2 </lib/passlib.hash.argon2>` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.10's :class:`!Argon2PasswordHasher` class.\n\n    .. versionadded:: 1.7\n    \"\"\")\ndjango_argon2.django_name=\"argon2\"\ndjango_argon2._using_clone_attrs +=(\"django_name\",)\n\n\n\n\nclass django_des_crypt(uh.TruncateMixin,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_des_crypt\"\n django_name=\"crypt\"\n setting_kwds=(\"salt\",\"salt_size\",\"truncate_error\")\n ident=u(\"crypt$\")\n checksum_chars=salt_chars=uh.HASH64_CHARS\n checksum_size=11\n min_salt_size=default_salt_size=2\n truncate_size=8\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n use_duplicate_salt=True\n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  if chk:\n  \n   if not salt:\n   \n   \n    salt=chk[:2]\n   elif salt[:2]!=chk[:2]:\n   \n   \n   \n    raise uh.exc.MalformedHashError(cls,\n    \"first two digits of salt and checksum must match\")\n    \n   chk=chk[2:]\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=self.salt\n  chk=salt[:2]+self.checksum\n  if self.use_duplicate_salt:\n  \n   return uh.render_mc2(self.ident,salt,chk)\n  else :\n  \n   return uh.render_mc2(self.ident,\"\",chk)\n   \n def _calc_checksum(self,secret):\n \n \n  global des_crypt\n  if des_crypt is None :\n   _import_des_crypt()\n   \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n  return des_crypt(salt=self.salt[:2])._calc_checksum(secret)\n  \nclass django_disabled(uh.ifc.DisabledHash,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_disabled\"\n _hash_prefix=u(\"!\")\n suffix_length=40\n \n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return hash.startswith(cls._hash_prefix)\n  \n def _calc_checksum(self,secret):\n \n  return getrandstr(rng,BASE64_CHARS[:-2],self.suffix_length)\n  \n @classmethod\n def verify(cls,secret,hash):\n  uh.validate_secret(secret)\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return False\n  \n  \n  \n  \n", ["base64", "binascii", "hashlib", "logging", "passlib.crypto.digest", "passlib.handlers.bcrypt", "passlib.hash", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.misc": [".py", "''\n\n\n\n\n\nimport sys\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_native_str,str_consteq\nfrom passlib.utils.compat import unicode,u,unicode_or_bytes_types\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"unix_disabled\",\n\"unix_fallback\",\n\"plaintext\",\n]\n\n\n\n\nclass unix_fallback(uh.ifc.DisabledHash,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"unix_fallback\"\n context_kwds=(\"enable_wildcard\",)\n \n @classmethod\n def identify(cls,hash):\n  if isinstance(hash,unicode_or_bytes_types):\n   return True\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n   \n def __init__(self,enable_wildcard=False ,**kwds):\n  warn(\"'unix_fallback' is deprecated, \"\n  \"and will be removed in Passlib 1.8; \"\n  \"please use 'unix_disabled' instead.\",\n  DeprecationWarning)\n  super(unix_fallback,self).__init__(**kwds)\n  self.enable_wildcard=enable_wildcard\n  \n def _calc_checksum(self,secret):\n  if self.checksum:\n  \n  \n   return self.checksum\n  else :\n   return u(\"!\")\n   \n @classmethod\n def verify(cls,secret,hash,enable_wildcard=False ):\n  uh.validate_secret(secret)\n  if not isinstance(hash,unicode_or_bytes_types):\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n  elif hash:\n   return False\n  else :\n   return enable_wildcard\n   \n_MARKER_CHARS=u(\"*!\")\n_MARKER_BYTES=b\"*!\"\n\nclass unix_disabled(uh.ifc.DisabledHash,uh.MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"unix_disabled\"\n setting_kwds=(\"marker\",)\n context_kwds=()\n \n _disable_prefixes=tuple(str(_MARKER_CHARS))\n \n \n if 'bsd'in sys.platform:\n  default_marker=u(\"*\")\n else :\n \n \n \n  default_marker=u(\"!\")\n  \n @classmethod\n def using(cls,marker=None ,**kwds):\n  subcls=super(unix_disabled,cls).using(**kwds)\n  if marker is not None :\n   if not cls.identify(marker):\n    raise ValueError(\"invalid marker: %r\"%marker)\n   subcls.default_marker=marker\n  return subcls\n  \n @classmethod\n def identify(cls,hash):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  if isinstance(hash,unicode):\n   start=_MARKER_CHARS\n  elif isinstance(hash,bytes):\n   start=_MARKER_BYTES\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n  return not hash or hash[0]in start\n  \n @classmethod\n def verify(cls,secret,hash):\n  uh.validate_secret(secret)\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return False\n  \n @classmethod\n def hash(cls,secret,**kwds):\n  if kwds:\n   uh.warn_hash_settings_deprecation(cls,kwds)\n   return cls.using(**kwds).hash(secret)\n  uh.validate_secret(secret)\n  marker=cls.default_marker\n  assert marker and cls.identify(marker)\n  return to_native_str(marker,param=\"marker\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,marker=None ):\n  if not cls.identify(config):\n   raise uh.exc.InvalidHashError(cls)\n  elif config:\n  \n   uh.validate_secret(secret)\n   return to_native_str(config,param=\"config\")\n  else :\n   if marker is not None :\n    cls=cls.using(marker=marker)\n   return cls.hash(secret)\n   \n @classmethod\n def disable(cls,hash=None ):\n  out=cls.hash(\"\")\n  if hash is not None :\n   hash=to_native_str(hash,param=\"hash\")\n   if cls.identify(hash):\n   \n    hash=cls.enable(hash)\n   if hash:\n    out +=hash\n  return out\n  \n @classmethod\n def enable(cls,hash):\n  hash=to_native_str(hash,param=\"hash\")\n  for prefix in cls._disable_prefixes:\n   if hash.startswith(prefix):\n    orig=hash[len(prefix):]\n    if orig:\n     return orig\n    else :\n     raise ValueError(\"cannot restore original hash\")\n  raise uh.exc.InvalidHashError(cls)\n  \nclass plaintext(uh.MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n name=\"plaintext\"\n setting_kwds=()\n context_kwds=(\"encoding\",)\n default_encoding=\"utf-8\"\n \n @classmethod\n def identify(cls,hash):\n  if isinstance(hash,unicode_or_bytes_types):\n   return True\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n   \n @classmethod\n def hash(cls,secret,encoding=None ):\n  uh.validate_secret(secret)\n  if not encoding:\n   encoding=cls.default_encoding\n  return to_native_str(secret,encoding,\"secret\")\n  \n @classmethod\n def verify(cls,secret,hash,encoding=None ):\n  if not encoding:\n   encoding=cls.default_encoding\n  hash=to_native_str(hash,encoding,\"hash\")\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return str_consteq(cls.hash(secret,encoding),hash)\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n  return cls.hash(\"\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,encoding=None ):\n \n  if not cls.identify(config):\n   raise uh.exc.InvalidHashError(cls)\n  return cls.hash(secret,encoding=encoding)\n  \n  \n  \n  \n", ["logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "sys", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.mssql": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import consteq\nfrom passlib.utils.compat import bascii_to_str,unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"mssql2000\",\n\"mssql2005\",\n]\n\n\n\n\ndef _raw_mssql(secret,salt):\n assert isinstance(secret,unicode)\n assert isinstance(salt,bytes)\n return sha1(secret.encode(\"utf-16-le\")+salt).digest()\n \nBIDENT=b\"0x0100\"\n\nUIDENT=u(\"0x0100\")\n\ndef _ident_mssql(hash,csize,bsize):\n ''\n if isinstance(hash,unicode):\n  if len(hash)==csize and hash.startswith(UIDENT):\n   return True\n elif isinstance(hash,bytes):\n  if len(hash)==csize and hash.startswith(BIDENT):\n   return True\n   \n   \n else :\n  raise uh.exc.ExpectedStringError(hash,\"hash\")\n return False\n \ndef _parse_mssql(hash,csize,bsize,handler):\n ''\n if isinstance(hash,unicode):\n  if len(hash)==csize and hash.startswith(UIDENT):\n   try :\n    return unhexlify(hash[6:].encode(\"utf-8\"))\n   except TypeError:\n    pass\n elif isinstance(hash,bytes):\n \n  assert isinstance(hash,bytes)\n  if len(hash)==csize and hash.startswith(BIDENT):\n   try :\n    return unhexlify(hash[6:])\n   except TypeError:\n    pass\n    \n    \n else :\n  raise uh.exc.ExpectedStringError(hash,\"hash\")\n raise uh.exc.InvalidHashError(handler)\n \nclass mssql2000(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"mssql2000\"\n setting_kwds=(\"salt\",)\n checksum_size=40\n min_salt_size=max_salt_size=4\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def identify(cls,hash):\n  return _ident_mssql(hash,94,46)\n  \n @classmethod\n def from_string(cls,hash):\n  data=_parse_mssql(hash,94,46,cls)\n  return cls(salt=data[:4],checksum=data[4:])\n  \n def to_string(self):\n  raw=self.salt+self.checksum\n  \n  return \"0x0100\"+bascii_to_str(hexlify(raw).upper())\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  salt=self.salt\n  return _raw_mssql(secret,salt)+_raw_mssql(secret.upper(),salt)\n  \n @classmethod\n def verify(cls,secret,hash):\n \n \n  uh.validate_secret(secret)\n  self=cls.from_string(hash)\n  chk=self.checksum\n  if chk is None :\n   raise uh.exc.MissingDigestError(cls)\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  result=_raw_mssql(secret.upper(),self.salt)\n  return consteq(result,chk[20:])\n  \n  \n  \n  \nclass mssql2005(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"mssql2005\"\n setting_kwds=(\"salt\",)\n \n checksum_size=20\n min_salt_size=max_salt_size=4\n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def identify(cls,hash):\n  return _ident_mssql(hash,54,26)\n  \n @classmethod\n def from_string(cls,hash):\n  data=_parse_mssql(hash,54,26,cls)\n  return cls(salt=data[:4],checksum=data[4:])\n  \n def to_string(self):\n  raw=self.salt+self.checksum\n  \n  return \"0x0100\"+bascii_to_str(hexlify(raw)).upper()\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  return _raw_mssql(secret,self.salt)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.md5_crypt": [".py", "''\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt,repeat_string\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"md5_crypt\",\n\"apr_md5_crypt\",\n]\n\n\n\n\n_BNULL=b\"\\x00\"\n_MD5_MAGIC=b\"$1$\"\n_APR_MAGIC=b\"$apr1$\"\n\n\n\n\n\n\n\n\n\n_c_digest_offsets=(\n(0,3),(5,1),(5,3),(1,2),(5,1),(5,3),(1,3),\n(4,1),(5,3),(1,3),(5,0),(5,3),(1,3),(5,1),\n(4,3),(1,3),(5,1),(5,2),(1,3),(5,1),(5,3),\n)\n\n\n_transpose_map=(12,6,0,13,7,1,14,8,2,15,9,3,5,10,4,11)\n\ndef _raw_md5_crypt(pwd,salt,use_apr=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n if isinstance(pwd,unicode):\n  pwd=pwd.encode(\"utf-8\")\n assert isinstance(pwd,bytes),\"pwd not unicode or bytes\"\n if _BNULL in pwd:\n  raise uh.exc.NullPasswordError(md5_crypt)\n pwd_len=len(pwd)\n \n \n assert isinstance(salt,unicode),\"salt not unicode\"\n salt=salt.encode(\"ascii\")\n assert len(salt)<9,\"salt too large\"\n \n \n \n \n \n if use_apr:\n  magic=_APR_MAGIC\n else :\n  magic=_MD5_MAGIC\n  \n  \n  \n  \n db=md5(pwd+salt+pwd).digest()\n \n \n \n \n \n a_ctx=md5(pwd+magic+salt)\n a_ctx_update=a_ctx.update\n \n \n a_ctx_update(repeat_string(db,pwd_len))\n \n \n \n \n \n \n i=pwd_len\n evenchar=pwd[:1]\n while i:\n  a_ctx_update(_BNULL if i&1 else evenchar)\n  i >>=1\n  \n  \n da=a_ctx.digest()\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n pwd_pwd=pwd+pwd\n pwd_salt=pwd+salt\n perms=[pwd,pwd_pwd,pwd_salt,pwd_salt+pwd,salt+pwd,salt+pwd_pwd]\n \n \n \n data=[(perms[even],perms[odd])for even,odd in _c_digest_offsets]\n \n \n dc=da\n blocks=23\n while blocks:\n  for even,odd in data:\n   dc=md5(odd+md5(dc+even).digest()).digest()\n  blocks -=1\n  \n  \n for even,odd in data[:17]:\n  dc=md5(odd+md5(dc+even).digest()).digest()\n  \n  \n  \n  \n return h64.encode_transposed_bytes(dc,_transpose_map).decode(\"ascii\")\n \n \n \n \nclass _MD5_Common(uh.HasSalt,uh.GenericHandler):\n ''\n \n \n \n \n setting_kwds=(\"salt\",\"salt_size\")\n \n checksum_size=22\n checksum_chars=uh.HASH64_CHARS\n \n max_salt_size=8\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc2(self.ident,self.salt,self.checksum)\n  \n  \n  \n  \n  \n  \n  \nclass md5_crypt(uh.HasManyBackends,_MD5_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"md5_crypt\"\n ident=u(\"$1$\")\n \n \n \n \n \n \n \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'$1$test$pi/xDtU5WFVRqYS6BMU8X/'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.ident+self.salt\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config)or len(hash)!=len(config)+23:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-22:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_md5_crypt(secret,self.salt)\n  \n  \n  \n  \n  \nclass apr_md5_crypt(_MD5_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"apr_md5_crypt\"\n ident=u(\"$apr1$\")\n \n \n \n \n def _calc_checksum(self,secret):\n  return _raw_md5_crypt(secret,self.salt,use_apr=True )\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.sun_md5_crypt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import md5\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_unicode\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import byte_elem_value,irange,u,\\\nuascii_to_str,unicode,str_to_bascii\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"sun_md5_crypt\",\n]\n\n\n\n\n\n\n\n\nMAGIC_HAMLET=(\nb\"To be, or not to be,--that is the question:--\\n\"\nb\"Whether 'tis nobler in the mind to suffer\\n\"\nb\"The slings and arrows of outrageous fortune\\n\"\nb\"Or to take arms against a sea of troubles,\\n\"\nb\"And by opposing end them?--To die,--to sleep,--\\n\"\nb\"No more; and by a sleep to say we end\\n\"\nb\"The heartache, and the thousand natural shocks\\n\"\nb\"That flesh is heir to,--'tis a consummation\\n\"\nb\"Devoutly to be wish'd. To die,--to sleep;--\\n\"\nb\"To sleep! perchance to dream:--ay, there's the rub;\\n\"\nb\"For in that sleep of death what dreams may come,\\n\"\nb\"When we have shuffled off this mortal coil,\\n\"\nb\"Must give us pause: there's the respect\\n\"\nb\"That makes calamity of so long life;\\n\"\nb\"For who would bear the whips and scorns of time,\\n\"\nb\"The oppressor's wrong, the proud man's contumely,\\n\"\nb\"The pangs of despis'd love, the law's delay,\\n\"\nb\"The insolence of office, and the spurns\\n\"\nb\"That patient merit of the unworthy takes,\\n\"\nb\"When he himself might his quietus make\\n\"\nb\"With a bare bodkin? who would these fardels bear,\\n\"\nb\"To grunt and sweat under a weary life,\\n\"\nb\"But that the dread of something after death,--\\n\"\nb\"The undiscover'd country, from whose bourn\\n\"\nb\"No traveller returns,--puzzles the will,\\n\"\nb\"And makes us rather bear those ills we have\\n\"\nb\"Than fly to others that we know not of?\\n\"\nb\"Thus conscience does make cowards of us all;\\n\"\nb\"And thus the native hue of resolution\\n\"\nb\"Is sicklied o'er with the pale cast of thought;\\n\"\nb\"And enterprises of great pith and moment,\\n\"\nb\"With this regard, their currents turn awry,\\n\"\nb\"And lose the name of action.--Soft you now!\\n\"\nb\"The fair Ophelia!--Nymph, in thy orisons\\n\"\nb\"Be all my sins remember'd.\\n\\x00\"\n)\n\n\nxr=irange(7)\n_XY_ROUNDS=[\ntuple((i,i,i+3)for i in xr),\ntuple((i,i+1,i+4)for i in xr),\ntuple((i,i+8,(i+11)&15)for i in xr),\ntuple((i,(i+9)&15,(i+12)&15)for i in xr),\n]\ndel xr\n\ndef raw_sun_md5_crypt(secret,rounds,salt):\n ''\n global MAGIC_HAMLET\n assert isinstance(secret,bytes)\n assert isinstance(salt,bytes)\n \n \n if rounds <=0:\n  rounds=0\n real_rounds=4096+rounds\n \n \n \n \n result=md5(secret+salt).digest()\n assert len(result)==16\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n X_ROUNDS_0,X_ROUNDS_1,Y_ROUNDS_0,Y_ROUNDS_1=_XY_ROUNDS\n \n \n \n round=0\n while round <real_rounds:\n \n  rval=[byte_elem_value(c)for c in result].__getitem__\n  \n  \n  x=0\n  xrounds=X_ROUNDS_1 if (rval((round >>3)&15)>>(round&7))&1 else X_ROUNDS_0\n  for i,ia,ib in xrounds:\n   a=rval(ia)\n   b=rval(ib)\n   v=rval((a >>(b %5))&15)>>((b >>(a&7))&1)\n   x |=((rval((v >>3)&15)>>(v&7))&1)<<i\n   \n   \n  y=0\n  yrounds=Y_ROUNDS_1 if (rval(((round+64)>>3)&15)>>(round&7))&1 else Y_ROUNDS_0\n  for i,ia,ib in yrounds:\n   a=rval(ia)\n   b=rval(ib)\n   v=rval((a >>(b %5))&15)>>((b >>(a&7))&1)\n   y |=((rval((v >>3)&15)>>(v&7))&1)<<i\n   \n   \n  coin=((rval(x >>3)>>(x&7))^(rval(y >>3)>>(y&7)))&1\n  \n  \n  h=md5(result)\n  if coin:\n   h.update(MAGIC_HAMLET)\n  h.update(unicode(round).encode(\"ascii\"))\n  result=h.digest()\n  \n  round +=1\n  \n  \n return h64.encode_transposed_bytes(result,_chk_offsets)\n \n \n_chk_offsets=(\n12,6,0,\n13,7,1,\n14,8,2,\n15,9,3,\n5,10,4,\n11,\n)\n\n\n\n\nclass sun_md5_crypt(uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"sun_md5_crypt\"\n setting_kwds=(\"salt\",\"rounds\",\"bare_salt\",\"salt_size\")\n checksum_chars=uh.HASH64_CHARS\n checksum_size=22\n \n \n \n \n \n \n default_salt_size=8\n max_salt_size=None\n salt_chars=uh.HASH64_CHARS\n \n default_rounds=34000\n min_rounds=0\n max_rounds=4294963199\n \n rounds_cost=\"linear\"\n \n ident_values=(u(\"$md5$\"),u(\"$md5,\"))\n \n \n \n \n bare_salt=False\n \n \n \n \n def __init__(self,bare_salt=False ,**kwds):\n  self.bare_salt=bare_salt\n  super(sun_md5_crypt,self).__init__(**kwds)\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return hash.startswith(cls.ident_values)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  \n  \n  \n  \n  \n  \n  if hash.startswith(u(\"$md5$\")):\n   rounds=0\n   salt_idx=5\n  elif hash.startswith(u(\"$md5,rounds=\")):\n   idx=hash.find(u(\"$\"),12)\n   if idx ==-1:\n    raise uh.exc.MalformedHashError(cls,\"unexpected end of rounds\")\n   rstr=hash[12:idx]\n   try :\n    rounds=int(rstr)\n   except ValueError:\n    raise uh.exc.MalformedHashError(cls,\"bad rounds\")\n   if rstr !=unicode(rounds):\n    raise uh.exc.ZeroPaddedRoundsError(cls)\n   if rounds ==0:\n   \n   \n   \n    raise uh.exc.MalformedHashError(cls,\"explicit zero rounds\")\n   salt_idx=idx+1\n  else :\n   raise uh.exc.InvalidHashError(cls)\n   \n   \n   \n   \n   \n   \n  chk_idx=hash.rfind(u(\"$\"),salt_idx)\n  if chk_idx ==-1:\n  \n   salt=hash[salt_idx:]\n   chk=None\n   bare_salt=True\n  elif chk_idx ==len(hash)-1:\n   if chk_idx >salt_idx and hash[-2]==u(\"$\"):\n    raise uh.exc.MalformedHashError(cls,\"too many '$' separators\")\n    \n   salt=hash[salt_idx:-1]\n   chk=None\n   bare_salt=False\n  elif chk_idx >0 and hash[chk_idx -1]==u(\"$\"):\n  \n   salt=hash[salt_idx:chk_idx -1]\n   chk=hash[chk_idx+1:]\n   bare_salt=False\n  else :\n  \n   salt=hash[salt_idx:chk_idx]\n   chk=hash[chk_idx+1:]\n   bare_salt=True\n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk,\n  bare_salt=bare_salt,\n  )\n  \n def to_string(self,_withchk=True ):\n  ss=u('')if self.bare_salt else u('$')\n  rounds=self.rounds\n  if rounds >0:\n   hash=u(\"$md5,rounds=%d$%s%s\")%(rounds,self.salt,ss)\n  else :\n   hash=u(\"$md5$%s%s\")%(self.salt,ss)\n  if _withchk:\n   chk=self.checksum\n   hash=u(\"%s$%s\")%(hash,chk)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  config=str_to_bascii(self.to_string(_withchk=False ))\n  return raw_sun_md5_crypt(secret,self.rounds,config).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.phpass": [".py", "''\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import u,uascii_to_str,unicode\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"phpass\",\n]\n\n\n\n\nclass phpass(uh.HasManyIdents,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"phpass\"\n setting_kwds=(\"salt\",\"rounds\",\"ident\")\n checksum_chars=uh.HASH64_CHARS\n \n \n min_salt_size=max_salt_size=8\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=19\n min_rounds=7\n max_rounds=30\n rounds_cost=\"log2\"\n \n \n default_ident=u(\"$P$\")\n ident_values=(u(\"$P$\"),u(\"$H$\"))\n ident_aliases={u(\"P\"):u(\"$P$\"),u(\"H\"):u(\"$H$\")}\n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  ident,data=cls._parse_ident(hash)\n  rounds,salt,chk=data[0],data[1:9],data[9:]\n  return cls(\n  ident=ident,\n  rounds=h64.decode_int6(rounds.encode(\"ascii\")),\n  salt=salt,\n  checksum=chk or None ,\n  )\n  \n def to_string(self):\n  hash=u(\"%s%s%s%s\")%(self.ident,\n  h64.encode_int6(self.rounds).decode(\"ascii\"),\n  self.salt,\n  self.checksum or u(''))\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  real_rounds=1 <<self.rounds\n  result=md5(self.salt.encode(\"ascii\")+secret).digest()\n  r=0\n  while r <real_rounds:\n   result=md5(result+secret).digest()\n   r +=1\n  return h64.encode_bytes(result).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.roundup": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nimport passlib.utils.handlers as uh\nfrom passlib.utils.compat import u\n\n__all__=[\n\"roundup_plaintext\",\n\"ldap_hex_md5\",\n\"ldap_hex_sha1\",\n]\n\n\n\nroundup_plaintext=uh.PrefixWrapper(\"roundup_plaintext\",\"plaintext\",\nprefix=u(\"{plaintext}\"),lazy=True )\n\n\nldap_hex_md5=uh.PrefixWrapper(\"ldap_hex_md5\",\"hex_md5\",u(\"{MD5}\"),lazy=True )\nldap_hex_sha1=uh.PrefixWrapper(\"ldap_hex_sha1\",\"hex_sha1\",u(\"{SHA}\"),lazy=True )\n\n\n\n\n", ["logging", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.sha2_crypt": [".py", "''\n\n\n\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt,\\\nrepeat_string,to_unicode\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import byte_elem_value,u,\\\nuascii_to_str,unicode\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"sha512_crypt\",\n\"sha256_crypt\",\n]\n\n\n\n\n\n_BNULL=b'\\x00'\n\n\n\n\n\n\n\n\n\n_c_digest_offsets=(\n(0,3),(5,1),(5,3),(1,2),(5,1),(5,3),(1,3),\n(4,1),(5,3),(1,3),(5,0),(5,3),(1,3),(5,1),\n(4,3),(1,3),(5,1),(5,2),(1,3),(5,1),(5,3),\n)\n\n\n_256_transpose_map=(\n20,10,0,11,1,21,2,22,12,23,13,3,14,4,24,5,\n25,15,26,16,6,17,7,27,8,28,18,29,19,9,30,31,\n)\n\n\n_512_transpose_map=(\n42,21,0,1,43,22,23,2,44,45,24,3,4,46,25,26,\n5,47,48,27,6,7,49,28,29,8,50,51,30,9,10,52,\n31,32,11,53,54,33,12,13,55,34,35,14,56,57,36,15,\n16,58,37,38,17,59,60,39,18,19,61,40,41,20,62,63,\n)\n\ndef _raw_sha2_crypt(pwd,salt,rounds,use_512=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n if isinstance(pwd,unicode):\n \n  pwd=pwd.encode(\"utf-8\")\n assert isinstance(pwd,bytes)\n if _BNULL in pwd:\n  raise uh.exc.NullPasswordError(sha512_crypt if use_512 else sha256_crypt)\n pwd_len=len(pwd)\n \n \n assert 1000 <=rounds <=999999999,\"invalid rounds\"\n \n \n \n \n \n assert isinstance(salt,unicode),\"salt not unicode\"\n salt=salt.encode(\"ascii\")\n salt_len=len(salt)\n assert salt_len <17,\"salt too large\"\n \n \n \n \n \n if use_512:\n  hash_const=hashlib.sha512\n  transpose_map=_512_transpose_map\n else :\n  hash_const=hashlib.sha256\n  transpose_map=_256_transpose_map\n  \n  \n  \n  \n db=hash_const(pwd+salt+pwd).digest()\n \n \n \n \n \n a_ctx=hash_const(pwd+salt)\n a_ctx_update=a_ctx.update\n \n \n a_ctx_update(repeat_string(db,pwd_len))\n \n \n i=pwd_len\n while i:\n  a_ctx_update(db if i&1 else pwd)\n  i >>=1\n  \n  \n da=a_ctx.digest()\n \n \n \n \n \n if pwd_len <96:\n \n \n  dp=repeat_string(hash_const(pwd *pwd_len).digest(),pwd_len)\n else :\n \n  tmp_ctx=hash_const(pwd)\n  tmp_ctx_update=tmp_ctx.update\n  i=pwd_len -1\n  while i:\n   tmp_ctx_update(pwd)\n   i -=1\n  dp=repeat_string(tmp_ctx.digest(),pwd_len)\n assert len(dp)==pwd_len\n \n \n \n \n ds=hash_const(salt *(16+byte_elem_value(da[0]))).digest()[:salt_len]\n assert len(ds)==salt_len,\"salt_len somehow > hash_len!\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n dp_dp=dp+dp\n dp_ds=dp+ds\n perms=[dp,dp_dp,dp_ds,dp_ds+dp,ds+dp,ds+dp_dp]\n \n \n \n data=[(perms[even],perms[odd])for even,odd in _c_digest_offsets]\n \n \n dc=da\n blocks,tail=divmod(rounds,42)\n while blocks:\n  for even,odd in data:\n   dc=hash_const(odd+hash_const(dc+even).digest()).digest()\n  blocks -=1\n  \n  \n if tail:\n \n  pairs=tail >>1\n  for even,odd in data[:pairs]:\n   dc=hash_const(odd+hash_const(dc+even).digest()).digest()\n   \n   \n   \n  if tail&1:\n   dc=hash_const(dc+data[pairs][0]).digest()\n   \n   \n   \n   \n return h64.encode_transposed_bytes(dc,transpose_map).decode(\"ascii\")\n \n \n \n \n_UROUNDS=u(\"rounds=\")\n_UDOLLAR=u(\"$\")\n_UZERO=u(\"0\")\n\nclass _SHA2_Common(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,\nuh.GenericHandler):\n ''\n \n \n \n \n setting_kwds=(\"salt\",\"rounds\",\"implicit_rounds\",\"salt_size\")\n \n checksum_chars=uh.HASH64_CHARS\n \n \n max_salt_size=16\n salt_chars=uh.HASH64_CHARS\n \n min_rounds=1000\n max_rounds=999999999\n rounds_cost=\"linear\"\n \n _cdb_use_512=False\n _rounds_prefix=None\n \n \n \n \n implicit_rounds=False\n \n def __init__(self,implicit_rounds=None ,**kwds):\n  super(_SHA2_Common,self).__init__(**kwds)\n  \n  if implicit_rounds is None :\n   implicit_rounds=(self.use_defaults and self.rounds ==5000)\n  self.implicit_rounds=implicit_rounds\n  \n def _parse_salt(self,salt):\n \n  return self._norm_salt(salt,relaxed=self.checksum is None )\n  \n def _parse_rounds(self,rounds):\n \n  return self._norm_rounds(rounds,relaxed=self.checksum is None )\n  \n @classmethod\n def from_string(cls,hash):\n \n \n \n \n \n \n \n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  ident=cls.ident\n  if not hash.startswith(ident):\n   raise uh.exc.InvalidHashError(cls)\n  assert len(ident)==3\n  parts=hash[3:].split(_UDOLLAR)\n  \n  \n  if parts[0].startswith(_UROUNDS):\n   assert len(_UROUNDS)==7\n   rounds=parts.pop(0)[7:]\n   if rounds.startswith(_UZERO)and rounds !=_UZERO:\n    raise uh.exc.ZeroPaddedRoundsError(cls)\n   rounds=int(rounds)\n   implicit_rounds=False\n  else :\n   rounds=5000\n   implicit_rounds=True\n   \n   \n  if len(parts)==2:\n   salt,chk=parts\n  elif len(parts)==1:\n   salt=parts[0]\n   chk=None\n  else :\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk or None ,\n  implicit_rounds=implicit_rounds,\n  )\n  \n def to_string(self):\n  if self.rounds ==5000 and self.implicit_rounds:\n   hash=u(\"%s%s$%s\")%(self.ident,self.salt,\n   self.checksum or u(''))\n  else :\n   hash=u(\"%srounds=%d$%s$%s\")%(self.ident,self.rounds,\n   self.salt,self.checksum or u(''))\n  return uascii_to_str(hash)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n \n \n _test_hash=None\n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(*cls._test_hash):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string()\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n   \n   \n  cs=self.checksum_size\n  if not hash.startswith(self.ident)or hash[-cs -1]!=_UDOLLAR:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-cs:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_sha2_crypt(secret,self.salt,self.rounds,\n  self._cdb_use_512)\n  \n  \n  \n  \n  \nclass sha256_crypt(_SHA2_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"sha256_crypt\"\n ident=u(\"$5$\")\n checksum_size=43\n \n default_rounds=535000\n \n \n \n \n _test_hash=(\"test\",\"$5$rounds=1000$test$QmQADEXMG8POI5W\"\n \"Dsaeho0P36yK3Tcrgboabng6bkb/\")\n \n \n \n \n \n \n \n \nclass sha512_crypt(_SHA2_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"sha512_crypt\"\n ident=u(\"$6$\")\n checksum_size=86\n _cdb_use_512=True\n \n default_rounds=656000\n \n \n \n \n _test_hash=(\"test\",\"$6$rounds=1000$test$2M/Lx6Mtobqj\"\n \"Ljobw0Wmo4Q5OFx5nVLJvmgseatA6oMn\"\n \"yWeBdRDx4DU.1H3eGmse6pgsOgDisWBG\"\n \"I5c7TZauS0\")\n \n \n \n \n \n \n \n \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.argon2": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nimport logging\nlog=logging.getLogger(__name__)\nimport re\nimport types\nfrom warnings import warn\n\n_argon2_cffi=None\n_argon2pure=None\n\nfrom passlib import exc\nfrom passlib.crypto.digest import MAX_UINT32\nfrom passlib.utils import classproperty,to_bytes,render_bytes\nfrom passlib.utils.binary import b64s_encode,b64s_decode\nfrom passlib.utils.compat import u,unicode,bascii_to_str,uascii_to_str,PY2\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"argon2\",\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\nTYPE_I=u(\"i\")\nTYPE_D=u(\"d\")\nTYPE_ID=u(\"id\")\n\n\nALL_TYPES=(TYPE_ID,TYPE_I,TYPE_D)\nALL_TYPES_SET=set(ALL_TYPES)\n\n\n\n\n\n\n\n\n_argon2_cffi_error=None\ntry :\n import argon2 as _argon2_cffi\nexcept ImportError:\n _argon2_cffi=None\nelse :\n if not hasattr(_argon2_cffi,\"Type\"):\n \n  _argon2_cffi_error=(\n  \"'argon2' module points to unsupported 'argon2' pypi package; \"\n  \"please install 'argon2-cffi' instead.\"\n  )\n  _argon2_cffi=None\n elif not hasattr(_argon2_cffi,\"low_level\"):\n \n  _argon2_cffi_error=\"'argon2-cffi' is too old, please update to argon2_cffi >= 18.2.0\"\n  _argon2_cffi=None\n  \n  \n  \nif hasattr(_argon2_cffi,\"PasswordHasher\"):\n\n _default_settings=_argon2_cffi.PasswordHasher()\n _default_version=_argon2_cffi.low_level.ARGON2_VERSION\nelse :\n\n class _DummyCffiHasher:\n  ''\n\n\n\n\n\n  \n  time_cost=2\n  memory_cost=512\n  parallelism=2\n  salt_len=16\n  hash_len=16\n  \n  \n  \n _default_settings=_DummyCffiHasher()\n _default_version=0x13\n \n \n \n \nclass _Argon2Common(uh.SubclassBackendMixin,uh.ParallelismMixin,\nuh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,\nuh.GenericHandler):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n name=\"argon2\"\n setting_kwds=(\"salt\",\n \"salt_size\",\n \"salt_len\",\n \"rounds\",\n \"time_cost\",\n \"memory_cost\",\n \"parallelism\",\n \"digest_size\",\n \"hash_len\",\n \"type\",\n )\n \n \n \n \n \n \n \n \n \n \n \n \n \n checksum_size=_default_settings.hash_len\n \n \n _always_parse_settings=uh.GenericHandler._always_parse_settings+\\\n (\"type\",)\n \n \n _unparsed_settings=uh.GenericHandler._unparsed_settings+\\\n (\"salt_len\",\"time_cost\",\"hash_len\",\"digest_size\")\n \n \n \n \n default_salt_size=_default_settings.salt_len\n min_salt_size=8\n max_salt_size=MAX_UINT32\n \n \n \n \n \n \n default_rounds=_default_settings.time_cost\n min_rounds=1\n max_rounds=MAX_UINT32\n rounds_cost=\"linear\"\n \n \n \n \n max_parallelism=(1 <<24)-1\n \n \n \n \n \n \n \n max_version=_default_version\n \n \n min_desired_version=None\n \n \n min_memory_cost=8\n \n \n \n max_threads=-1\n \n \n \n pure_use_threads=False\n \n \n \n \n _backend_type_map={}\n \n @classproperty\n def type_values(cls):\n  ''\n\n\n\n  \n  cls.get_backend()\n  return tuple(cls._backend_type_map)\n  \n  \n  \n  \n  \n  \n  \n type=TYPE_ID\n \n \n parallelism=_default_settings.parallelism\n \n \n \n version=_default_version\n \n \n memory_cost=_default_settings.memory_cost\n \n @property\n def type_d(self):\n  ''\n\n\n\n  \n  return self.type ==TYPE_D\n  \n  \n data=None\n \n \n \n \n \n @classmethod\n def using(cls,type=None ,memory_cost=None ,salt_len=None ,time_cost=None ,digest_size=None ,\n checksum_size=None ,hash_len=None ,max_threads=None ,**kwds):\n \n  if time_cost is not None :\n   if \"rounds\"in kwds:\n    raise TypeError(\"'time_cost' and 'rounds' are mutually exclusive\")\n   kwds['rounds']=time_cost\n   \n  if salt_len is not None :\n   if \"salt_size\"in kwds:\n    raise TypeError(\"'salt_len' and 'salt_size' are mutually exclusive\")\n   kwds['salt_size']=salt_len\n   \n  if hash_len is not None :\n   if digest_size is not None :\n    raise TypeError(\"'hash_len' and 'digest_size' are mutually exclusive\")\n   digest_size=hash_len\n   \n  if checksum_size is not None :\n   if digest_size is not None :\n    raise TypeError(\"'checksum_size' and 'digest_size' are mutually exclusive\")\n   digest_size=checksum_size\n   \n   \n  subcls=super(_Argon2Common,cls).using(**kwds)\n  \n  \n  if type is not None :\n   subcls.type=subcls._norm_type(type)\n   \n   \n  relaxed=kwds.get(\"relaxed\")\n  if digest_size is not None :\n   if isinstance(digest_size,uh.native_string_types):\n    digest_size=int(digest_size)\n    \n   subcls.checksum_size=uh.norm_integer(subcls,digest_size,min=16,max=MAX_UINT32,\n   param=\"digest_size\",relaxed=relaxed)\n   \n   \n  if memory_cost is not None :\n   if isinstance(memory_cost,uh.native_string_types):\n    memory_cost=int(memory_cost)\n   subcls.memory_cost=subcls._norm_memory_cost(memory_cost,relaxed=relaxed)\n   \n   \n  subcls._validate_constraints(subcls.memory_cost,subcls.parallelism)\n  \n  \n  if max_threads is not None :\n   if isinstance(max_threads,uh.native_string_types):\n    max_threads=int(max_threads)\n   if max_threads <1 and max_threads !=-1:\n    raise ValueError(\"max_threads (%d) must be -1 (unlimited), or at least 1.\"%\n    (max_threads,))\n   subcls.max_threads=max_threads\n   \n  return subcls\n  \n @classmethod\n def _validate_constraints(cls,memory_cost,parallelism):\n \n \n  min_memory_cost=8 *parallelism\n  if memory_cost <min_memory_cost:\n   raise ValueError(\"%s: memory_cost (%d) is too low, must be at least \"\n   \"8 * parallelism (8 * %d = %d)\"%\n   (cls.name,memory_cost,\n   parallelism,min_memory_cost))\n   \n   \n   \n   \n   \n   \n _ident_regex=re.compile(r\"^\\$argon2[a-z]+\\$\")\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return cls._ident_regex.match(hash)is not None\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n _hash_regex=re.compile(br\"\"\"\n        ^\n        \\$argon2(?P<type>[a-z]+)\\$\n        (?:\n            v=(?P<version>\\d+)\n            \\$\n        )?\n        m=(?P<memory_cost>\\d+)\n        ,\n        t=(?P<time_cost>\\d+)\n        ,\n        p=(?P<parallelism>\\d+)\n        (?:\n            ,keyid=(?P<keyid>[^,$]+)\n        )?\n        (?:\n            ,data=(?P<data>[^,$]+)\n        )?\n        (?:\n            \\$\n            (?P<salt>[^$]+)\n            (?:\n                \\$\n                (?P<digest>.+)\n            )?\n        )?\n        $\n    \"\"\",re.X)\n \n @classmethod\n def from_string(cls,hash):\n \n \n  if isinstance(hash,unicode):\n   hash=hash.encode(\"utf-8\")\n  if not isinstance(hash,bytes):\n   raise exc.ExpectedStringError(hash,\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise exc.MalformedHashError(cls)\n  type,version,memory_cost,time_cost,parallelism,keyid,data,salt,digest=\\\n  m.group(\"type\",\"version\",\"memory_cost\",\"time_cost\",\"parallelism\",\n  \"keyid\",\"data\",\"salt\",\"digest\")\n  if keyid:\n   raise NotImplementedError(\"argon2 'keyid' parameter not supported\")\n  return cls(\n  type=type.decode(\"ascii\"),\n  version=int(version)if version else 0x10,\n  memory_cost=int(memory_cost),\n  rounds=int(time_cost),\n  parallelism=int(parallelism),\n  salt=b64s_decode(salt)if salt else None ,\n  data=b64s_decode(data)if data else None ,\n  checksum=b64s_decode(digest)if digest else None ,\n  )\n  \n def to_string(self):\n  version=self.version\n  if version ==0x10:\n   vstr=\"\"\n  else :\n   vstr=\"v=%d$\"%version\n   \n  data=self.data\n  if data:\n   kdstr=\",data=\"+bascii_to_str(b64s_encode(self.data))\n  else :\n   kdstr=\"\"\n   \n   \n  return \"$argon2%s$%sm=%d,t=%d,p=%d%s$%s$%s\"%(\n  uascii_to_str(self.type),\n  vstr,\n  self.memory_cost,\n  self.rounds,\n  self.parallelism,\n  kdstr,\n  bascii_to_str(b64s_encode(self.salt)),\n  bascii_to_str(b64s_encode(self.checksum)),\n  )\n  \n  \n  \n  \n def __init__(self,type=None ,type_d=False ,version=None ,memory_cost=None ,data=None ,**kwds):\n \n \n  if type_d:\n   warn('argon2 `type_d=True` keyword is deprecated, and will be removed in passlib 2.0; '\n   'please use ``type=\"d\"`` instead')\n   assert type is None\n   type=TYPE_D\n   \n   \n   \n  checksum=kwds.get(\"checksum\")\n  if checksum is not None :\n   self.checksum_size=len(checksum)\n   \n   \n  super(_Argon2Common,self).__init__(**kwds)\n  \n  \n  if type is None :\n   assert uh.validate_default_value(self,self.type,self._norm_type,param=\"type\")\n  else :\n   self.type=self._norm_type(type)\n   \n   \n  if version is None :\n   assert uh.validate_default_value(self,self.version,self._norm_version,\n   param=\"version\")\n  else :\n   self.version=self._norm_version(version)\n   \n   \n  if memory_cost is None :\n   assert uh.validate_default_value(self,self.memory_cost,self._norm_memory_cost,\n   param=\"memory_cost\")\n  else :\n   self.memory_cost=self._norm_memory_cost(memory_cost)\n   \n   \n  if data is None :\n   assert self.data is None\n  else :\n   if not isinstance(data,bytes):\n    raise uh.exc.ExpectedTypeError(data,\"bytes\",\"data\")\n   self.data=data\n   \n   \n   \n   \n   \n @classmethod\n def _norm_type(cls,value):\n \n  if not isinstance(value,unicode):\n   if PY2 and isinstance(value,bytes):\n    value=value.decode('ascii')\n   else :\n    raise uh.exc.ExpectedTypeError(value,\"str\",\"type\")\n    \n    \n  if value in ALL_TYPES_SET:\n   return value\n   \n   \n  temp=value.lower()\n  if temp in ALL_TYPES_SET:\n   return temp\n   \n   \n  raise ValueError(\"unknown argon2 hash type: %r\"%(value,))\n  \n @classmethod\n def _norm_version(cls,version):\n  if not isinstance(version,uh.int_types):\n   raise uh.exc.ExpectedTypeError(version,\"integer\",\"version\")\n   \n   \n  if version <0x13 and version !=0x10:\n   raise ValueError(\"invalid argon2 hash version: %d\"%(version,))\n   \n   \n  backend=cls.get_backend()\n  if version >cls.max_version:\n   raise ValueError(\"%s: hash version 0x%X not supported by %r backend \"\n   \"(max version is 0x%X); try updating or switching backends\"%\n   (cls.name,version,backend,cls.max_version))\n  return version\n  \n @classmethod\n def _norm_memory_cost(cls,memory_cost,relaxed=False ):\n  return uh.norm_integer(cls,memory_cost,min=cls.min_memory_cost,\n  param=\"memory_cost\",relaxed=relaxed)\n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def _get_backend_type(cls,value):\n  ''\n\n  \n  try :\n   return cls._backend_type_map[value]\n  except KeyError:\n   pass\n   \n  msg=\"unsupported argon2 hash (type %r not supported by %s backend)\"%\\\n  (value,cls.get_backend())\n  raise ValueError(msg)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  cls=type(self)\n  if self.type !=cls.type:\n   return True\n  minver=cls.min_desired_version\n  if minver is None or minver >cls.max_version:\n   minver=cls.max_version\n  if self.version <minver:\n  \n   return True\n  if self.memory_cost !=cls.memory_cost:\n   return True\n  if self.checksum_size !=cls.checksum_size:\n   return True\n  return super(_Argon2Common,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n _no_backend_suggestion=\" -- recommend you install one (e.g. 'pip install argon2_cffi')\"\n \n @classmethod\n def _finalize_backend_mixin(mixin_cls,name,dryrun):\n  ''\n\n\n\n  \n  \n  max_version=mixin_cls.max_version\n  assert isinstance(max_version,int)and max_version >=0x10\n  if max_version <0x13:\n   warn(\"%r doesn't support argon2 v1.3, and should be upgraded\"%name,\n   uh.exc.PasslibSecurityWarning)\n   \n   \n  for type in ALL_TYPES:\n   if type in mixin_cls._backend_type_map:\n    mixin_cls.type=type\n    break\n  else :\n   warn(\"%r lacks support for all known hash types\"%name,uh.exc.PasslibRuntimeWarning)\n   \n   mixin_cls.type=TYPE_ID\n   \n  return True\n  \n @classmethod\n def _adapt_backend_error(cls,err,hash=None ,self=None ):\n  ''\n\n\n  \n  backend=cls.get_backend()\n  \n  \n  if self is None and hash is not None :\n   self=cls.from_string(hash)\n   \n   \n   \n  if self is not None :\n   self._validate_constraints(self.memory_cost,self.parallelism)\n   \n   \n   \n   if backend ==\"argon2_cffi\"and self.data is not None :\n    raise NotImplementedError(\"argon2_cffi backend doesn't support the 'data' parameter\")\n    \n    \n  text=str(err)\n  if text not in [\n  \"Decoding failed\"\n  ]:\n   reason=\"%s reported: %s: hash=%r\"%(backend,text,hash)\n  else :\n   reason=repr(hash)\n  raise exc.MalformedHashError(cls,reason=reason)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _NoBackend(_Argon2Common):\n ''\n\n\n \n \n \n \n @classmethod\n def hash(cls,secret):\n  cls._stub_requires_backend()\n  return cls.hash(secret)\n  \n @classmethod\n def verify(cls,secret,hash):\n  cls._stub_requires_backend()\n  return cls.verify(secret,hash)\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config):\n  cls._stub_requires_backend()\n  return cls.genhash(secret,config)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n  self._stub_requires_backend()\n  \n  \n  return super(argon2,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CffiBackend(_Argon2Common):\n ''\n\n \n \n \n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  assert mixin_cls is _CffiBackend\n  \n  \n  if _argon2_cffi is None :\n   if _argon2_cffi_error:\n    raise exc.PasslibSecurityError(_argon2_cffi_error)\n   return False\n  max_version=_argon2_cffi.low_level.ARGON2_VERSION\n  log.debug(\"detected 'argon2_cffi' backend, version %r, with support for 0x%x argon2 hashes\",\n  _argon2_cffi.__version__,max_version)\n  \n  \n  TypeEnum=_argon2_cffi.Type\n  type_map={}\n  for type in ALL_TYPES:\n   try :\n    type_map[type]=getattr(TypeEnum,type.upper())\n   except AttributeError:\n   \n    assert type not in (TYPE_I,TYPE_D),\"unexpected missing type: %r\"%type\n  mixin_cls._backend_type_map=type_map\n  \n  \n  mixin_cls.version=mixin_cls.max_version=max_version\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n @classmethod\n def hash(cls,secret):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  \n  try :\n   return bascii_to_str(_argon2_cffi.low_level.hash_secret(\n   type=cls._get_backend_type(cls.type),\n   memory_cost=cls.memory_cost,\n   time_cost=cls.default_rounds,\n   parallelism=cls.parallelism,\n   salt=to_bytes(cls._generate_salt()),\n   hash_len=cls.checksum_size,\n   secret=secret,\n   ))\n  except _argon2_cffi.exceptions.HashingError as err:\n   raise cls._adapt_backend_error(err)\n   \n   \n _byte_ident_map=dict((render_bytes(b\"$argon2%s$\",type.encode(\"ascii\")),type)\n for type in ALL_TYPES)\n \n @classmethod\n def verify(cls,secret,hash):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  hash=to_bytes(hash,\"ascii\")\n  \n  \n  \n  type=cls._byte_ident_map.get(hash[:1+hash.find(b\"$\",1)],TYPE_I)\n  type_code=cls._get_backend_type(type)\n  \n  \n  try :\n   result=_argon2_cffi.low_level.verify_secret(hash,secret,type_code)\n   assert result is True\n   return True\n  except _argon2_cffi.exceptions.VerifyMismatchError:\n   return False\n  except _argon2_cffi.exceptions.VerificationError as err:\n   raise cls._adapt_backend_error(err,hash=hash)\n   \n   \n @classmethod\n def genhash(cls,secret,config):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  self=cls.from_string(config)\n  \n  try :\n   result=bascii_to_str(_argon2_cffi.low_level.hash_secret(\n   type=cls._get_backend_type(self.type),\n   memory_cost=self.memory_cost,\n   time_cost=self.rounds,\n   parallelism=self.parallelism,\n   salt=to_bytes(self.salt),\n   hash_len=self.checksum_size,\n   secret=secret,\n   version=self.version,\n   ))\n  except _argon2_cffi.exceptions.HashingError as err:\n   raise cls._adapt_backend_error(err,hash=config)\n  if self.version ==0x10:\n  \n   result=result.replace(\"$v=16$\",\"$\")\n  return result\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  raise AssertionError(\"shouldn't be called under argon2_cffi backend\")\n  \n  \n  \n  \n  \n  \n  \n  \nclass _PureBackend(_Argon2Common):\n ''\n\n \n \n \n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  assert mixin_cls is _PureBackend\n  \n  \n  global _argon2pure\n  try :\n   import argon2pure as _argon2pure\n  except ImportError:\n   return False\n   \n   \n  try :\n   from argon2pure import ARGON2_DEFAULT_VERSION as max_version\n  except ImportError:\n   log.warning(\"detected 'argon2pure' backend, but package is too old \"\n   \"(passlib requires argon2pure >= 1.2.3)\")\n   return False\n   \n  log.debug(\"detected 'argon2pure' backend, with support for 0x%x argon2 hashes\",\n  max_version)\n  \n  if not dryrun:\n   warn(\"Using argon2pure backend, which is 100x+ slower than is required \"\n   \"for adequate security. Installing argon2_cffi (via 'pip install argon2_cffi') \"\n   \"is strongly recommended\",exc.PasslibSecurityWarning)\n   \n   \n  type_map={}\n  for type in ALL_TYPES:\n   try :\n    type_map[type]=getattr(_argon2pure,\"ARGON2\"+type.upper())\n   except AttributeError:\n   \n    assert type not in (TYPE_I,TYPE_D),\"unexpected missing type: %r\"%type\n  mixin_cls._backend_type_map=type_map\n  \n  mixin_cls.version=mixin_cls.max_version=max_version\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  kwds=dict(\n  password=secret,\n  salt=self.salt,\n  time_cost=self.rounds,\n  memory_cost=self.memory_cost,\n  parallelism=self.parallelism,\n  tag_length=self.checksum_size,\n  type_code=self._get_backend_type(self.type),\n  version=self.version,\n  )\n  if self.max_threads >0:\n   kwds['threads']=self.max_threads\n  if self.pure_use_threads:\n   kwds['use_threads']=True\n  if self.data:\n   kwds['associated_data']=self.data\n   \n   \n   \n  try :\n   return _argon2pure.argon2(**kwds)\n  except _argon2pure.Argon2Error as err:\n   raise self._adapt_backend_error(err,self=self)\n   \n   \n   \n   \n   \nclass argon2(_NoBackend,_Argon2Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n backends=(\"argon2_cffi\",\"argon2pure\")\n \n \n _backend_mixin_target=True\n \n \n _backend_mixin_map={\n None :_NoBackend,\n \"argon2_cffi\":_CffiBackend,\n \"argon2pure\":_PureBackend,\n }\n \n \n \n \n \n \n \n \n", ["__future__", "argon2", "argon2pure", "logging", "passlib", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "types", "warnings"]], "passlib.Lib.site-packages.passlib.handlers": [".py", "''\n", [], 1], "passlib.Lib.site-packages.passlib.handlers.scrypt": [".py", "''\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.crypto import scrypt as _scrypt\nfrom passlib.utils import h64,to_bytes\nfrom passlib.utils.binary import h64,b64s_decode,b64s_encode\nfrom passlib.utils.compat import u,bascii_to_str,suppress_cause\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"scrypt\",\n]\n\n\n\n\n\nIDENT_SCRYPT=u(\"$scrypt$\")\nIDENT_7=u(\"$7$\")\n\n_UDOLLAR=u(\"$\")\n\n\n\n\nclass scrypt(uh.ParallelismMixin,uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.HasManyIdents,\nuh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n name=\"scrypt\"\n setting_kwds=(\"ident\",\"salt\",\"salt_size\",\"rounds\",\"block_size\",\"parallelism\")\n \n \n \n \n \n \n \n \n checksum_size=32\n \n \n \n \n default_ident=IDENT_SCRYPT\n ident_values=(IDENT_SCRYPT,IDENT_7)\n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n \n \n \n default_rounds=16\n min_rounds=1\n max_rounds=31\n rounds_cost=\"log2\"\n \n \n \n \n \n \n \n \n parallelism=1\n \n \n block_size=8\n \n \n \n \n \n @classmethod\n def using(cls,block_size=None ,**kwds):\n  subcls=super(scrypt,cls).using(**kwds)\n  if block_size is not None :\n   if isinstance(block_size,uh.native_string_types):\n    block_size=int(block_size)\n   subcls.block_size=subcls._norm_block_size(block_size,relaxed=kwds.get(\"relaxed\"))\n   \n   \n  try :\n   _scrypt.validate(1 <<cls.default_rounds,cls.block_size,cls.parallelism)\n  except ValueError as err:\n   raise suppress_cause(ValueError(\"scrypt: invalid settings combination: \"+str(err)))\n   \n  return subcls\n  \n  \n  \n  \n  \n @classmethod\n def from_string(cls,hash):\n  return cls(**cls.parse(hash))\n  \n @classmethod\n def parse(cls,hash):\n  ident,suffix=cls._parse_ident(hash)\n  func=getattr(cls,\"_parse_%s_string\"%ident.strip(_UDOLLAR),None )\n  if func:\n   return func(suffix)\n  else :\n   raise uh.exc.InvalidHashError(cls)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n @classmethod\n def _parse_scrypt_string(cls,suffix):\n \n  parts=suffix.split(\"$\")\n  if len(parts)==3:\n   params,salt,digest=parts\n  elif len(parts)==2:\n   params,salt=parts\n   digest=None\n  else :\n   raise uh.exc.MalformedHashError(cls,\"malformed hash\")\n   \n   \n  parts=params.split(\",\")\n  if len(parts)==3:\n   nstr,bstr,pstr=parts\n   assert nstr.startswith(\"ln=\")\n   assert bstr.startswith(\"r=\")\n   assert pstr.startswith(\"p=\")\n  else :\n   raise uh.exc.MalformedHashError(cls,\"malformed settings field\")\n   \n  return dict(\n  ident=IDENT_SCRYPT,\n  rounds=int(nstr[3:]),\n  block_size=int(bstr[2:]),\n  parallelism=int(pstr[2:]),\n  salt=b64s_decode(salt.encode(\"ascii\")),\n  checksum=b64s_decode(digest.encode(\"ascii\"))if digest else None ,\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def _parse_7_string(cls,suffix):\n \n \n \n \n  parts=suffix.encode(\"ascii\").split(b\"$\")\n  if len(parts)==2:\n   params,digest=parts\n  elif len(parts)==1:\n   params,=parts\n   digest=None\n  else :\n   raise uh.exc.MalformedHashError()\n   \n   \n  if len(params)<11:\n   raise uh.exc.MalformedHashError(cls,\"params field too short\")\n  return dict(\n  ident=IDENT_7,\n  rounds=h64.decode_int6(params[:1]),\n  block_size=h64.decode_int30(params[1:6]),\n  parallelism=h64.decode_int30(params[6:11]),\n  salt=params[11:],\n  checksum=h64.decode_bytes(digest)if digest else None ,\n  )\n  \n  \n  \n  \n def to_string(self):\n  ident=self.ident\n  if ident ==IDENT_SCRYPT:\n   return \"$scrypt$ln=%d,r=%d,p=%d$%s$%s\"%(\n   self.rounds,\n   self.block_size,\n   self.parallelism,\n   bascii_to_str(b64s_encode(self.salt)),\n   bascii_to_str(b64s_encode(self.checksum)),\n   )\n  else :\n   assert ident ==IDENT_7\n   salt=self.salt\n   try :\n    salt.decode(\"ascii\")\n   except UnicodeDecodeError:\n    raise suppress_cause(NotImplementedError(\"scrypt $7$ hashes dont support non-ascii salts\"))\n   return bascii_to_str(b\"\".join([\n   b\"$7$\",\n   h64.encode_int6(self.rounds),\n   h64.encode_int30(self.block_size),\n   h64.encode_int30(self.parallelism),\n   self.salt,\n   b\"$\",\n   h64.encode_bytes(self.checksum)\n   ]))\n   \n   \n   \n   \n def __init__(self,block_size=None ,**kwds):\n  super(scrypt,self).__init__(**kwds)\n  \n  \n  if block_size is None :\n   assert uh.validate_default_value(self,self.block_size,self._norm_block_size,\n   param=\"block_size\")\n  else :\n   self.block_size=self._norm_block_size(block_size)\n   \n   \n   \n   \n @classmethod\n def _norm_block_size(cls,block_size,relaxed=False ):\n  return uh.norm_integer(cls,block_size,min=1,param=\"block_size\",relaxed=relaxed)\n  \n def _generate_salt(self):\n  salt=super(scrypt,self)._generate_salt()\n  if self.ident ==IDENT_7:\n  \n  \n   salt=b64s_encode(salt)\n  return salt\n  \n  \n  \n  \n  \n  \n  \n @classproperty\n def backends(cls):\n  return _scrypt.backend_values\n  \n @classmethod\n def get_backend(cls):\n  return _scrypt.backend\n  \n @classmethod\n def has_backend(cls,name=\"any\"):\n  try :\n   cls.set_backend(name,dryrun=True )\n   return True\n  except uh.exc.MissingBackendError:\n   return False\n   \n @classmethod\n def set_backend(cls,name=\"any\",dryrun=False ):\n  _scrypt._set_backend(name,dryrun=dryrun)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  secret=to_bytes(secret,param=\"secret\")\n  return _scrypt.scrypt(secret,self.salt,n=(1 <<self.rounds),r=self.block_size,\n  p=self.parallelism,keylen=self.checksum_size)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  \n  if self.block_size !=type(self).block_size:\n   return True\n  return super(scrypt,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "passlib.crypto", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.digests": [".py", "''\n\n\n\n\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_native_str,to_bytes,render_bytes,consteq\nfrom passlib.utils.compat import unicode,str_to_uascii\nimport passlib.utils.handlers as uh\nfrom passlib.crypto.digest import lookup_hash\n\n__all__=[\n\"create_hex_hash\",\n\"hex_md4\",\n\"hex_md5\",\n\"hex_sha1\",\n\"hex_sha256\",\n\"hex_sha512\",\n]\n\n\n\n\nclass HexDigestHash(uh.StaticHandler):\n ''\n \n \n \n _hash_func=None\n checksum_size=None\n checksum_chars=uh.HEX_CHARS\n \n \n supported=True\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(self._hash_func(secret).hexdigest())\n  \n  \n  \n  \n  \ndef create_hex_hash(digest,module=__name__,django_name=None ,required=True ):\n ''\n\n\n\n\n\n\n\n \n info=lookup_hash(digest,required=required)\n name=\"hex_\"+info.name\n if not info.supported:\n  info.digest_size=0\n hasher=type(name,(HexDigestHash,),dict(\n name=name,\n __module__=module,\n _hash_func=staticmethod(info.const),\n checksum_size=info.digest_size *2,\n __doc__=\"\"\"This class implements a plain hexadecimal %s hash, and follows the :ref:`password-hash-api`.\n\nIt supports no optional or contextual keywords.\n\"\"\"%(info.name,)\n ))\n if not info.supported:\n  hasher.supported=False\n if django_name:\n  hasher.django_name=django_name\n return hasher\n \n \n \n \n \n \n \n \n \nhex_md4=create_hex_hash(\"md4\",required=False )\nhex_md5=create_hex_hash(\"md5\",django_name=\"unsalted_md5\",required=False )\nhex_sha1=create_hex_hash(\"sha1\",required=False )\nhex_sha256=create_hex_hash(\"sha256\")\nhex_sha512=create_hex_hash(\"sha512\")\n\n\n\n\nclass htdigest(uh.MinimalHandler):\n ''\n\n\n\n \n name=\"htdigest\"\n setting_kwds=()\n context_kwds=(\"user\",\"realm\",\"encoding\")\n default_encoding=\"utf-8\"\n \n @classmethod\n def hash(cls,secret,user,realm,encoding=None ):\n \n \n  if not encoding:\n   encoding=cls.default_encoding\n  uh.validate_secret(secret)\n  if isinstance(secret,unicode):\n   secret=secret.encode(encoding)\n  user=to_bytes(user,encoding,\"user\")\n  realm=to_bytes(realm,encoding,\"realm\")\n  data=render_bytes(\"%s:%s:%s\",user,realm,secret)\n  return hashlib.md5(data).hexdigest()\n  \n @classmethod\n def _norm_hash(cls,hash):\n  ''\n  hash=to_native_str(hash,param=\"hash\")\n  if len(hash)!=32:\n   raise uh.exc.MalformedHashError(cls,\"wrong size\")\n  for char in hash:\n   if char not in uh.LC_HEX_CHARS:\n    raise uh.exc.MalformedHashError(cls,\"invalid chars in hash\")\n  return hash\n  \n @classmethod\n def verify(cls,secret,hash,user,realm,encoding=\"utf-8\"):\n  hash=cls._norm_hash(hash)\n  other=cls.hash(secret,user,realm,encoding)\n  return consteq(hash,other)\n  \n @classmethod\n def identify(cls,hash):\n  try :\n   cls._norm_hash(hash)\n  except ValueError:\n   return False\n  return True\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n  return cls.hash(\"\",\"\",\"\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,user,realm,encoding=None ):\n \n \n  cls._norm_hash(config)\n  return cls.hash(secret,user,realm,encoding)\n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.pbkdf2": [".py", "''\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom base64 import b64encode,b64decode\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode\nfrom passlib.utils.binary import ab64_decode,ab64_encode\nfrom passlib.utils.compat import str_to_bascii,u,uascii_to_str,unicode\nfrom passlib.crypto.digest import pbkdf2_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"pbkdf2_sha1\",\n\"pbkdf2_sha256\",\n\"pbkdf2_sha512\",\n\"cta_pbkdf2_sha1\",\n\"dlitz_pbkdf2_sha1\",\n\"grub_pbkdf2_sha512\",\n]\n\n\n\n\nclass Pbkdf2DigestHandler(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n \n \n \n \n \n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n checksum_chars=uh.HASH64_CHARS\n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n default_rounds=None\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n _digest=None\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  salt=ab64_decode(salt.encode(\"ascii\"))\n  if chk:\n   chk=ab64_decode(chk.encode(\"ascii\"))\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=ab64_encode(self.salt).decode(\"ascii\")\n  chk=ab64_encode(self.checksum).decode(\"ascii\")\n  return uh.render_mc3(self.ident,self.rounds,salt,chk)\n  \n def _calc_checksum(self,secret):\n \n  return pbkdf2_hmac(self._digest,secret,self.salt,self.rounds,self.checksum_size)\n  \ndef create_pbkdf2_hash(hash_name,digest_size,rounds=12000,ident=None ,module=__name__):\n ''\n name='pbkdf2_'+hash_name\n if ident is None :\n  ident=u(\"$pbkdf2-%s$\")%(hash_name,)\n base=Pbkdf2DigestHandler\n return type(name,(base,),dict(\n __module__=module,\n name=name,\n ident=ident,\n _digest=hash_name,\n default_rounds=rounds,\n checksum_size=digest_size,\n encoded_checksum_size=(digest_size *4+2)//3,\n __doc__=\"\"\"This class implements a generic ``PBKDF2-HMAC-%(digest)s``-based password hash, and follows the :ref:`password-hash-api`.\n\n    It supports a variable-length salt, and a variable number of rounds.\n\n    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:\n\n    :type salt: bytes\n    :param salt:\n        Optional salt bytes.\n        If specified, the length must be between 0-1024 bytes.\n        If not specified, a %(dsc)d byte salt will be autogenerated (this is recommended).\n\n    :type salt_size: int\n    :param salt_size:\n        Optional number of bytes to use when autogenerating new salts.\n        Defaults to %(dsc)d bytes, but can be any value between 0 and 1024.\n\n    :type rounds: int\n    :param rounds:\n        Optional number of rounds to use.\n        Defaults to %(dr)d, but must be within ``range(1,1<<32)``.\n\n    :type relaxed: bool\n    :param relaxed:\n        By default, providing an invalid value for one of the other\n        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,\n        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`\n        will be issued instead. Correctable errors include ``rounds``\n        that are too small or too large, and ``salt`` strings that are too long.\n\n        .. versionadded:: 1.6\n    \"\"\"%dict(digest=hash_name.upper(),dsc=base.default_salt_size,dr=rounds)\n ))\n \n \n \n \npbkdf2_sha1=create_pbkdf2_hash(\"sha1\",20,131000,ident=u(\"$pbkdf2$\"))\npbkdf2_sha256=create_pbkdf2_hash(\"sha256\",32,29000)\npbkdf2_sha512=create_pbkdf2_hash(\"sha512\",64,25000)\n\nldap_pbkdf2_sha1=uh.PrefixWrapper(\"ldap_pbkdf2_sha1\",pbkdf2_sha1,\"{PBKDF2}\",\"$pbkdf2$\",ident=True )\nldap_pbkdf2_sha256=uh.PrefixWrapper(\"ldap_pbkdf2_sha256\",pbkdf2_sha256,\"{PBKDF2-SHA256}\",\"$pbkdf2-sha256$\",ident=True )\nldap_pbkdf2_sha512=uh.PrefixWrapper(\"ldap_pbkdf2_sha512\",pbkdf2_sha512,\"{PBKDF2-SHA512}\",\"$pbkdf2-sha512$\",ident=True )\n\n\n\n\n\n\nCTA_ALTCHARS=b\"-_\"\n\nclass cta_pbkdf2_sha1(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"cta_pbkdf2_sha1\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$p5k2$\")\n checksum_size=20\n \n \n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n default_rounds=pbkdf2_sha1.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n \n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,rounds_base=16,handler=cls)\n  salt=b64decode(salt.encode(\"ascii\"),CTA_ALTCHARS)\n  if chk:\n   chk=b64decode(chk.encode(\"ascii\"),CTA_ALTCHARS)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=b64encode(self.salt,CTA_ALTCHARS).decode(\"ascii\")\n  chk=b64encode(self.checksum,CTA_ALTCHARS).decode(\"ascii\")\n  return uh.render_mc3(self.ident,self.rounds,salt,chk,rounds_base=16)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  return pbkdf2_hmac(\"sha1\",secret,self.salt,self.rounds,20)\n  \n  \n  \n  \n  \n  \n  \n  \nclass dlitz_pbkdf2_sha1(uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"dlitz_pbkdf2_sha1\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$p5k2$\")\n _stub_checksum=u(\"0\"*48+\"=\")\n \n \n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n default_rounds=pbkdf2_sha1.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,rounds_base=16,\n  default_rounds=400,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  rounds=self.rounds\n  if rounds ==400:\n   rounds=None\n  return uh.render_mc3(self.ident,rounds,self.salt,self.checksum,rounds_base=16)\n  \n def _get_config(self):\n  rounds=self.rounds\n  if rounds ==400:\n   rounds=None\n  return uh.render_mc3(self.ident,rounds,self.salt,None ,rounds_base=16)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  salt=self._get_config()\n  result=pbkdf2_hmac(\"sha1\",secret,salt,self.rounds,24)\n  return ab64_encode(result).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \nclass atlassian_pbkdf2_sha1(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n name=\"atlassian_pbkdf2_sha1\"\n setting_kwds=(\"salt\",)\n ident=u(\"{PKCS5S2}\")\n checksum_size=32\n \n \n min_salt_size=max_salt_size=16\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  ident=cls.ident\n  if not hash.startswith(ident):\n   raise uh.exc.InvalidHashError(cls)\n  data=b64decode(hash[len(ident):].encode(\"ascii\"))\n  salt,chk=data[:16],data[16:]\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  data=self.salt+self.checksum\n  hash=self.ident+b64encode(data).decode(\"ascii\")\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n \n \n \n  return pbkdf2_hmac(\"sha1\",secret,self.salt,10000,32)\n  \n  \n  \n  \nclass grub_pbkdf2_sha512(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"grub_pbkdf2_sha512\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n \n ident=u(\"grub.pbkdf2.sha512.\")\n checksum_size=64\n \n \n \n \n \n default_salt_size=64\n max_salt_size=1024\n \n default_rounds=pbkdf2_sha512.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,sep=u(\".\"),\n  handler=cls)\n  salt=unhexlify(salt.encode(\"ascii\"))\n  if chk:\n   chk=unhexlify(chk.encode(\"ascii\"))\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=hexlify(self.salt).decode(\"ascii\").upper()\n  chk=hexlify(self.checksum).decode(\"ascii\").upper()\n  return uh.render_mc3(self.ident,self.rounds,salt,chk,sep=u(\".\"))\n  \n def _calc_checksum(self,secret):\n \n \n  return pbkdf2_hmac(\"sha512\",secret,self.salt,self.rounds,64)\n  \n  \n  \n  \n", ["base64", "binascii", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.cisco": [".py", "''\n\n\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import right_pad_string,to_unicode,repeat_string,to_bytes\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import unicode,u,join_byte_values,\\\njoin_byte_elems,iter_byte_values,uascii_to_str\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"cisco_pix\",\n\"cisco_asa\",\n\"cisco_type7\",\n]\n\n\n\n\n\n\n_DUMMY_BYTES=b'\\xFF'*32\n\n\n\n\nclass cisco_pix(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_pix\"\n \n truncate_size=16\n \n \n \n truncate_error=True\n truncate_verify_reject=True\n \n \n \n \n checksum_size=16\n checksum_chars=uh.HASH64_CHARS\n \n \n \n \n \n \n _is_asa=False\n \n \n \n \n def _calc_checksum(self,secret):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  asa=self._is_asa\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  spoil_digest=None\n  if len(secret)>self.truncate_size:\n   if self.use_defaults:\n   \n    msg=\"Password too long (%s allows at most %d bytes)\"%\\\n    (self.name,self.truncate_size)\n    raise uh.exc.PasswordSizeError(self.truncate_size,msg=msg)\n   else :\n   \n   \n   \n   \n   \n   \n    spoil_digest=secret+_DUMMY_BYTES\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  user=self.user\n  if user:\n   if isinstance(user,unicode):\n    user=user.encode(\"utf-8\")\n   if not asa or len(secret)<28:\n    secret +=repeat_string(user,4)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n  if asa and len(secret)>16:\n   pad_size=32\n  else :\n   pad_size=16\n  secret=right_pad_string(secret,pad_size)\n  \n  \n  \n  \n  if spoil_digest:\n  \n   secret +=spoil_digest\n  digest=md5(secret).digest()\n  \n  \n  \n  \n  \n  \n  \n  digest=join_byte_elems(c for i,c in enumerate(digest)if (i+1)&3)\n  \n  \n  \n  \n  return h64.encode_bytes(digest).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass cisco_asa(cisco_pix):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_asa\"\n \n \n \n \n truncate_size=32\n \n \n \n \n _is_asa=True\n \n \n \n \n \n \n \n \nclass cisco_type7(uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_type7\"\n setting_kwds=(\"salt\",)\n \n \n \n \n checksum_chars=uh.UPPER_HEX_CHARS\n \n \n \n \n \n \n \n min_salt_value=0\n max_salt_value=52\n \n \n \n \n @classmethod\n def using(cls,salt=None ,**kwds):\n  subcls=super(cisco_type7,cls).using(**kwds)\n  if salt is not None :\n   salt=subcls._norm_salt(salt,relaxed=kwds.get(\"relaxed\"))\n   subcls._generate_salt=staticmethod(lambda :salt)\n  return subcls\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if len(hash)<2:\n   raise uh.exc.InvalidHashError(cls)\n  salt=int(hash[:2])\n  return cls(salt=salt,checksum=hash[2:].upper())\n  \n def __init__(self,salt=None ,**kwds):\n  super(cisco_type7,self).__init__(**kwds)\n  if salt is not None :\n   salt=self._norm_salt(salt)\n  elif self.use_defaults:\n   salt=self._generate_salt()\n   assert self._norm_salt(salt)==salt,\"generated invalid salt: %r\"%(salt,)\n  else :\n   raise TypeError(\"no salt specified\")\n  self.salt=salt\n  \n @classmethod\n def _norm_salt(cls,salt,relaxed=False ):\n  ''\n\n\n\n  \n  if not isinstance(salt,int):\n   raise uh.exc.ExpectedTypeError(salt,\"integer\",\"salt\")\n  if 0 <=salt <=cls.max_salt_value:\n   return salt\n  msg=\"salt/offset must be in 0..52 range\"\n  if relaxed:\n   warn(msg,uh.PasslibHashWarning)\n   return 0 if salt <0 else cls.max_salt_value\n  else :\n   raise ValueError(msg)\n   \n @staticmethod\n def _generate_salt():\n  return uh.rng.randint(0,15)\n  \n def to_string(self):\n  return \"%02d%s\"%(self.salt,uascii_to_str(self.checksum))\n  \n def _calc_checksum(self,secret):\n \n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return hexlify(self._cipher(secret,self.salt)).decode(\"ascii\").upper()\n  \n @classmethod\n def decode(cls,hash,encoding=\"utf-8\"):\n  ''\n\n\n\n\n  \n  self=cls.from_string(hash)\n  tmp=unhexlify(self.checksum.encode(\"ascii\"))\n  raw=self._cipher(tmp,self.salt)\n  return raw.decode(encoding)if encoding else raw\n  \n  \n _key=u(\"dsfd;kfoA,.iyewrkldJKDHSUBsgvca69834ncxv9873254k;fg87\")\n \n @classmethod\n def _cipher(cls,data,salt):\n  ''\n  key=cls._key\n  key_size=len(key)\n  return join_byte_values(\n  value ^ord(key[(salt+idx)%key_size])\n  for idx,value in enumerate(iter_byte_values(data))\n  )\n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.des_crypt": [".py", "''\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import safe_crypt,test_crypt,to_unicode\nfrom passlib.utils.binary import h64,h64big\nfrom passlib.utils.compat import byte_elem_value,u,uascii_to_str,unicode,suppress_cause\nfrom passlib.crypto.des import des_encrypt_int_block\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"des_crypt\",\n\"bsdi_crypt\",\n\"bigcrypt\",\n\"crypt16\",\n]\n\n\n\n\n_BNULL=b'\\x00'\n\ndef _crypt_secret_to_key(secret):\n ''\n\n\n\n\n \n \n \n \n \n return sum((byte_elem_value(c)&0x7f)<<(57 -i *8)\n for i,c in enumerate(secret[:8]))\n \ndef _raw_des_crypt(secret,salt):\n ''\n assert len(salt)==2\n \n \n \n \n \n \n \n salt_value=h64.decode_int12(salt)\n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(\"utf-8\")\n assert isinstance(secret,bytes)\n \n \n if _BNULL in secret:\n  raise uh.exc.NullPasswordError(des_crypt)\n  \n  \n key_value=_crypt_secret_to_key(secret)\n \n \n result=des_encrypt_int_block(key_value,0,salt_value,25)\n \n \n return h64big.encode_int64(result)\n \ndef _bsdi_secret_to_key(secret):\n ''\n key_value=_crypt_secret_to_key(secret)\n idx=8\n end=len(secret)\n while idx <end:\n  next=idx+8\n  tmp_value=_crypt_secret_to_key(secret[idx:next])\n  key_value=des_encrypt_int_block(key_value,key_value)^tmp_value\n  idx=next\n return key_value\n \ndef _raw_bsdi_crypt(secret,rounds,salt):\n ''\n \n \n salt_value=h64.decode_int24(salt)\n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(\"utf-8\")\n assert isinstance(secret,bytes)\n \n \n if _BNULL in secret:\n  raise uh.exc.NullPasswordError(bsdi_crypt)\n  \n  \n key_value=_bsdi_secret_to_key(secret)\n \n \n result=des_encrypt_int_block(key_value,0,salt_value,rounds)\n \n \n return h64big.encode_int64(result)\n \n \n \n \nclass des_crypt(uh.TruncateMixin,uh.HasManyBackends,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"des_crypt\"\n setting_kwds=(\"salt\",\"truncate_error\")\n \n \n \n \n checksum_chars=uh.HASH64_CHARS\n checksum_size=11\n \n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n truncate_size=8\n \n \n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{11})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  salt,chk=hash[:2],hash[2:]\n  return cls(salt=salt,checksum=chk or None )\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n  return self._calc_checksum_backend(secret)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'abgOeLfPimXQo'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n \n \n  hash=safe_crypt(secret,self.salt)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(self.salt)or len(hash)!=13:\n   raise uh.exc.CryptBackendError(self,self.salt,hash)\n  return hash[2:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_des_crypt(secret,self.salt.encode(\"ascii\")).decode(\"ascii\")\n  \n  \n  \n  \n  \nclass bsdi_crypt(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"bsdi_crypt\"\n setting_kwds=(\"salt\",\"rounds\")\n checksum_size=11\n checksum_chars=uh.HASH64_CHARS\n \n \n min_salt_size=max_salt_size=4\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=5001\n min_rounds=1\n max_rounds=16777215\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        _\n        (?P<rounds>[./a-z0-9]{4})\n        (?P<salt>[./a-z0-9]{4})\n        (?P<chk>[./a-z0-9]{11})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  rounds,salt,chk=m.group(\"rounds\",\"salt\",\"chk\")\n  return cls(\n  rounds=h64.decode_int24(rounds.encode(\"ascii\")),\n  salt=salt,\n  checksum=chk,\n  )\n  \n def to_string(self):\n  hash=u(\"_%s%s%s\")%(h64.encode_int24(self.rounds).decode(\"ascii\"),\n  self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n  \n  \n _avoid_even_rounds=True\n \n @classmethod\n def using(cls,**kwds):\n  subcls=super(bsdi_crypt,cls).using(**kwds)\n  if not subcls.default_rounds&1:\n  \n   warn(\"bsdi_crypt rounds should be odd, as even rounds may reveal weak DES keys\",\n   uh.exc.PasslibSecurityWarning)\n  return subcls\n  \n @classmethod\n def _generate_rounds(cls):\n  rounds=super(bsdi_crypt,cls)._generate_rounds()\n  \n  \n  \n  \n  \n  return rounds |1\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n \n  if not self.rounds&1:\n   return True\n   \n  return super(bsdi_crypt,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'_/...lLDAxARksGCHin.'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string()\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config[:9])or len(hash)!=20:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-11:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_bsdi_crypt(secret,self.rounds,self.salt.encode(\"ascii\")).decode(\"ascii\")\n  \n  \n  \n  \n  \nclass bigcrypt(uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"bigcrypt\"\n setting_kwds=(\"salt\",)\n checksum_chars=uh.HASH64_CHARS\n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>([./a-z0-9]{11})+)?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  checksum=super(bigcrypt,self)._norm_checksum(checksum,relaxed=relaxed)\n  if len(checksum)%11:\n   raise uh.exc.InvalidHashError(self)\n  return checksum\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=_raw_des_crypt(secret,self.salt.encode(\"ascii\"))\n  idx=8\n  end=len(secret)\n  while idx <end:\n   next=idx+8\n   chk +=_raw_des_crypt(secret[idx:next],chk[-11:-9])\n   idx=next\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \n  \nclass crypt16(uh.TruncateMixin,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"crypt16\"\n setting_kwds=(\"salt\",\"truncate_error\")\n \n \n \n \n checksum_size=22\n checksum_chars=uh.HASH64_CHARS\n \n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n truncate_size=16\n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{22})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n   \n  try :\n   salt_value=h64.decode_int12(self.salt.encode(\"ascii\"))\n  except ValueError:\n   raise suppress_cause(ValueError(\"invalid chars in salt\"))\n   \n   \n  key1=_crypt_secret_to_key(secret)\n  \n  \n  result1=des_encrypt_int_block(key1,0,salt_value,20)\n  \n  \n  key2=_crypt_secret_to_key(secret[8:16])\n  \n  \n  result2=des_encrypt_int_block(key2,0,salt_value,5)\n  \n  \n  chk=h64big.encode_int64(result1)+h64big.encode_int64(result2)\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["logging", "passlib.crypto.des", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.postgres": [".py", "''\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_bytes\nfrom passlib.utils.compat import str_to_uascii,unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"postgres_md5\",\n]\n\n\n\n\nclass postgres_md5(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"postgres_md5\"\n _hash_prefix=u(\"md5\")\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  user=to_bytes(self.user,\"utf-8\",param=\"user\")\n  return str_to_uascii(md5(secret+user).hexdigest())\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.bcrypt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nfrom base64 import b64encode\nfrom hashlib import sha256\nimport os\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n_bcrypt=None\n_pybcrypt=None\n_bcryptor=None\n\n_builtin_bcrypt=None\nfrom passlib.crypto.digest import compile_hmac\nfrom passlib.exc import PasslibHashWarning,PasslibSecurityWarning,PasslibSecurityError\nfrom passlib.utils import safe_crypt,repeat_string,to_bytes,parse_version,\\\nrng,getrandstr,test_crypt,to_unicode,\\\nutf8_truncate,utf8_repeat_string,crypt_accepts_bytes\nfrom passlib.utils.binary import bcrypt64\nfrom passlib.utils.compat import get_unbound_method_function\nfrom passlib.utils.compat import u,uascii_to_str,unicode,str_to_uascii,PY3,error_from\nimport passlib.utils.handlers as uh\n\n\n__all__=[\n\"bcrypt\",\n]\n\n\n\n\nIDENT_2=u(\"$2$\")\nIDENT_2A=u(\"$2a$\")\nIDENT_2X=u(\"$2x$\")\nIDENT_2Y=u(\"$2y$\")\nIDENT_2B=u(\"$2b$\")\n_BNULL=b'\\x00'\n\n\nTEST_HASH_2A=\"$2a$04$5BJqKfqMQvV7nS.yUguNcueVirQqDBGaLXSqj.rs.pZPlNR0UX/HK\"\n\ndef _detect_pybcrypt():\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n try :\n  import bcrypt\n except ImportError:\n \n \n  return None\n  \n  \n  \n  \n try :\n  from bcrypt._bcrypt import __version__\n except ImportError:\n  return False\n return True\n \n \n \n \nclass _BcryptCommon(uh.SubclassBackendMixin,uh.TruncateMixin,uh.HasManyIdents,\nuh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"bcrypt\"\n setting_kwds=(\"salt\",\"rounds\",\"ident\",\"truncate_error\")\n \n \n \n \n checksum_size=31\n checksum_chars=bcrypt64.charmap\n \n \n \n \n default_ident=IDENT_2B\n ident_values=(IDENT_2,IDENT_2A,IDENT_2X,IDENT_2Y,IDENT_2B)\n ident_aliases={u(\"2\"):IDENT_2,u(\"2a\"):IDENT_2A,u(\"2y\"):IDENT_2Y,\n u(\"2b\"):IDENT_2B}\n \n \n \n \n min_salt_size=max_salt_size=22\n salt_chars=bcrypt64.charmap\n \n \n final_salt_chars=\".Oeu\"\n \n \n \n \n default_rounds=12\n min_rounds=4\n max_rounds=31\n rounds_cost=\"log2\"\n \n \n \n \n truncate_size=72\n \n \n \n \n \n \n \n _workrounds_initialized=False\n _has_2a_wraparound_bug=False\n _lacks_20_support=False\n _lacks_2y_support=False\n _lacks_2b_support=False\n _fallback_ident=IDENT_2A\n _require_valid_utf8_bytes=False\n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  ident,tail=cls._parse_ident(hash)\n  if ident ==IDENT_2X:\n   raise ValueError(\"crypt_blowfish's buggy '2x' hashes are not \"\n   \"currently supported\")\n  rounds_str,data=tail.split(u(\"$\"))\n  rounds=int(rounds_str)\n  if rounds_str !=u('%02d')%(rounds,):\n   raise uh.exc.MalformedHashError(cls,\"malformed cost field\")\n  salt,chk=data[:22],data[22:]\n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk or None ,\n  ident=ident,\n  )\n  \n def to_string(self):\n  hash=u(\"%s%02d$%s%s\")%(self.ident,self.rounds,self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n def _get_config(self,ident):\n  ''\n  config=u(\"%s%02d$%s\")%(ident,self.rounds,self.salt)\n  return uascii_to_str(config)\n  \n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,**kwds):\n \n \n \n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  if hash.startswith(IDENT_2A)and hash[28]not in cls.final_salt_chars:\n   return True\n   \n   \n   \n   \n  return super(_BcryptCommon,cls).needs_update(hash,**kwds)\n  \n  \n  \n  \n  \n @classmethod\n def normhash(cls,hash):\n  ''\n  if cls.identify(hash):\n   return cls.from_string(hash).to_string()\n  else :\n   return hash\n   \n @classmethod\n def _generate_salt(cls):\n \n \n  salt=super(_BcryptCommon,cls)._generate_salt()\n  return bcrypt64.repair_unused(salt)\n  \n @classmethod\n def _norm_salt(cls,salt,**kwds):\n  salt=super(_BcryptCommon,cls)._norm_salt(salt,**kwds)\n  assert salt is not None ,\"HasSalt didn't generate new salt!\"\n  changed,salt=bcrypt64.check_repair_unused(salt)\n  if changed:\n  \n  \n   warn(\n   \"encountered a bcrypt salt with incorrectly set padding bits; \"\n   \"you may want to use bcrypt.normhash() \"\n   \"to fix this; this will be an error under Passlib 2.0\",\n   PasslibHashWarning)\n  return salt\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  checksum=super(_BcryptCommon,self)._norm_checksum(checksum,relaxed=relaxed)\n  changed,checksum=bcrypt64.check_repair_unused(checksum)\n  if changed:\n   warn(\n   \"encountered a bcrypt hash with incorrectly set padding bits; \"\n   \"you may want to use bcrypt.normhash() \"\n   \"to fix this; this will be an error under Passlib 2.0\",\n   PasslibHashWarning)\n  return checksum\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n _no_backend_suggestion=\" -- recommend you install one (e.g. 'pip install bcrypt')\"\n \n @classmethod\n def _finalize_backend_mixin(mixin_cls,backend,dryrun):\n  ''\n\n\n\n  \n  \n  \n  \n  assert mixin_cls is bcrypt._backend_mixin_map[backend],\\\n  \"_configure_workarounds() invoked from wrong class\"\n  \n  if mixin_cls._workrounds_initialized:\n   return True\n   \n  verify=mixin_cls.verify\n  \n  err_types=(ValueError,uh.exc.MissingBackendError)\n  if _bcryptor:\n   err_types +=(_bcryptor.engine.SaltError,)\n   \n  def safe_verify(secret,hash):\n   ''\n   try :\n    return verify(secret,hash)\n   except err_types:\n   \n   \n   \n   \n   \n   \n   \n   \n    return NotImplemented\n   except uh.exc.InternalBackendError:\n   \n   \n   \n    log.debug(\"trapped unexpected response from %r backend: verify(%r, %r):\",\n    backend,secret,hash,exc_info=True )\n    return NotImplemented\n    \n  def assert_lacks_8bit_bug(ident):\n   ''\n\n\n\n\n\n\n\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   secret=b\"\\xd1\\x91\"\n   bug_hash=ident.encode(\"ascii\")+b\"05$6bNw2HLQYeqHYyBfLMsv/OiwqTymGIGzFsA4hOTWebfehXHNprcAS\"\n   correct_hash=ident.encode(\"ascii\")+b\"05$6bNw2HLQYeqHYyBfLMsv/OUcZd0LKP39b87nBw3.S2tVZSqiQX6eu\"\n   \n   if verify(secret,bug_hash):\n   \n   \n   \n    raise PasslibSecurityError(\n    \"passlib.hash.bcrypt: Your installation of the %r backend is vulnerable to \"\n    \"the crypt_blowfish 8-bit bug (CVE-2011-2483) under %r hashes, \"\n    \"and should be upgraded or replaced with another backend\"%(backend,ident))\n    \n    \n    \n   if not verify(secret,correct_hash):\n    raise RuntimeError(\"%s backend failed to verify %s 8bit hash\"%(backend,ident))\n    \n  def detect_wrap_bug(ident):\n   ''\n\n\n\n\n\n\n\n\n\n\n   \n   \n   secret=(b\"0123456789\"*26)[:255]\n   bug_hash=ident.encode(\"ascii\")+b\"04$R1lJ2gkNaoPGdafE.H.16.nVyh2niHsGJhayOHLMiXlI45o8/DU.6\"\n   if verify(secret,bug_hash):\n    return True\n    \n    \n    \n   correct_hash=ident.encode(\"ascii\")+b\"04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi\"\n   if not verify(secret,correct_hash):\n    raise RuntimeError(\"%s backend failed to verify %s wraparound hash\"%(backend,ident))\n    \n   return False\n   \n  def assert_lacks_wrap_bug(ident):\n   if not detect_wrap_bug(ident):\n    return\n    \n    \n    \n   raise RuntimeError(\"%s backend unexpectedly has wraparound bug for %s\"%(backend,ident))\n   \n   \n   \n   \n  test_hash_20=b\"$2$04$5BJqKfqMQvV7nS.yUguNcuRfMMOXK0xPWavM7pOzjEi5ze5T1k8/S\"\n  result=safe_verify(\"test\",test_hash_20)\n  if result is NotImplemented:\n   mixin_cls._lacks_20_support=True\n   log.debug(\"%r backend lacks $2$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2$ hash\"%backend)\n   \n   \n   \n   \n  result=safe_verify(\"test\",TEST_HASH_2A)\n  if result is NotImplemented:\n  \n   raise RuntimeError(\"%s lacks support for $2a$ hashes\"%backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2a$ hash\"%backend)\n  else :\n   assert_lacks_8bit_bug(IDENT_2A)\n   if detect_wrap_bug(IDENT_2A):\n    if backend ==\"os_crypt\":\n    \n    \n    \n     log.debug(\"%r backend has $2a$ bsd wraparound bug, enabling workaround\",backend)\n    else :\n    \n    \n     warn(\"passlib.hash.bcrypt: Your installation of the %r backend is vulnerable to \"\n     \"the bsd wraparound bug, \"\n     \"and should be upgraded or replaced with another backend \"\n     \"(enabling workaround for now).\"%backend,\n     uh.exc.PasslibSecurityWarning)\n    mixin_cls._has_2a_wraparound_bug=True\n    \n    \n    \n    \n  test_hash_2y=TEST_HASH_2A.replace(\"2a\",\"2y\")\n  result=safe_verify(\"test\",test_hash_2y)\n  if result is NotImplemented:\n   mixin_cls._lacks_2y_support=True\n   log.debug(\"%r backend lacks $2y$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2y$ hash\"%backend)\n  else :\n  \n  \n   assert_lacks_8bit_bug(IDENT_2Y)\n   assert_lacks_wrap_bug(IDENT_2Y)\n   \n   \n   \n   \n   \n   \n   \n   \n  test_hash_2b=TEST_HASH_2A.replace(\"2a\",\"2b\")\n  result=safe_verify(\"test\",test_hash_2b)\n  if result is NotImplemented:\n   mixin_cls._lacks_2b_support=True\n   log.debug(\"%r backend lacks $2b$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2b$ hash\"%backend)\n  else :\n   mixin_cls._fallback_ident=IDENT_2B\n   assert_lacks_8bit_bug(IDENT_2B)\n   assert_lacks_wrap_bug(IDENT_2B)\n   \n   \n  mixin_cls._workrounds_initialized=True\n  return True\n  \n  \n  \n  \n  \n  \n  \n def _prepare_digest_args(self,secret):\n  ''\n\n\n  \n  return self._norm_digest_args(secret,self.ident,new=self.use_defaults)\n  \n @classmethod\n def _norm_digest_args(cls,secret,ident,new=False ):\n \n  require_valid_utf8_bytes=cls._require_valid_utf8_bytes\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  elif require_valid_utf8_bytes:\n  \n  \n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n   \n   \n    require_valid_utf8_bytes=False\n    \n    \n  uh.validate_secret(secret)\n  \n  \n  if new:\n   cls._check_truncate_policy(secret)\n   \n   \n   \n   \n  if _BNULL in secret:\n   raise uh.exc.NullPasswordError(cls)\n   \n   \n   \n   \n   \n   \n  if cls._has_2a_wraparound_bug and len(secret)>=255:\n   if require_valid_utf8_bytes:\n   \n   \n   \n   \n   \n    secret=utf8_truncate(secret,72)\n   else :\n    secret=secret[:72]\n    \n    \n  if ident ==IDENT_2A:\n  \n   pass\n   \n  elif ident ==IDENT_2B:\n   if cls._lacks_2b_support:\n   \n   \n   \n   \n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2Y:\n   if cls._lacks_2y_support:\n   \n   \n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2:\n   if cls._lacks_20_support:\n   \n   \n   \n    if secret:\n     if require_valid_utf8_bytes:\n     \n     \n     \n      secret=utf8_repeat_string(secret,72)\n     else :\n      secret=repeat_string(secret,72)\n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2X:\n  \n  \n  \n   raise RuntimeError(\"$2x$ hashes not currently supported by passlib\")\n   \n  else :\n   raise AssertionError(\"unexpected ident value: %r\"%ident)\n   \n  return secret,ident\n  \n  \n  \n  \nclass _NoBackend(_BcryptCommon):\n ''\n\n\n \n \n \n \n def _calc_checksum(self,secret):\n  self._stub_requires_backend()\n  \n  \n  return super(bcrypt,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _BcryptBackend(_BcryptCommon):\n ''\n\n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _bcrypt\n  if _detect_pybcrypt():\n  \n   return False\n  try :\n   import bcrypt as _bcrypt\n  except ImportError:\n   return False\n  try :\n   version=_bcrypt.__about__.__version__\n  except :\n   log.warning(\"(trapped) error reading bcrypt version\",exc_info=True )\n   version='<unknown>'\n   \n  log.debug(\"detected 'bcrypt' backend, version %r\",version)\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  if isinstance(config,unicode):\n   config=config.encode(\"ascii\")\n  hash=_bcrypt.hashpw(secret,config)\n  assert isinstance(hash,bytes)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"`bcrypt` package\")\n  return hash[-31:].decode(\"ascii\")\n  \n  \n  \n  \nclass _BcryptorBackend(_BcryptCommon):\n ''\n\n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _bcryptor\n  try :\n   import bcryptor as _bcryptor\n  except ImportError:\n   return False\n   \n   \n  if not dryrun:\n   warn(\"Support for `bcryptor` is deprecated, and will be removed in Passlib 1.8; \"\n   \"Please use `pip install bcrypt` instead\",DeprecationWarning)\n   \n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=_bcryptor.engine.Engine(False ).hash_key(secret,config)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"bcryptor library\")\n  return str_to_uascii(hash[-31:])\n  \n  \n  \n  \nclass _PyBcryptBackend(_BcryptCommon):\n ''\n\n \n \n \n _calc_lock=None\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _pybcrypt\n  if not _detect_pybcrypt():\n  \n   return False\n  try :\n   import bcrypt as _pybcrypt\n  except ImportError:\n  \n   return False\n   \n   \n  if not dryrun:\n   warn(\"Support for `py-bcrypt` is deprecated, and will be removed in Passlib 1.8; \"\n   \"Please use `pip install bcrypt` instead\",DeprecationWarning)\n   \n   \n  try :\n   version=_pybcrypt._bcrypt.__version__\n  except :\n   log.warning(\"(trapped) error reading pybcrypt version\",exc_info=True )\n   version=\"<unknown>\"\n  log.debug(\"detected 'pybcrypt' backend, version %r\",version)\n  \n  \n  vinfo=parse_version(version)or (0,0)\n  if vinfo <(0,3):\n   warn(\"py-bcrypt %s has a major security vulnerability, \"\n   \"you should upgrade to py-bcrypt 0.3 immediately.\"\n   %version,uh.exc.PasslibSecurityWarning)\n   if mixin_cls._calc_lock is None :\n    import threading\n    mixin_cls._calc_lock=threading.Lock()\n   mixin_cls._calc_checksum=get_unbound_method_function(mixin_cls._calc_checksum_threadsafe)\n   \n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum_threadsafe(self,secret):\n \n \n \n  with self._calc_lock:\n   return self._calc_checksum_raw(secret)\n   \n def _calc_checksum_raw(self,secret):\n \n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=_pybcrypt.hashpw(secret,config)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"pybcrypt library\")\n  return str_to_uascii(hash[-31:])\n  \n _calc_checksum=_calc_checksum_raw\n \n \n \n \nclass _OsCryptBackend(_BcryptCommon):\n ''\n\n \n \n \n \n _require_valid_utf8_bytes=not crypt_accepts_bytes\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n  if not test_crypt(\"test\",TEST_HASH_2A):\n   return False\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=safe_crypt(secret,config)\n  if hash is not None :\n   if not hash.startswith(config)or len(hash)!=len(config)+31:\n    raise uh.exc.CryptBackendError(self,config,hash)\n   return hash[-31:]\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if PY3 and isinstance(secret,bytes):\n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n    raise error_from(uh.exc.PasswordValueError(\n    \"python3 crypt.crypt() ony supports bytes passwords using UTF8; \"\n    \"passlib recommends running `pip install bcrypt` for general bcrypt support.\",\n    ),None )\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  debug_only_repr=uh.exc.debug_only_repr\n  raise uh.exc.InternalBackendError(\n  \"crypt.crypt() failed for unknown reason; \"\n  \"passlib recommends running `pip install bcrypt` for general bcrypt support.\"\n  \n  \"(config=%s, secret=%s)\"%(debug_only_repr(config),debug_only_repr(secret)),\n  )\n  \n  \n  \n  \nclass _BuiltinBackend(_BcryptCommon):\n ''\n\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n  from passlib.utils import as_bool\n  if not as_bool(os.environ.get(\"PASSLIB_BUILTIN_BCRYPT\")):\n   log.debug(\"bcrypt 'builtin' backend not enabled via $PASSLIB_BUILTIN_BCRYPT\")\n   return False\n  global _builtin_bcrypt\n  from passlib.crypto._blowfish import raw_bcrypt as _builtin_bcrypt\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n  secret,ident=self._prepare_digest_args(secret)\n  chk=_builtin_bcrypt(secret,ident[1:-1],\n  self.salt.encode(\"ascii\"),self.rounds)\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \nclass bcrypt(_NoBackend,_BcryptCommon):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n backends=(\"bcrypt\",\"pybcrypt\",\"bcryptor\",\"os_crypt\",\"builtin\")\n \n \n _backend_mixin_target=True\n \n \n _backend_mixin_map={\n None :_NoBackend,\n \"bcrypt\":_BcryptBackend,\n \"pybcrypt\":_PyBcryptBackend,\n \"bcryptor\":_BcryptorBackend,\n \"os_crypt\":_OsCryptBackend,\n \"builtin\":_BuiltinBackend,\n }\n \n \n \n \n \n \n \n \n_UDOLLAR=u(\"$\")\n\n\n\nclass _wrapped_bcrypt(bcrypt):\n ''\n\n\n\n \n setting_kwds=tuple(elem for elem in bcrypt.setting_kwds if elem not in [\"truncate_error\"])\n truncate_size=None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def _check_truncate_policy(cls,secret):\n \n  pass\n  \n  \n  \n  \n  \nclass bcrypt_sha256(_wrapped_bcrypt):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"bcrypt_sha256\"\n \n \n \n \n \n ident_values=(IDENT_2A,IDENT_2B)\n \n \n ident_aliases=(lambda ident_values:dict(item for item in bcrypt.ident_aliases.items()\n if item[1]in ident_values))(ident_values)\n default_ident=IDENT_2B\n \n \n \n \n \n _supported_versions=set([1,2])\n \n \n \n \n \n \n \n \n version=2\n \n \n \n \n \n @classmethod\n def using(cls,version=None ,**kwds):\n  subcls=super(bcrypt_sha256,cls).using(**kwds)\n  if version is not None :\n   subcls.version=subcls._norm_version(version)\n  ident=subcls.default_ident\n  if subcls.version >1 and ident !=IDENT_2B:\n   raise ValueError(\"bcrypt %r hashes not allowed for version %r\"%\n   (ident,subcls.version))\n  return subcls\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n prefix=u('$bcrypt-sha256$')\n \n \n _v2_hash_re=re.compile(r\"\"\"(?x)\n        ^\n        [$]bcrypt-sha256[$]\n        v=(?P<version>\\d+),\n        t=(?P<type>2b),\n        r=(?P<rounds>\\d{1,2})\n        [$](?P<salt>[^$]{22})\n        (?:[$](?P<digest>[^$]{31}))?\n        $\n        \"\"\")\n \n \n _v1_hash_re=re.compile(r\"\"\"(?x)\n        ^\n        [$]bcrypt-sha256[$]\n        (?P<type>2[ab]),\n        (?P<rounds>\\d{1,2})\n        [$](?P<salt>[^$]{22})\n        (?:[$](?P<digest>[^$]{31}))?\n        $\n        \"\"\")\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  if not hash:\n   return False\n  return hash.startswith(cls.prefix)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if not hash.startswith(cls.prefix):\n   raise uh.exc.InvalidHashError(cls)\n  m=cls._v2_hash_re.match(hash)\n  if m:\n   version=int(m.group(\"version\"))\n   if version <2:\n    raise uh.exc.MalformedHashError(cls)\n  else :\n   m=cls._v1_hash_re.match(hash)\n   if m:\n    version=1\n   else :\n    raise uh.exc.MalformedHashError(cls)\n  rounds=m.group(\"rounds\")\n  if rounds.startswith(uh._UZERO)and rounds !=uh._UZERO:\n   raise uh.exc.ZeroPaddedRoundsError(cls)\n  return cls(\n  version=version,\n  ident=m.group(\"type\"),\n  rounds=int(rounds),\n  salt=m.group(\"salt\"),\n  checksum=m.group(\"digest\"),\n  )\n  \n _v2_template=u(\"$bcrypt-sha256$v=2,t=%s,r=%d$%s$%s\")\n _v1_template=u(\"$bcrypt-sha256$%s,%d$%s$%s\")\n \n def to_string(self):\n  if self.version ==1:\n   template=self._v1_template\n  else :\n   template=self._v2_template\n  hash=template %(self.ident.strip(_UDOLLAR),self.rounds,self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n def __init__(self,version=None ,**kwds):\n  if version is not None :\n   self.version=self._norm_version(version)\n  super(bcrypt_sha256,self).__init__(**kwds)\n  \n  \n  \n  \n  \n @classmethod\n def _norm_version(cls,version):\n  if version not in cls._supported_versions:\n   raise ValueError(\"%s: unknown or unsupported version: %r\"%(cls.name,version))\n  return version\n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n \n \n \n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n  if self.version ==1:\n  \n  \n  \n   digest=sha256(secret).digest()\n  else :\n  \n  \n  \n  \n  \n  \n  \n  \n   salt=self.salt\n   if salt[-1]not in self.final_salt_chars:\n   \n   \n   \n    raise ValueError(\"invalid salt string\")\n   digest=compile_hmac(\"sha256\",salt.encode(\"ascii\"))(secret)\n   \n   \n   \n  key=b64encode(digest)\n  \n  \n  return super(bcrypt_sha256,self)._calc_checksum(key)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  if self.version <type(self).version:\n   return True\n  return super(bcrypt_sha256,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "base64", "bcrypt", "bcrypt._bcrypt", "bcryptor", "hashlib", "logging", "os", "passlib.crypto._blowfish", "passlib.crypto.digest", "passlib.exc", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "threading", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.windows": [".py", "''\n\n\n\n\nfrom binascii import hexlify\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_unicode,right_pad_string\nfrom passlib.utils.compat import unicode\nfrom passlib.crypto.digest import lookup_hash\nmd4=lookup_hash(\"md4\").const\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"lmhash\",\n\"nthash\",\n\"bsd_nthash\",\n\"msdcc\",\n\"msdcc2\",\n]\n\n\n\n\nclass lmhash(uh.TruncateMixin,uh.HasEncodingContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"lmhash\"\n setting_kwds=(\"truncate_error\",)\n \n \n \n \n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n truncate_size=14\n \n \n \n \n default_encoding=\"cp437\"\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n  return hexlify(self.raw(secret,self.encoding)).decode(\"ascii\")\n  \n  \n _magic=b\"KGS!@#$%\"\n \n @classmethod\n def raw(cls,secret,encoding=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not encoding:\n   encoding=cls.default_encoding\n   \n   \n   \n  from passlib.crypto.des import des_encrypt_block\n  MAGIC=cls._magic\n  if isinstance(secret,unicode):\n  \n  \n  \n   secret=secret.upper().encode(encoding)\n  elif isinstance(secret,bytes):\n  \n  \n  \n  \n   secret=secret.upper()\n  else :\n   raise TypeError(\"secret must be unicode or bytes\")\n  secret=right_pad_string(secret,14)\n  return des_encrypt_block(secret[0:7],MAGIC)+\\\n  des_encrypt_block(secret[7:14],MAGIC)\n  \n  \n  \n  \n  \n  \n  \n  \nclass nthash(uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n \n \n \n \n name=\"nthash\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret):\n  ''\n\n\n\n\n  \n  secret=to_unicode(secret,\"utf-8\",param=\"secret\")\n  \n  return md4(secret.encode(\"utf-16-le\")).digest()\n  \n @classmethod\n def raw_nthash(cls,secret,hex=False ):\n  warn(\"nthash.raw_nthash() is deprecated, and will be removed \"\n  \"in Passlib 1.8, please use nthash.raw() instead\",\n  DeprecationWarning)\n  ret=nthash.raw(secret)\n  return hexlify(ret).decode(\"ascii\")if hex else ret\n  \n  \n  \n  \n  \nbsd_nthash=uh.PrefixWrapper(\"bsd_nthash\",nthash,prefix=\"$3$$\",ident=\"$3$$\",\ndoc=\"\"\"The class support FreeBSD's representation of NTHASH\n    (which is compatible with the :ref:`modular-crypt-format`),\n    and follows the :ref:`password-hash-api`.\n\n    It has no salt and a single fixed round.\n\n    The :meth:`~passlib.ifc.PasswordHash.hash` and :meth:`~passlib.ifc.PasswordHash.genconfig` methods accept no optional keywords.\n    \"\"\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass msdcc(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"msdcc\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret,self.user)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret,user):\n  ''\n\n\n\n\n\n  \n  secret=to_unicode(secret,\"utf-8\",param=\"secret\").encode(\"utf-16-le\")\n  user=to_unicode(user,\"utf-8\",param=\"user\").lower().encode(\"utf-16-le\")\n  return md4(md4(secret).digest()+user).digest()\n  \n  \n  \n  \nclass msdcc2(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"msdcc2\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret,self.user)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret,user):\n  ''\n\n\n\n\n\n\n\n\n  \n  from passlib.crypto.digest import pbkdf2_hmac\n  secret=to_unicode(secret,\"utf-8\",param=\"secret\").encode(\"utf-16-le\")\n  user=to_unicode(user,\"utf-8\",param=\"user\").lower().encode(\"utf-16-le\")\n  tmp=md4(md4(secret).digest()+user).digest()\n  return pbkdf2_hmac(\"sha1\",tmp,user,10240,16)\n  \n  \n  \n  \n", ["binascii", "logging", "passlib.crypto.des", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.oracle": [".py", "''\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode,xor_bytes\nfrom passlib.utils.compat import irange,u,\\\nuascii_to_str,unicode,str_to_uascii\nfrom passlib.crypto.des import des_encrypt_block\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"oracle10g\",\n\"oracle11g\"\n]\n\n\n\n\ndef des_cbc_encrypt(key,value,iv=b'\\x00'*8,pad=b'\\x00'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n value +=pad *(-len(value)%8)\n hash=iv\n for offset in irange(0,len(value),8):\n  chunk=xor_bytes(hash,value[offset:offset+8])\n  hash=des_encrypt_block(key,chunk)\n return hash\n \n \nORACLE10_MAGIC=b\"\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\"\n\nclass oracle10(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"oracle10\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=16\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.upper()\n  \n def _calc_checksum(self,secret):\n \n \n \n \n \n \n \n \n \n \n \n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  user=to_unicode(self.user,\"utf-8\",param=\"user\")\n  input=(user+secret).upper().encode(\"utf-16-be\")\n  hash=des_cbc_encrypt(ORACLE10_MAGIC,input)\n  hash=des_cbc_encrypt(hash,input)\n  return hexlify(hash).decode(\"ascii\").upper()\n  \n  \n  \n  \n  \n  \n  \n  \nclass oracle11(uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"oracle11\"\n setting_kwds=(\"salt\",)\n checksum_size=40\n checksum_chars=uh.UPPER_HEX_CHARS\n \n \n min_salt_size=max_salt_size=20\n salt_chars=uh.UPPER_HEX_CHARS\n \n \n \n \n \n _hash_regex=re.compile(u(\"^S:(?P<chk>[0-9a-f]{40})(?P<salt>[0-9a-f]{20})$\"),re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk.upper())\n  \n def to_string(self):\n  chk=self.checksum\n  hash=u(\"S:%s%s\")%(chk.upper(),self.salt.upper())\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=sha1(secret+unhexlify(self.salt.encode(\"ascii\"))).hexdigest()\n  return str_to_uascii(chk).upper()\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.crypto.des", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re"]], "passlib.Lib.site-packages.passlib.handlers.ldap_digests": [".py", "''\n\n\n\n\n\nfrom base64 import b64encode,b64decode\nfrom hashlib import md5,sha1,sha256,sha512\nimport logging ;log=logging.getLogger(__name__)\nimport re\n\n\nfrom passlib.handlers.misc import plaintext\nfrom passlib.utils import unix_crypt_schemes,to_unicode\nfrom passlib.utils.compat import uascii_to_str,unicode,u\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"ldap_plaintext\",\n\"ldap_md5\",\n\"ldap_sha1\",\n\"ldap_salted_md5\",\n\"ldap_salted_sha1\",\n\"ldap_salted_sha256\",\n\"ldap_salted_sha512\",\n\n\n\"ldap_des_crypt\",\n\"ldap_bsdi_crypt\",\n\"ldap_md5_crypt\",\n\"ldap_sha1_crypt\",\n\"ldap_bcrypt\",\n\"ldap_sha256_crypt\",\n\"ldap_sha512_crypt\",\n]\n\n\n\n\nclass _Base64DigestHelper(uh.StaticHandler):\n ''\n \n \n ident=None\n _hash_func=None\n _hash_regex=None\n checksum_chars=uh.PADDED_BASE64_CHARS\n \n @classproperty\n def _hash_prefix(cls):\n  ''\n  return cls.ident\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=self._hash_func(secret).digest()\n  return b64encode(chk).decode(\"ascii\")\n  \nclass _SaltedBase64DigestHelper(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n setting_kwds=(\"salt\",\"salt_size\")\n checksum_chars=uh.PADDED_BASE64_CHARS\n \n ident=None\n _hash_func=None\n _hash_regex=None\n min_salt_size=max_salt_size=4\n \n \n \n \n min_salt_size=4\n default_salt_size=4\n max_salt_size=16\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  try :\n   data=b64decode(m.group(\"tmp\").encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n  cs=cls.checksum_size\n  assert cs\n  return cls(checksum=data[:cs],salt=data[cs:])\n  \n def to_string(self):\n  data=self.checksum+self.salt\n  hash=self.ident+b64encode(data).decode(\"ascii\")\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return self._hash_func(secret+self.salt).digest()\n  \n  \n  \n  \nclass ldap_md5(_Base64DigestHelper):\n ''\n\n\n \n name=\"ldap_md5\"\n ident=u(\"{MD5}\")\n _hash_func=md5\n _hash_regex=re.compile(u(r\"^\\{MD5\\}(?P<chk>[+/a-zA-Z0-9]{22}==)$\"))\n \nclass ldap_sha1(_Base64DigestHelper):\n ''\n\n\n \n name=\"ldap_sha1\"\n ident=u(\"{SHA}\")\n _hash_func=sha1\n _hash_regex=re.compile(u(r\"^\\{SHA\\}(?P<chk>[+/a-zA-Z0-9]{27}=)$\"))\n \nclass ldap_salted_md5(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_md5\"\n ident=u(\"{SMD5}\")\n checksum_size=16\n _hash_func=md5\n _hash_regex=re.compile(u(r\"^\\{SMD5\\}(?P<tmp>[+/a-zA-Z0-9]{27,}={0,2})$\"))\n \nclass ldap_salted_sha1(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha1\"\n ident=u(\"{SSHA}\")\n checksum_size=20\n _hash_func=sha1\n \n _hash_regex=re.compile(u(r\"^\\{SSHA\\}(?P<tmp>[+/a-zA-Z0-9]{32,}={0,2})$\"))\n \n \n \nclass ldap_salted_sha256(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha256\"\n ident=u(\"{SSHA256}\")\n checksum_size=32\n default_salt_size=8\n _hash_func=sha256\n \n _hash_regex=re.compile(u(r\"^\\{SSHA256\\}(?P<tmp>[+/a-zA-Z0-9]{48,}={0,2})$\"))\n \n \nclass ldap_salted_sha512(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha512\"\n ident=u(\"{SSHA512}\")\n checksum_size=64\n default_salt_size=8\n _hash_func=sha512\n \n _hash_regex=re.compile(u(r\"^\\{SSHA512\\}(?P<tmp>[+/a-zA-Z0-9]{91,}={0,2})$\"))\n \n \nclass ldap_plaintext(plaintext):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"ldap_plaintext\"\n _2307_pat=re.compile(u(r\"^\\{\\w+\\}.*$\"))\n \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n \n \n  return \"!\"\n  \n @classmethod\n def identify(cls,hash):\n \n  hash=uh.to_unicode_for_identify(hash)\n  return bool(hash)and cls._2307_pat.match(hash)is None\n  \n  \n  \n  \n  \n  \nldap_crypt_schemes=['ldap_'+name for name in unix_crypt_schemes]\n\ndef _init_ldap_crypt_handlers():\n\n\n g=globals()\n for wname in unix_crypt_schemes:\n  name='ldap_'+wname\n  g[name]=uh.PrefixWrapper(name,wname,prefix=u(\"{CRYPT}\"),lazy=True )\n del g\n_init_ldap_crypt_handlers()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ["base64", "hashlib", "logging", "passlib.handlers.misc", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers", "re"]], "passlib.Lib.site-packages.passlib.handlers.scram": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import consteq,saslprep,to_native_str,splitcomma\nfrom passlib.utils.binary import ab64_decode,ab64_encode\nfrom passlib.utils.compat import bascii_to_str,iteritems,u,native_string_types\nfrom passlib.crypto.digest import pbkdf2_hmac,norm_hash_name\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"scram\",\n]\n\n\n\n\nclass scram(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n name=\"scram\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\",\"algs\")\n ident=u(\"$scram$\")\n \n \n default_salt_size=12\n max_salt_size=1024\n \n \n default_rounds=100000\n min_rounds=1\n max_rounds=2 **32 -1\n rounds_cost=\"linear\"\n \n \n \n \n default_algs=[\"sha-1\",\"sha-256\",\"sha-512\"]\n \n \n _verify_algs=[\"sha-256\",\"sha-512\",\"sha-224\",\"sha-384\",\"sha-1\"]\n \n \n \n \n \n \n \n \n \n \n algs=None\n \n \n \n \n @classmethod\n def extract_digest_info(cls,hash,alg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  alg=norm_hash_name(alg,'iana')\n  self=cls.from_string(hash)\n  chkmap=self.checksum\n  if not chkmap:\n   raise ValueError(\"scram hash contains no digests\")\n  return self.salt,self.rounds,chkmap[alg]\n  \n @classmethod\n def extract_digest_algs(cls,hash,format=\"iana\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  algs=cls.from_string(hash).algs\n  if format ==\"iana\":\n   return algs\n  else :\n   return [norm_hash_name(alg,format)for alg in algs]\n   \n @classmethod\n def derive_digest(cls,password,salt,rounds,alg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(password,bytes):\n   password=password.decode(\"utf-8\")\n   \n   \n  return pbkdf2_hmac(alg,saslprep(password),salt,rounds)\n  \n  \n  \n  \n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_native_str(hash,\"ascii\",\"hash\")\n  if not hash.startswith(\"$scram$\"):\n   raise uh.exc.InvalidHashError(cls)\n  parts=hash[7:].split(\"$\")\n  if len(parts)!=3:\n   raise uh.exc.MalformedHashError(cls)\n  rounds_str,salt_str,chk_str=parts\n  \n  \n  rounds=int(rounds_str)\n  if rounds_str !=str(rounds):\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  try :\n   salt=ab64_decode(salt_str.encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  if not chk_str:\n  \n   raise uh.exc.MalformedHashError(cls)\n  elif \"=\"in chk_str:\n  \n   algs=None\n   chkmap={}\n   for pair in chk_str.split(\",\"):\n    alg,digest=pair.split(\"=\")\n    try :\n     chkmap[alg]=ab64_decode(digest.encode(\"ascii\"))\n    except TypeError:\n     raise uh.exc.MalformedHashError(cls)\n  else :\n  \n   algs=chk_str\n   chkmap=None\n   \n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chkmap,\n  algs=algs,\n  )\n  \n def to_string(self):\n  salt=bascii_to_str(ab64_encode(self.salt))\n  chkmap=self.checksum\n  chk_str=\",\".join(\n  \"%s=%s\"%(alg,bascii_to_str(ab64_encode(chkmap[alg])))\n  for alg in self.algs\n  )\n  return '$scram$%d$%s$%s'%(self.rounds,salt,chk_str)\n  \n  \n  \n  \n @classmethod\n def using(cls,default_algs=None ,algs=None ,**kwds):\n \n  if algs is not None :\n   assert default_algs is None\n   default_algs=algs\n   \n   \n  subcls=super(scram,cls).using(**kwds)\n  \n  \n  if default_algs is not None :\n   subcls.default_algs=cls._norm_algs(default_algs)\n  return subcls\n  \n  \n  \n  \n def __init__(self,algs=None ,**kwds):\n  super(scram,self).__init__(**kwds)\n  \n  \n  digest_map=self.checksum\n  if algs is not None :\n   if digest_map is not None :\n    raise RuntimeError(\"checksum & algs kwds are mutually exclusive\")\n   algs=self._norm_algs(algs)\n  elif digest_map is not None :\n  \n   algs=self._norm_algs(digest_map.keys())\n  elif self.use_defaults:\n   algs=list(self.default_algs)\n   assert self._norm_algs(algs)==algs,\"invalid default algs: %r\"%(algs,)\n  else :\n   raise TypeError(\"no algs list specified\")\n  self.algs=algs\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  if not isinstance(checksum,dict):\n   raise uh.exc.ExpectedTypeError(checksum,\"dict\",\"checksum\")\n  for alg,digest in iteritems(checksum):\n   if alg !=norm_hash_name(alg,'iana'):\n    raise ValueError(\"malformed algorithm name in scram hash: %r\"%\n    (alg,))\n   if len(alg)>9:\n    raise ValueError(\"SCRAM limits algorithm names to \"\n    \"9 characters: %r\"%(alg,))\n   if not isinstance(digest,bytes):\n    raise uh.exc.ExpectedTypeError(digest,\"raw bytes\",\"digests\")\n    \n  if 'sha-1'not in checksum:\n  \n   raise ValueError(\"sha-1 must be in algorithm list of scram hash\")\n  return checksum\n  \n @classmethod\n def _norm_algs(cls,algs):\n  ''\n  if isinstance(algs,native_string_types):\n   algs=splitcomma(algs)\n  algs=sorted(norm_hash_name(alg,'iana')for alg in algs)\n  if any(len(alg)>9 for alg in algs):\n   raise ValueError(\"SCRAM limits alg names to max of 9 characters\")\n  if 'sha-1'not in algs:\n  \n   raise ValueError(\"sha-1 must be in algorithm list of scram hash\")\n  return algs\n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n \n \n \n  if not set(self.algs).issuperset(self.default_algs):\n   return True\n   \n   \n  return super(scram,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n def _calc_checksum(self,secret,alg=None ):\n  rounds=self.rounds\n  salt=self.salt\n  hash=self.derive_digest\n  if alg:\n  \n   return hash(secret,salt,rounds,alg)\n  else :\n  \n   return dict(\n   (alg,hash(secret,salt,rounds,alg))\n   for alg in self.algs\n   )\n   \n @classmethod\n def verify(cls,secret,hash,full=False ):\n  uh.validate_secret(secret)\n  self=cls.from_string(hash)\n  chkmap=self.checksum\n  if not chkmap:\n   raise ValueError(\"expected %s hash, got %s config string instead\"%\n   (cls.name,cls.name))\n   \n   \n   \n   \n  if full:\n   correct=failed=False\n   for alg,digest in iteritems(chkmap):\n    other=self._calc_checksum(secret,alg)\n    \n    \n    \n    \n    if len(digest)!=len(other):\n     raise ValueError(\"mis-sized %s digest in scram hash: %r != %r\"\n     %(alg,len(digest),len(other)))\n    if consteq(other,digest):\n     correct=True\n    else :\n     failed=True\n   if correct and failed:\n    raise ValueError(\"scram hash verified inconsistently, \"\n    \"may be corrupted\")\n   else :\n    return correct\n  else :\n  \n  \n   for alg in self._verify_algs:\n    if alg in chkmap:\n     other=self._calc_checksum(secret,alg)\n     return consteq(other,chkmap[alg])\n     \n     \n   raise AssertionError(\"sha-1 digest not found!\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n", ["logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.sha1_crypt": [".py", "''\n\n\n\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import u,unicode,irange\nfrom passlib.crypto.digest import compile_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n]\n\n\n\n_BNULL=b'\\x00'\n\nclass sha1_crypt(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"sha1_crypt\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$sha1$\")\n checksum_size=28\n checksum_chars=uh.HASH64_CHARS\n \n \n default_salt_size=8\n max_salt_size=64\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=480000\n min_rounds=1\n max_rounds=4294967295\n rounds_cost=\"linear\"\n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self,config=False ):\n  chk=None if config else self.checksum\n  return uh.render_mc3(self.ident,self.rounds,self.salt,chk)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'$sha1$1$Wq3GL2Vp$C8U25GvfHS8qGHim'\n  'ExLaiSFlGkAe'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string(config=True )\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config)or len(hash)!=len(config)+29:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-28:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  if _BNULL in secret:\n   raise uh.exc.NullPasswordError(self)\n  rounds=self.rounds\n  \n  result=(u(\"%s$sha1$%s\")%(self.salt,rounds)).encode(\"ascii\")\n  \n  keyed_hmac=compile_hmac(\"sha1\",secret)\n  for _ in irange(rounds):\n   result=keyed_hmac(result)\n  return h64.encode_transposed_bytes(result,self._chk_offsets).decode(\"ascii\")\n  \n _chk_offsets=[\n 2,1,0,\n 5,4,3,\n 8,7,6,\n 11,10,9,\n 14,13,12,\n 17,16,15,\n 0,19,18,\n ]\n \n \n \n \n \n \n \n \n", ["logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.Lib.site-packages.passlib.handlers.mysql": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_native_str\nfrom passlib.utils.compat import bascii_to_str,unicode,u,\\\nbyte_elem_value,str_to_uascii\nimport passlib.utils.handlers as uh\n\n__all__=[\n'mysql323',\n'mysq41',\n]\n\n\n\n\nclass mysql323(uh.StaticHandler):\n ''\n\n\n\n\n \n \n \n \n name=\"mysql323\"\n checksum_size=16\n checksum_chars=uh.HEX_CHARS\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n  MASK_32=0xffffffff\n  MASK_31=0x7fffffff\n  WHITE=b' \\t'\n  \n  nr1=0x50305735\n  nr2=0x12345671\n  add=7\n  for c in secret:\n   if c in WHITE:\n    continue\n   tmp=byte_elem_value(c)\n   nr1 ^=((((nr1&63)+add)*tmp)+(nr1 <<8))&MASK_32\n   nr2=(nr2+((nr2 <<8)^nr1))&MASK_32\n   add=(add+tmp)&MASK_32\n  return u(\"%08x%08x\")%(nr1&MASK_31,nr2&MASK_31)\n  \n  \n  \n  \n  \n  \n  \n  \nclass mysql41(uh.StaticHandler):\n ''\n\n\n\n\n \n \n \n \n name=\"mysql41\"\n _hash_prefix=u(\"*\")\n checksum_chars=uh.HEX_CHARS\n checksum_size=40\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.upper()\n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(sha1(sha1(secret).digest()).hexdigest()).upper()\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.Lib.site-packages.passlib.handlers.fshp": [".py", "''\n\n\n\n\n\n\nfrom base64 import b64encode,b64decode\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode\nimport passlib.utils.handlers as uh\nfrom passlib.utils.compat import bascii_to_str,iteritems,u,\\\nunicode\nfrom passlib.crypto.digest import pbkdf1\n\n__all__=[\n'fshp',\n]\n\n\n\nclass fshp(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"fshp\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\",\"variant\")\n checksum_chars=uh.PADDED_BASE64_CHARS\n ident=u(\"{FSHP\")\n \n \n \n default_salt_size=16\n max_salt_size=None\n \n \n \n \n default_rounds=480000\n min_rounds=1\n max_rounds=4294967295\n rounds_cost=\"linear\"\n \n \n default_variant=1\n _variant_info={\n \n 0:(\"sha1\",20),\n 1:(\"sha256\",32),\n 2:(\"sha384\",48),\n 3:(\"sha512\",64),\n }\n _variant_aliases=dict(\n [(unicode(k),k)for k in _variant_info]+\n [(v[0],k)for k,v in iteritems(_variant_info)]\n )\n \n \n \n \n @classmethod\n def using(cls,variant=None ,**kwds):\n  subcls=super(fshp,cls).using(**kwds)\n  if variant is not None :\n   subcls.default_variant=cls._norm_variant(variant)\n  return subcls\n  \n  \n  \n  \n variant=None\n \n \n \n \n def __init__(self,variant=None ,**kwds):\n \n  self.use_defaults=kwds.get(\"use_defaults\")\n  if variant is not None :\n   variant=self._norm_variant(variant)\n  elif self.use_defaults:\n   variant=self.default_variant\n   assert self._norm_variant(variant)==variant,\"invalid default variant: %r\"%(variant,)\n  else :\n   raise TypeError(\"no variant specified\")\n  self.variant=variant\n  super(fshp,self).__init__(**kwds)\n  \n @classmethod\n def _norm_variant(cls,variant):\n  if isinstance(variant,bytes):\n   variant=variant.decode(\"ascii\")\n  if isinstance(variant,unicode):\n   try :\n    variant=cls._variant_aliases[variant]\n   except KeyError:\n    raise ValueError(\"invalid fshp variant\")\n  if not isinstance(variant,int):\n   raise TypeError(\"fshp variant must be int or known alias\")\n  if variant not in cls._variant_info:\n   raise ValueError(\"invalid fshp variant\")\n  return variant\n  \n @property\n def checksum_alg(self):\n  return self._variant_info[self.variant][0]\n  \n @property\n def checksum_size(self):\n  return self._variant_info[self.variant][1]\n  \n  \n  \n  \n  \n _hash_regex=re.compile(u(r\"\"\"\n            ^\n            \\{FSHP\n            (\\d+)\\| # variant\n            (\\d+)\\| # salt size\n            (\\d+)\\} # rounds\n            ([a-zA-Z0-9+/]+={0,3}) # digest\n            $\"\"\"),re.X)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  variant,salt_size,rounds,data=m.group(1,2,3,4)\n  variant=int(variant)\n  salt_size=int(salt_size)\n  rounds=int(rounds)\n  try :\n   data=b64decode(data.encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n  salt=data[:salt_size]\n  chk=data[salt_size:]\n  return cls(salt=salt,checksum=chk,rounds=rounds,variant=variant)\n  \n def to_string(self):\n  chk=self.checksum\n  salt=self.salt\n  data=bascii_to_str(b64encode(salt+chk))\n  return \"{FSHP%d|%d|%d}%s\"%(self.variant,len(salt),self.rounds,data)\n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n   \n  return pbkdf1(\n  digest=self.checksum_alg,\n  secret=self.salt,\n  salt=secret,\n  rounds=self.rounds,\n  keylen=self.checksum_size,\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n", ["base64", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re"]], "passlib.handlers.django": [".py", "''\n\n\n\n\nfrom base64 import b64encode\nfrom binascii import hexlify\nfrom hashlib import md5,sha1,sha256\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.handlers.bcrypt import _wrapped_bcrypt\nfrom passlib.hash import argon2,bcrypt,pbkdf2_sha1,pbkdf2_sha256\nfrom passlib.utils import to_unicode,rng,getrandstr\nfrom passlib.utils.binary import BASE64_CHARS\nfrom passlib.utils.compat import str_to_uascii,uascii_to_str,unicode,u\nfrom passlib.crypto.digest import pbkdf2_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"django_salted_sha1\",\n\"django_salted_md5\",\n\"django_bcrypt\",\n\"django_pbkdf2_sha1\",\n\"django_pbkdf2_sha256\",\n\"django_argon2\",\n\"django_des_crypt\",\n\"django_disabled\",\n]\n\n\n\n\n\n\ndes_crypt=None\n\ndef _import_des_crypt():\n global des_crypt\n if des_crypt is None :\n  from passlib.hash import des_crypt\n return des_crypt\n \n \nSALT_CHARS='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n\n\n\nclass DjangoSaltedHash(uh.HasSalt,uh.GenericHandler):\n ''\n \n \n setting_kwds=(\"salt\",\"salt_size\")\n \n \n \n \n \n default_salt_size=12\n max_salt_size=None\n salt_chars=SALT_CHARS\n \n checksum_chars=uh.LOWER_HEX_CHARS\n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc2(self.ident,self.salt,self.checksum)\n  \n  \nclass DjangoVariableHash(uh.HasRounds,DjangoSaltedHash):\n ''\n setting_kwds=DjangoSaltedHash.setting_kwds+(\"rounds\",)\n \n min_rounds=1\n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc3(self.ident,self.rounds,self.salt,self.checksum)\n  \nclass django_salted_sha1(DjangoSaltedHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_salted_sha1\"\n django_name=\"sha1\"\n ident=u(\"sha1$\")\n checksum_size=40\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(sha1(self.salt.encode(\"ascii\")+secret).hexdigest())\n  \nclass django_salted_md5(DjangoSaltedHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_salted_md5\"\n django_name=\"md5\"\n ident=u(\"md5$\")\n checksum_size=32\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(md5(self.salt.encode(\"ascii\")+secret).hexdigest())\n  \n  \n  \n  \n  \ndjango_bcrypt=uh.PrefixWrapper(\"django_bcrypt\",bcrypt,\nprefix=u('bcrypt$'),ident=u(\"bcrypt$\"),\n\n\ndoc=\"\"\"This class implements Django 1.4's BCrypt wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!bcrypt` itself, but with\n    the Django-specific prefix ``\"bcrypt$\"`` prepended.\n\n    See :doc:`/lib/passlib.hash.bcrypt` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.4's :class:`!BCryptPasswordHasher` class.\n\n    .. versionadded:: 1.6\n    \"\"\")\ndjango_bcrypt.django_name=\"bcrypt\"\ndjango_bcrypt._using_clone_attrs +=(\"django_name\",)\n\n\n\n\n\nclass django_bcrypt_sha256(_wrapped_bcrypt):\n ''\n\n\n\n\n\n\n\n\n \n name=\"django_bcrypt_sha256\"\n django_name=\"bcrypt_sha256\"\n _digest=sha256\n \n \n \n \n \n \n django_prefix=u('bcrypt_sha256$')\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  if not hash:\n   return False\n  return hash.startswith(cls.django_prefix)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if not hash.startswith(cls.django_prefix):\n   raise uh.exc.InvalidHashError(cls)\n  bhash=hash[len(cls.django_prefix):]\n  if not bhash.startswith(\"$2\"):\n   raise uh.exc.MalformedHashError(cls)\n  return super(django_bcrypt_sha256,cls).from_string(bhash)\n  \n def to_string(self):\n  bhash=super(django_bcrypt_sha256,self).to_string()\n  return uascii_to_str(self.django_prefix)+bhash\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  secret=hexlify(self._digest(secret).digest())\n  return super(django_bcrypt_sha256,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \nclass django_pbkdf2_sha256(DjangoVariableHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_pbkdf2_sha256\"\n django_name=\"pbkdf2_sha256\"\n ident=u('pbkdf2_sha256$')\n min_salt_size=1\n max_rounds=0xffffffff\n checksum_chars=uh.PADDED_BASE64_CHARS\n checksum_size=44\n default_rounds=pbkdf2_sha256.default_rounds\n _digest=\"sha256\"\n \n def _calc_checksum(self,secret):\n \n  hash=pbkdf2_hmac(self._digest,secret,self.salt,self.rounds)\n  return b64encode(hash).rstrip().decode(\"ascii\")\n  \nclass django_pbkdf2_sha1(django_pbkdf2_sha256):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_pbkdf2_sha1\"\n django_name=\"pbkdf2_sha1\"\n ident=u('pbkdf2_sha1$')\n checksum_size=28\n default_rounds=pbkdf2_sha1.default_rounds\n _digest=\"sha1\"\n \n \n \n \n \n \n \n \ndjango_argon2=uh.PrefixWrapper(\nname=\"django_argon2\",\nwrapped=argon2.using(type=\"I\"),\nprefix=u('argon2'),\nident=u('argon2$argon2i$'),\n\n\ndoc=\"\"\"This class implements Django 1.10's Argon2 wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!argon2` itself, but with\n    the Django-specific prefix ``\"argon2$\"`` prepended.\n\n    See :doc:`argon2 </lib/passlib.hash.argon2>` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.10's :class:`!Argon2PasswordHasher` class.\n\n    .. versionadded:: 1.7\n    \"\"\")\ndjango_argon2.django_name=\"argon2\"\ndjango_argon2._using_clone_attrs +=(\"django_name\",)\n\n\n\n\nclass django_des_crypt(uh.TruncateMixin,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_des_crypt\"\n django_name=\"crypt\"\n setting_kwds=(\"salt\",\"salt_size\",\"truncate_error\")\n ident=u(\"crypt$\")\n checksum_chars=salt_chars=uh.HASH64_CHARS\n checksum_size=11\n min_salt_size=default_salt_size=2\n truncate_size=8\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n use_duplicate_salt=True\n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  if chk:\n  \n   if not salt:\n   \n   \n    salt=chk[:2]\n   elif salt[:2]!=chk[:2]:\n   \n   \n   \n    raise uh.exc.MalformedHashError(cls,\n    \"first two digits of salt and checksum must match\")\n    \n   chk=chk[2:]\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=self.salt\n  chk=salt[:2]+self.checksum\n  if self.use_duplicate_salt:\n  \n   return uh.render_mc2(self.ident,salt,chk)\n  else :\n  \n   return uh.render_mc2(self.ident,\"\",chk)\n   \n def _calc_checksum(self,secret):\n \n \n  global des_crypt\n  if des_crypt is None :\n   _import_des_crypt()\n   \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n  return des_crypt(salt=self.salt[:2])._calc_checksum(secret)\n  \nclass django_disabled(uh.ifc.DisabledHash,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_disabled\"\n _hash_prefix=u(\"!\")\n suffix_length=40\n \n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return hash.startswith(cls._hash_prefix)\n  \n def _calc_checksum(self,secret):\n \n  return getrandstr(rng,BASE64_CHARS[:-2],self.suffix_length)\n  \n @classmethod\n def verify(cls,secret,hash):\n  uh.validate_secret(secret)\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return False\n  \n  \n  \n  \n", ["base64", "binascii", "hashlib", "logging", "passlib.crypto.digest", "passlib.handlers.bcrypt", "passlib.hash", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.misc": [".py", "''\n\n\n\n\n\nimport sys\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_native_str,str_consteq\nfrom passlib.utils.compat import unicode,u,unicode_or_bytes_types\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"unix_disabled\",\n\"unix_fallback\",\n\"plaintext\",\n]\n\n\n\n\nclass unix_fallback(uh.ifc.DisabledHash,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"unix_fallback\"\n context_kwds=(\"enable_wildcard\",)\n \n @classmethod\n def identify(cls,hash):\n  if isinstance(hash,unicode_or_bytes_types):\n   return True\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n   \n def __init__(self,enable_wildcard=False ,**kwds):\n  warn(\"'unix_fallback' is deprecated, \"\n  \"and will be removed in Passlib 1.8; \"\n  \"please use 'unix_disabled' instead.\",\n  DeprecationWarning)\n  super(unix_fallback,self).__init__(**kwds)\n  self.enable_wildcard=enable_wildcard\n  \n def _calc_checksum(self,secret):\n  if self.checksum:\n  \n  \n   return self.checksum\n  else :\n   return u(\"!\")\n   \n @classmethod\n def verify(cls,secret,hash,enable_wildcard=False ):\n  uh.validate_secret(secret)\n  if not isinstance(hash,unicode_or_bytes_types):\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n  elif hash:\n   return False\n  else :\n   return enable_wildcard\n   \n_MARKER_CHARS=u(\"*!\")\n_MARKER_BYTES=b\"*!\"\n\nclass unix_disabled(uh.ifc.DisabledHash,uh.MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"unix_disabled\"\n setting_kwds=(\"marker\",)\n context_kwds=()\n \n _disable_prefixes=tuple(str(_MARKER_CHARS))\n \n \n if 'bsd'in sys.platform:\n  default_marker=u(\"*\")\n else :\n \n \n \n  default_marker=u(\"!\")\n  \n @classmethod\n def using(cls,marker=None ,**kwds):\n  subcls=super(unix_disabled,cls).using(**kwds)\n  if marker is not None :\n   if not cls.identify(marker):\n    raise ValueError(\"invalid marker: %r\"%marker)\n   subcls.default_marker=marker\n  return subcls\n  \n @classmethod\n def identify(cls,hash):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  if isinstance(hash,unicode):\n   start=_MARKER_CHARS\n  elif isinstance(hash,bytes):\n   start=_MARKER_BYTES\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n  return not hash or hash[0]in start\n  \n @classmethod\n def verify(cls,secret,hash):\n  uh.validate_secret(secret)\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return False\n  \n @classmethod\n def hash(cls,secret,**kwds):\n  if kwds:\n   uh.warn_hash_settings_deprecation(cls,kwds)\n   return cls.using(**kwds).hash(secret)\n  uh.validate_secret(secret)\n  marker=cls.default_marker\n  assert marker and cls.identify(marker)\n  return to_native_str(marker,param=\"marker\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,marker=None ):\n  if not cls.identify(config):\n   raise uh.exc.InvalidHashError(cls)\n  elif config:\n  \n   uh.validate_secret(secret)\n   return to_native_str(config,param=\"config\")\n  else :\n   if marker is not None :\n    cls=cls.using(marker=marker)\n   return cls.hash(secret)\n   \n @classmethod\n def disable(cls,hash=None ):\n  out=cls.hash(\"\")\n  if hash is not None :\n   hash=to_native_str(hash,param=\"hash\")\n   if cls.identify(hash):\n   \n    hash=cls.enable(hash)\n   if hash:\n    out +=hash\n  return out\n  \n @classmethod\n def enable(cls,hash):\n  hash=to_native_str(hash,param=\"hash\")\n  for prefix in cls._disable_prefixes:\n   if hash.startswith(prefix):\n    orig=hash[len(prefix):]\n    if orig:\n     return orig\n    else :\n     raise ValueError(\"cannot restore original hash\")\n  raise uh.exc.InvalidHashError(cls)\n  \nclass plaintext(uh.MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n name=\"plaintext\"\n setting_kwds=()\n context_kwds=(\"encoding\",)\n default_encoding=\"utf-8\"\n \n @classmethod\n def identify(cls,hash):\n  if isinstance(hash,unicode_or_bytes_types):\n   return True\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n   \n @classmethod\n def hash(cls,secret,encoding=None ):\n  uh.validate_secret(secret)\n  if not encoding:\n   encoding=cls.default_encoding\n  return to_native_str(secret,encoding,\"secret\")\n  \n @classmethod\n def verify(cls,secret,hash,encoding=None ):\n  if not encoding:\n   encoding=cls.default_encoding\n  hash=to_native_str(hash,encoding,\"hash\")\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return str_consteq(cls.hash(secret,encoding),hash)\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n  return cls.hash(\"\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,encoding=None ):\n \n  if not cls.identify(config):\n   raise uh.exc.InvalidHashError(cls)\n  return cls.hash(secret,encoding=encoding)\n  \n  \n  \n  \n", ["logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "sys", "warnings"]], "passlib.handlers.mssql": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import consteq\nfrom passlib.utils.compat import bascii_to_str,unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"mssql2000\",\n\"mssql2005\",\n]\n\n\n\n\ndef _raw_mssql(secret,salt):\n assert isinstance(secret,unicode)\n assert isinstance(salt,bytes)\n return sha1(secret.encode(\"utf-16-le\")+salt).digest()\n \nBIDENT=b\"0x0100\"\n\nUIDENT=u(\"0x0100\")\n\ndef _ident_mssql(hash,csize,bsize):\n ''\n if isinstance(hash,unicode):\n  if len(hash)==csize and hash.startswith(UIDENT):\n   return True\n elif isinstance(hash,bytes):\n  if len(hash)==csize and hash.startswith(BIDENT):\n   return True\n   \n   \n else :\n  raise uh.exc.ExpectedStringError(hash,\"hash\")\n return False\n \ndef _parse_mssql(hash,csize,bsize,handler):\n ''\n if isinstance(hash,unicode):\n  if len(hash)==csize and hash.startswith(UIDENT):\n   try :\n    return unhexlify(hash[6:].encode(\"utf-8\"))\n   except TypeError:\n    pass\n elif isinstance(hash,bytes):\n \n  assert isinstance(hash,bytes)\n  if len(hash)==csize and hash.startswith(BIDENT):\n   try :\n    return unhexlify(hash[6:])\n   except TypeError:\n    pass\n    \n    \n else :\n  raise uh.exc.ExpectedStringError(hash,\"hash\")\n raise uh.exc.InvalidHashError(handler)\n \nclass mssql2000(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"mssql2000\"\n setting_kwds=(\"salt\",)\n checksum_size=40\n min_salt_size=max_salt_size=4\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def identify(cls,hash):\n  return _ident_mssql(hash,94,46)\n  \n @classmethod\n def from_string(cls,hash):\n  data=_parse_mssql(hash,94,46,cls)\n  return cls(salt=data[:4],checksum=data[4:])\n  \n def to_string(self):\n  raw=self.salt+self.checksum\n  \n  return \"0x0100\"+bascii_to_str(hexlify(raw).upper())\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  salt=self.salt\n  return _raw_mssql(secret,salt)+_raw_mssql(secret.upper(),salt)\n  \n @classmethod\n def verify(cls,secret,hash):\n \n \n  uh.validate_secret(secret)\n  self=cls.from_string(hash)\n  chk=self.checksum\n  if chk is None :\n   raise uh.exc.MissingDigestError(cls)\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  result=_raw_mssql(secret.upper(),self.salt)\n  return consteq(result,chk[20:])\n  \n  \n  \n  \nclass mssql2005(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"mssql2005\"\n setting_kwds=(\"salt\",)\n \n checksum_size=20\n min_salt_size=max_salt_size=4\n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def identify(cls,hash):\n  return _ident_mssql(hash,54,26)\n  \n @classmethod\n def from_string(cls,hash):\n  data=_parse_mssql(hash,54,26,cls)\n  return cls(salt=data[:4],checksum=data[4:])\n  \n def to_string(self):\n  raw=self.salt+self.checksum\n  \n  return \"0x0100\"+bascii_to_str(hexlify(raw)).upper()\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  return _raw_mssql(secret,self.salt)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.handlers.md5_crypt": [".py", "''\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt,repeat_string\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"md5_crypt\",\n\"apr_md5_crypt\",\n]\n\n\n\n\n_BNULL=b\"\\x00\"\n_MD5_MAGIC=b\"$1$\"\n_APR_MAGIC=b\"$apr1$\"\n\n\n\n\n\n\n\n\n\n_c_digest_offsets=(\n(0,3),(5,1),(5,3),(1,2),(5,1),(5,3),(1,3),\n(4,1),(5,3),(1,3),(5,0),(5,3),(1,3),(5,1),\n(4,3),(1,3),(5,1),(5,2),(1,3),(5,1),(5,3),\n)\n\n\n_transpose_map=(12,6,0,13,7,1,14,8,2,15,9,3,5,10,4,11)\n\ndef _raw_md5_crypt(pwd,salt,use_apr=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n if isinstance(pwd,unicode):\n  pwd=pwd.encode(\"utf-8\")\n assert isinstance(pwd,bytes),\"pwd not unicode or bytes\"\n if _BNULL in pwd:\n  raise uh.exc.NullPasswordError(md5_crypt)\n pwd_len=len(pwd)\n \n \n assert isinstance(salt,unicode),\"salt not unicode\"\n salt=salt.encode(\"ascii\")\n assert len(salt)<9,\"salt too large\"\n \n \n \n \n \n if use_apr:\n  magic=_APR_MAGIC\n else :\n  magic=_MD5_MAGIC\n  \n  \n  \n  \n db=md5(pwd+salt+pwd).digest()\n \n \n \n \n \n a_ctx=md5(pwd+magic+salt)\n a_ctx_update=a_ctx.update\n \n \n a_ctx_update(repeat_string(db,pwd_len))\n \n \n \n \n \n \n i=pwd_len\n evenchar=pwd[:1]\n while i:\n  a_ctx_update(_BNULL if i&1 else evenchar)\n  i >>=1\n  \n  \n da=a_ctx.digest()\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n pwd_pwd=pwd+pwd\n pwd_salt=pwd+salt\n perms=[pwd,pwd_pwd,pwd_salt,pwd_salt+pwd,salt+pwd,salt+pwd_pwd]\n \n \n \n data=[(perms[even],perms[odd])for even,odd in _c_digest_offsets]\n \n \n dc=da\n blocks=23\n while blocks:\n  for even,odd in data:\n   dc=md5(odd+md5(dc+even).digest()).digest()\n  blocks -=1\n  \n  \n for even,odd in data[:17]:\n  dc=md5(odd+md5(dc+even).digest()).digest()\n  \n  \n  \n  \n return h64.encode_transposed_bytes(dc,_transpose_map).decode(\"ascii\")\n \n \n \n \nclass _MD5_Common(uh.HasSalt,uh.GenericHandler):\n ''\n \n \n \n \n setting_kwds=(\"salt\",\"salt_size\")\n \n checksum_size=22\n checksum_chars=uh.HASH64_CHARS\n \n max_salt_size=8\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc2(self.ident,self.salt,self.checksum)\n  \n  \n  \n  \n  \n  \n  \nclass md5_crypt(uh.HasManyBackends,_MD5_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"md5_crypt\"\n ident=u(\"$1$\")\n \n \n \n \n \n \n \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'$1$test$pi/xDtU5WFVRqYS6BMU8X/'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.ident+self.salt\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config)or len(hash)!=len(config)+23:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-22:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_md5_crypt(secret,self.salt)\n  \n  \n  \n  \n  \nclass apr_md5_crypt(_MD5_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"apr_md5_crypt\"\n ident=u(\"$apr1$\")\n \n \n \n \n def _calc_checksum(self,secret):\n  return _raw_md5_crypt(secret,self.salt,use_apr=True )\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.sun_md5_crypt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import md5\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_unicode\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import byte_elem_value,irange,u,\\\nuascii_to_str,unicode,str_to_bascii\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"sun_md5_crypt\",\n]\n\n\n\n\n\n\n\n\nMAGIC_HAMLET=(\nb\"To be, or not to be,--that is the question:--\\n\"\nb\"Whether 'tis nobler in the mind to suffer\\n\"\nb\"The slings and arrows of outrageous fortune\\n\"\nb\"Or to take arms against a sea of troubles,\\n\"\nb\"And by opposing end them?--To die,--to sleep,--\\n\"\nb\"No more; and by a sleep to say we end\\n\"\nb\"The heartache, and the thousand natural shocks\\n\"\nb\"That flesh is heir to,--'tis a consummation\\n\"\nb\"Devoutly to be wish'd. To die,--to sleep;--\\n\"\nb\"To sleep! perchance to dream:--ay, there's the rub;\\n\"\nb\"For in that sleep of death what dreams may come,\\n\"\nb\"When we have shuffled off this mortal coil,\\n\"\nb\"Must give us pause: there's the respect\\n\"\nb\"That makes calamity of so long life;\\n\"\nb\"For who would bear the whips and scorns of time,\\n\"\nb\"The oppressor's wrong, the proud man's contumely,\\n\"\nb\"The pangs of despis'd love, the law's delay,\\n\"\nb\"The insolence of office, and the spurns\\n\"\nb\"That patient merit of the unworthy takes,\\n\"\nb\"When he himself might his quietus make\\n\"\nb\"With a bare bodkin? who would these fardels bear,\\n\"\nb\"To grunt and sweat under a weary life,\\n\"\nb\"But that the dread of something after death,--\\n\"\nb\"The undiscover'd country, from whose bourn\\n\"\nb\"No traveller returns,--puzzles the will,\\n\"\nb\"And makes us rather bear those ills we have\\n\"\nb\"Than fly to others that we know not of?\\n\"\nb\"Thus conscience does make cowards of us all;\\n\"\nb\"And thus the native hue of resolution\\n\"\nb\"Is sicklied o'er with the pale cast of thought;\\n\"\nb\"And enterprises of great pith and moment,\\n\"\nb\"With this regard, their currents turn awry,\\n\"\nb\"And lose the name of action.--Soft you now!\\n\"\nb\"The fair Ophelia!--Nymph, in thy orisons\\n\"\nb\"Be all my sins remember'd.\\n\\x00\"\n)\n\n\nxr=irange(7)\n_XY_ROUNDS=[\ntuple((i,i,i+3)for i in xr),\ntuple((i,i+1,i+4)for i in xr),\ntuple((i,i+8,(i+11)&15)for i in xr),\ntuple((i,(i+9)&15,(i+12)&15)for i in xr),\n]\ndel xr\n\ndef raw_sun_md5_crypt(secret,rounds,salt):\n ''\n global MAGIC_HAMLET\n assert isinstance(secret,bytes)\n assert isinstance(salt,bytes)\n \n \n if rounds <=0:\n  rounds=0\n real_rounds=4096+rounds\n \n \n \n \n result=md5(secret+salt).digest()\n assert len(result)==16\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n X_ROUNDS_0,X_ROUNDS_1,Y_ROUNDS_0,Y_ROUNDS_1=_XY_ROUNDS\n \n \n \n round=0\n while round <real_rounds:\n \n  rval=[byte_elem_value(c)for c in result].__getitem__\n  \n  \n  x=0\n  xrounds=X_ROUNDS_1 if (rval((round >>3)&15)>>(round&7))&1 else X_ROUNDS_0\n  for i,ia,ib in xrounds:\n   a=rval(ia)\n   b=rval(ib)\n   v=rval((a >>(b %5))&15)>>((b >>(a&7))&1)\n   x |=((rval((v >>3)&15)>>(v&7))&1)<<i\n   \n   \n  y=0\n  yrounds=Y_ROUNDS_1 if (rval(((round+64)>>3)&15)>>(round&7))&1 else Y_ROUNDS_0\n  for i,ia,ib in yrounds:\n   a=rval(ia)\n   b=rval(ib)\n   v=rval((a >>(b %5))&15)>>((b >>(a&7))&1)\n   y |=((rval((v >>3)&15)>>(v&7))&1)<<i\n   \n   \n  coin=((rval(x >>3)>>(x&7))^(rval(y >>3)>>(y&7)))&1\n  \n  \n  h=md5(result)\n  if coin:\n   h.update(MAGIC_HAMLET)\n  h.update(unicode(round).encode(\"ascii\"))\n  result=h.digest()\n  \n  round +=1\n  \n  \n return h64.encode_transposed_bytes(result,_chk_offsets)\n \n \n_chk_offsets=(\n12,6,0,\n13,7,1,\n14,8,2,\n15,9,3,\n5,10,4,\n11,\n)\n\n\n\n\nclass sun_md5_crypt(uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"sun_md5_crypt\"\n setting_kwds=(\"salt\",\"rounds\",\"bare_salt\",\"salt_size\")\n checksum_chars=uh.HASH64_CHARS\n checksum_size=22\n \n \n \n \n \n \n default_salt_size=8\n max_salt_size=None\n salt_chars=uh.HASH64_CHARS\n \n default_rounds=34000\n min_rounds=0\n max_rounds=4294963199\n \n rounds_cost=\"linear\"\n \n ident_values=(u(\"$md5$\"),u(\"$md5,\"))\n \n \n \n \n bare_salt=False\n \n \n \n \n def __init__(self,bare_salt=False ,**kwds):\n  self.bare_salt=bare_salt\n  super(sun_md5_crypt,self).__init__(**kwds)\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return hash.startswith(cls.ident_values)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  \n  \n  \n  \n  \n  \n  if hash.startswith(u(\"$md5$\")):\n   rounds=0\n   salt_idx=5\n  elif hash.startswith(u(\"$md5,rounds=\")):\n   idx=hash.find(u(\"$\"),12)\n   if idx ==-1:\n    raise uh.exc.MalformedHashError(cls,\"unexpected end of rounds\")\n   rstr=hash[12:idx]\n   try :\n    rounds=int(rstr)\n   except ValueError:\n    raise uh.exc.MalformedHashError(cls,\"bad rounds\")\n   if rstr !=unicode(rounds):\n    raise uh.exc.ZeroPaddedRoundsError(cls)\n   if rounds ==0:\n   \n   \n   \n    raise uh.exc.MalformedHashError(cls,\"explicit zero rounds\")\n   salt_idx=idx+1\n  else :\n   raise uh.exc.InvalidHashError(cls)\n   \n   \n   \n   \n   \n   \n  chk_idx=hash.rfind(u(\"$\"),salt_idx)\n  if chk_idx ==-1:\n  \n   salt=hash[salt_idx:]\n   chk=None\n   bare_salt=True\n  elif chk_idx ==len(hash)-1:\n   if chk_idx >salt_idx and hash[-2]==u(\"$\"):\n    raise uh.exc.MalformedHashError(cls,\"too many '$' separators\")\n    \n   salt=hash[salt_idx:-1]\n   chk=None\n   bare_salt=False\n  elif chk_idx >0 and hash[chk_idx -1]==u(\"$\"):\n  \n   salt=hash[salt_idx:chk_idx -1]\n   chk=hash[chk_idx+1:]\n   bare_salt=False\n  else :\n  \n   salt=hash[salt_idx:chk_idx]\n   chk=hash[chk_idx+1:]\n   bare_salt=True\n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk,\n  bare_salt=bare_salt,\n  )\n  \n def to_string(self,_withchk=True ):\n  ss=u('')if self.bare_salt else u('$')\n  rounds=self.rounds\n  if rounds >0:\n   hash=u(\"$md5,rounds=%d$%s%s\")%(rounds,self.salt,ss)\n  else :\n   hash=u(\"$md5$%s%s\")%(self.salt,ss)\n  if _withchk:\n   chk=self.checksum\n   hash=u(\"%s$%s\")%(hash,chk)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  config=str_to_bascii(self.to_string(_withchk=False ))\n  return raw_sun_md5_crypt(secret,self.rounds,config).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.handlers.phpass": [".py", "''\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import u,uascii_to_str,unicode\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"phpass\",\n]\n\n\n\n\nclass phpass(uh.HasManyIdents,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"phpass\"\n setting_kwds=(\"salt\",\"rounds\",\"ident\")\n checksum_chars=uh.HASH64_CHARS\n \n \n min_salt_size=max_salt_size=8\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=19\n min_rounds=7\n max_rounds=30\n rounds_cost=\"log2\"\n \n \n default_ident=u(\"$P$\")\n ident_values=(u(\"$P$\"),u(\"$H$\"))\n ident_aliases={u(\"P\"):u(\"$P$\"),u(\"H\"):u(\"$H$\")}\n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  ident,data=cls._parse_ident(hash)\n  rounds,salt,chk=data[0],data[1:9],data[9:]\n  return cls(\n  ident=ident,\n  rounds=h64.decode_int6(rounds.encode(\"ascii\")),\n  salt=salt,\n  checksum=chk or None ,\n  )\n  \n def to_string(self):\n  hash=u(\"%s%s%s%s\")%(self.ident,\n  h64.encode_int6(self.rounds).decode(\"ascii\"),\n  self.salt,\n  self.checksum or u(''))\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  real_rounds=1 <<self.rounds\n  result=md5(self.salt.encode(\"ascii\")+secret).digest()\n  r=0\n  while r <real_rounds:\n   result=md5(result+secret).digest()\n   r +=1\n  return h64.encode_bytes(result).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.roundup": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nimport passlib.utils.handlers as uh\nfrom passlib.utils.compat import u\n\n__all__=[\n\"roundup_plaintext\",\n\"ldap_hex_md5\",\n\"ldap_hex_sha1\",\n]\n\n\n\nroundup_plaintext=uh.PrefixWrapper(\"roundup_plaintext\",\"plaintext\",\nprefix=u(\"{plaintext}\"),lazy=True )\n\n\nldap_hex_md5=uh.PrefixWrapper(\"ldap_hex_md5\",\"hex_md5\",u(\"{MD5}\"),lazy=True )\nldap_hex_sha1=uh.PrefixWrapper(\"ldap_hex_sha1\",\"hex_sha1\",u(\"{SHA}\"),lazy=True )\n\n\n\n\n", ["logging", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.sha2_crypt": [".py", "''\n\n\n\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt,\\\nrepeat_string,to_unicode\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import byte_elem_value,u,\\\nuascii_to_str,unicode\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"sha512_crypt\",\n\"sha256_crypt\",\n]\n\n\n\n\n\n_BNULL=b'\\x00'\n\n\n\n\n\n\n\n\n\n_c_digest_offsets=(\n(0,3),(5,1),(5,3),(1,2),(5,1),(5,3),(1,3),\n(4,1),(5,3),(1,3),(5,0),(5,3),(1,3),(5,1),\n(4,3),(1,3),(5,1),(5,2),(1,3),(5,1),(5,3),\n)\n\n\n_256_transpose_map=(\n20,10,0,11,1,21,2,22,12,23,13,3,14,4,24,5,\n25,15,26,16,6,17,7,27,8,28,18,29,19,9,30,31,\n)\n\n\n_512_transpose_map=(\n42,21,0,1,43,22,23,2,44,45,24,3,4,46,25,26,\n5,47,48,27,6,7,49,28,29,8,50,51,30,9,10,52,\n31,32,11,53,54,33,12,13,55,34,35,14,56,57,36,15,\n16,58,37,38,17,59,60,39,18,19,61,40,41,20,62,63,\n)\n\ndef _raw_sha2_crypt(pwd,salt,rounds,use_512=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n if isinstance(pwd,unicode):\n \n  pwd=pwd.encode(\"utf-8\")\n assert isinstance(pwd,bytes)\n if _BNULL in pwd:\n  raise uh.exc.NullPasswordError(sha512_crypt if use_512 else sha256_crypt)\n pwd_len=len(pwd)\n \n \n assert 1000 <=rounds <=999999999,\"invalid rounds\"\n \n \n \n \n \n assert isinstance(salt,unicode),\"salt not unicode\"\n salt=salt.encode(\"ascii\")\n salt_len=len(salt)\n assert salt_len <17,\"salt too large\"\n \n \n \n \n \n if use_512:\n  hash_const=hashlib.sha512\n  transpose_map=_512_transpose_map\n else :\n  hash_const=hashlib.sha256\n  transpose_map=_256_transpose_map\n  \n  \n  \n  \n db=hash_const(pwd+salt+pwd).digest()\n \n \n \n \n \n a_ctx=hash_const(pwd+salt)\n a_ctx_update=a_ctx.update\n \n \n a_ctx_update(repeat_string(db,pwd_len))\n \n \n i=pwd_len\n while i:\n  a_ctx_update(db if i&1 else pwd)\n  i >>=1\n  \n  \n da=a_ctx.digest()\n \n \n \n \n \n if pwd_len <96:\n \n \n  dp=repeat_string(hash_const(pwd *pwd_len).digest(),pwd_len)\n else :\n \n  tmp_ctx=hash_const(pwd)\n  tmp_ctx_update=tmp_ctx.update\n  i=pwd_len -1\n  while i:\n   tmp_ctx_update(pwd)\n   i -=1\n  dp=repeat_string(tmp_ctx.digest(),pwd_len)\n assert len(dp)==pwd_len\n \n \n \n \n ds=hash_const(salt *(16+byte_elem_value(da[0]))).digest()[:salt_len]\n assert len(ds)==salt_len,\"salt_len somehow > hash_len!\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n dp_dp=dp+dp\n dp_ds=dp+ds\n perms=[dp,dp_dp,dp_ds,dp_ds+dp,ds+dp,ds+dp_dp]\n \n \n \n data=[(perms[even],perms[odd])for even,odd in _c_digest_offsets]\n \n \n dc=da\n blocks,tail=divmod(rounds,42)\n while blocks:\n  for even,odd in data:\n   dc=hash_const(odd+hash_const(dc+even).digest()).digest()\n  blocks -=1\n  \n  \n if tail:\n \n  pairs=tail >>1\n  for even,odd in data[:pairs]:\n   dc=hash_const(odd+hash_const(dc+even).digest()).digest()\n   \n   \n   \n  if tail&1:\n   dc=hash_const(dc+data[pairs][0]).digest()\n   \n   \n   \n   \n return h64.encode_transposed_bytes(dc,transpose_map).decode(\"ascii\")\n \n \n \n \n_UROUNDS=u(\"rounds=\")\n_UDOLLAR=u(\"$\")\n_UZERO=u(\"0\")\n\nclass _SHA2_Common(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,\nuh.GenericHandler):\n ''\n \n \n \n \n setting_kwds=(\"salt\",\"rounds\",\"implicit_rounds\",\"salt_size\")\n \n checksum_chars=uh.HASH64_CHARS\n \n \n max_salt_size=16\n salt_chars=uh.HASH64_CHARS\n \n min_rounds=1000\n max_rounds=999999999\n rounds_cost=\"linear\"\n \n _cdb_use_512=False\n _rounds_prefix=None\n \n \n \n \n implicit_rounds=False\n \n def __init__(self,implicit_rounds=None ,**kwds):\n  super(_SHA2_Common,self).__init__(**kwds)\n  \n  if implicit_rounds is None :\n   implicit_rounds=(self.use_defaults and self.rounds ==5000)\n  self.implicit_rounds=implicit_rounds\n  \n def _parse_salt(self,salt):\n \n  return self._norm_salt(salt,relaxed=self.checksum is None )\n  \n def _parse_rounds(self,rounds):\n \n  return self._norm_rounds(rounds,relaxed=self.checksum is None )\n  \n @classmethod\n def from_string(cls,hash):\n \n \n \n \n \n \n \n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  ident=cls.ident\n  if not hash.startswith(ident):\n   raise uh.exc.InvalidHashError(cls)\n  assert len(ident)==3\n  parts=hash[3:].split(_UDOLLAR)\n  \n  \n  if parts[0].startswith(_UROUNDS):\n   assert len(_UROUNDS)==7\n   rounds=parts.pop(0)[7:]\n   if rounds.startswith(_UZERO)and rounds !=_UZERO:\n    raise uh.exc.ZeroPaddedRoundsError(cls)\n   rounds=int(rounds)\n   implicit_rounds=False\n  else :\n   rounds=5000\n   implicit_rounds=True\n   \n   \n  if len(parts)==2:\n   salt,chk=parts\n  elif len(parts)==1:\n   salt=parts[0]\n   chk=None\n  else :\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk or None ,\n  implicit_rounds=implicit_rounds,\n  )\n  \n def to_string(self):\n  if self.rounds ==5000 and self.implicit_rounds:\n   hash=u(\"%s%s$%s\")%(self.ident,self.salt,\n   self.checksum or u(''))\n  else :\n   hash=u(\"%srounds=%d$%s$%s\")%(self.ident,self.rounds,\n   self.salt,self.checksum or u(''))\n  return uascii_to_str(hash)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n \n \n _test_hash=None\n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(*cls._test_hash):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string()\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n   \n   \n  cs=self.checksum_size\n  if not hash.startswith(self.ident)or hash[-cs -1]!=_UDOLLAR:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-cs:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_sha2_crypt(secret,self.salt,self.rounds,\n  self._cdb_use_512)\n  \n  \n  \n  \n  \nclass sha256_crypt(_SHA2_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"sha256_crypt\"\n ident=u(\"$5$\")\n checksum_size=43\n \n default_rounds=535000\n \n \n \n \n _test_hash=(\"test\",\"$5$rounds=1000$test$QmQADEXMG8POI5W\"\n \"Dsaeho0P36yK3Tcrgboabng6bkb/\")\n \n \n \n \n \n \n \n \nclass sha512_crypt(_SHA2_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"sha512_crypt\"\n ident=u(\"$6$\")\n checksum_size=86\n _cdb_use_512=True\n \n default_rounds=656000\n \n \n \n \n _test_hash=(\"test\",\"$6$rounds=1000$test$2M/Lx6Mtobqj\"\n \"Ljobw0Wmo4Q5OFx5nVLJvmgseatA6oMn\"\n \"yWeBdRDx4DU.1H3eGmse6pgsOgDisWBG\"\n \"I5c7TZauS0\")\n \n \n \n \n \n \n \n \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.argon2": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nimport logging\nlog=logging.getLogger(__name__)\nimport re\nimport types\nfrom warnings import warn\n\n_argon2_cffi=None\n_argon2pure=None\n\nfrom passlib import exc\nfrom passlib.crypto.digest import MAX_UINT32\nfrom passlib.utils import classproperty,to_bytes,render_bytes\nfrom passlib.utils.binary import b64s_encode,b64s_decode\nfrom passlib.utils.compat import u,unicode,bascii_to_str,uascii_to_str,PY2\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"argon2\",\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\nTYPE_I=u(\"i\")\nTYPE_D=u(\"d\")\nTYPE_ID=u(\"id\")\n\n\nALL_TYPES=(TYPE_ID,TYPE_I,TYPE_D)\nALL_TYPES_SET=set(ALL_TYPES)\n\n\n\n\n\n\n\n\n_argon2_cffi_error=None\ntry :\n import argon2 as _argon2_cffi\nexcept ImportError:\n _argon2_cffi=None\nelse :\n if not hasattr(_argon2_cffi,\"Type\"):\n \n  _argon2_cffi_error=(\n  \"'argon2' module points to unsupported 'argon2' pypi package; \"\n  \"please install 'argon2-cffi' instead.\"\n  )\n  _argon2_cffi=None\n elif not hasattr(_argon2_cffi,\"low_level\"):\n \n  _argon2_cffi_error=\"'argon2-cffi' is too old, please update to argon2_cffi >= 18.2.0\"\n  _argon2_cffi=None\n  \n  \n  \nif hasattr(_argon2_cffi,\"PasswordHasher\"):\n\n _default_settings=_argon2_cffi.PasswordHasher()\n _default_version=_argon2_cffi.low_level.ARGON2_VERSION\nelse :\n\n class _DummyCffiHasher:\n  ''\n\n\n\n\n\n  \n  time_cost=2\n  memory_cost=512\n  parallelism=2\n  salt_len=16\n  hash_len=16\n  \n  \n  \n _default_settings=_DummyCffiHasher()\n _default_version=0x13\n \n \n \n \nclass _Argon2Common(uh.SubclassBackendMixin,uh.ParallelismMixin,\nuh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,\nuh.GenericHandler):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n name=\"argon2\"\n setting_kwds=(\"salt\",\n \"salt_size\",\n \"salt_len\",\n \"rounds\",\n \"time_cost\",\n \"memory_cost\",\n \"parallelism\",\n \"digest_size\",\n \"hash_len\",\n \"type\",\n )\n \n \n \n \n \n \n \n \n \n \n \n \n \n checksum_size=_default_settings.hash_len\n \n \n _always_parse_settings=uh.GenericHandler._always_parse_settings+\\\n (\"type\",)\n \n \n _unparsed_settings=uh.GenericHandler._unparsed_settings+\\\n (\"salt_len\",\"time_cost\",\"hash_len\",\"digest_size\")\n \n \n \n \n default_salt_size=_default_settings.salt_len\n min_salt_size=8\n max_salt_size=MAX_UINT32\n \n \n \n \n \n \n default_rounds=_default_settings.time_cost\n min_rounds=1\n max_rounds=MAX_UINT32\n rounds_cost=\"linear\"\n \n \n \n \n max_parallelism=(1 <<24)-1\n \n \n \n \n \n \n \n max_version=_default_version\n \n \n min_desired_version=None\n \n \n min_memory_cost=8\n \n \n \n max_threads=-1\n \n \n \n pure_use_threads=False\n \n \n \n \n _backend_type_map={}\n \n @classproperty\n def type_values(cls):\n  ''\n\n\n\n  \n  cls.get_backend()\n  return tuple(cls._backend_type_map)\n  \n  \n  \n  \n  \n  \n  \n type=TYPE_ID\n \n \n parallelism=_default_settings.parallelism\n \n \n \n version=_default_version\n \n \n memory_cost=_default_settings.memory_cost\n \n @property\n def type_d(self):\n  ''\n\n\n\n  \n  return self.type ==TYPE_D\n  \n  \n data=None\n \n \n \n \n \n @classmethod\n def using(cls,type=None ,memory_cost=None ,salt_len=None ,time_cost=None ,digest_size=None ,\n checksum_size=None ,hash_len=None ,max_threads=None ,**kwds):\n \n  if time_cost is not None :\n   if \"rounds\"in kwds:\n    raise TypeError(\"'time_cost' and 'rounds' are mutually exclusive\")\n   kwds['rounds']=time_cost\n   \n  if salt_len is not None :\n   if \"salt_size\"in kwds:\n    raise TypeError(\"'salt_len' and 'salt_size' are mutually exclusive\")\n   kwds['salt_size']=salt_len\n   \n  if hash_len is not None :\n   if digest_size is not None :\n    raise TypeError(\"'hash_len' and 'digest_size' are mutually exclusive\")\n   digest_size=hash_len\n   \n  if checksum_size is not None :\n   if digest_size is not None :\n    raise TypeError(\"'checksum_size' and 'digest_size' are mutually exclusive\")\n   digest_size=checksum_size\n   \n   \n  subcls=super(_Argon2Common,cls).using(**kwds)\n  \n  \n  if type is not None :\n   subcls.type=subcls._norm_type(type)\n   \n   \n  relaxed=kwds.get(\"relaxed\")\n  if digest_size is not None :\n   if isinstance(digest_size,uh.native_string_types):\n    digest_size=int(digest_size)\n    \n   subcls.checksum_size=uh.norm_integer(subcls,digest_size,min=16,max=MAX_UINT32,\n   param=\"digest_size\",relaxed=relaxed)\n   \n   \n  if memory_cost is not None :\n   if isinstance(memory_cost,uh.native_string_types):\n    memory_cost=int(memory_cost)\n   subcls.memory_cost=subcls._norm_memory_cost(memory_cost,relaxed=relaxed)\n   \n   \n  subcls._validate_constraints(subcls.memory_cost,subcls.parallelism)\n  \n  \n  if max_threads is not None :\n   if isinstance(max_threads,uh.native_string_types):\n    max_threads=int(max_threads)\n   if max_threads <1 and max_threads !=-1:\n    raise ValueError(\"max_threads (%d) must be -1 (unlimited), or at least 1.\"%\n    (max_threads,))\n   subcls.max_threads=max_threads\n   \n  return subcls\n  \n @classmethod\n def _validate_constraints(cls,memory_cost,parallelism):\n \n \n  min_memory_cost=8 *parallelism\n  if memory_cost <min_memory_cost:\n   raise ValueError(\"%s: memory_cost (%d) is too low, must be at least \"\n   \"8 * parallelism (8 * %d = %d)\"%\n   (cls.name,memory_cost,\n   parallelism,min_memory_cost))\n   \n   \n   \n   \n   \n   \n _ident_regex=re.compile(r\"^\\$argon2[a-z]+\\$\")\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return cls._ident_regex.match(hash)is not None\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n _hash_regex=re.compile(br\"\"\"\n        ^\n        \\$argon2(?P<type>[a-z]+)\\$\n        (?:\n            v=(?P<version>\\d+)\n            \\$\n        )?\n        m=(?P<memory_cost>\\d+)\n        ,\n        t=(?P<time_cost>\\d+)\n        ,\n        p=(?P<parallelism>\\d+)\n        (?:\n            ,keyid=(?P<keyid>[^,$]+)\n        )?\n        (?:\n            ,data=(?P<data>[^,$]+)\n        )?\n        (?:\n            \\$\n            (?P<salt>[^$]+)\n            (?:\n                \\$\n                (?P<digest>.+)\n            )?\n        )?\n        $\n    \"\"\",re.X)\n \n @classmethod\n def from_string(cls,hash):\n \n \n  if isinstance(hash,unicode):\n   hash=hash.encode(\"utf-8\")\n  if not isinstance(hash,bytes):\n   raise exc.ExpectedStringError(hash,\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise exc.MalformedHashError(cls)\n  type,version,memory_cost,time_cost,parallelism,keyid,data,salt,digest=\\\n  m.group(\"type\",\"version\",\"memory_cost\",\"time_cost\",\"parallelism\",\n  \"keyid\",\"data\",\"salt\",\"digest\")\n  if keyid:\n   raise NotImplementedError(\"argon2 'keyid' parameter not supported\")\n  return cls(\n  type=type.decode(\"ascii\"),\n  version=int(version)if version else 0x10,\n  memory_cost=int(memory_cost),\n  rounds=int(time_cost),\n  parallelism=int(parallelism),\n  salt=b64s_decode(salt)if salt else None ,\n  data=b64s_decode(data)if data else None ,\n  checksum=b64s_decode(digest)if digest else None ,\n  )\n  \n def to_string(self):\n  version=self.version\n  if version ==0x10:\n   vstr=\"\"\n  else :\n   vstr=\"v=%d$\"%version\n   \n  data=self.data\n  if data:\n   kdstr=\",data=\"+bascii_to_str(b64s_encode(self.data))\n  else :\n   kdstr=\"\"\n   \n   \n  return \"$argon2%s$%sm=%d,t=%d,p=%d%s$%s$%s\"%(\n  uascii_to_str(self.type),\n  vstr,\n  self.memory_cost,\n  self.rounds,\n  self.parallelism,\n  kdstr,\n  bascii_to_str(b64s_encode(self.salt)),\n  bascii_to_str(b64s_encode(self.checksum)),\n  )\n  \n  \n  \n  \n def __init__(self,type=None ,type_d=False ,version=None ,memory_cost=None ,data=None ,**kwds):\n \n \n  if type_d:\n   warn('argon2 `type_d=True` keyword is deprecated, and will be removed in passlib 2.0; '\n   'please use ``type=\"d\"`` instead')\n   assert type is None\n   type=TYPE_D\n   \n   \n   \n  checksum=kwds.get(\"checksum\")\n  if checksum is not None :\n   self.checksum_size=len(checksum)\n   \n   \n  super(_Argon2Common,self).__init__(**kwds)\n  \n  \n  if type is None :\n   assert uh.validate_default_value(self,self.type,self._norm_type,param=\"type\")\n  else :\n   self.type=self._norm_type(type)\n   \n   \n  if version is None :\n   assert uh.validate_default_value(self,self.version,self._norm_version,\n   param=\"version\")\n  else :\n   self.version=self._norm_version(version)\n   \n   \n  if memory_cost is None :\n   assert uh.validate_default_value(self,self.memory_cost,self._norm_memory_cost,\n   param=\"memory_cost\")\n  else :\n   self.memory_cost=self._norm_memory_cost(memory_cost)\n   \n   \n  if data is None :\n   assert self.data is None\n  else :\n   if not isinstance(data,bytes):\n    raise uh.exc.ExpectedTypeError(data,\"bytes\",\"data\")\n   self.data=data\n   \n   \n   \n   \n   \n @classmethod\n def _norm_type(cls,value):\n \n  if not isinstance(value,unicode):\n   if PY2 and isinstance(value,bytes):\n    value=value.decode('ascii')\n   else :\n    raise uh.exc.ExpectedTypeError(value,\"str\",\"type\")\n    \n    \n  if value in ALL_TYPES_SET:\n   return value\n   \n   \n  temp=value.lower()\n  if temp in ALL_TYPES_SET:\n   return temp\n   \n   \n  raise ValueError(\"unknown argon2 hash type: %r\"%(value,))\n  \n @classmethod\n def _norm_version(cls,version):\n  if not isinstance(version,uh.int_types):\n   raise uh.exc.ExpectedTypeError(version,\"integer\",\"version\")\n   \n   \n  if version <0x13 and version !=0x10:\n   raise ValueError(\"invalid argon2 hash version: %d\"%(version,))\n   \n   \n  backend=cls.get_backend()\n  if version >cls.max_version:\n   raise ValueError(\"%s: hash version 0x%X not supported by %r backend \"\n   \"(max version is 0x%X); try updating or switching backends\"%\n   (cls.name,version,backend,cls.max_version))\n  return version\n  \n @classmethod\n def _norm_memory_cost(cls,memory_cost,relaxed=False ):\n  return uh.norm_integer(cls,memory_cost,min=cls.min_memory_cost,\n  param=\"memory_cost\",relaxed=relaxed)\n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def _get_backend_type(cls,value):\n  ''\n\n  \n  try :\n   return cls._backend_type_map[value]\n  except KeyError:\n   pass\n   \n  msg=\"unsupported argon2 hash (type %r not supported by %s backend)\"%\\\n  (value,cls.get_backend())\n  raise ValueError(msg)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  cls=type(self)\n  if self.type !=cls.type:\n   return True\n  minver=cls.min_desired_version\n  if minver is None or minver >cls.max_version:\n   minver=cls.max_version\n  if self.version <minver:\n  \n   return True\n  if self.memory_cost !=cls.memory_cost:\n   return True\n  if self.checksum_size !=cls.checksum_size:\n   return True\n  return super(_Argon2Common,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n _no_backend_suggestion=\" -- recommend you install one (e.g. 'pip install argon2_cffi')\"\n \n @classmethod\n def _finalize_backend_mixin(mixin_cls,name,dryrun):\n  ''\n\n\n\n  \n  \n  max_version=mixin_cls.max_version\n  assert isinstance(max_version,int)and max_version >=0x10\n  if max_version <0x13:\n   warn(\"%r doesn't support argon2 v1.3, and should be upgraded\"%name,\n   uh.exc.PasslibSecurityWarning)\n   \n   \n  for type in ALL_TYPES:\n   if type in mixin_cls._backend_type_map:\n    mixin_cls.type=type\n    break\n  else :\n   warn(\"%r lacks support for all known hash types\"%name,uh.exc.PasslibRuntimeWarning)\n   \n   mixin_cls.type=TYPE_ID\n   \n  return True\n  \n @classmethod\n def _adapt_backend_error(cls,err,hash=None ,self=None ):\n  ''\n\n\n  \n  backend=cls.get_backend()\n  \n  \n  if self is None and hash is not None :\n   self=cls.from_string(hash)\n   \n   \n   \n  if self is not None :\n   self._validate_constraints(self.memory_cost,self.parallelism)\n   \n   \n   \n   if backend ==\"argon2_cffi\"and self.data is not None :\n    raise NotImplementedError(\"argon2_cffi backend doesn't support the 'data' parameter\")\n    \n    \n  text=str(err)\n  if text not in [\n  \"Decoding failed\"\n  ]:\n   reason=\"%s reported: %s: hash=%r\"%(backend,text,hash)\n  else :\n   reason=repr(hash)\n  raise exc.MalformedHashError(cls,reason=reason)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _NoBackend(_Argon2Common):\n ''\n\n\n \n \n \n \n @classmethod\n def hash(cls,secret):\n  cls._stub_requires_backend()\n  return cls.hash(secret)\n  \n @classmethod\n def verify(cls,secret,hash):\n  cls._stub_requires_backend()\n  return cls.verify(secret,hash)\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config):\n  cls._stub_requires_backend()\n  return cls.genhash(secret,config)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n  self._stub_requires_backend()\n  \n  \n  return super(argon2,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CffiBackend(_Argon2Common):\n ''\n\n \n \n \n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  assert mixin_cls is _CffiBackend\n  \n  \n  if _argon2_cffi is None :\n   if _argon2_cffi_error:\n    raise exc.PasslibSecurityError(_argon2_cffi_error)\n   return False\n  max_version=_argon2_cffi.low_level.ARGON2_VERSION\n  log.debug(\"detected 'argon2_cffi' backend, version %r, with support for 0x%x argon2 hashes\",\n  _argon2_cffi.__version__,max_version)\n  \n  \n  TypeEnum=_argon2_cffi.Type\n  type_map={}\n  for type in ALL_TYPES:\n   try :\n    type_map[type]=getattr(TypeEnum,type.upper())\n   except AttributeError:\n   \n    assert type not in (TYPE_I,TYPE_D),\"unexpected missing type: %r\"%type\n  mixin_cls._backend_type_map=type_map\n  \n  \n  mixin_cls.version=mixin_cls.max_version=max_version\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n @classmethod\n def hash(cls,secret):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  \n  try :\n   return bascii_to_str(_argon2_cffi.low_level.hash_secret(\n   type=cls._get_backend_type(cls.type),\n   memory_cost=cls.memory_cost,\n   time_cost=cls.default_rounds,\n   parallelism=cls.parallelism,\n   salt=to_bytes(cls._generate_salt()),\n   hash_len=cls.checksum_size,\n   secret=secret,\n   ))\n  except _argon2_cffi.exceptions.HashingError as err:\n   raise cls._adapt_backend_error(err)\n   \n   \n _byte_ident_map=dict((render_bytes(b\"$argon2%s$\",type.encode(\"ascii\")),type)\n for type in ALL_TYPES)\n \n @classmethod\n def verify(cls,secret,hash):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  hash=to_bytes(hash,\"ascii\")\n  \n  \n  \n  type=cls._byte_ident_map.get(hash[:1+hash.find(b\"$\",1)],TYPE_I)\n  type_code=cls._get_backend_type(type)\n  \n  \n  try :\n   result=_argon2_cffi.low_level.verify_secret(hash,secret,type_code)\n   assert result is True\n   return True\n  except _argon2_cffi.exceptions.VerifyMismatchError:\n   return False\n  except _argon2_cffi.exceptions.VerificationError as err:\n   raise cls._adapt_backend_error(err,hash=hash)\n   \n   \n @classmethod\n def genhash(cls,secret,config):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  self=cls.from_string(config)\n  \n  try :\n   result=bascii_to_str(_argon2_cffi.low_level.hash_secret(\n   type=cls._get_backend_type(self.type),\n   memory_cost=self.memory_cost,\n   time_cost=self.rounds,\n   parallelism=self.parallelism,\n   salt=to_bytes(self.salt),\n   hash_len=self.checksum_size,\n   secret=secret,\n   version=self.version,\n   ))\n  except _argon2_cffi.exceptions.HashingError as err:\n   raise cls._adapt_backend_error(err,hash=config)\n  if self.version ==0x10:\n  \n   result=result.replace(\"$v=16$\",\"$\")\n  return result\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  raise AssertionError(\"shouldn't be called under argon2_cffi backend\")\n  \n  \n  \n  \n  \n  \n  \n  \nclass _PureBackend(_Argon2Common):\n ''\n\n \n \n \n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  assert mixin_cls is _PureBackend\n  \n  \n  global _argon2pure\n  try :\n   import argon2pure as _argon2pure\n  except ImportError:\n   return False\n   \n   \n  try :\n   from argon2pure import ARGON2_DEFAULT_VERSION as max_version\n  except ImportError:\n   log.warning(\"detected 'argon2pure' backend, but package is too old \"\n   \"(passlib requires argon2pure >= 1.2.3)\")\n   return False\n   \n  log.debug(\"detected 'argon2pure' backend, with support for 0x%x argon2 hashes\",\n  max_version)\n  \n  if not dryrun:\n   warn(\"Using argon2pure backend, which is 100x+ slower than is required \"\n   \"for adequate security. Installing argon2_cffi (via 'pip install argon2_cffi') \"\n   \"is strongly recommended\",exc.PasslibSecurityWarning)\n   \n   \n  type_map={}\n  for type in ALL_TYPES:\n   try :\n    type_map[type]=getattr(_argon2pure,\"ARGON2\"+type.upper())\n   except AttributeError:\n   \n    assert type not in (TYPE_I,TYPE_D),\"unexpected missing type: %r\"%type\n  mixin_cls._backend_type_map=type_map\n  \n  mixin_cls.version=mixin_cls.max_version=max_version\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  kwds=dict(\n  password=secret,\n  salt=self.salt,\n  time_cost=self.rounds,\n  memory_cost=self.memory_cost,\n  parallelism=self.parallelism,\n  tag_length=self.checksum_size,\n  type_code=self._get_backend_type(self.type),\n  version=self.version,\n  )\n  if self.max_threads >0:\n   kwds['threads']=self.max_threads\n  if self.pure_use_threads:\n   kwds['use_threads']=True\n  if self.data:\n   kwds['associated_data']=self.data\n   \n   \n   \n  try :\n   return _argon2pure.argon2(**kwds)\n  except _argon2pure.Argon2Error as err:\n   raise self._adapt_backend_error(err,self=self)\n   \n   \n   \n   \n   \nclass argon2(_NoBackend,_Argon2Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n backends=(\"argon2_cffi\",\"argon2pure\")\n \n \n _backend_mixin_target=True\n \n \n _backend_mixin_map={\n None :_NoBackend,\n \"argon2_cffi\":_CffiBackend,\n \"argon2pure\":_PureBackend,\n }\n \n \n \n \n \n \n \n \n", ["__future__", "argon2", "argon2pure", "logging", "passlib", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "types", "warnings"]], "passlib.handlers": [".py", "''\n", [], 1], "passlib.handlers.scrypt": [".py", "''\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.crypto import scrypt as _scrypt\nfrom passlib.utils import h64,to_bytes\nfrom passlib.utils.binary import h64,b64s_decode,b64s_encode\nfrom passlib.utils.compat import u,bascii_to_str,suppress_cause\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"scrypt\",\n]\n\n\n\n\n\nIDENT_SCRYPT=u(\"$scrypt$\")\nIDENT_7=u(\"$7$\")\n\n_UDOLLAR=u(\"$\")\n\n\n\n\nclass scrypt(uh.ParallelismMixin,uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.HasManyIdents,\nuh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n name=\"scrypt\"\n setting_kwds=(\"ident\",\"salt\",\"salt_size\",\"rounds\",\"block_size\",\"parallelism\")\n \n \n \n \n \n \n \n \n checksum_size=32\n \n \n \n \n default_ident=IDENT_SCRYPT\n ident_values=(IDENT_SCRYPT,IDENT_7)\n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n \n \n \n default_rounds=16\n min_rounds=1\n max_rounds=31\n rounds_cost=\"log2\"\n \n \n \n \n \n \n \n \n parallelism=1\n \n \n block_size=8\n \n \n \n \n \n @classmethod\n def using(cls,block_size=None ,**kwds):\n  subcls=super(scrypt,cls).using(**kwds)\n  if block_size is not None :\n   if isinstance(block_size,uh.native_string_types):\n    block_size=int(block_size)\n   subcls.block_size=subcls._norm_block_size(block_size,relaxed=kwds.get(\"relaxed\"))\n   \n   \n  try :\n   _scrypt.validate(1 <<cls.default_rounds,cls.block_size,cls.parallelism)\n  except ValueError as err:\n   raise suppress_cause(ValueError(\"scrypt: invalid settings combination: \"+str(err)))\n   \n  return subcls\n  \n  \n  \n  \n  \n @classmethod\n def from_string(cls,hash):\n  return cls(**cls.parse(hash))\n  \n @classmethod\n def parse(cls,hash):\n  ident,suffix=cls._parse_ident(hash)\n  func=getattr(cls,\"_parse_%s_string\"%ident.strip(_UDOLLAR),None )\n  if func:\n   return func(suffix)\n  else :\n   raise uh.exc.InvalidHashError(cls)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n @classmethod\n def _parse_scrypt_string(cls,suffix):\n \n  parts=suffix.split(\"$\")\n  if len(parts)==3:\n   params,salt,digest=parts\n  elif len(parts)==2:\n   params,salt=parts\n   digest=None\n  else :\n   raise uh.exc.MalformedHashError(cls,\"malformed hash\")\n   \n   \n  parts=params.split(\",\")\n  if len(parts)==3:\n   nstr,bstr,pstr=parts\n   assert nstr.startswith(\"ln=\")\n   assert bstr.startswith(\"r=\")\n   assert pstr.startswith(\"p=\")\n  else :\n   raise uh.exc.MalformedHashError(cls,\"malformed settings field\")\n   \n  return dict(\n  ident=IDENT_SCRYPT,\n  rounds=int(nstr[3:]),\n  block_size=int(bstr[2:]),\n  parallelism=int(pstr[2:]),\n  salt=b64s_decode(salt.encode(\"ascii\")),\n  checksum=b64s_decode(digest.encode(\"ascii\"))if digest else None ,\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def _parse_7_string(cls,suffix):\n \n \n \n \n  parts=suffix.encode(\"ascii\").split(b\"$\")\n  if len(parts)==2:\n   params,digest=parts\n  elif len(parts)==1:\n   params,=parts\n   digest=None\n  else :\n   raise uh.exc.MalformedHashError()\n   \n   \n  if len(params)<11:\n   raise uh.exc.MalformedHashError(cls,\"params field too short\")\n  return dict(\n  ident=IDENT_7,\n  rounds=h64.decode_int6(params[:1]),\n  block_size=h64.decode_int30(params[1:6]),\n  parallelism=h64.decode_int30(params[6:11]),\n  salt=params[11:],\n  checksum=h64.decode_bytes(digest)if digest else None ,\n  )\n  \n  \n  \n  \n def to_string(self):\n  ident=self.ident\n  if ident ==IDENT_SCRYPT:\n   return \"$scrypt$ln=%d,r=%d,p=%d$%s$%s\"%(\n   self.rounds,\n   self.block_size,\n   self.parallelism,\n   bascii_to_str(b64s_encode(self.salt)),\n   bascii_to_str(b64s_encode(self.checksum)),\n   )\n  else :\n   assert ident ==IDENT_7\n   salt=self.salt\n   try :\n    salt.decode(\"ascii\")\n   except UnicodeDecodeError:\n    raise suppress_cause(NotImplementedError(\"scrypt $7$ hashes dont support non-ascii salts\"))\n   return bascii_to_str(b\"\".join([\n   b\"$7$\",\n   h64.encode_int6(self.rounds),\n   h64.encode_int30(self.block_size),\n   h64.encode_int30(self.parallelism),\n   self.salt,\n   b\"$\",\n   h64.encode_bytes(self.checksum)\n   ]))\n   \n   \n   \n   \n def __init__(self,block_size=None ,**kwds):\n  super(scrypt,self).__init__(**kwds)\n  \n  \n  if block_size is None :\n   assert uh.validate_default_value(self,self.block_size,self._norm_block_size,\n   param=\"block_size\")\n  else :\n   self.block_size=self._norm_block_size(block_size)\n   \n   \n   \n   \n @classmethod\n def _norm_block_size(cls,block_size,relaxed=False ):\n  return uh.norm_integer(cls,block_size,min=1,param=\"block_size\",relaxed=relaxed)\n  \n def _generate_salt(self):\n  salt=super(scrypt,self)._generate_salt()\n  if self.ident ==IDENT_7:\n  \n  \n   salt=b64s_encode(salt)\n  return salt\n  \n  \n  \n  \n  \n  \n  \n @classproperty\n def backends(cls):\n  return _scrypt.backend_values\n  \n @classmethod\n def get_backend(cls):\n  return _scrypt.backend\n  \n @classmethod\n def has_backend(cls,name=\"any\"):\n  try :\n   cls.set_backend(name,dryrun=True )\n   return True\n  except uh.exc.MissingBackendError:\n   return False\n   \n @classmethod\n def set_backend(cls,name=\"any\",dryrun=False ):\n  _scrypt._set_backend(name,dryrun=dryrun)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  secret=to_bytes(secret,param=\"secret\")\n  return _scrypt.scrypt(secret,self.salt,n=(1 <<self.rounds),r=self.block_size,\n  p=self.parallelism,keylen=self.checksum_size)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  \n  if self.block_size !=type(self).block_size:\n   return True\n  return super(scrypt,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "passlib.crypto", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers"]], "passlib.handlers.digests": [".py", "''\n\n\n\n\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_native_str,to_bytes,render_bytes,consteq\nfrom passlib.utils.compat import unicode,str_to_uascii\nimport passlib.utils.handlers as uh\nfrom passlib.crypto.digest import lookup_hash\n\n__all__=[\n\"create_hex_hash\",\n\"hex_md4\",\n\"hex_md5\",\n\"hex_sha1\",\n\"hex_sha256\",\n\"hex_sha512\",\n]\n\n\n\n\nclass HexDigestHash(uh.StaticHandler):\n ''\n \n \n \n _hash_func=None\n checksum_size=None\n checksum_chars=uh.HEX_CHARS\n \n \n supported=True\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(self._hash_func(secret).hexdigest())\n  \n  \n  \n  \n  \ndef create_hex_hash(digest,module=__name__,django_name=None ,required=True ):\n ''\n\n\n\n\n\n\n\n \n info=lookup_hash(digest,required=required)\n name=\"hex_\"+info.name\n if not info.supported:\n  info.digest_size=0\n hasher=type(name,(HexDigestHash,),dict(\n name=name,\n __module__=module,\n _hash_func=staticmethod(info.const),\n checksum_size=info.digest_size *2,\n __doc__=\"\"\"This class implements a plain hexadecimal %s hash, and follows the :ref:`password-hash-api`.\n\nIt supports no optional or contextual keywords.\n\"\"\"%(info.name,)\n ))\n if not info.supported:\n  hasher.supported=False\n if django_name:\n  hasher.django_name=django_name\n return hasher\n \n \n \n \n \n \n \n \n \nhex_md4=create_hex_hash(\"md4\",required=False )\nhex_md5=create_hex_hash(\"md5\",django_name=\"unsalted_md5\",required=False )\nhex_sha1=create_hex_hash(\"sha1\",required=False )\nhex_sha256=create_hex_hash(\"sha256\")\nhex_sha512=create_hex_hash(\"sha512\")\n\n\n\n\nclass htdigest(uh.MinimalHandler):\n ''\n\n\n\n \n name=\"htdigest\"\n setting_kwds=()\n context_kwds=(\"user\",\"realm\",\"encoding\")\n default_encoding=\"utf-8\"\n \n @classmethod\n def hash(cls,secret,user,realm,encoding=None ):\n \n \n  if not encoding:\n   encoding=cls.default_encoding\n  uh.validate_secret(secret)\n  if isinstance(secret,unicode):\n   secret=secret.encode(encoding)\n  user=to_bytes(user,encoding,\"user\")\n  realm=to_bytes(realm,encoding,\"realm\")\n  data=render_bytes(\"%s:%s:%s\",user,realm,secret)\n  return hashlib.md5(data).hexdigest()\n  \n @classmethod\n def _norm_hash(cls,hash):\n  ''\n  hash=to_native_str(hash,param=\"hash\")\n  if len(hash)!=32:\n   raise uh.exc.MalformedHashError(cls,\"wrong size\")\n  for char in hash:\n   if char not in uh.LC_HEX_CHARS:\n    raise uh.exc.MalformedHashError(cls,\"invalid chars in hash\")\n  return hash\n  \n @classmethod\n def verify(cls,secret,hash,user,realm,encoding=\"utf-8\"):\n  hash=cls._norm_hash(hash)\n  other=cls.hash(secret,user,realm,encoding)\n  return consteq(hash,other)\n  \n @classmethod\n def identify(cls,hash):\n  try :\n   cls._norm_hash(hash)\n  except ValueError:\n   return False\n  return True\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n  return cls.hash(\"\",\"\",\"\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,user,realm,encoding=None ):\n \n \n  cls._norm_hash(config)\n  return cls.hash(secret,user,realm,encoding)\n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.pbkdf2": [".py", "''\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom base64 import b64encode,b64decode\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode\nfrom passlib.utils.binary import ab64_decode,ab64_encode\nfrom passlib.utils.compat import str_to_bascii,u,uascii_to_str,unicode\nfrom passlib.crypto.digest import pbkdf2_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"pbkdf2_sha1\",\n\"pbkdf2_sha256\",\n\"pbkdf2_sha512\",\n\"cta_pbkdf2_sha1\",\n\"dlitz_pbkdf2_sha1\",\n\"grub_pbkdf2_sha512\",\n]\n\n\n\n\nclass Pbkdf2DigestHandler(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n \n \n \n \n \n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n checksum_chars=uh.HASH64_CHARS\n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n default_rounds=None\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n _digest=None\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  salt=ab64_decode(salt.encode(\"ascii\"))\n  if chk:\n   chk=ab64_decode(chk.encode(\"ascii\"))\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=ab64_encode(self.salt).decode(\"ascii\")\n  chk=ab64_encode(self.checksum).decode(\"ascii\")\n  return uh.render_mc3(self.ident,self.rounds,salt,chk)\n  \n def _calc_checksum(self,secret):\n \n  return pbkdf2_hmac(self._digest,secret,self.salt,self.rounds,self.checksum_size)\n  \ndef create_pbkdf2_hash(hash_name,digest_size,rounds=12000,ident=None ,module=__name__):\n ''\n name='pbkdf2_'+hash_name\n if ident is None :\n  ident=u(\"$pbkdf2-%s$\")%(hash_name,)\n base=Pbkdf2DigestHandler\n return type(name,(base,),dict(\n __module__=module,\n name=name,\n ident=ident,\n _digest=hash_name,\n default_rounds=rounds,\n checksum_size=digest_size,\n encoded_checksum_size=(digest_size *4+2)//3,\n __doc__=\"\"\"This class implements a generic ``PBKDF2-HMAC-%(digest)s``-based password hash, and follows the :ref:`password-hash-api`.\n\n    It supports a variable-length salt, and a variable number of rounds.\n\n    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:\n\n    :type salt: bytes\n    :param salt:\n        Optional salt bytes.\n        If specified, the length must be between 0-1024 bytes.\n        If not specified, a %(dsc)d byte salt will be autogenerated (this is recommended).\n\n    :type salt_size: int\n    :param salt_size:\n        Optional number of bytes to use when autogenerating new salts.\n        Defaults to %(dsc)d bytes, but can be any value between 0 and 1024.\n\n    :type rounds: int\n    :param rounds:\n        Optional number of rounds to use.\n        Defaults to %(dr)d, but must be within ``range(1,1<<32)``.\n\n    :type relaxed: bool\n    :param relaxed:\n        By default, providing an invalid value for one of the other\n        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,\n        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`\n        will be issued instead. Correctable errors include ``rounds``\n        that are too small or too large, and ``salt`` strings that are too long.\n\n        .. versionadded:: 1.6\n    \"\"\"%dict(digest=hash_name.upper(),dsc=base.default_salt_size,dr=rounds)\n ))\n \n \n \n \npbkdf2_sha1=create_pbkdf2_hash(\"sha1\",20,131000,ident=u(\"$pbkdf2$\"))\npbkdf2_sha256=create_pbkdf2_hash(\"sha256\",32,29000)\npbkdf2_sha512=create_pbkdf2_hash(\"sha512\",64,25000)\n\nldap_pbkdf2_sha1=uh.PrefixWrapper(\"ldap_pbkdf2_sha1\",pbkdf2_sha1,\"{PBKDF2}\",\"$pbkdf2$\",ident=True )\nldap_pbkdf2_sha256=uh.PrefixWrapper(\"ldap_pbkdf2_sha256\",pbkdf2_sha256,\"{PBKDF2-SHA256}\",\"$pbkdf2-sha256$\",ident=True )\nldap_pbkdf2_sha512=uh.PrefixWrapper(\"ldap_pbkdf2_sha512\",pbkdf2_sha512,\"{PBKDF2-SHA512}\",\"$pbkdf2-sha512$\",ident=True )\n\n\n\n\n\n\nCTA_ALTCHARS=b\"-_\"\n\nclass cta_pbkdf2_sha1(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"cta_pbkdf2_sha1\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$p5k2$\")\n checksum_size=20\n \n \n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n default_rounds=pbkdf2_sha1.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n \n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,rounds_base=16,handler=cls)\n  salt=b64decode(salt.encode(\"ascii\"),CTA_ALTCHARS)\n  if chk:\n   chk=b64decode(chk.encode(\"ascii\"),CTA_ALTCHARS)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=b64encode(self.salt,CTA_ALTCHARS).decode(\"ascii\")\n  chk=b64encode(self.checksum,CTA_ALTCHARS).decode(\"ascii\")\n  return uh.render_mc3(self.ident,self.rounds,salt,chk,rounds_base=16)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  return pbkdf2_hmac(\"sha1\",secret,self.salt,self.rounds,20)\n  \n  \n  \n  \n  \n  \n  \n  \nclass dlitz_pbkdf2_sha1(uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"dlitz_pbkdf2_sha1\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$p5k2$\")\n _stub_checksum=u(\"0\"*48+\"=\")\n \n \n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n default_rounds=pbkdf2_sha1.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,rounds_base=16,\n  default_rounds=400,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  rounds=self.rounds\n  if rounds ==400:\n   rounds=None\n  return uh.render_mc3(self.ident,rounds,self.salt,self.checksum,rounds_base=16)\n  \n def _get_config(self):\n  rounds=self.rounds\n  if rounds ==400:\n   rounds=None\n  return uh.render_mc3(self.ident,rounds,self.salt,None ,rounds_base=16)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  salt=self._get_config()\n  result=pbkdf2_hmac(\"sha1\",secret,salt,self.rounds,24)\n  return ab64_encode(result).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \nclass atlassian_pbkdf2_sha1(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n name=\"atlassian_pbkdf2_sha1\"\n setting_kwds=(\"salt\",)\n ident=u(\"{PKCS5S2}\")\n checksum_size=32\n \n \n min_salt_size=max_salt_size=16\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  ident=cls.ident\n  if not hash.startswith(ident):\n   raise uh.exc.InvalidHashError(cls)\n  data=b64decode(hash[len(ident):].encode(\"ascii\"))\n  salt,chk=data[:16],data[16:]\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  data=self.salt+self.checksum\n  hash=self.ident+b64encode(data).decode(\"ascii\")\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n \n \n \n  return pbkdf2_hmac(\"sha1\",secret,self.salt,10000,32)\n  \n  \n  \n  \nclass grub_pbkdf2_sha512(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"grub_pbkdf2_sha512\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n \n ident=u(\"grub.pbkdf2.sha512.\")\n checksum_size=64\n \n \n \n \n \n default_salt_size=64\n max_salt_size=1024\n \n default_rounds=pbkdf2_sha512.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,sep=u(\".\"),\n  handler=cls)\n  salt=unhexlify(salt.encode(\"ascii\"))\n  if chk:\n   chk=unhexlify(chk.encode(\"ascii\"))\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=hexlify(self.salt).decode(\"ascii\").upper()\n  chk=hexlify(self.checksum).decode(\"ascii\").upper()\n  return uh.render_mc3(self.ident,self.rounds,salt,chk,sep=u(\".\"))\n  \n def _calc_checksum(self,secret):\n \n \n  return pbkdf2_hmac(\"sha512\",secret,self.salt,self.rounds,64)\n  \n  \n  \n  \n", ["base64", "binascii", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.cisco": [".py", "''\n\n\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import right_pad_string,to_unicode,repeat_string,to_bytes\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import unicode,u,join_byte_values,\\\njoin_byte_elems,iter_byte_values,uascii_to_str\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"cisco_pix\",\n\"cisco_asa\",\n\"cisco_type7\",\n]\n\n\n\n\n\n\n_DUMMY_BYTES=b'\\xFF'*32\n\n\n\n\nclass cisco_pix(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_pix\"\n \n truncate_size=16\n \n \n \n truncate_error=True\n truncate_verify_reject=True\n \n \n \n \n checksum_size=16\n checksum_chars=uh.HASH64_CHARS\n \n \n \n \n \n \n _is_asa=False\n \n \n \n \n def _calc_checksum(self,secret):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  asa=self._is_asa\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  spoil_digest=None\n  if len(secret)>self.truncate_size:\n   if self.use_defaults:\n   \n    msg=\"Password too long (%s allows at most %d bytes)\"%\\\n    (self.name,self.truncate_size)\n    raise uh.exc.PasswordSizeError(self.truncate_size,msg=msg)\n   else :\n   \n   \n   \n   \n   \n   \n    spoil_digest=secret+_DUMMY_BYTES\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  user=self.user\n  if user:\n   if isinstance(user,unicode):\n    user=user.encode(\"utf-8\")\n   if not asa or len(secret)<28:\n    secret +=repeat_string(user,4)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n  if asa and len(secret)>16:\n   pad_size=32\n  else :\n   pad_size=16\n  secret=right_pad_string(secret,pad_size)\n  \n  \n  \n  \n  if spoil_digest:\n  \n   secret +=spoil_digest\n  digest=md5(secret).digest()\n  \n  \n  \n  \n  \n  \n  \n  digest=join_byte_elems(c for i,c in enumerate(digest)if (i+1)&3)\n  \n  \n  \n  \n  return h64.encode_bytes(digest).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass cisco_asa(cisco_pix):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_asa\"\n \n \n \n \n truncate_size=32\n \n \n \n \n _is_asa=True\n \n \n \n \n \n \n \n \nclass cisco_type7(uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_type7\"\n setting_kwds=(\"salt\",)\n \n \n \n \n checksum_chars=uh.UPPER_HEX_CHARS\n \n \n \n \n \n \n \n min_salt_value=0\n max_salt_value=52\n \n \n \n \n @classmethod\n def using(cls,salt=None ,**kwds):\n  subcls=super(cisco_type7,cls).using(**kwds)\n  if salt is not None :\n   salt=subcls._norm_salt(salt,relaxed=kwds.get(\"relaxed\"))\n   subcls._generate_salt=staticmethod(lambda :salt)\n  return subcls\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if len(hash)<2:\n   raise uh.exc.InvalidHashError(cls)\n  salt=int(hash[:2])\n  return cls(salt=salt,checksum=hash[2:].upper())\n  \n def __init__(self,salt=None ,**kwds):\n  super(cisco_type7,self).__init__(**kwds)\n  if salt is not None :\n   salt=self._norm_salt(salt)\n  elif self.use_defaults:\n   salt=self._generate_salt()\n   assert self._norm_salt(salt)==salt,\"generated invalid salt: %r\"%(salt,)\n  else :\n   raise TypeError(\"no salt specified\")\n  self.salt=salt\n  \n @classmethod\n def _norm_salt(cls,salt,relaxed=False ):\n  ''\n\n\n\n  \n  if not isinstance(salt,int):\n   raise uh.exc.ExpectedTypeError(salt,\"integer\",\"salt\")\n  if 0 <=salt <=cls.max_salt_value:\n   return salt\n  msg=\"salt/offset must be in 0..52 range\"\n  if relaxed:\n   warn(msg,uh.PasslibHashWarning)\n   return 0 if salt <0 else cls.max_salt_value\n  else :\n   raise ValueError(msg)\n   \n @staticmethod\n def _generate_salt():\n  return uh.rng.randint(0,15)\n  \n def to_string(self):\n  return \"%02d%s\"%(self.salt,uascii_to_str(self.checksum))\n  \n def _calc_checksum(self,secret):\n \n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return hexlify(self._cipher(secret,self.salt)).decode(\"ascii\").upper()\n  \n @classmethod\n def decode(cls,hash,encoding=\"utf-8\"):\n  ''\n\n\n\n\n  \n  self=cls.from_string(hash)\n  tmp=unhexlify(self.checksum.encode(\"ascii\"))\n  raw=self._cipher(tmp,self.salt)\n  return raw.decode(encoding)if encoding else raw\n  \n  \n _key=u(\"dsfd;kfoA,.iyewrkldJKDHSUBsgvca69834ncxv9873254k;fg87\")\n \n @classmethod\n def _cipher(cls,data,salt):\n  ''\n  key=cls._key\n  key_size=len(key)\n  return join_byte_values(\n  value ^ord(key[(salt+idx)%key_size])\n  for idx,value in enumerate(iter_byte_values(data))\n  )\n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "warnings"]], "passlib.handlers.des_crypt": [".py", "''\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import safe_crypt,test_crypt,to_unicode\nfrom passlib.utils.binary import h64,h64big\nfrom passlib.utils.compat import byte_elem_value,u,uascii_to_str,unicode,suppress_cause\nfrom passlib.crypto.des import des_encrypt_int_block\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"des_crypt\",\n\"bsdi_crypt\",\n\"bigcrypt\",\n\"crypt16\",\n]\n\n\n\n\n_BNULL=b'\\x00'\n\ndef _crypt_secret_to_key(secret):\n ''\n\n\n\n\n \n \n \n \n \n return sum((byte_elem_value(c)&0x7f)<<(57 -i *8)\n for i,c in enumerate(secret[:8]))\n \ndef _raw_des_crypt(secret,salt):\n ''\n assert len(salt)==2\n \n \n \n \n \n \n \n salt_value=h64.decode_int12(salt)\n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(\"utf-8\")\n assert isinstance(secret,bytes)\n \n \n if _BNULL in secret:\n  raise uh.exc.NullPasswordError(des_crypt)\n  \n  \n key_value=_crypt_secret_to_key(secret)\n \n \n result=des_encrypt_int_block(key_value,0,salt_value,25)\n \n \n return h64big.encode_int64(result)\n \ndef _bsdi_secret_to_key(secret):\n ''\n key_value=_crypt_secret_to_key(secret)\n idx=8\n end=len(secret)\n while idx <end:\n  next=idx+8\n  tmp_value=_crypt_secret_to_key(secret[idx:next])\n  key_value=des_encrypt_int_block(key_value,key_value)^tmp_value\n  idx=next\n return key_value\n \ndef _raw_bsdi_crypt(secret,rounds,salt):\n ''\n \n \n salt_value=h64.decode_int24(salt)\n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(\"utf-8\")\n assert isinstance(secret,bytes)\n \n \n if _BNULL in secret:\n  raise uh.exc.NullPasswordError(bsdi_crypt)\n  \n  \n key_value=_bsdi_secret_to_key(secret)\n \n \n result=des_encrypt_int_block(key_value,0,salt_value,rounds)\n \n \n return h64big.encode_int64(result)\n \n \n \n \nclass des_crypt(uh.TruncateMixin,uh.HasManyBackends,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"des_crypt\"\n setting_kwds=(\"salt\",\"truncate_error\")\n \n \n \n \n checksum_chars=uh.HASH64_CHARS\n checksum_size=11\n \n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n truncate_size=8\n \n \n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{11})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  salt,chk=hash[:2],hash[2:]\n  return cls(salt=salt,checksum=chk or None )\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n  return self._calc_checksum_backend(secret)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'abgOeLfPimXQo'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n \n \n  hash=safe_crypt(secret,self.salt)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(self.salt)or len(hash)!=13:\n   raise uh.exc.CryptBackendError(self,self.salt,hash)\n  return hash[2:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_des_crypt(secret,self.salt.encode(\"ascii\")).decode(\"ascii\")\n  \n  \n  \n  \n  \nclass bsdi_crypt(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"bsdi_crypt\"\n setting_kwds=(\"salt\",\"rounds\")\n checksum_size=11\n checksum_chars=uh.HASH64_CHARS\n \n \n min_salt_size=max_salt_size=4\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=5001\n min_rounds=1\n max_rounds=16777215\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        _\n        (?P<rounds>[./a-z0-9]{4})\n        (?P<salt>[./a-z0-9]{4})\n        (?P<chk>[./a-z0-9]{11})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  rounds,salt,chk=m.group(\"rounds\",\"salt\",\"chk\")\n  return cls(\n  rounds=h64.decode_int24(rounds.encode(\"ascii\")),\n  salt=salt,\n  checksum=chk,\n  )\n  \n def to_string(self):\n  hash=u(\"_%s%s%s\")%(h64.encode_int24(self.rounds).decode(\"ascii\"),\n  self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n  \n  \n _avoid_even_rounds=True\n \n @classmethod\n def using(cls,**kwds):\n  subcls=super(bsdi_crypt,cls).using(**kwds)\n  if not subcls.default_rounds&1:\n  \n   warn(\"bsdi_crypt rounds should be odd, as even rounds may reveal weak DES keys\",\n   uh.exc.PasslibSecurityWarning)\n  return subcls\n  \n @classmethod\n def _generate_rounds(cls):\n  rounds=super(bsdi_crypt,cls)._generate_rounds()\n  \n  \n  \n  \n  \n  return rounds |1\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n \n  if not self.rounds&1:\n   return True\n   \n  return super(bsdi_crypt,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'_/...lLDAxARksGCHin.'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string()\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config[:9])or len(hash)!=20:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-11:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_bsdi_crypt(secret,self.rounds,self.salt.encode(\"ascii\")).decode(\"ascii\")\n  \n  \n  \n  \n  \nclass bigcrypt(uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"bigcrypt\"\n setting_kwds=(\"salt\",)\n checksum_chars=uh.HASH64_CHARS\n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>([./a-z0-9]{11})+)?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  checksum=super(bigcrypt,self)._norm_checksum(checksum,relaxed=relaxed)\n  if len(checksum)%11:\n   raise uh.exc.InvalidHashError(self)\n  return checksum\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=_raw_des_crypt(secret,self.salt.encode(\"ascii\"))\n  idx=8\n  end=len(secret)\n  while idx <end:\n   next=idx+8\n   chk +=_raw_des_crypt(secret[idx:next],chk[-11:-9])\n   idx=next\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \n  \nclass crypt16(uh.TruncateMixin,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"crypt16\"\n setting_kwds=(\"salt\",\"truncate_error\")\n \n \n \n \n checksum_size=22\n checksum_chars=uh.HASH64_CHARS\n \n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n truncate_size=16\n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{22})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n   \n  try :\n   salt_value=h64.decode_int12(self.salt.encode(\"ascii\"))\n  except ValueError:\n   raise suppress_cause(ValueError(\"invalid chars in salt\"))\n   \n   \n  key1=_crypt_secret_to_key(secret)\n  \n  \n  result1=des_encrypt_int_block(key1,0,salt_value,20)\n  \n  \n  key2=_crypt_secret_to_key(secret[8:16])\n  \n  \n  result2=des_encrypt_int_block(key2,0,salt_value,5)\n  \n  \n  chk=h64big.encode_int64(result1)+h64big.encode_int64(result2)\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["logging", "passlib.crypto.des", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.handlers.postgres": [".py", "''\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_bytes\nfrom passlib.utils.compat import str_to_uascii,unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"postgres_md5\",\n]\n\n\n\n\nclass postgres_md5(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"postgres_md5\"\n _hash_prefix=u(\"md5\")\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  user=to_bytes(self.user,\"utf-8\",param=\"user\")\n  return str_to_uascii(md5(secret+user).hexdigest())\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.bcrypt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nfrom base64 import b64encode\nfrom hashlib import sha256\nimport os\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n_bcrypt=None\n_pybcrypt=None\n_bcryptor=None\n\n_builtin_bcrypt=None\nfrom passlib.crypto.digest import compile_hmac\nfrom passlib.exc import PasslibHashWarning,PasslibSecurityWarning,PasslibSecurityError\nfrom passlib.utils import safe_crypt,repeat_string,to_bytes,parse_version,\\\nrng,getrandstr,test_crypt,to_unicode,\\\nutf8_truncate,utf8_repeat_string,crypt_accepts_bytes\nfrom passlib.utils.binary import bcrypt64\nfrom passlib.utils.compat import get_unbound_method_function\nfrom passlib.utils.compat import u,uascii_to_str,unicode,str_to_uascii,PY3,error_from\nimport passlib.utils.handlers as uh\n\n\n__all__=[\n\"bcrypt\",\n]\n\n\n\n\nIDENT_2=u(\"$2$\")\nIDENT_2A=u(\"$2a$\")\nIDENT_2X=u(\"$2x$\")\nIDENT_2Y=u(\"$2y$\")\nIDENT_2B=u(\"$2b$\")\n_BNULL=b'\\x00'\n\n\nTEST_HASH_2A=\"$2a$04$5BJqKfqMQvV7nS.yUguNcueVirQqDBGaLXSqj.rs.pZPlNR0UX/HK\"\n\ndef _detect_pybcrypt():\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n try :\n  import bcrypt\n except ImportError:\n \n \n  return None\n  \n  \n  \n  \n try :\n  from bcrypt._bcrypt import __version__\n except ImportError:\n  return False\n return True\n \n \n \n \nclass _BcryptCommon(uh.SubclassBackendMixin,uh.TruncateMixin,uh.HasManyIdents,\nuh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"bcrypt\"\n setting_kwds=(\"salt\",\"rounds\",\"ident\",\"truncate_error\")\n \n \n \n \n checksum_size=31\n checksum_chars=bcrypt64.charmap\n \n \n \n \n default_ident=IDENT_2B\n ident_values=(IDENT_2,IDENT_2A,IDENT_2X,IDENT_2Y,IDENT_2B)\n ident_aliases={u(\"2\"):IDENT_2,u(\"2a\"):IDENT_2A,u(\"2y\"):IDENT_2Y,\n u(\"2b\"):IDENT_2B}\n \n \n \n \n min_salt_size=max_salt_size=22\n salt_chars=bcrypt64.charmap\n \n \n final_salt_chars=\".Oeu\"\n \n \n \n \n default_rounds=12\n min_rounds=4\n max_rounds=31\n rounds_cost=\"log2\"\n \n \n \n \n truncate_size=72\n \n \n \n \n \n \n \n _workrounds_initialized=False\n _has_2a_wraparound_bug=False\n _lacks_20_support=False\n _lacks_2y_support=False\n _lacks_2b_support=False\n _fallback_ident=IDENT_2A\n _require_valid_utf8_bytes=False\n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  ident,tail=cls._parse_ident(hash)\n  if ident ==IDENT_2X:\n   raise ValueError(\"crypt_blowfish's buggy '2x' hashes are not \"\n   \"currently supported\")\n  rounds_str,data=tail.split(u(\"$\"))\n  rounds=int(rounds_str)\n  if rounds_str !=u('%02d')%(rounds,):\n   raise uh.exc.MalformedHashError(cls,\"malformed cost field\")\n  salt,chk=data[:22],data[22:]\n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk or None ,\n  ident=ident,\n  )\n  \n def to_string(self):\n  hash=u(\"%s%02d$%s%s\")%(self.ident,self.rounds,self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n def _get_config(self,ident):\n  ''\n  config=u(\"%s%02d$%s\")%(ident,self.rounds,self.salt)\n  return uascii_to_str(config)\n  \n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,**kwds):\n \n \n \n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  if hash.startswith(IDENT_2A)and hash[28]not in cls.final_salt_chars:\n   return True\n   \n   \n   \n   \n  return super(_BcryptCommon,cls).needs_update(hash,**kwds)\n  \n  \n  \n  \n  \n @classmethod\n def normhash(cls,hash):\n  ''\n  if cls.identify(hash):\n   return cls.from_string(hash).to_string()\n  else :\n   return hash\n   \n @classmethod\n def _generate_salt(cls):\n \n \n  salt=super(_BcryptCommon,cls)._generate_salt()\n  return bcrypt64.repair_unused(salt)\n  \n @classmethod\n def _norm_salt(cls,salt,**kwds):\n  salt=super(_BcryptCommon,cls)._norm_salt(salt,**kwds)\n  assert salt is not None ,\"HasSalt didn't generate new salt!\"\n  changed,salt=bcrypt64.check_repair_unused(salt)\n  if changed:\n  \n  \n   warn(\n   \"encountered a bcrypt salt with incorrectly set padding bits; \"\n   \"you may want to use bcrypt.normhash() \"\n   \"to fix this; this will be an error under Passlib 2.0\",\n   PasslibHashWarning)\n  return salt\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  checksum=super(_BcryptCommon,self)._norm_checksum(checksum,relaxed=relaxed)\n  changed,checksum=bcrypt64.check_repair_unused(checksum)\n  if changed:\n   warn(\n   \"encountered a bcrypt hash with incorrectly set padding bits; \"\n   \"you may want to use bcrypt.normhash() \"\n   \"to fix this; this will be an error under Passlib 2.0\",\n   PasslibHashWarning)\n  return checksum\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n _no_backend_suggestion=\" -- recommend you install one (e.g. 'pip install bcrypt')\"\n \n @classmethod\n def _finalize_backend_mixin(mixin_cls,backend,dryrun):\n  ''\n\n\n\n  \n  \n  \n  \n  assert mixin_cls is bcrypt._backend_mixin_map[backend],\\\n  \"_configure_workarounds() invoked from wrong class\"\n  \n  if mixin_cls._workrounds_initialized:\n   return True\n   \n  verify=mixin_cls.verify\n  \n  err_types=(ValueError,uh.exc.MissingBackendError)\n  if _bcryptor:\n   err_types +=(_bcryptor.engine.SaltError,)\n   \n  def safe_verify(secret,hash):\n   ''\n   try :\n    return verify(secret,hash)\n   except err_types:\n   \n   \n   \n   \n   \n   \n   \n   \n    return NotImplemented\n   except uh.exc.InternalBackendError:\n   \n   \n   \n    log.debug(\"trapped unexpected response from %r backend: verify(%r, %r):\",\n    backend,secret,hash,exc_info=True )\n    return NotImplemented\n    \n  def assert_lacks_8bit_bug(ident):\n   ''\n\n\n\n\n\n\n\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   secret=b\"\\xd1\\x91\"\n   bug_hash=ident.encode(\"ascii\")+b\"05$6bNw2HLQYeqHYyBfLMsv/OiwqTymGIGzFsA4hOTWebfehXHNprcAS\"\n   correct_hash=ident.encode(\"ascii\")+b\"05$6bNw2HLQYeqHYyBfLMsv/OUcZd0LKP39b87nBw3.S2tVZSqiQX6eu\"\n   \n   if verify(secret,bug_hash):\n   \n   \n   \n    raise PasslibSecurityError(\n    \"passlib.hash.bcrypt: Your installation of the %r backend is vulnerable to \"\n    \"the crypt_blowfish 8-bit bug (CVE-2011-2483) under %r hashes, \"\n    \"and should be upgraded or replaced with another backend\"%(backend,ident))\n    \n    \n    \n   if not verify(secret,correct_hash):\n    raise RuntimeError(\"%s backend failed to verify %s 8bit hash\"%(backend,ident))\n    \n  def detect_wrap_bug(ident):\n   ''\n\n\n\n\n\n\n\n\n\n\n   \n   \n   secret=(b\"0123456789\"*26)[:255]\n   bug_hash=ident.encode(\"ascii\")+b\"04$R1lJ2gkNaoPGdafE.H.16.nVyh2niHsGJhayOHLMiXlI45o8/DU.6\"\n   if verify(secret,bug_hash):\n    return True\n    \n    \n    \n   correct_hash=ident.encode(\"ascii\")+b\"04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi\"\n   if not verify(secret,correct_hash):\n    raise RuntimeError(\"%s backend failed to verify %s wraparound hash\"%(backend,ident))\n    \n   return False\n   \n  def assert_lacks_wrap_bug(ident):\n   if not detect_wrap_bug(ident):\n    return\n    \n    \n    \n   raise RuntimeError(\"%s backend unexpectedly has wraparound bug for %s\"%(backend,ident))\n   \n   \n   \n   \n  test_hash_20=b\"$2$04$5BJqKfqMQvV7nS.yUguNcuRfMMOXK0xPWavM7pOzjEi5ze5T1k8/S\"\n  result=safe_verify(\"test\",test_hash_20)\n  if result is NotImplemented:\n   mixin_cls._lacks_20_support=True\n   log.debug(\"%r backend lacks $2$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2$ hash\"%backend)\n   \n   \n   \n   \n  result=safe_verify(\"test\",TEST_HASH_2A)\n  if result is NotImplemented:\n  \n   raise RuntimeError(\"%s lacks support for $2a$ hashes\"%backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2a$ hash\"%backend)\n  else :\n   assert_lacks_8bit_bug(IDENT_2A)\n   if detect_wrap_bug(IDENT_2A):\n    if backend ==\"os_crypt\":\n    \n    \n    \n     log.debug(\"%r backend has $2a$ bsd wraparound bug, enabling workaround\",backend)\n    else :\n    \n    \n     warn(\"passlib.hash.bcrypt: Your installation of the %r backend is vulnerable to \"\n     \"the bsd wraparound bug, \"\n     \"and should be upgraded or replaced with another backend \"\n     \"(enabling workaround for now).\"%backend,\n     uh.exc.PasslibSecurityWarning)\n    mixin_cls._has_2a_wraparound_bug=True\n    \n    \n    \n    \n  test_hash_2y=TEST_HASH_2A.replace(\"2a\",\"2y\")\n  result=safe_verify(\"test\",test_hash_2y)\n  if result is NotImplemented:\n   mixin_cls._lacks_2y_support=True\n   log.debug(\"%r backend lacks $2y$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2y$ hash\"%backend)\n  else :\n  \n  \n   assert_lacks_8bit_bug(IDENT_2Y)\n   assert_lacks_wrap_bug(IDENT_2Y)\n   \n   \n   \n   \n   \n   \n   \n   \n  test_hash_2b=TEST_HASH_2A.replace(\"2a\",\"2b\")\n  result=safe_verify(\"test\",test_hash_2b)\n  if result is NotImplemented:\n   mixin_cls._lacks_2b_support=True\n   log.debug(\"%r backend lacks $2b$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2b$ hash\"%backend)\n  else :\n   mixin_cls._fallback_ident=IDENT_2B\n   assert_lacks_8bit_bug(IDENT_2B)\n   assert_lacks_wrap_bug(IDENT_2B)\n   \n   \n  mixin_cls._workrounds_initialized=True\n  return True\n  \n  \n  \n  \n  \n  \n  \n def _prepare_digest_args(self,secret):\n  ''\n\n\n  \n  return self._norm_digest_args(secret,self.ident,new=self.use_defaults)\n  \n @classmethod\n def _norm_digest_args(cls,secret,ident,new=False ):\n \n  require_valid_utf8_bytes=cls._require_valid_utf8_bytes\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  elif require_valid_utf8_bytes:\n  \n  \n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n   \n   \n    require_valid_utf8_bytes=False\n    \n    \n  uh.validate_secret(secret)\n  \n  \n  if new:\n   cls._check_truncate_policy(secret)\n   \n   \n   \n   \n  if _BNULL in secret:\n   raise uh.exc.NullPasswordError(cls)\n   \n   \n   \n   \n   \n   \n  if cls._has_2a_wraparound_bug and len(secret)>=255:\n   if require_valid_utf8_bytes:\n   \n   \n   \n   \n   \n    secret=utf8_truncate(secret,72)\n   else :\n    secret=secret[:72]\n    \n    \n  if ident ==IDENT_2A:\n  \n   pass\n   \n  elif ident ==IDENT_2B:\n   if cls._lacks_2b_support:\n   \n   \n   \n   \n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2Y:\n   if cls._lacks_2y_support:\n   \n   \n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2:\n   if cls._lacks_20_support:\n   \n   \n   \n    if secret:\n     if require_valid_utf8_bytes:\n     \n     \n     \n      secret=utf8_repeat_string(secret,72)\n     else :\n      secret=repeat_string(secret,72)\n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2X:\n  \n  \n  \n   raise RuntimeError(\"$2x$ hashes not currently supported by passlib\")\n   \n  else :\n   raise AssertionError(\"unexpected ident value: %r\"%ident)\n   \n  return secret,ident\n  \n  \n  \n  \nclass _NoBackend(_BcryptCommon):\n ''\n\n\n \n \n \n \n def _calc_checksum(self,secret):\n  self._stub_requires_backend()\n  \n  \n  return super(bcrypt,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _BcryptBackend(_BcryptCommon):\n ''\n\n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _bcrypt\n  if _detect_pybcrypt():\n  \n   return False\n  try :\n   import bcrypt as _bcrypt\n  except ImportError:\n   return False\n  try :\n   version=_bcrypt.__about__.__version__\n  except :\n   log.warning(\"(trapped) error reading bcrypt version\",exc_info=True )\n   version='<unknown>'\n   \n  log.debug(\"detected 'bcrypt' backend, version %r\",version)\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  if isinstance(config,unicode):\n   config=config.encode(\"ascii\")\n  hash=_bcrypt.hashpw(secret,config)\n  assert isinstance(hash,bytes)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"`bcrypt` package\")\n  return hash[-31:].decode(\"ascii\")\n  \n  \n  \n  \nclass _BcryptorBackend(_BcryptCommon):\n ''\n\n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _bcryptor\n  try :\n   import bcryptor as _bcryptor\n  except ImportError:\n   return False\n   \n   \n  if not dryrun:\n   warn(\"Support for `bcryptor` is deprecated, and will be removed in Passlib 1.8; \"\n   \"Please use `pip install bcrypt` instead\",DeprecationWarning)\n   \n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=_bcryptor.engine.Engine(False ).hash_key(secret,config)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"bcryptor library\")\n  return str_to_uascii(hash[-31:])\n  \n  \n  \n  \nclass _PyBcryptBackend(_BcryptCommon):\n ''\n\n \n \n \n _calc_lock=None\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _pybcrypt\n  if not _detect_pybcrypt():\n  \n   return False\n  try :\n   import bcrypt as _pybcrypt\n  except ImportError:\n  \n   return False\n   \n   \n  if not dryrun:\n   warn(\"Support for `py-bcrypt` is deprecated, and will be removed in Passlib 1.8; \"\n   \"Please use `pip install bcrypt` instead\",DeprecationWarning)\n   \n   \n  try :\n   version=_pybcrypt._bcrypt.__version__\n  except :\n   log.warning(\"(trapped) error reading pybcrypt version\",exc_info=True )\n   version=\"<unknown>\"\n  log.debug(\"detected 'pybcrypt' backend, version %r\",version)\n  \n  \n  vinfo=parse_version(version)or (0,0)\n  if vinfo <(0,3):\n   warn(\"py-bcrypt %s has a major security vulnerability, \"\n   \"you should upgrade to py-bcrypt 0.3 immediately.\"\n   %version,uh.exc.PasslibSecurityWarning)\n   if mixin_cls._calc_lock is None :\n    import threading\n    mixin_cls._calc_lock=threading.Lock()\n   mixin_cls._calc_checksum=get_unbound_method_function(mixin_cls._calc_checksum_threadsafe)\n   \n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum_threadsafe(self,secret):\n \n \n \n  with self._calc_lock:\n   return self._calc_checksum_raw(secret)\n   \n def _calc_checksum_raw(self,secret):\n \n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=_pybcrypt.hashpw(secret,config)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"pybcrypt library\")\n  return str_to_uascii(hash[-31:])\n  \n _calc_checksum=_calc_checksum_raw\n \n \n \n \nclass _OsCryptBackend(_BcryptCommon):\n ''\n\n \n \n \n \n _require_valid_utf8_bytes=not crypt_accepts_bytes\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n  if not test_crypt(\"test\",TEST_HASH_2A):\n   return False\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=safe_crypt(secret,config)\n  if hash is not None :\n   if not hash.startswith(config)or len(hash)!=len(config)+31:\n    raise uh.exc.CryptBackendError(self,config,hash)\n   return hash[-31:]\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if PY3 and isinstance(secret,bytes):\n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n    raise error_from(uh.exc.PasswordValueError(\n    \"python3 crypt.crypt() ony supports bytes passwords using UTF8; \"\n    \"passlib recommends running `pip install bcrypt` for general bcrypt support.\",\n    ),None )\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  debug_only_repr=uh.exc.debug_only_repr\n  raise uh.exc.InternalBackendError(\n  \"crypt.crypt() failed for unknown reason; \"\n  \"passlib recommends running `pip install bcrypt` for general bcrypt support.\"\n  \n  \"(config=%s, secret=%s)\"%(debug_only_repr(config),debug_only_repr(secret)),\n  )\n  \n  \n  \n  \nclass _BuiltinBackend(_BcryptCommon):\n ''\n\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n  from passlib.utils import as_bool\n  if not as_bool(os.environ.get(\"PASSLIB_BUILTIN_BCRYPT\")):\n   log.debug(\"bcrypt 'builtin' backend not enabled via $PASSLIB_BUILTIN_BCRYPT\")\n   return False\n  global _builtin_bcrypt\n  from passlib.crypto._blowfish import raw_bcrypt as _builtin_bcrypt\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n  secret,ident=self._prepare_digest_args(secret)\n  chk=_builtin_bcrypt(secret,ident[1:-1],\n  self.salt.encode(\"ascii\"),self.rounds)\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \nclass bcrypt(_NoBackend,_BcryptCommon):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n backends=(\"bcrypt\",\"pybcrypt\",\"bcryptor\",\"os_crypt\",\"builtin\")\n \n \n _backend_mixin_target=True\n \n \n _backend_mixin_map={\n None :_NoBackend,\n \"bcrypt\":_BcryptBackend,\n \"pybcrypt\":_PyBcryptBackend,\n \"bcryptor\":_BcryptorBackend,\n \"os_crypt\":_OsCryptBackend,\n \"builtin\":_BuiltinBackend,\n }\n \n \n \n \n \n \n \n \n_UDOLLAR=u(\"$\")\n\n\n\nclass _wrapped_bcrypt(bcrypt):\n ''\n\n\n\n \n setting_kwds=tuple(elem for elem in bcrypt.setting_kwds if elem not in [\"truncate_error\"])\n truncate_size=None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def _check_truncate_policy(cls,secret):\n \n  pass\n  \n  \n  \n  \n  \nclass bcrypt_sha256(_wrapped_bcrypt):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"bcrypt_sha256\"\n \n \n \n \n \n ident_values=(IDENT_2A,IDENT_2B)\n \n \n ident_aliases=(lambda ident_values:dict(item for item in bcrypt.ident_aliases.items()\n if item[1]in ident_values))(ident_values)\n default_ident=IDENT_2B\n \n \n \n \n \n _supported_versions=set([1,2])\n \n \n \n \n \n \n \n \n version=2\n \n \n \n \n \n @classmethod\n def using(cls,version=None ,**kwds):\n  subcls=super(bcrypt_sha256,cls).using(**kwds)\n  if version is not None :\n   subcls.version=subcls._norm_version(version)\n  ident=subcls.default_ident\n  if subcls.version >1 and ident !=IDENT_2B:\n   raise ValueError(\"bcrypt %r hashes not allowed for version %r\"%\n   (ident,subcls.version))\n  return subcls\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n prefix=u('$bcrypt-sha256$')\n \n \n _v2_hash_re=re.compile(r\"\"\"(?x)\n        ^\n        [$]bcrypt-sha256[$]\n        v=(?P<version>\\d+),\n        t=(?P<type>2b),\n        r=(?P<rounds>\\d{1,2})\n        [$](?P<salt>[^$]{22})\n        (?:[$](?P<digest>[^$]{31}))?\n        $\n        \"\"\")\n \n \n _v1_hash_re=re.compile(r\"\"\"(?x)\n        ^\n        [$]bcrypt-sha256[$]\n        (?P<type>2[ab]),\n        (?P<rounds>\\d{1,2})\n        [$](?P<salt>[^$]{22})\n        (?:[$](?P<digest>[^$]{31}))?\n        $\n        \"\"\")\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  if not hash:\n   return False\n  return hash.startswith(cls.prefix)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if not hash.startswith(cls.prefix):\n   raise uh.exc.InvalidHashError(cls)\n  m=cls._v2_hash_re.match(hash)\n  if m:\n   version=int(m.group(\"version\"))\n   if version <2:\n    raise uh.exc.MalformedHashError(cls)\n  else :\n   m=cls._v1_hash_re.match(hash)\n   if m:\n    version=1\n   else :\n    raise uh.exc.MalformedHashError(cls)\n  rounds=m.group(\"rounds\")\n  if rounds.startswith(uh._UZERO)and rounds !=uh._UZERO:\n   raise uh.exc.ZeroPaddedRoundsError(cls)\n  return cls(\n  version=version,\n  ident=m.group(\"type\"),\n  rounds=int(rounds),\n  salt=m.group(\"salt\"),\n  checksum=m.group(\"digest\"),\n  )\n  \n _v2_template=u(\"$bcrypt-sha256$v=2,t=%s,r=%d$%s$%s\")\n _v1_template=u(\"$bcrypt-sha256$%s,%d$%s$%s\")\n \n def to_string(self):\n  if self.version ==1:\n   template=self._v1_template\n  else :\n   template=self._v2_template\n  hash=template %(self.ident.strip(_UDOLLAR),self.rounds,self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n def __init__(self,version=None ,**kwds):\n  if version is not None :\n   self.version=self._norm_version(version)\n  super(bcrypt_sha256,self).__init__(**kwds)\n  \n  \n  \n  \n  \n @classmethod\n def _norm_version(cls,version):\n  if version not in cls._supported_versions:\n   raise ValueError(\"%s: unknown or unsupported version: %r\"%(cls.name,version))\n  return version\n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n \n \n \n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n  if self.version ==1:\n  \n  \n  \n   digest=sha256(secret).digest()\n  else :\n  \n  \n  \n  \n  \n  \n  \n  \n   salt=self.salt\n   if salt[-1]not in self.final_salt_chars:\n   \n   \n   \n    raise ValueError(\"invalid salt string\")\n   digest=compile_hmac(\"sha256\",salt.encode(\"ascii\"))(secret)\n   \n   \n   \n  key=b64encode(digest)\n  \n  \n  return super(bcrypt_sha256,self)._calc_checksum(key)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  if self.version <type(self).version:\n   return True\n  return super(bcrypt_sha256,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "base64", "bcrypt", "bcrypt._bcrypt", "bcryptor", "hashlib", "logging", "os", "passlib.crypto._blowfish", "passlib.crypto.digest", "passlib.exc", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "threading", "warnings"]], "passlib.handlers.windows": [".py", "''\n\n\n\n\nfrom binascii import hexlify\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_unicode,right_pad_string\nfrom passlib.utils.compat import unicode\nfrom passlib.crypto.digest import lookup_hash\nmd4=lookup_hash(\"md4\").const\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"lmhash\",\n\"nthash\",\n\"bsd_nthash\",\n\"msdcc\",\n\"msdcc2\",\n]\n\n\n\n\nclass lmhash(uh.TruncateMixin,uh.HasEncodingContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"lmhash\"\n setting_kwds=(\"truncate_error\",)\n \n \n \n \n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n truncate_size=14\n \n \n \n \n default_encoding=\"cp437\"\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n  return hexlify(self.raw(secret,self.encoding)).decode(\"ascii\")\n  \n  \n _magic=b\"KGS!@#$%\"\n \n @classmethod\n def raw(cls,secret,encoding=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not encoding:\n   encoding=cls.default_encoding\n   \n   \n   \n  from passlib.crypto.des import des_encrypt_block\n  MAGIC=cls._magic\n  if isinstance(secret,unicode):\n  \n  \n  \n   secret=secret.upper().encode(encoding)\n  elif isinstance(secret,bytes):\n  \n  \n  \n  \n   secret=secret.upper()\n  else :\n   raise TypeError(\"secret must be unicode or bytes\")\n  secret=right_pad_string(secret,14)\n  return des_encrypt_block(secret[0:7],MAGIC)+\\\n  des_encrypt_block(secret[7:14],MAGIC)\n  \n  \n  \n  \n  \n  \n  \n  \nclass nthash(uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n \n \n \n \n name=\"nthash\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret):\n  ''\n\n\n\n\n  \n  secret=to_unicode(secret,\"utf-8\",param=\"secret\")\n  \n  return md4(secret.encode(\"utf-16-le\")).digest()\n  \n @classmethod\n def raw_nthash(cls,secret,hex=False ):\n  warn(\"nthash.raw_nthash() is deprecated, and will be removed \"\n  \"in Passlib 1.8, please use nthash.raw() instead\",\n  DeprecationWarning)\n  ret=nthash.raw(secret)\n  return hexlify(ret).decode(\"ascii\")if hex else ret\n  \n  \n  \n  \n  \nbsd_nthash=uh.PrefixWrapper(\"bsd_nthash\",nthash,prefix=\"$3$$\",ident=\"$3$$\",\ndoc=\"\"\"The class support FreeBSD's representation of NTHASH\n    (which is compatible with the :ref:`modular-crypt-format`),\n    and follows the :ref:`password-hash-api`.\n\n    It has no salt and a single fixed round.\n\n    The :meth:`~passlib.ifc.PasswordHash.hash` and :meth:`~passlib.ifc.PasswordHash.genconfig` methods accept no optional keywords.\n    \"\"\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass msdcc(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"msdcc\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret,self.user)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret,user):\n  ''\n\n\n\n\n\n  \n  secret=to_unicode(secret,\"utf-8\",param=\"secret\").encode(\"utf-16-le\")\n  user=to_unicode(user,\"utf-8\",param=\"user\").lower().encode(\"utf-16-le\")\n  return md4(md4(secret).digest()+user).digest()\n  \n  \n  \n  \nclass msdcc2(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"msdcc2\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret,self.user)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret,user):\n  ''\n\n\n\n\n\n\n\n\n  \n  from passlib.crypto.digest import pbkdf2_hmac\n  secret=to_unicode(secret,\"utf-8\",param=\"secret\").encode(\"utf-16-le\")\n  user=to_unicode(user,\"utf-8\",param=\"user\").lower().encode(\"utf-16-le\")\n  tmp=md4(md4(secret).digest()+user).digest()\n  return pbkdf2_hmac(\"sha1\",tmp,user,10240,16)\n  \n  \n  \n  \n", ["binascii", "logging", "passlib.crypto.des", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "warnings"]], "passlib.handlers.oracle": [".py", "''\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode,xor_bytes\nfrom passlib.utils.compat import irange,u,\\\nuascii_to_str,unicode,str_to_uascii\nfrom passlib.crypto.des import des_encrypt_block\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"oracle10g\",\n\"oracle11g\"\n]\n\n\n\n\ndef des_cbc_encrypt(key,value,iv=b'\\x00'*8,pad=b'\\x00'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n value +=pad *(-len(value)%8)\n hash=iv\n for offset in irange(0,len(value),8):\n  chunk=xor_bytes(hash,value[offset:offset+8])\n  hash=des_encrypt_block(key,chunk)\n return hash\n \n \nORACLE10_MAGIC=b\"\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\"\n\nclass oracle10(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"oracle10\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=16\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.upper()\n  \n def _calc_checksum(self,secret):\n \n \n \n \n \n \n \n \n \n \n \n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  user=to_unicode(self.user,\"utf-8\",param=\"user\")\n  input=(user+secret).upper().encode(\"utf-16-be\")\n  hash=des_cbc_encrypt(ORACLE10_MAGIC,input)\n  hash=des_cbc_encrypt(hash,input)\n  return hexlify(hash).decode(\"ascii\").upper()\n  \n  \n  \n  \n  \n  \n  \n  \nclass oracle11(uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"oracle11\"\n setting_kwds=(\"salt\",)\n checksum_size=40\n checksum_chars=uh.UPPER_HEX_CHARS\n \n \n min_salt_size=max_salt_size=20\n salt_chars=uh.UPPER_HEX_CHARS\n \n \n \n \n \n _hash_regex=re.compile(u(\"^S:(?P<chk>[0-9a-f]{40})(?P<salt>[0-9a-f]{20})$\"),re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk.upper())\n  \n def to_string(self):\n  chk=self.checksum\n  hash=u(\"S:%s%s\")%(chk.upper(),self.salt.upper())\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=sha1(secret+unhexlify(self.salt.encode(\"ascii\"))).hexdigest()\n  return str_to_uascii(chk).upper()\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.crypto.des", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re"]], "passlib.handlers.ldap_digests": [".py", "''\n\n\n\n\n\nfrom base64 import b64encode,b64decode\nfrom hashlib import md5,sha1,sha256,sha512\nimport logging ;log=logging.getLogger(__name__)\nimport re\n\n\nfrom passlib.handlers.misc import plaintext\nfrom passlib.utils import unix_crypt_schemes,to_unicode\nfrom passlib.utils.compat import uascii_to_str,unicode,u\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"ldap_plaintext\",\n\"ldap_md5\",\n\"ldap_sha1\",\n\"ldap_salted_md5\",\n\"ldap_salted_sha1\",\n\"ldap_salted_sha256\",\n\"ldap_salted_sha512\",\n\n\n\"ldap_des_crypt\",\n\"ldap_bsdi_crypt\",\n\"ldap_md5_crypt\",\n\"ldap_sha1_crypt\",\n\"ldap_bcrypt\",\n\"ldap_sha256_crypt\",\n\"ldap_sha512_crypt\",\n]\n\n\n\n\nclass _Base64DigestHelper(uh.StaticHandler):\n ''\n \n \n ident=None\n _hash_func=None\n _hash_regex=None\n checksum_chars=uh.PADDED_BASE64_CHARS\n \n @classproperty\n def _hash_prefix(cls):\n  ''\n  return cls.ident\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=self._hash_func(secret).digest()\n  return b64encode(chk).decode(\"ascii\")\n  \nclass _SaltedBase64DigestHelper(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n setting_kwds=(\"salt\",\"salt_size\")\n checksum_chars=uh.PADDED_BASE64_CHARS\n \n ident=None\n _hash_func=None\n _hash_regex=None\n min_salt_size=max_salt_size=4\n \n \n \n \n min_salt_size=4\n default_salt_size=4\n max_salt_size=16\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  try :\n   data=b64decode(m.group(\"tmp\").encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n  cs=cls.checksum_size\n  assert cs\n  return cls(checksum=data[:cs],salt=data[cs:])\n  \n def to_string(self):\n  data=self.checksum+self.salt\n  hash=self.ident+b64encode(data).decode(\"ascii\")\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return self._hash_func(secret+self.salt).digest()\n  \n  \n  \n  \nclass ldap_md5(_Base64DigestHelper):\n ''\n\n\n \n name=\"ldap_md5\"\n ident=u(\"{MD5}\")\n _hash_func=md5\n _hash_regex=re.compile(u(r\"^\\{MD5\\}(?P<chk>[+/a-zA-Z0-9]{22}==)$\"))\n \nclass ldap_sha1(_Base64DigestHelper):\n ''\n\n\n \n name=\"ldap_sha1\"\n ident=u(\"{SHA}\")\n _hash_func=sha1\n _hash_regex=re.compile(u(r\"^\\{SHA\\}(?P<chk>[+/a-zA-Z0-9]{27}=)$\"))\n \nclass ldap_salted_md5(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_md5\"\n ident=u(\"{SMD5}\")\n checksum_size=16\n _hash_func=md5\n _hash_regex=re.compile(u(r\"^\\{SMD5\\}(?P<tmp>[+/a-zA-Z0-9]{27,}={0,2})$\"))\n \nclass ldap_salted_sha1(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha1\"\n ident=u(\"{SSHA}\")\n checksum_size=20\n _hash_func=sha1\n \n _hash_regex=re.compile(u(r\"^\\{SSHA\\}(?P<tmp>[+/a-zA-Z0-9]{32,}={0,2})$\"))\n \n \n \nclass ldap_salted_sha256(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha256\"\n ident=u(\"{SSHA256}\")\n checksum_size=32\n default_salt_size=8\n _hash_func=sha256\n \n _hash_regex=re.compile(u(r\"^\\{SSHA256\\}(?P<tmp>[+/a-zA-Z0-9]{48,}={0,2})$\"))\n \n \nclass ldap_salted_sha512(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha512\"\n ident=u(\"{SSHA512}\")\n checksum_size=64\n default_salt_size=8\n _hash_func=sha512\n \n _hash_regex=re.compile(u(r\"^\\{SSHA512\\}(?P<tmp>[+/a-zA-Z0-9]{91,}={0,2})$\"))\n \n \nclass ldap_plaintext(plaintext):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"ldap_plaintext\"\n _2307_pat=re.compile(u(r\"^\\{\\w+\\}.*$\"))\n \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n \n \n  return \"!\"\n  \n @classmethod\n def identify(cls,hash):\n \n  hash=uh.to_unicode_for_identify(hash)\n  return bool(hash)and cls._2307_pat.match(hash)is None\n  \n  \n  \n  \n  \n  \nldap_crypt_schemes=['ldap_'+name for name in unix_crypt_schemes]\n\ndef _init_ldap_crypt_handlers():\n\n\n g=globals()\n for wname in unix_crypt_schemes:\n  name='ldap_'+wname\n  g[name]=uh.PrefixWrapper(name,wname,prefix=u(\"{CRYPT}\"),lazy=True )\n del g\n_init_ldap_crypt_handlers()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ["base64", "hashlib", "logging", "passlib.handlers.misc", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers", "re"]], "passlib.handlers.scram": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import consteq,saslprep,to_native_str,splitcomma\nfrom passlib.utils.binary import ab64_decode,ab64_encode\nfrom passlib.utils.compat import bascii_to_str,iteritems,u,native_string_types\nfrom passlib.crypto.digest import pbkdf2_hmac,norm_hash_name\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"scram\",\n]\n\n\n\n\nclass scram(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n name=\"scram\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\",\"algs\")\n ident=u(\"$scram$\")\n \n \n default_salt_size=12\n max_salt_size=1024\n \n \n default_rounds=100000\n min_rounds=1\n max_rounds=2 **32 -1\n rounds_cost=\"linear\"\n \n \n \n \n default_algs=[\"sha-1\",\"sha-256\",\"sha-512\"]\n \n \n _verify_algs=[\"sha-256\",\"sha-512\",\"sha-224\",\"sha-384\",\"sha-1\"]\n \n \n \n \n \n \n \n \n \n \n algs=None\n \n \n \n \n @classmethod\n def extract_digest_info(cls,hash,alg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  alg=norm_hash_name(alg,'iana')\n  self=cls.from_string(hash)\n  chkmap=self.checksum\n  if not chkmap:\n   raise ValueError(\"scram hash contains no digests\")\n  return self.salt,self.rounds,chkmap[alg]\n  \n @classmethod\n def extract_digest_algs(cls,hash,format=\"iana\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  algs=cls.from_string(hash).algs\n  if format ==\"iana\":\n   return algs\n  else :\n   return [norm_hash_name(alg,format)for alg in algs]\n   \n @classmethod\n def derive_digest(cls,password,salt,rounds,alg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(password,bytes):\n   password=password.decode(\"utf-8\")\n   \n   \n  return pbkdf2_hmac(alg,saslprep(password),salt,rounds)\n  \n  \n  \n  \n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_native_str(hash,\"ascii\",\"hash\")\n  if not hash.startswith(\"$scram$\"):\n   raise uh.exc.InvalidHashError(cls)\n  parts=hash[7:].split(\"$\")\n  if len(parts)!=3:\n   raise uh.exc.MalformedHashError(cls)\n  rounds_str,salt_str,chk_str=parts\n  \n  \n  rounds=int(rounds_str)\n  if rounds_str !=str(rounds):\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  try :\n   salt=ab64_decode(salt_str.encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  if not chk_str:\n  \n   raise uh.exc.MalformedHashError(cls)\n  elif \"=\"in chk_str:\n  \n   algs=None\n   chkmap={}\n   for pair in chk_str.split(\",\"):\n    alg,digest=pair.split(\"=\")\n    try :\n     chkmap[alg]=ab64_decode(digest.encode(\"ascii\"))\n    except TypeError:\n     raise uh.exc.MalformedHashError(cls)\n  else :\n  \n   algs=chk_str\n   chkmap=None\n   \n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chkmap,\n  algs=algs,\n  )\n  \n def to_string(self):\n  salt=bascii_to_str(ab64_encode(self.salt))\n  chkmap=self.checksum\n  chk_str=\",\".join(\n  \"%s=%s\"%(alg,bascii_to_str(ab64_encode(chkmap[alg])))\n  for alg in self.algs\n  )\n  return '$scram$%d$%s$%s'%(self.rounds,salt,chk_str)\n  \n  \n  \n  \n @classmethod\n def using(cls,default_algs=None ,algs=None ,**kwds):\n \n  if algs is not None :\n   assert default_algs is None\n   default_algs=algs\n   \n   \n  subcls=super(scram,cls).using(**kwds)\n  \n  \n  if default_algs is not None :\n   subcls.default_algs=cls._norm_algs(default_algs)\n  return subcls\n  \n  \n  \n  \n def __init__(self,algs=None ,**kwds):\n  super(scram,self).__init__(**kwds)\n  \n  \n  digest_map=self.checksum\n  if algs is not None :\n   if digest_map is not None :\n    raise RuntimeError(\"checksum & algs kwds are mutually exclusive\")\n   algs=self._norm_algs(algs)\n  elif digest_map is not None :\n  \n   algs=self._norm_algs(digest_map.keys())\n  elif self.use_defaults:\n   algs=list(self.default_algs)\n   assert self._norm_algs(algs)==algs,\"invalid default algs: %r\"%(algs,)\n  else :\n   raise TypeError(\"no algs list specified\")\n  self.algs=algs\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  if not isinstance(checksum,dict):\n   raise uh.exc.ExpectedTypeError(checksum,\"dict\",\"checksum\")\n  for alg,digest in iteritems(checksum):\n   if alg !=norm_hash_name(alg,'iana'):\n    raise ValueError(\"malformed algorithm name in scram hash: %r\"%\n    (alg,))\n   if len(alg)>9:\n    raise ValueError(\"SCRAM limits algorithm names to \"\n    \"9 characters: %r\"%(alg,))\n   if not isinstance(digest,bytes):\n    raise uh.exc.ExpectedTypeError(digest,\"raw bytes\",\"digests\")\n    \n  if 'sha-1'not in checksum:\n  \n   raise ValueError(\"sha-1 must be in algorithm list of scram hash\")\n  return checksum\n  \n @classmethod\n def _norm_algs(cls,algs):\n  ''\n  if isinstance(algs,native_string_types):\n   algs=splitcomma(algs)\n  algs=sorted(norm_hash_name(alg,'iana')for alg in algs)\n  if any(len(alg)>9 for alg in algs):\n   raise ValueError(\"SCRAM limits alg names to max of 9 characters\")\n  if 'sha-1'not in algs:\n  \n   raise ValueError(\"sha-1 must be in algorithm list of scram hash\")\n  return algs\n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n \n \n \n  if not set(self.algs).issuperset(self.default_algs):\n   return True\n   \n   \n  return super(scram,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n def _calc_checksum(self,secret,alg=None ):\n  rounds=self.rounds\n  salt=self.salt\n  hash=self.derive_digest\n  if alg:\n  \n   return hash(secret,salt,rounds,alg)\n  else :\n  \n   return dict(\n   (alg,hash(secret,salt,rounds,alg))\n   for alg in self.algs\n   )\n   \n @classmethod\n def verify(cls,secret,hash,full=False ):\n  uh.validate_secret(secret)\n  self=cls.from_string(hash)\n  chkmap=self.checksum\n  if not chkmap:\n   raise ValueError(\"expected %s hash, got %s config string instead\"%\n   (cls.name,cls.name))\n   \n   \n   \n   \n  if full:\n   correct=failed=False\n   for alg,digest in iteritems(chkmap):\n    other=self._calc_checksum(secret,alg)\n    \n    \n    \n    \n    if len(digest)!=len(other):\n     raise ValueError(\"mis-sized %s digest in scram hash: %r != %r\"\n     %(alg,len(digest),len(other)))\n    if consteq(other,digest):\n     correct=True\n    else :\n     failed=True\n   if correct and failed:\n    raise ValueError(\"scram hash verified inconsistently, \"\n    \"may be corrupted\")\n   else :\n    return correct\n  else :\n  \n  \n   for alg in self._verify_algs:\n    if alg in chkmap:\n     other=self._calc_checksum(secret,alg)\n     return consteq(other,chkmap[alg])\n     \n     \n   raise AssertionError(\"sha-1 digest not found!\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n", ["logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.sha1_crypt": [".py", "''\n\n\n\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import u,unicode,irange\nfrom passlib.crypto.digest import compile_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n]\n\n\n\n_BNULL=b'\\x00'\n\nclass sha1_crypt(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"sha1_crypt\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$sha1$\")\n checksum_size=28\n checksum_chars=uh.HASH64_CHARS\n \n \n default_salt_size=8\n max_salt_size=64\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=480000\n min_rounds=1\n max_rounds=4294967295\n rounds_cost=\"linear\"\n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self,config=False ):\n  chk=None if config else self.checksum\n  return uh.render_mc3(self.ident,self.rounds,self.salt,chk)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'$sha1$1$Wq3GL2Vp$C8U25GvfHS8qGHim'\n  'ExLaiSFlGkAe'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string(config=True )\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config)or len(hash)!=len(config)+29:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-28:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  if _BNULL in secret:\n   raise uh.exc.NullPasswordError(self)\n  rounds=self.rounds\n  \n  result=(u(\"%s$sha1$%s\")%(self.salt,rounds)).encode(\"ascii\")\n  \n  keyed_hmac=compile_hmac(\"sha1\",secret)\n  for _ in irange(rounds):\n   result=keyed_hmac(result)\n  return h64.encode_transposed_bytes(result,self._chk_offsets).decode(\"ascii\")\n  \n _chk_offsets=[\n 2,1,0,\n 5,4,3,\n 8,7,6,\n 11,10,9,\n 14,13,12,\n 17,16,15,\n 0,19,18,\n ]\n \n \n \n \n \n \n \n \n", ["logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.handlers.mysql": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_native_str\nfrom passlib.utils.compat import bascii_to_str,unicode,u,\\\nbyte_elem_value,str_to_uascii\nimport passlib.utils.handlers as uh\n\n__all__=[\n'mysql323',\n'mysq41',\n]\n\n\n\n\nclass mysql323(uh.StaticHandler):\n ''\n\n\n\n\n \n \n \n \n name=\"mysql323\"\n checksum_size=16\n checksum_chars=uh.HEX_CHARS\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n  MASK_32=0xffffffff\n  MASK_31=0x7fffffff\n  WHITE=b' \\t'\n  \n  nr1=0x50305735\n  nr2=0x12345671\n  add=7\n  for c in secret:\n   if c in WHITE:\n    continue\n   tmp=byte_elem_value(c)\n   nr1 ^=((((nr1&63)+add)*tmp)+(nr1 <<8))&MASK_32\n   nr2=(nr2+((nr2 <<8)^nr1))&MASK_32\n   add=(add+tmp)&MASK_32\n  return u(\"%08x%08x\")%(nr1&MASK_31,nr2&MASK_31)\n  \n  \n  \n  \n  \n  \n  \n  \nclass mysql41(uh.StaticHandler):\n ''\n\n\n\n\n \n \n \n \n name=\"mysql41\"\n _hash_prefix=u(\"*\")\n checksum_chars=uh.HEX_CHARS\n checksum_size=40\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.upper()\n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(sha1(sha1(secret).digest()).hexdigest()).upper()\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.handlers.fshp": [".py", "''\n\n\n\n\n\n\nfrom base64 import b64encode,b64decode\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode\nimport passlib.utils.handlers as uh\nfrom passlib.utils.compat import bascii_to_str,iteritems,u,\\\nunicode\nfrom passlib.crypto.digest import pbkdf1\n\n__all__=[\n'fshp',\n]\n\n\n\nclass fshp(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"fshp\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\",\"variant\")\n checksum_chars=uh.PADDED_BASE64_CHARS\n ident=u(\"{FSHP\")\n \n \n \n default_salt_size=16\n max_salt_size=None\n \n \n \n \n default_rounds=480000\n min_rounds=1\n max_rounds=4294967295\n rounds_cost=\"linear\"\n \n \n default_variant=1\n _variant_info={\n \n 0:(\"sha1\",20),\n 1:(\"sha256\",32),\n 2:(\"sha384\",48),\n 3:(\"sha512\",64),\n }\n _variant_aliases=dict(\n [(unicode(k),k)for k in _variant_info]+\n [(v[0],k)for k,v in iteritems(_variant_info)]\n )\n \n \n \n \n @classmethod\n def using(cls,variant=None ,**kwds):\n  subcls=super(fshp,cls).using(**kwds)\n  if variant is not None :\n   subcls.default_variant=cls._norm_variant(variant)\n  return subcls\n  \n  \n  \n  \n variant=None\n \n \n \n \n def __init__(self,variant=None ,**kwds):\n \n  self.use_defaults=kwds.get(\"use_defaults\")\n  if variant is not None :\n   variant=self._norm_variant(variant)\n  elif self.use_defaults:\n   variant=self.default_variant\n   assert self._norm_variant(variant)==variant,\"invalid default variant: %r\"%(variant,)\n  else :\n   raise TypeError(\"no variant specified\")\n  self.variant=variant\n  super(fshp,self).__init__(**kwds)\n  \n @classmethod\n def _norm_variant(cls,variant):\n  if isinstance(variant,bytes):\n   variant=variant.decode(\"ascii\")\n  if isinstance(variant,unicode):\n   try :\n    variant=cls._variant_aliases[variant]\n   except KeyError:\n    raise ValueError(\"invalid fshp variant\")\n  if not isinstance(variant,int):\n   raise TypeError(\"fshp variant must be int or known alias\")\n  if variant not in cls._variant_info:\n   raise ValueError(\"invalid fshp variant\")\n  return variant\n  \n @property\n def checksum_alg(self):\n  return self._variant_info[self.variant][0]\n  \n @property\n def checksum_size(self):\n  return self._variant_info[self.variant][1]\n  \n  \n  \n  \n  \n _hash_regex=re.compile(u(r\"\"\"\n            ^\n            \\{FSHP\n            (\\d+)\\| # variant\n            (\\d+)\\| # salt size\n            (\\d+)\\} # rounds\n            ([a-zA-Z0-9+/]+={0,3}) # digest\n            $\"\"\"),re.X)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  variant,salt_size,rounds,data=m.group(1,2,3,4)\n  variant=int(variant)\n  salt_size=int(salt_size)\n  rounds=int(rounds)\n  try :\n   data=b64decode(data.encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n  salt=data[:salt_size]\n  chk=data[salt_size:]\n  return cls(salt=salt,checksum=chk,rounds=rounds,variant=variant)\n  \n def to_string(self):\n  chk=self.checksum\n  salt=self.salt\n  data=bascii_to_str(b64encode(salt+chk))\n  return \"{FSHP%d|%d|%d}%s\"%(self.variant,len(salt),self.rounds,data)\n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n   \n  return pbkdf1(\n  digest=self.checksum_alg,\n  secret=self.salt,\n  salt=secret,\n  rounds=self.rounds,\n  keylen=self.checksum_size,\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n", ["base64", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re"]]}
__BRYTHON__.update_VFS(scripts)
