__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1629387660085, "passlib.hash.django": [".py", "''\n\n\n\n\nfrom base64 import b64encode\nfrom binascii import hexlify\nfrom hashlib import md5,sha1,sha256\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.handlers.bcrypt import _wrapped_bcrypt\nfrom passlib.hash import argon2,bcrypt,pbkdf2_sha1,pbkdf2_sha256\nfrom passlib.utils import to_unicode,rng,getrandstr\nfrom passlib.utils.binary import BASE64_CHARS\nfrom passlib.utils.compat import str_to_uascii,uascii_to_str,unicode,u\nfrom passlib.crypto.digest import pbkdf2_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"django_salted_sha1\",\n\"django_salted_md5\",\n\"django_bcrypt\",\n\"django_pbkdf2_sha1\",\n\"django_pbkdf2_sha256\",\n\"django_argon2\",\n\"django_des_crypt\",\n\"django_disabled\",\n]\n\n\n\n\n\n\ndes_crypt=None\n\ndef _import_des_crypt():\n global des_crypt\n if des_crypt is None :\n  from passlib.hash import des_crypt\n return des_crypt\n \n \nSALT_CHARS='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n\n\n\n\nclass DjangoSaltedHash(uh.HasSalt,uh.GenericHandler):\n ''\n \n \n setting_kwds=(\"salt\",\"salt_size\")\n \n \n \n \n \n default_salt_size=12\n max_salt_size=None\n salt_chars=SALT_CHARS\n \n checksum_chars=uh.LOWER_HEX_CHARS\n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc2(self.ident,self.salt,self.checksum)\n  \n  \nclass DjangoVariableHash(uh.HasRounds,DjangoSaltedHash):\n ''\n setting_kwds=DjangoSaltedHash.setting_kwds+(\"rounds\",)\n \n min_rounds=1\n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc3(self.ident,self.rounds,self.salt,self.checksum)\n  \nclass django_salted_sha1(DjangoSaltedHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_salted_sha1\"\n django_name=\"sha1\"\n ident=u(\"sha1$\")\n checksum_size=40\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(sha1(self.salt.encode(\"ascii\")+secret).hexdigest())\n  \nclass django_salted_md5(DjangoSaltedHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_salted_md5\"\n django_name=\"md5\"\n ident=u(\"md5$\")\n checksum_size=32\n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(md5(self.salt.encode(\"ascii\")+secret).hexdigest())\n  \n  \n  \n  \n  \ndjango_bcrypt=uh.PrefixWrapper(\"django_bcrypt\",bcrypt,\nprefix=u('bcrypt$'),ident=u(\"bcrypt$\"),\n\n\ndoc=\"\"\"This class implements Django 1.4's BCrypt wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!bcrypt` itself, but with\n    the Django-specific prefix ``\"bcrypt$\"`` prepended.\n\n    See :doc:`/lib/passlib.hash.bcrypt` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.4's :class:`!BCryptPasswordHasher` class.\n\n    .. versionadded:: 1.6\n    \"\"\")\ndjango_bcrypt.django_name=\"bcrypt\"\ndjango_bcrypt._using_clone_attrs +=(\"django_name\",)\n\n\n\n\n\nclass django_bcrypt_sha256(_wrapped_bcrypt):\n ''\n\n\n\n\n\n\n\n\n \n name=\"django_bcrypt_sha256\"\n django_name=\"bcrypt_sha256\"\n _digest=sha256\n \n \n \n \n \n \n django_prefix=u('bcrypt_sha256$')\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  if not hash:\n   return False\n  return hash.startswith(cls.django_prefix)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if not hash.startswith(cls.django_prefix):\n   raise uh.exc.InvalidHashError(cls)\n  bhash=hash[len(cls.django_prefix):]\n  if not bhash.startswith(\"$2\"):\n   raise uh.exc.MalformedHashError(cls)\n  return super(django_bcrypt_sha256,cls).from_string(bhash)\n  \n def to_string(self):\n  bhash=super(django_bcrypt_sha256,self).to_string()\n  return uascii_to_str(self.django_prefix)+bhash\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  secret=hexlify(self._digest(secret).digest())\n  return super(django_bcrypt_sha256,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \nclass django_pbkdf2_sha256(DjangoVariableHash):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_pbkdf2_sha256\"\n django_name=\"pbkdf2_sha256\"\n ident=u('pbkdf2_sha256$')\n min_salt_size=1\n max_rounds=0xffffffff\n checksum_chars=uh.PADDED_BASE64_CHARS\n checksum_size=44\n default_rounds=pbkdf2_sha256.default_rounds\n _digest=\"sha256\"\n \n def _calc_checksum(self,secret):\n \n  hash=pbkdf2_hmac(self._digest,secret,self.salt,self.rounds)\n  return b64encode(hash).rstrip().decode(\"ascii\")\n  \nclass django_pbkdf2_sha1(django_pbkdf2_sha256):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_pbkdf2_sha1\"\n django_name=\"pbkdf2_sha1\"\n ident=u('pbkdf2_sha1$')\n checksum_size=28\n default_rounds=pbkdf2_sha1.default_rounds\n _digest=\"sha1\"\n \n \n \n \n \n \n \n \ndjango_argon2=uh.PrefixWrapper(\nname=\"django_argon2\",\nwrapped=argon2.using(type=\"I\"),\nprefix=u('argon2'),\nident=u('argon2$argon2i$'),\n\n\ndoc=\"\"\"This class implements Django 1.10's Argon2 wrapper, and follows the :ref:`password-hash-api`.\n\n    This is identical to :class:`!argon2` itself, but with\n    the Django-specific prefix ``\"argon2$\"`` prepended.\n\n    See :doc:`argon2 </lib/passlib.hash.argon2>` for more details,\n    the usage and behavior is identical.\n\n    This should be compatible with the hashes generated by\n    Django 1.10's :class:`!Argon2PasswordHasher` class.\n\n    .. versionadded:: 1.7\n    \"\"\")\ndjango_argon2.django_name=\"argon2\"\ndjango_argon2._using_clone_attrs +=(\"django_name\",)\n\n\n\n\nclass django_des_crypt(uh.TruncateMixin,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_des_crypt\"\n django_name=\"crypt\"\n setting_kwds=(\"salt\",\"salt_size\",\"truncate_error\")\n ident=u(\"crypt$\")\n checksum_chars=salt_chars=uh.HASH64_CHARS\n checksum_size=11\n min_salt_size=default_salt_size=2\n truncate_size=8\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n use_duplicate_salt=True\n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  if chk:\n  \n   if not salt:\n   \n   \n    salt=chk[:2]\n   elif salt[:2]!=chk[:2]:\n   \n   \n   \n    raise uh.exc.MalformedHashError(cls,\n    \"first two digits of salt and checksum must match\")\n    \n   chk=chk[2:]\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=self.salt\n  chk=salt[:2]+self.checksum\n  if self.use_duplicate_salt:\n  \n   return uh.render_mc2(self.ident,salt,chk)\n  else :\n  \n   return uh.render_mc2(self.ident,\"\",chk)\n   \n def _calc_checksum(self,secret):\n \n \n  global des_crypt\n  if des_crypt is None :\n   _import_des_crypt()\n   \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n  return des_crypt(salt=self.salt[:2])._calc_checksum(secret)\n  \nclass django_disabled(uh.ifc.DisabledHash,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"django_disabled\"\n _hash_prefix=u(\"!\")\n suffix_length=40\n \n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return hash.startswith(cls._hash_prefix)\n  \n def _calc_checksum(self,secret):\n \n  return getrandstr(rng,BASE64_CHARS[:-2],self.suffix_length)\n  \n @classmethod\n def verify(cls,secret,hash):\n  uh.validate_secret(secret)\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return False\n  \n  \n  \n  \n", ["base64", "binascii", "hashlib", "logging", "passlib.crypto.digest", "passlib.handlers.bcrypt", "passlib.hash", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.misc": [".py", "''\n\n\n\n\n\nimport sys\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_native_str,str_consteq\nfrom passlib.utils.compat import unicode,u,unicode_or_bytes_types\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"unix_disabled\",\n\"unix_fallback\",\n\"plaintext\",\n]\n\n\n\n\nclass unix_fallback(uh.ifc.DisabledHash,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"unix_fallback\"\n context_kwds=(\"enable_wildcard\",)\n \n @classmethod\n def identify(cls,hash):\n  if isinstance(hash,unicode_or_bytes_types):\n   return True\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n   \n def __init__(self,enable_wildcard=False ,**kwds):\n  warn(\"'unix_fallback' is deprecated, \"\n  \"and will be removed in Passlib 1.8; \"\n  \"please use 'unix_disabled' instead.\",\n  DeprecationWarning)\n  super(unix_fallback,self).__init__(**kwds)\n  self.enable_wildcard=enable_wildcard\n  \n def _calc_checksum(self,secret):\n  if self.checksum:\n  \n  \n   return self.checksum\n  else :\n   return u(\"!\")\n   \n @classmethod\n def verify(cls,secret,hash,enable_wildcard=False ):\n  uh.validate_secret(secret)\n  if not isinstance(hash,unicode_or_bytes_types):\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n  elif hash:\n   return False\n  else :\n   return enable_wildcard\n   \n_MARKER_CHARS=u(\"*!\")\n_MARKER_BYTES=b\"*!\"\n\nclass unix_disabled(uh.ifc.DisabledHash,uh.MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"unix_disabled\"\n setting_kwds=(\"marker\",)\n context_kwds=()\n \n _disable_prefixes=tuple(str(_MARKER_CHARS))\n \n \n if 'bsd'in sys.platform:\n  default_marker=u(\"*\")\n else :\n \n \n \n  default_marker=u(\"!\")\n  \n @classmethod\n def using(cls,marker=None ,**kwds):\n  subcls=super(unix_disabled,cls).using(**kwds)\n  if marker is not None :\n   if not cls.identify(marker):\n    raise ValueError(\"invalid marker: %r\"%marker)\n   subcls.default_marker=marker\n  return subcls\n  \n @classmethod\n def identify(cls,hash):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  if isinstance(hash,unicode):\n   start=_MARKER_CHARS\n  elif isinstance(hash,bytes):\n   start=_MARKER_BYTES\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n  return not hash or hash[0]in start\n  \n @classmethod\n def verify(cls,secret,hash):\n  uh.validate_secret(secret)\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return False\n  \n @classmethod\n def hash(cls,secret,**kwds):\n  if kwds:\n   uh.warn_hash_settings_deprecation(cls,kwds)\n   return cls.using(**kwds).hash(secret)\n  uh.validate_secret(secret)\n  marker=cls.default_marker\n  assert marker and cls.identify(marker)\n  return to_native_str(marker,param=\"marker\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,marker=None ):\n  if not cls.identify(config):\n   raise uh.exc.InvalidHashError(cls)\n  elif config:\n  \n   uh.validate_secret(secret)\n   return to_native_str(config,param=\"config\")\n  else :\n   if marker is not None :\n    cls=cls.using(marker=marker)\n   return cls.hash(secret)\n   \n @classmethod\n def disable(cls,hash=None ):\n  out=cls.hash(\"\")\n  if hash is not None :\n   hash=to_native_str(hash,param=\"hash\")\n   if cls.identify(hash):\n   \n    hash=cls.enable(hash)\n   if hash:\n    out +=hash\n  return out\n  \n @classmethod\n def enable(cls,hash):\n  hash=to_native_str(hash,param=\"hash\")\n  for prefix in cls._disable_prefixes:\n   if hash.startswith(prefix):\n    orig=hash[len(prefix):]\n    if orig:\n     return orig\n    else :\n     raise ValueError(\"cannot restore original hash\")\n  raise uh.exc.InvalidHashError(cls)\n  \nclass plaintext(uh.MinimalHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n name=\"plaintext\"\n setting_kwds=()\n context_kwds=(\"encoding\",)\n default_encoding=\"utf-8\"\n \n @classmethod\n def identify(cls,hash):\n  if isinstance(hash,unicode_or_bytes_types):\n   return True\n  else :\n   raise uh.exc.ExpectedStringError(hash,\"hash\")\n   \n @classmethod\n def hash(cls,secret,encoding=None ):\n  uh.validate_secret(secret)\n  if not encoding:\n   encoding=cls.default_encoding\n  return to_native_str(secret,encoding,\"secret\")\n  \n @classmethod\n def verify(cls,secret,hash,encoding=None ):\n  if not encoding:\n   encoding=cls.default_encoding\n  hash=to_native_str(hash,encoding,\"hash\")\n  if not cls.identify(hash):\n   raise uh.exc.InvalidHashError(cls)\n  return str_consteq(cls.hash(secret,encoding),hash)\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n  return cls.hash(\"\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,encoding=None ):\n \n  if not cls.identify(config):\n   raise uh.exc.InvalidHashError(cls)\n  return cls.hash(secret,encoding=encoding)\n  \n  \n  \n  \n", ["logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "sys", "warnings"]], "passlib.hash.mssql": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import consteq\nfrom passlib.utils.compat import bascii_to_str,unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"mssql2000\",\n\"mssql2005\",\n]\n\n\n\n\ndef _raw_mssql(secret,salt):\n assert isinstance(secret,unicode)\n assert isinstance(salt,bytes)\n return sha1(secret.encode(\"utf-16-le\")+salt).digest()\n \nBIDENT=b\"0x0100\"\n\nUIDENT=u(\"0x0100\")\n\ndef _ident_mssql(hash,csize,bsize):\n ''\n if isinstance(hash,unicode):\n  if len(hash)==csize and hash.startswith(UIDENT):\n   return True\n elif isinstance(hash,bytes):\n  if len(hash)==csize and hash.startswith(BIDENT):\n   return True\n   \n   \n else :\n  raise uh.exc.ExpectedStringError(hash,\"hash\")\n return False\n \ndef _parse_mssql(hash,csize,bsize,handler):\n ''\n if isinstance(hash,unicode):\n  if len(hash)==csize and hash.startswith(UIDENT):\n   try :\n    return unhexlify(hash[6:].encode(\"utf-8\"))\n   except TypeError:\n    pass\n elif isinstance(hash,bytes):\n \n  assert isinstance(hash,bytes)\n  if len(hash)==csize and hash.startswith(BIDENT):\n   try :\n    return unhexlify(hash[6:])\n   except TypeError:\n    pass\n    \n    \n else :\n  raise uh.exc.ExpectedStringError(hash,\"hash\")\n raise uh.exc.InvalidHashError(handler)\n \nclass mssql2000(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"mssql2000\"\n setting_kwds=(\"salt\",)\n checksum_size=40\n min_salt_size=max_salt_size=4\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def identify(cls,hash):\n  return _ident_mssql(hash,94,46)\n  \n @classmethod\n def from_string(cls,hash):\n  data=_parse_mssql(hash,94,46,cls)\n  return cls(salt=data[:4],checksum=data[4:])\n  \n def to_string(self):\n  raw=self.salt+self.checksum\n  \n  return \"0x0100\"+bascii_to_str(hexlify(raw).upper())\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  salt=self.salt\n  return _raw_mssql(secret,salt)+_raw_mssql(secret.upper(),salt)\n  \n @classmethod\n def verify(cls,secret,hash):\n \n \n  uh.validate_secret(secret)\n  self=cls.from_string(hash)\n  chk=self.checksum\n  if chk is None :\n   raise uh.exc.MissingDigestError(cls)\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  result=_raw_mssql(secret.upper(),self.salt)\n  return consteq(result,chk[20:])\n  \n  \n  \n  \nclass mssql2005(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"mssql2005\"\n setting_kwds=(\"salt\",)\n \n checksum_size=20\n min_salt_size=max_salt_size=4\n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def identify(cls,hash):\n  return _ident_mssql(hash,54,26)\n  \n @classmethod\n def from_string(cls,hash):\n  data=_parse_mssql(hash,54,26,cls)\n  return cls(salt=data[:4],checksum=data[4:])\n  \n def to_string(self):\n  raw=self.salt+self.checksum\n  \n  return \"0x0100\"+bascii_to_str(hexlify(raw)).upper()\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  return _raw_mssql(secret,self.salt)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.hash.md5_crypt": [".py", "''\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt,repeat_string\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"md5_crypt\",\n\"apr_md5_crypt\",\n]\n\n\n\n\n_BNULL=b\"\\x00\"\n_MD5_MAGIC=b\"$1$\"\n_APR_MAGIC=b\"$apr1$\"\n\n\n\n\n\n\n\n\n\n_c_digest_offsets=(\n(0,3),(5,1),(5,3),(1,2),(5,1),(5,3),(1,3),\n(4,1),(5,3),(1,3),(5,0),(5,3),(1,3),(5,1),\n(4,3),(1,3),(5,1),(5,2),(1,3),(5,1),(5,3),\n)\n\n\n_transpose_map=(12,6,0,13,7,1,14,8,2,15,9,3,5,10,4,11)\n\ndef _raw_md5_crypt(pwd,salt,use_apr=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n if isinstance(pwd,unicode):\n  pwd=pwd.encode(\"utf-8\")\n assert isinstance(pwd,bytes),\"pwd not unicode or bytes\"\n if _BNULL in pwd:\n  raise uh.exc.NullPasswordError(md5_crypt)\n pwd_len=len(pwd)\n \n \n assert isinstance(salt,unicode),\"salt not unicode\"\n salt=salt.encode(\"ascii\")\n assert len(salt)<9,\"salt too large\"\n \n \n \n \n \n if use_apr:\n  magic=_APR_MAGIC\n else :\n  magic=_MD5_MAGIC\n  \n  \n  \n  \n db=md5(pwd+salt+pwd).digest()\n \n \n \n \n \n a_ctx=md5(pwd+magic+salt)\n a_ctx_update=a_ctx.update\n \n \n a_ctx_update(repeat_string(db,pwd_len))\n \n \n \n \n \n \n i=pwd_len\n evenchar=pwd[:1]\n while i:\n  a_ctx_update(_BNULL if i&1 else evenchar)\n  i >>=1\n  \n  \n da=a_ctx.digest()\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n pwd_pwd=pwd+pwd\n pwd_salt=pwd+salt\n perms=[pwd,pwd_pwd,pwd_salt,pwd_salt+pwd,salt+pwd,salt+pwd_pwd]\n \n \n \n data=[(perms[even],perms[odd])for even,odd in _c_digest_offsets]\n \n \n dc=da\n blocks=23\n while blocks:\n  for even,odd in data:\n   dc=md5(odd+md5(dc+even).digest()).digest()\n  blocks -=1\n  \n  \n for even,odd in data[:17]:\n  dc=md5(odd+md5(dc+even).digest()).digest()\n  \n  \n  \n  \n return h64.encode_transposed_bytes(dc,_transpose_map).decode(\"ascii\")\n \n \n \n \nclass _MD5_Common(uh.HasSalt,uh.GenericHandler):\n ''\n \n \n \n \n setting_kwds=(\"salt\",\"salt_size\")\n \n checksum_size=22\n checksum_chars=uh.HASH64_CHARS\n \n max_salt_size=8\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  salt,chk=uh.parse_mc2(hash,cls.ident,handler=cls)\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  return uh.render_mc2(self.ident,self.salt,self.checksum)\n  \n  \n  \n  \n  \n  \n  \nclass md5_crypt(uh.HasManyBackends,_MD5_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"md5_crypt\"\n ident=u(\"$1$\")\n \n \n \n \n \n \n \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'$1$test$pi/xDtU5WFVRqYS6BMU8X/'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.ident+self.salt\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config)or len(hash)!=len(config)+23:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-22:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_md5_crypt(secret,self.salt)\n  \n  \n  \n  \n  \nclass apr_md5_crypt(_MD5_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"apr_md5_crypt\"\n ident=u(\"$apr1$\")\n \n \n \n \n def _calc_checksum(self,secret):\n  return _raw_md5_crypt(secret,self.salt,use_apr=True )\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.sun_md5_crypt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import md5\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_unicode\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import byte_elem_value,irange,u,\\\nuascii_to_str,unicode,str_to_bascii\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"sun_md5_crypt\",\n]\n\n\n\n\n\n\n\n\nMAGIC_HAMLET=(\nb\"To be, or not to be,--that is the question:--\\n\"\nb\"Whether 'tis nobler in the mind to suffer\\n\"\nb\"The slings and arrows of outrageous fortune\\n\"\nb\"Or to take arms against a sea of troubles,\\n\"\nb\"And by opposing end them?--To die,--to sleep,--\\n\"\nb\"No more; and by a sleep to say we end\\n\"\nb\"The heartache, and the thousand natural shocks\\n\"\nb\"That flesh is heir to,--'tis a consummation\\n\"\nb\"Devoutly to be wish'd. To die,--to sleep;--\\n\"\nb\"To sleep! perchance to dream:--ay, there's the rub;\\n\"\nb\"For in that sleep of death what dreams may come,\\n\"\nb\"When we have shuffled off this mortal coil,\\n\"\nb\"Must give us pause: there's the respect\\n\"\nb\"That makes calamity of so long life;\\n\"\nb\"For who would bear the whips and scorns of time,\\n\"\nb\"The oppressor's wrong, the proud man's contumely,\\n\"\nb\"The pangs of despis'd love, the law's delay,\\n\"\nb\"The insolence of office, and the spurns\\n\"\nb\"That patient merit of the unworthy takes,\\n\"\nb\"When he himself might his quietus make\\n\"\nb\"With a bare bodkin? who would these fardels bear,\\n\"\nb\"To grunt and sweat under a weary life,\\n\"\nb\"But that the dread of something after death,--\\n\"\nb\"The undiscover'd country, from whose bourn\\n\"\nb\"No traveller returns,--puzzles the will,\\n\"\nb\"And makes us rather bear those ills we have\\n\"\nb\"Than fly to others that we know not of?\\n\"\nb\"Thus conscience does make cowards of us all;\\n\"\nb\"And thus the native hue of resolution\\n\"\nb\"Is sicklied o'er with the pale cast of thought;\\n\"\nb\"And enterprises of great pith and moment,\\n\"\nb\"With this regard, their currents turn awry,\\n\"\nb\"And lose the name of action.--Soft you now!\\n\"\nb\"The fair Ophelia!--Nymph, in thy orisons\\n\"\nb\"Be all my sins remember'd.\\n\\x00\"\n)\n\n\nxr=irange(7)\n_XY_ROUNDS=[\ntuple((i,i,i+3)for i in xr),\ntuple((i,i+1,i+4)for i in xr),\ntuple((i,i+8,(i+11)&15)for i in xr),\ntuple((i,(i+9)&15,(i+12)&15)for i in xr),\n]\ndel xr\n\ndef raw_sun_md5_crypt(secret,rounds,salt):\n ''\n global MAGIC_HAMLET\n assert isinstance(secret,bytes)\n assert isinstance(salt,bytes)\n \n \n if rounds <=0:\n  rounds=0\n real_rounds=4096+rounds\n \n \n \n \n result=md5(secret+salt).digest()\n assert len(result)==16\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n X_ROUNDS_0,X_ROUNDS_1,Y_ROUNDS_0,Y_ROUNDS_1=_XY_ROUNDS\n \n \n \n round=0\n while round <real_rounds:\n \n  rval=[byte_elem_value(c)for c in result].__getitem__\n  \n  \n  x=0\n  xrounds=X_ROUNDS_1 if (rval((round >>3)&15)>>(round&7))&1 else X_ROUNDS_0\n  for i,ia,ib in xrounds:\n   a=rval(ia)\n   b=rval(ib)\n   v=rval((a >>(b %5))&15)>>((b >>(a&7))&1)\n   x |=((rval((v >>3)&15)>>(v&7))&1)<<i\n   \n   \n  y=0\n  yrounds=Y_ROUNDS_1 if (rval(((round+64)>>3)&15)>>(round&7))&1 else Y_ROUNDS_0\n  for i,ia,ib in yrounds:\n   a=rval(ia)\n   b=rval(ib)\n   v=rval((a >>(b %5))&15)>>((b >>(a&7))&1)\n   y |=((rval((v >>3)&15)>>(v&7))&1)<<i\n   \n   \n  coin=((rval(x >>3)>>(x&7))^(rval(y >>3)>>(y&7)))&1\n  \n  \n  h=md5(result)\n  if coin:\n   h.update(MAGIC_HAMLET)\n  h.update(unicode(round).encode(\"ascii\"))\n  result=h.digest()\n  \n  round +=1\n  \n  \n return h64.encode_transposed_bytes(result,_chk_offsets)\n \n \n_chk_offsets=(\n12,6,0,\n13,7,1,\n14,8,2,\n15,9,3,\n5,10,4,\n11,\n)\n\n\n\n\nclass sun_md5_crypt(uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"sun_md5_crypt\"\n setting_kwds=(\"salt\",\"rounds\",\"bare_salt\",\"salt_size\")\n checksum_chars=uh.HASH64_CHARS\n checksum_size=22\n \n \n \n \n \n \n default_salt_size=8\n max_salt_size=None\n salt_chars=uh.HASH64_CHARS\n \n default_rounds=34000\n min_rounds=0\n max_rounds=4294963199\n \n rounds_cost=\"linear\"\n \n ident_values=(u(\"$md5$\"),u(\"$md5,\"))\n \n \n \n \n bare_salt=False\n \n \n \n \n def __init__(self,bare_salt=False ,**kwds):\n  self.bare_salt=bare_salt\n  super(sun_md5_crypt,self).__init__(**kwds)\n  \n  \n  \n  \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return hash.startswith(cls.ident_values)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  \n  \n  \n  \n  \n  \n  if hash.startswith(u(\"$md5$\")):\n   rounds=0\n   salt_idx=5\n  elif hash.startswith(u(\"$md5,rounds=\")):\n   idx=hash.find(u(\"$\"),12)\n   if idx ==-1:\n    raise uh.exc.MalformedHashError(cls,\"unexpected end of rounds\")\n   rstr=hash[12:idx]\n   try :\n    rounds=int(rstr)\n   except ValueError:\n    raise uh.exc.MalformedHashError(cls,\"bad rounds\")\n   if rstr !=unicode(rounds):\n    raise uh.exc.ZeroPaddedRoundsError(cls)\n   if rounds ==0:\n   \n   \n   \n    raise uh.exc.MalformedHashError(cls,\"explicit zero rounds\")\n   salt_idx=idx+1\n  else :\n   raise uh.exc.InvalidHashError(cls)\n   \n   \n   \n   \n   \n   \n  chk_idx=hash.rfind(u(\"$\"),salt_idx)\n  if chk_idx ==-1:\n  \n   salt=hash[salt_idx:]\n   chk=None\n   bare_salt=True\n  elif chk_idx ==len(hash)-1:\n   if chk_idx >salt_idx and hash[-2]==u(\"$\"):\n    raise uh.exc.MalformedHashError(cls,\"too many '$' separators\")\n    \n   salt=hash[salt_idx:-1]\n   chk=None\n   bare_salt=False\n  elif chk_idx >0 and hash[chk_idx -1]==u(\"$\"):\n  \n   salt=hash[salt_idx:chk_idx -1]\n   chk=hash[chk_idx+1:]\n   bare_salt=False\n  else :\n  \n   salt=hash[salt_idx:chk_idx]\n   chk=hash[chk_idx+1:]\n   bare_salt=True\n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk,\n  bare_salt=bare_salt,\n  )\n  \n def to_string(self,_withchk=True ):\n  ss=u('')if self.bare_salt else u('$')\n  rounds=self.rounds\n  if rounds >0:\n   hash=u(\"$md5,rounds=%d$%s%s\")%(rounds,self.salt,ss)\n  else :\n   hash=u(\"$md5$%s%s\")%(self.salt,ss)\n  if _withchk:\n   chk=self.checksum\n   hash=u(\"%s$%s\")%(hash,chk)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  config=str_to_bascii(self.to_string(_withchk=False ))\n  return raw_sun_md5_crypt(secret,self.rounds,config).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.hash.phpass": [".py", "''\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import u,uascii_to_str,unicode\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"phpass\",\n]\n\n\n\n\nclass phpass(uh.HasManyIdents,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"phpass\"\n setting_kwds=(\"salt\",\"rounds\",\"ident\")\n checksum_chars=uh.HASH64_CHARS\n \n \n min_salt_size=max_salt_size=8\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=19\n min_rounds=7\n max_rounds=30\n rounds_cost=\"log2\"\n \n \n default_ident=u(\"$P$\")\n ident_values=(u(\"$P$\"),u(\"$H$\"))\n ident_aliases={u(\"P\"):u(\"$P$\"),u(\"H\"):u(\"$H$\")}\n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  ident,data=cls._parse_ident(hash)\n  rounds,salt,chk=data[0],data[1:9],data[9:]\n  return cls(\n  ident=ident,\n  rounds=h64.decode_int6(rounds.encode(\"ascii\")),\n  salt=salt,\n  checksum=chk or None ,\n  )\n  \n def to_string(self):\n  hash=u(\"%s%s%s%s\")%(self.ident,\n  h64.encode_int6(self.rounds).decode(\"ascii\"),\n  self.salt,\n  self.checksum or u(''))\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  real_rounds=1 <<self.rounds\n  result=md5(self.salt.encode(\"ascii\")+secret).digest()\n  r=0\n  while r <real_rounds:\n   result=md5(result+secret).digest()\n   r +=1\n  return h64.encode_bytes(result).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.roundup": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nimport passlib.utils.handlers as uh\nfrom passlib.utils.compat import u\n\n__all__=[\n\"roundup_plaintext\",\n\"ldap_hex_md5\",\n\"ldap_hex_sha1\",\n]\n\n\n\nroundup_plaintext=uh.PrefixWrapper(\"roundup_plaintext\",\"plaintext\",\nprefix=u(\"{plaintext}\"),lazy=True )\n\n\nldap_hex_md5=uh.PrefixWrapper(\"ldap_hex_md5\",\"hex_md5\",u(\"{MD5}\"),lazy=True )\nldap_hex_sha1=uh.PrefixWrapper(\"ldap_hex_sha1\",\"hex_sha1\",u(\"{SHA}\"),lazy=True )\n\n\n\n\n", ["logging", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.sha2_crypt": [".py", "''\n\n\n\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt,\\\nrepeat_string,to_unicode\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import byte_elem_value,u,\\\nuascii_to_str,unicode\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"sha512_crypt\",\n\"sha256_crypt\",\n]\n\n\n\n\n\n_BNULL=b'\\x00'\n\n\n\n\n\n\n\n\n\n_c_digest_offsets=(\n(0,3),(5,1),(5,3),(1,2),(5,1),(5,3),(1,3),\n(4,1),(5,3),(1,3),(5,0),(5,3),(1,3),(5,1),\n(4,3),(1,3),(5,1),(5,2),(1,3),(5,1),(5,3),\n)\n\n\n_256_transpose_map=(\n20,10,0,11,1,21,2,22,12,23,13,3,14,4,24,5,\n25,15,26,16,6,17,7,27,8,28,18,29,19,9,30,31,\n)\n\n\n_512_transpose_map=(\n42,21,0,1,43,22,23,2,44,45,24,3,4,46,25,26,\n5,47,48,27,6,7,49,28,29,8,50,51,30,9,10,52,\n31,32,11,53,54,33,12,13,55,34,35,14,56,57,36,15,\n16,58,37,38,17,59,60,39,18,19,61,40,41,20,62,63,\n)\n\ndef _raw_sha2_crypt(pwd,salt,rounds,use_512=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n if isinstance(pwd,unicode):\n \n  pwd=pwd.encode(\"utf-8\")\n assert isinstance(pwd,bytes)\n if _BNULL in pwd:\n  raise uh.exc.NullPasswordError(sha512_crypt if use_512 else sha256_crypt)\n pwd_len=len(pwd)\n \n \n assert 1000 <=rounds <=999999999,\"invalid rounds\"\n \n \n \n \n \n assert isinstance(salt,unicode),\"salt not unicode\"\n salt=salt.encode(\"ascii\")\n salt_len=len(salt)\n assert salt_len <17,\"salt too large\"\n \n \n \n \n \n if use_512:\n  hash_const=hashlib.sha512\n  transpose_map=_512_transpose_map\n else :\n  hash_const=hashlib.sha256\n  transpose_map=_256_transpose_map\n  \n  \n  \n  \n db=hash_const(pwd+salt+pwd).digest()\n \n \n \n \n \n a_ctx=hash_const(pwd+salt)\n a_ctx_update=a_ctx.update\n \n \n a_ctx_update(repeat_string(db,pwd_len))\n \n \n i=pwd_len\n while i:\n  a_ctx_update(db if i&1 else pwd)\n  i >>=1\n  \n  \n da=a_ctx.digest()\n \n \n \n \n \n if pwd_len <96:\n \n \n  dp=repeat_string(hash_const(pwd *pwd_len).digest(),pwd_len)\n else :\n \n  tmp_ctx=hash_const(pwd)\n  tmp_ctx_update=tmp_ctx.update\n  i=pwd_len -1\n  while i:\n   tmp_ctx_update(pwd)\n   i -=1\n  dp=repeat_string(tmp_ctx.digest(),pwd_len)\n assert len(dp)==pwd_len\n \n \n \n \n ds=hash_const(salt *(16+byte_elem_value(da[0]))).digest()[:salt_len]\n assert len(ds)==salt_len,\"salt_len somehow > hash_len!\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n dp_dp=dp+dp\n dp_ds=dp+ds\n perms=[dp,dp_dp,dp_ds,dp_ds+dp,ds+dp,ds+dp_dp]\n \n \n \n data=[(perms[even],perms[odd])for even,odd in _c_digest_offsets]\n \n \n dc=da\n blocks,tail=divmod(rounds,42)\n while blocks:\n  for even,odd in data:\n   dc=hash_const(odd+hash_const(dc+even).digest()).digest()\n  blocks -=1\n  \n  \n if tail:\n \n  pairs=tail >>1\n  for even,odd in data[:pairs]:\n   dc=hash_const(odd+hash_const(dc+even).digest()).digest()\n   \n   \n   \n  if tail&1:\n   dc=hash_const(dc+data[pairs][0]).digest()\n   \n   \n   \n   \n return h64.encode_transposed_bytes(dc,transpose_map).decode(\"ascii\")\n \n \n \n \n_UROUNDS=u(\"rounds=\")\n_UDOLLAR=u(\"$\")\n_UZERO=u(\"0\")\n\nclass _SHA2_Common(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,\nuh.GenericHandler):\n ''\n \n \n \n \n setting_kwds=(\"salt\",\"rounds\",\"implicit_rounds\",\"salt_size\")\n \n checksum_chars=uh.HASH64_CHARS\n \n \n max_salt_size=16\n salt_chars=uh.HASH64_CHARS\n \n min_rounds=1000\n max_rounds=999999999\n rounds_cost=\"linear\"\n \n _cdb_use_512=False\n _rounds_prefix=None\n \n \n \n \n implicit_rounds=False\n \n def __init__(self,implicit_rounds=None ,**kwds):\n  super(_SHA2_Common,self).__init__(**kwds)\n  \n  if implicit_rounds is None :\n   implicit_rounds=(self.use_defaults and self.rounds ==5000)\n  self.implicit_rounds=implicit_rounds\n  \n def _parse_salt(self,salt):\n \n  return self._norm_salt(salt,relaxed=self.checksum is None )\n  \n def _parse_rounds(self,rounds):\n \n  return self._norm_rounds(rounds,relaxed=self.checksum is None )\n  \n @classmethod\n def from_string(cls,hash):\n \n \n \n \n \n \n \n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  ident=cls.ident\n  if not hash.startswith(ident):\n   raise uh.exc.InvalidHashError(cls)\n  assert len(ident)==3\n  parts=hash[3:].split(_UDOLLAR)\n  \n  \n  if parts[0].startswith(_UROUNDS):\n   assert len(_UROUNDS)==7\n   rounds=parts.pop(0)[7:]\n   if rounds.startswith(_UZERO)and rounds !=_UZERO:\n    raise uh.exc.ZeroPaddedRoundsError(cls)\n   rounds=int(rounds)\n   implicit_rounds=False\n  else :\n   rounds=5000\n   implicit_rounds=True\n   \n   \n  if len(parts)==2:\n   salt,chk=parts\n  elif len(parts)==1:\n   salt=parts[0]\n   chk=None\n  else :\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk or None ,\n  implicit_rounds=implicit_rounds,\n  )\n  \n def to_string(self):\n  if self.rounds ==5000 and self.implicit_rounds:\n   hash=u(\"%s%s$%s\")%(self.ident,self.salt,\n   self.checksum or u(''))\n  else :\n   hash=u(\"%srounds=%d$%s$%s\")%(self.ident,self.rounds,\n   self.salt,self.checksum or u(''))\n  return uascii_to_str(hash)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n \n \n _test_hash=None\n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(*cls._test_hash):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string()\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n   \n   \n  cs=self.checksum_size\n  if not hash.startswith(self.ident)or hash[-cs -1]!=_UDOLLAR:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-cs:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_sha2_crypt(secret,self.salt,self.rounds,\n  self._cdb_use_512)\n  \n  \n  \n  \n  \nclass sha256_crypt(_SHA2_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"sha256_crypt\"\n ident=u(\"$5$\")\n checksum_size=43\n \n default_rounds=535000\n \n \n \n \n _test_hash=(\"test\",\"$5$rounds=1000$test$QmQADEXMG8POI5W\"\n \"Dsaeho0P36yK3Tcrgboabng6bkb/\")\n \n \n \n \n \n \n \n \nclass sha512_crypt(_SHA2_Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"sha512_crypt\"\n ident=u(\"$6$\")\n checksum_size=86\n _cdb_use_512=True\n \n default_rounds=656000\n \n \n \n \n _test_hash=(\"test\",\"$6$rounds=1000$test$2M/Lx6Mtobqj\"\n \"Ljobw0Wmo4Q5OFx5nVLJvmgseatA6oMn\"\n \"yWeBdRDx4DU.1H3eGmse6pgsOgDisWBG\"\n \"I5c7TZauS0\")\n \n \n \n \n \n \n \n \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.argon2": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nimport logging\nlog=logging.getLogger(__name__)\nimport re\nimport types\nfrom warnings import warn\n\n_argon2_cffi=None\n_argon2pure=None\n\nfrom passlib import exc\nfrom passlib.crypto.digest import MAX_UINT32\nfrom passlib.utils import classproperty,to_bytes,render_bytes\nfrom passlib.utils.binary import b64s_encode,b64s_decode\nfrom passlib.utils.compat import u,unicode,bascii_to_str,uascii_to_str,PY2\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"argon2\",\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\nTYPE_I=u(\"i\")\nTYPE_D=u(\"d\")\nTYPE_ID=u(\"id\")\n\n\nALL_TYPES=(TYPE_ID,TYPE_I,TYPE_D)\nALL_TYPES_SET=set(ALL_TYPES)\n\n\n\n\n\n\n\n\n_argon2_cffi_error=None\ntry :\n import argon2 as _argon2_cffi\nexcept ImportError:\n _argon2_cffi=None\nelse :\n if not hasattr(_argon2_cffi,\"Type\"):\n \n  _argon2_cffi_error=(\n  \"'argon2' module points to unsupported 'argon2' pypi package; \"\n  \"please install 'argon2-cffi' instead.\"\n  )\n  _argon2_cffi=None\n elif not hasattr(_argon2_cffi,\"low_level\"):\n \n  _argon2_cffi_error=\"'argon2-cffi' is too old, please update to argon2_cffi >= 18.2.0\"\n  _argon2_cffi=None\n  \n  \n  \nif hasattr(_argon2_cffi,\"PasswordHasher\"):\n\n _default_settings=_argon2_cffi.PasswordHasher()\n _default_version=_argon2_cffi.low_level.ARGON2_VERSION\nelse :\n\n class _DummyCffiHasher:\n  ''\n\n\n\n\n\n  \n  time_cost=2\n  memory_cost=512\n  parallelism=2\n  salt_len=16\n  hash_len=16\n  \n  \n  \n _default_settings=_DummyCffiHasher()\n _default_version=0x13\n \n \n \n \nclass _Argon2Common(uh.SubclassBackendMixin,uh.ParallelismMixin,\nuh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,\nuh.GenericHandler):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n name=\"argon2\"\n setting_kwds=(\"salt\",\n \"salt_size\",\n \"salt_len\",\n \"rounds\",\n \"time_cost\",\n \"memory_cost\",\n \"parallelism\",\n \"digest_size\",\n \"hash_len\",\n \"type\",\n )\n \n \n \n \n \n \n \n \n \n \n \n \n \n checksum_size=_default_settings.hash_len\n \n \n _always_parse_settings=uh.GenericHandler._always_parse_settings+\\\n (\"type\",)\n \n \n _unparsed_settings=uh.GenericHandler._unparsed_settings+\\\n (\"salt_len\",\"time_cost\",\"hash_len\",\"digest_size\")\n \n \n \n \n default_salt_size=_default_settings.salt_len\n min_salt_size=8\n max_salt_size=MAX_UINT32\n \n \n \n \n \n \n default_rounds=_default_settings.time_cost\n min_rounds=1\n max_rounds=MAX_UINT32\n rounds_cost=\"linear\"\n \n \n \n \n max_parallelism=(1 <<24)-1\n \n \n \n \n \n \n \n max_version=_default_version\n \n \n min_desired_version=None\n \n \n min_memory_cost=8\n \n \n \n max_threads=-1\n \n \n \n pure_use_threads=False\n \n \n \n \n _backend_type_map={}\n \n @classproperty\n def type_values(cls):\n  ''\n\n\n\n  \n  cls.get_backend()\n  return tuple(cls._backend_type_map)\n  \n  \n  \n  \n  \n  \n  \n type=TYPE_ID\n \n \n parallelism=_default_settings.parallelism\n \n \n \n version=_default_version\n \n \n memory_cost=_default_settings.memory_cost\n \n @property\n def type_d(self):\n  ''\n\n\n\n  \n  return self.type ==TYPE_D\n  \n  \n data=None\n \n \n \n \n \n @classmethod\n def using(cls,type=None ,memory_cost=None ,salt_len=None ,time_cost=None ,digest_size=None ,\n checksum_size=None ,hash_len=None ,max_threads=None ,**kwds):\n \n  if time_cost is not None :\n   if \"rounds\"in kwds:\n    raise TypeError(\"'time_cost' and 'rounds' are mutually exclusive\")\n   kwds['rounds']=time_cost\n   \n  if salt_len is not None :\n   if \"salt_size\"in kwds:\n    raise TypeError(\"'salt_len' and 'salt_size' are mutually exclusive\")\n   kwds['salt_size']=salt_len\n   \n  if hash_len is not None :\n   if digest_size is not None :\n    raise TypeError(\"'hash_len' and 'digest_size' are mutually exclusive\")\n   digest_size=hash_len\n   \n  if checksum_size is not None :\n   if digest_size is not None :\n    raise TypeError(\"'checksum_size' and 'digest_size' are mutually exclusive\")\n   digest_size=checksum_size\n   \n   \n  subcls=super(_Argon2Common,cls).using(**kwds)\n  \n  \n  if type is not None :\n   subcls.type=subcls._norm_type(type)\n   \n   \n  relaxed=kwds.get(\"relaxed\")\n  if digest_size is not None :\n   if isinstance(digest_size,uh.native_string_types):\n    digest_size=int(digest_size)\n    \n   subcls.checksum_size=uh.norm_integer(subcls,digest_size,min=16,max=MAX_UINT32,\n   param=\"digest_size\",relaxed=relaxed)\n   \n   \n  if memory_cost is not None :\n   if isinstance(memory_cost,uh.native_string_types):\n    memory_cost=int(memory_cost)\n   subcls.memory_cost=subcls._norm_memory_cost(memory_cost,relaxed=relaxed)\n   \n   \n  subcls._validate_constraints(subcls.memory_cost,subcls.parallelism)\n  \n  \n  if max_threads is not None :\n   if isinstance(max_threads,uh.native_string_types):\n    max_threads=int(max_threads)\n   if max_threads <1 and max_threads !=-1:\n    raise ValueError(\"max_threads (%d) must be -1 (unlimited), or at least 1.\"%\n    (max_threads,))\n   subcls.max_threads=max_threads\n   \n  return subcls\n  \n @classmethod\n def _validate_constraints(cls,memory_cost,parallelism):\n \n \n  min_memory_cost=8 *parallelism\n  if memory_cost <min_memory_cost:\n   raise ValueError(\"%s: memory_cost (%d) is too low, must be at least \"\n   \"8 * parallelism (8 * %d = %d)\"%\n   (cls.name,memory_cost,\n   parallelism,min_memory_cost))\n   \n   \n   \n   \n   \n   \n _ident_regex=re.compile(r\"^\\$argon2[a-z]+\\$\")\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  return cls._ident_regex.match(hash)is not None\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n _hash_regex=re.compile(br\"\"\"\n        ^\n        \\$argon2(?P<type>[a-z]+)\\$\n        (?:\n            v=(?P<version>\\d+)\n            \\$\n        )?\n        m=(?P<memory_cost>\\d+)\n        ,\n        t=(?P<time_cost>\\d+)\n        ,\n        p=(?P<parallelism>\\d+)\n        (?:\n            ,keyid=(?P<keyid>[^,$]+)\n        )?\n        (?:\n            ,data=(?P<data>[^,$]+)\n        )?\n        (?:\n            \\$\n            (?P<salt>[^$]+)\n            (?:\n                \\$\n                (?P<digest>.+)\n            )?\n        )?\n        $\n    \"\"\",re.X)\n \n @classmethod\n def from_string(cls,hash):\n \n \n  if isinstance(hash,unicode):\n   hash=hash.encode(\"utf-8\")\n  if not isinstance(hash,bytes):\n   raise exc.ExpectedStringError(hash,\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise exc.MalformedHashError(cls)\n  type,version,memory_cost,time_cost,parallelism,keyid,data,salt,digest=\\\n  m.group(\"type\",\"version\",\"memory_cost\",\"time_cost\",\"parallelism\",\n  \"keyid\",\"data\",\"salt\",\"digest\")\n  if keyid:\n   raise NotImplementedError(\"argon2 'keyid' parameter not supported\")\n  return cls(\n  type=type.decode(\"ascii\"),\n  version=int(version)if version else 0x10,\n  memory_cost=int(memory_cost),\n  rounds=int(time_cost),\n  parallelism=int(parallelism),\n  salt=b64s_decode(salt)if salt else None ,\n  data=b64s_decode(data)if data else None ,\n  checksum=b64s_decode(digest)if digest else None ,\n  )\n  \n def to_string(self):\n  version=self.version\n  if version ==0x10:\n   vstr=\"\"\n  else :\n   vstr=\"v=%d$\"%version\n   \n  data=self.data\n  if data:\n   kdstr=\",data=\"+bascii_to_str(b64s_encode(self.data))\n  else :\n   kdstr=\"\"\n   \n   \n  return \"$argon2%s$%sm=%d,t=%d,p=%d%s$%s$%s\"%(\n  uascii_to_str(self.type),\n  vstr,\n  self.memory_cost,\n  self.rounds,\n  self.parallelism,\n  kdstr,\n  bascii_to_str(b64s_encode(self.salt)),\n  bascii_to_str(b64s_encode(self.checksum)),\n  )\n  \n  \n  \n  \n def __init__(self,type=None ,type_d=False ,version=None ,memory_cost=None ,data=None ,**kwds):\n \n \n  if type_d:\n   warn('argon2 `type_d=True` keyword is deprecated, and will be removed in passlib 2.0; '\n   'please use ``type=\"d\"`` instead')\n   assert type is None\n   type=TYPE_D\n   \n   \n   \n  checksum=kwds.get(\"checksum\")\n  if checksum is not None :\n   self.checksum_size=len(checksum)\n   \n   \n  super(_Argon2Common,self).__init__(**kwds)\n  \n  \n  if type is None :\n   assert uh.validate_default_value(self,self.type,self._norm_type,param=\"type\")\n  else :\n   self.type=self._norm_type(type)\n   \n   \n  if version is None :\n   assert uh.validate_default_value(self,self.version,self._norm_version,\n   param=\"version\")\n  else :\n   self.version=self._norm_version(version)\n   \n   \n  if memory_cost is None :\n   assert uh.validate_default_value(self,self.memory_cost,self._norm_memory_cost,\n   param=\"memory_cost\")\n  else :\n   self.memory_cost=self._norm_memory_cost(memory_cost)\n   \n   \n  if data is None :\n   assert self.data is None\n  else :\n   if not isinstance(data,bytes):\n    raise uh.exc.ExpectedTypeError(data,\"bytes\",\"data\")\n   self.data=data\n   \n   \n   \n   \n   \n @classmethod\n def _norm_type(cls,value):\n \n  if not isinstance(value,unicode):\n   if PY2 and isinstance(value,bytes):\n    value=value.decode('ascii')\n   else :\n    raise uh.exc.ExpectedTypeError(value,\"str\",\"type\")\n    \n    \n  if value in ALL_TYPES_SET:\n   return value\n   \n   \n  temp=value.lower()\n  if temp in ALL_TYPES_SET:\n   return temp\n   \n   \n  raise ValueError(\"unknown argon2 hash type: %r\"%(value,))\n  \n @classmethod\n def _norm_version(cls,version):\n  if not isinstance(version,uh.int_types):\n   raise uh.exc.ExpectedTypeError(version,\"integer\",\"version\")\n   \n   \n  if version <0x13 and version !=0x10:\n   raise ValueError(\"invalid argon2 hash version: %d\"%(version,))\n   \n   \n  backend=cls.get_backend()\n  if version >cls.max_version:\n   raise ValueError(\"%s: hash version 0x%X not supported by %r backend \"\n   \"(max version is 0x%X); try updating or switching backends\"%\n   (cls.name,version,backend,cls.max_version))\n  return version\n  \n @classmethod\n def _norm_memory_cost(cls,memory_cost,relaxed=False ):\n  return uh.norm_integer(cls,memory_cost,min=cls.min_memory_cost,\n  param=\"memory_cost\",relaxed=relaxed)\n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def _get_backend_type(cls,value):\n  ''\n\n  \n  try :\n   return cls._backend_type_map[value]\n  except KeyError:\n   pass\n   \n  msg=\"unsupported argon2 hash (type %r not supported by %s backend)\"%\\\n  (value,cls.get_backend())\n  raise ValueError(msg)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  cls=type(self)\n  if self.type !=cls.type:\n   return True\n  minver=cls.min_desired_version\n  if minver is None or minver >cls.max_version:\n   minver=cls.max_version\n  if self.version <minver:\n  \n   return True\n  if self.memory_cost !=cls.memory_cost:\n   return True\n  if self.checksum_size !=cls.checksum_size:\n   return True\n  return super(_Argon2Common,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n _no_backend_suggestion=\" -- recommend you install one (e.g. 'pip install argon2_cffi')\"\n \n @classmethod\n def _finalize_backend_mixin(mixin_cls,name,dryrun):\n  ''\n\n\n\n  \n  \n  max_version=mixin_cls.max_version\n  assert isinstance(max_version,int)and max_version >=0x10\n  if max_version <0x13:\n   warn(\"%r doesn't support argon2 v1.3, and should be upgraded\"%name,\n   uh.exc.PasslibSecurityWarning)\n   \n   \n  for type in ALL_TYPES:\n   if type in mixin_cls._backend_type_map:\n    mixin_cls.type=type\n    break\n  else :\n   warn(\"%r lacks support for all known hash types\"%name,uh.exc.PasslibRuntimeWarning)\n   \n   mixin_cls.type=TYPE_ID\n   \n  return True\n  \n @classmethod\n def _adapt_backend_error(cls,err,hash=None ,self=None ):\n  ''\n\n\n  \n  backend=cls.get_backend()\n  \n  \n  if self is None and hash is not None :\n   self=cls.from_string(hash)\n   \n   \n   \n  if self is not None :\n   self._validate_constraints(self.memory_cost,self.parallelism)\n   \n   \n   \n   if backend ==\"argon2_cffi\"and self.data is not None :\n    raise NotImplementedError(\"argon2_cffi backend doesn't support the 'data' parameter\")\n    \n    \n  text=str(err)\n  if text not in [\n  \"Decoding failed\"\n  ]:\n   reason=\"%s reported: %s: hash=%r\"%(backend,text,hash)\n  else :\n   reason=repr(hash)\n  raise exc.MalformedHashError(cls,reason=reason)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _NoBackend(_Argon2Common):\n ''\n\n\n \n \n \n \n @classmethod\n def hash(cls,secret):\n  cls._stub_requires_backend()\n  return cls.hash(secret)\n  \n @classmethod\n def verify(cls,secret,hash):\n  cls._stub_requires_backend()\n  return cls.verify(secret,hash)\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config):\n  cls._stub_requires_backend()\n  return cls.genhash(secret,config)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n  self._stub_requires_backend()\n  \n  \n  return super(argon2,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _CffiBackend(_Argon2Common):\n ''\n\n \n \n \n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  assert mixin_cls is _CffiBackend\n  \n  \n  if _argon2_cffi is None :\n   if _argon2_cffi_error:\n    raise exc.PasslibSecurityError(_argon2_cffi_error)\n   return False\n  max_version=_argon2_cffi.low_level.ARGON2_VERSION\n  log.debug(\"detected 'argon2_cffi' backend, version %r, with support for 0x%x argon2 hashes\",\n  _argon2_cffi.__version__,max_version)\n  \n  \n  TypeEnum=_argon2_cffi.Type\n  type_map={}\n  for type in ALL_TYPES:\n   try :\n    type_map[type]=getattr(TypeEnum,type.upper())\n   except AttributeError:\n   \n    assert type not in (TYPE_I,TYPE_D),\"unexpected missing type: %r\"%type\n  mixin_cls._backend_type_map=type_map\n  \n  \n  mixin_cls.version=mixin_cls.max_version=max_version\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n @classmethod\n def hash(cls,secret):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  \n  try :\n   return bascii_to_str(_argon2_cffi.low_level.hash_secret(\n   type=cls._get_backend_type(cls.type),\n   memory_cost=cls.memory_cost,\n   time_cost=cls.default_rounds,\n   parallelism=cls.parallelism,\n   salt=to_bytes(cls._generate_salt()),\n   hash_len=cls.checksum_size,\n   secret=secret,\n   ))\n  except _argon2_cffi.exceptions.HashingError as err:\n   raise cls._adapt_backend_error(err)\n   \n   \n _byte_ident_map=dict((render_bytes(b\"$argon2%s$\",type.encode(\"ascii\")),type)\n for type in ALL_TYPES)\n \n @classmethod\n def verify(cls,secret,hash):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  hash=to_bytes(hash,\"ascii\")\n  \n  \n  \n  type=cls._byte_ident_map.get(hash[:1+hash.find(b\"$\",1)],TYPE_I)\n  type_code=cls._get_backend_type(type)\n  \n  \n  try :\n   result=_argon2_cffi.low_level.verify_secret(hash,secret,type_code)\n   assert result is True\n   return True\n  except _argon2_cffi.exceptions.VerifyMismatchError:\n   return False\n  except _argon2_cffi.exceptions.VerificationError as err:\n   raise cls._adapt_backend_error(err,hash=hash)\n   \n   \n @classmethod\n def genhash(cls,secret,config):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  self=cls.from_string(config)\n  \n  try :\n   result=bascii_to_str(_argon2_cffi.low_level.hash_secret(\n   type=cls._get_backend_type(self.type),\n   memory_cost=self.memory_cost,\n   time_cost=self.rounds,\n   parallelism=self.parallelism,\n   salt=to_bytes(self.salt),\n   hash_len=self.checksum_size,\n   secret=secret,\n   version=self.version,\n   ))\n  except _argon2_cffi.exceptions.HashingError as err:\n   raise cls._adapt_backend_error(err,hash=config)\n  if self.version ==0x10:\n  \n   result=result.replace(\"$v=16$\",\"$\")\n  return result\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  raise AssertionError(\"shouldn't be called under argon2_cffi backend\")\n  \n  \n  \n  \n  \n  \n  \n  \nclass _PureBackend(_Argon2Common):\n ''\n\n \n \n \n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  assert mixin_cls is _PureBackend\n  \n  \n  global _argon2pure\n  try :\n   import argon2pure as _argon2pure\n  except ImportError:\n   return False\n   \n   \n  try :\n   from argon2pure import ARGON2_DEFAULT_VERSION as max_version\n  except ImportError:\n   log.warning(\"detected 'argon2pure' backend, but package is too old \"\n   \"(passlib requires argon2pure >= 1.2.3)\")\n   return False\n   \n  log.debug(\"detected 'argon2pure' backend, with support for 0x%x argon2 hashes\",\n  max_version)\n  \n  if not dryrun:\n   warn(\"Using argon2pure backend, which is 100x+ slower than is required \"\n   \"for adequate security. Installing argon2_cffi (via 'pip install argon2_cffi') \"\n   \"is strongly recommended\",exc.PasslibSecurityWarning)\n   \n   \n  type_map={}\n  for type in ALL_TYPES:\n   try :\n    type_map[type]=getattr(_argon2pure,\"ARGON2\"+type.upper())\n   except AttributeError:\n   \n    assert type not in (TYPE_I,TYPE_D),\"unexpected missing type: %r\"%type\n  mixin_cls._backend_type_map=type_map\n  \n  mixin_cls.version=mixin_cls.max_version=max_version\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  uh.validate_secret(secret)\n  secret=to_bytes(secret,\"utf-8\")\n  kwds=dict(\n  password=secret,\n  salt=self.salt,\n  time_cost=self.rounds,\n  memory_cost=self.memory_cost,\n  parallelism=self.parallelism,\n  tag_length=self.checksum_size,\n  type_code=self._get_backend_type(self.type),\n  version=self.version,\n  )\n  if self.max_threads >0:\n   kwds['threads']=self.max_threads\n  if self.pure_use_threads:\n   kwds['use_threads']=True\n  if self.data:\n   kwds['associated_data']=self.data\n   \n   \n   \n  try :\n   return _argon2pure.argon2(**kwds)\n  except _argon2pure.Argon2Error as err:\n   raise self._adapt_backend_error(err,self=self)\n   \n   \n   \n   \n   \nclass argon2(_NoBackend,_Argon2Common):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n backends=(\"argon2_cffi\",\"argon2pure\")\n \n \n _backend_mixin_target=True\n \n \n _backend_mixin_map={\n None :_NoBackend,\n \"argon2_cffi\":_CffiBackend,\n \"argon2pure\":_PureBackend,\n }\n \n \n \n \n \n \n \n \n", ["__future__", "argon2", "argon2pure", "logging", "passlib", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "types", "warnings"]], "passlib.hash": [".py", "''\n", [], 1], "passlib.hash.scrypt": [".py", "''\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.crypto import scrypt as _scrypt\nfrom passlib.utils import h64,to_bytes\nfrom passlib.utils.binary import h64,b64s_decode,b64s_encode\nfrom passlib.utils.compat import u,bascii_to_str,suppress_cause\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"scrypt\",\n]\n\n\n\n\n\nIDENT_SCRYPT=u(\"$scrypt$\")\nIDENT_7=u(\"$7$\")\n\n_UDOLLAR=u(\"$\")\n\n\n\n\nclass scrypt(uh.ParallelismMixin,uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.HasManyIdents,\nuh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n name=\"scrypt\"\n setting_kwds=(\"ident\",\"salt\",\"salt_size\",\"rounds\",\"block_size\",\"parallelism\")\n \n \n \n \n \n \n \n \n checksum_size=32\n \n \n \n \n default_ident=IDENT_SCRYPT\n ident_values=(IDENT_SCRYPT,IDENT_7)\n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n \n \n \n default_rounds=16\n min_rounds=1\n max_rounds=31\n rounds_cost=\"log2\"\n \n \n \n \n \n \n \n \n parallelism=1\n \n \n block_size=8\n \n \n \n \n \n @classmethod\n def using(cls,block_size=None ,**kwds):\n  subcls=super(scrypt,cls).using(**kwds)\n  if block_size is not None :\n   if isinstance(block_size,uh.native_string_types):\n    block_size=int(block_size)\n   subcls.block_size=subcls._norm_block_size(block_size,relaxed=kwds.get(\"relaxed\"))\n   \n   \n  try :\n   _scrypt.validate(1 <<cls.default_rounds,cls.block_size,cls.parallelism)\n  except ValueError as err:\n   raise suppress_cause(ValueError(\"scrypt: invalid settings combination: \"+str(err)))\n   \n  return subcls\n  \n  \n  \n  \n  \n @classmethod\n def from_string(cls,hash):\n  return cls(**cls.parse(hash))\n  \n @classmethod\n def parse(cls,hash):\n  ident,suffix=cls._parse_ident(hash)\n  func=getattr(cls,\"_parse_%s_string\"%ident.strip(_UDOLLAR),None )\n  if func:\n   return func(suffix)\n  else :\n   raise uh.exc.InvalidHashError(cls)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n @classmethod\n def _parse_scrypt_string(cls,suffix):\n \n  parts=suffix.split(\"$\")\n  if len(parts)==3:\n   params,salt,digest=parts\n  elif len(parts)==2:\n   params,salt=parts\n   digest=None\n  else :\n   raise uh.exc.MalformedHashError(cls,\"malformed hash\")\n   \n   \n  parts=params.split(\",\")\n  if len(parts)==3:\n   nstr,bstr,pstr=parts\n   assert nstr.startswith(\"ln=\")\n   assert bstr.startswith(\"r=\")\n   assert pstr.startswith(\"p=\")\n  else :\n   raise uh.exc.MalformedHashError(cls,\"malformed settings field\")\n   \n  return dict(\n  ident=IDENT_SCRYPT,\n  rounds=int(nstr[3:]),\n  block_size=int(bstr[2:]),\n  parallelism=int(pstr[2:]),\n  salt=b64s_decode(salt.encode(\"ascii\")),\n  checksum=b64s_decode(digest.encode(\"ascii\"))if digest else None ,\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n @classmethod\n def _parse_7_string(cls,suffix):\n \n \n \n \n  parts=suffix.encode(\"ascii\").split(b\"$\")\n  if len(parts)==2:\n   params,digest=parts\n  elif len(parts)==1:\n   params,=parts\n   digest=None\n  else :\n   raise uh.exc.MalformedHashError()\n   \n   \n  if len(params)<11:\n   raise uh.exc.MalformedHashError(cls,\"params field too short\")\n  return dict(\n  ident=IDENT_7,\n  rounds=h64.decode_int6(params[:1]),\n  block_size=h64.decode_int30(params[1:6]),\n  parallelism=h64.decode_int30(params[6:11]),\n  salt=params[11:],\n  checksum=h64.decode_bytes(digest)if digest else None ,\n  )\n  \n  \n  \n  \n def to_string(self):\n  ident=self.ident\n  if ident ==IDENT_SCRYPT:\n   return \"$scrypt$ln=%d,r=%d,p=%d$%s$%s\"%(\n   self.rounds,\n   self.block_size,\n   self.parallelism,\n   bascii_to_str(b64s_encode(self.salt)),\n   bascii_to_str(b64s_encode(self.checksum)),\n   )\n  else :\n   assert ident ==IDENT_7\n   salt=self.salt\n   try :\n    salt.decode(\"ascii\")\n   except UnicodeDecodeError:\n    raise suppress_cause(NotImplementedError(\"scrypt $7$ hashes dont support non-ascii salts\"))\n   return bascii_to_str(b\"\".join([\n   b\"$7$\",\n   h64.encode_int6(self.rounds),\n   h64.encode_int30(self.block_size),\n   h64.encode_int30(self.parallelism),\n   self.salt,\n   b\"$\",\n   h64.encode_bytes(self.checksum)\n   ]))\n   \n   \n   \n   \n def __init__(self,block_size=None ,**kwds):\n  super(scrypt,self).__init__(**kwds)\n  \n  \n  if block_size is None :\n   assert uh.validate_default_value(self,self.block_size,self._norm_block_size,\n   param=\"block_size\")\n  else :\n   self.block_size=self._norm_block_size(block_size)\n   \n   \n   \n   \n @classmethod\n def _norm_block_size(cls,block_size,relaxed=False ):\n  return uh.norm_integer(cls,block_size,min=1,param=\"block_size\",relaxed=relaxed)\n  \n def _generate_salt(self):\n  salt=super(scrypt,self)._generate_salt()\n  if self.ident ==IDENT_7:\n  \n  \n   salt=b64s_encode(salt)\n  return salt\n  \n  \n  \n  \n  \n  \n  \n @classproperty\n def backends(cls):\n  return _scrypt.backend_values\n  \n @classmethod\n def get_backend(cls):\n  return _scrypt.backend\n  \n @classmethod\n def has_backend(cls,name=\"any\"):\n  try :\n   cls.set_backend(name,dryrun=True )\n   return True\n  except uh.exc.MissingBackendError:\n   return False\n   \n @classmethod\n def set_backend(cls,name=\"any\",dryrun=False ):\n  _scrypt._set_backend(name,dryrun=dryrun)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  secret=to_bytes(secret,param=\"secret\")\n  return _scrypt.scrypt(secret,self.salt,n=(1 <<self.rounds),r=self.block_size,\n  p=self.parallelism,keylen=self.checksum_size)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  ''\n\n  \n  \n  if self.block_size !=type(self).block_size:\n   return True\n  return super(scrypt,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "logging", "passlib.crypto", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers"]], "passlib.hash.digests": [".py", "''\n\n\n\n\n\nimport hashlib\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_native_str,to_bytes,render_bytes,consteq\nfrom passlib.utils.compat import unicode,str_to_uascii\nimport passlib.utils.handlers as uh\nfrom passlib.crypto.digest import lookup_hash\n\n__all__=[\n\"create_hex_hash\",\n\"hex_md4\",\n\"hex_md5\",\n\"hex_sha1\",\n\"hex_sha256\",\n\"hex_sha512\",\n]\n\n\n\n\nclass HexDigestHash(uh.StaticHandler):\n ''\n \n \n \n _hash_func=None\n checksum_size=None\n checksum_chars=uh.HEX_CHARS\n \n \n supported=True\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(self._hash_func(secret).hexdigest())\n  \n  \n  \n  \n  \ndef create_hex_hash(digest,module=__name__,django_name=None ,required=True ):\n ''\n\n\n\n\n\n\n\n \n info=lookup_hash(digest,required=required)\n name=\"hex_\"+info.name\n if not info.supported:\n  info.digest_size=0\n hasher=type(name,(HexDigestHash,),dict(\n name=name,\n __module__=module,\n _hash_func=staticmethod(info.const),\n checksum_size=info.digest_size *2,\n __doc__=\"\"\"This class implements a plain hexadecimal %s hash, and follows the :ref:`password-hash-api`.\n\nIt supports no optional or contextual keywords.\n\"\"\"%(info.name,)\n ))\n if not info.supported:\n  hasher.supported=False\n if django_name:\n  hasher.django_name=django_name\n return hasher\n \n \n \n \n \n \n \n \n \nhex_md4=create_hex_hash(\"md4\",required=False )\nhex_md5=create_hex_hash(\"md5\",django_name=\"unsalted_md5\",required=False )\nhex_sha1=create_hex_hash(\"sha1\",required=False )\nhex_sha256=create_hex_hash(\"sha256\")\nhex_sha512=create_hex_hash(\"sha512\")\n\n\n\n\nclass htdigest(uh.MinimalHandler):\n ''\n\n\n\n \n name=\"htdigest\"\n setting_kwds=()\n context_kwds=(\"user\",\"realm\",\"encoding\")\n default_encoding=\"utf-8\"\n \n @classmethod\n def hash(cls,secret,user,realm,encoding=None ):\n \n \n  if not encoding:\n   encoding=cls.default_encoding\n  uh.validate_secret(secret)\n  if isinstance(secret,unicode):\n   secret=secret.encode(encoding)\n  user=to_bytes(user,encoding,\"user\")\n  realm=to_bytes(realm,encoding,\"realm\")\n  data=render_bytes(\"%s:%s:%s\",user,realm,secret)\n  return hashlib.md5(data).hexdigest()\n  \n @classmethod\n def _norm_hash(cls,hash):\n  ''\n  hash=to_native_str(hash,param=\"hash\")\n  if len(hash)!=32:\n   raise uh.exc.MalformedHashError(cls,\"wrong size\")\n  for char in hash:\n   if char not in uh.LC_HEX_CHARS:\n    raise uh.exc.MalformedHashError(cls,\"invalid chars in hash\")\n  return hash\n  \n @classmethod\n def verify(cls,secret,hash,user,realm,encoding=\"utf-8\"):\n  hash=cls._norm_hash(hash)\n  other=cls.hash(secret,user,realm,encoding)\n  return consteq(hash,other)\n  \n @classmethod\n def identify(cls,hash):\n  try :\n   cls._norm_hash(hash)\n  except ValueError:\n   return False\n  return True\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n  return cls.hash(\"\",\"\",\"\")\n  \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genhash(cls,secret,config,user,realm,encoding=None ):\n \n \n  cls._norm_hash(config)\n  return cls.hash(secret,user,realm,encoding)\n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.pbkdf2": [".py", "''\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom base64 import b64encode,b64decode\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode\nfrom passlib.utils.binary import ab64_decode,ab64_encode\nfrom passlib.utils.compat import str_to_bascii,u,uascii_to_str,unicode\nfrom passlib.crypto.digest import pbkdf2_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"pbkdf2_sha1\",\n\"pbkdf2_sha256\",\n\"pbkdf2_sha512\",\n\"cta_pbkdf2_sha1\",\n\"dlitz_pbkdf2_sha1\",\n\"grub_pbkdf2_sha512\",\n]\n\n\n\n\nclass Pbkdf2DigestHandler(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n \n \n \n \n \n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n checksum_chars=uh.HASH64_CHARS\n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n default_rounds=None\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n _digest=None\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  salt=ab64_decode(salt.encode(\"ascii\"))\n  if chk:\n   chk=ab64_decode(chk.encode(\"ascii\"))\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=ab64_encode(self.salt).decode(\"ascii\")\n  chk=ab64_encode(self.checksum).decode(\"ascii\")\n  return uh.render_mc3(self.ident,self.rounds,salt,chk)\n  \n def _calc_checksum(self,secret):\n \n  return pbkdf2_hmac(self._digest,secret,self.salt,self.rounds,self.checksum_size)\n  \ndef create_pbkdf2_hash(hash_name,digest_size,rounds=12000,ident=None ,module=__name__):\n ''\n name='pbkdf2_'+hash_name\n if ident is None :\n  ident=u(\"$pbkdf2-%s$\")%(hash_name,)\n base=Pbkdf2DigestHandler\n return type(name,(base,),dict(\n __module__=module,\n name=name,\n ident=ident,\n _digest=hash_name,\n default_rounds=rounds,\n checksum_size=digest_size,\n encoded_checksum_size=(digest_size *4+2)//3,\n __doc__=\"\"\"This class implements a generic ``PBKDF2-HMAC-%(digest)s``-based password hash, and follows the :ref:`password-hash-api`.\n\n    It supports a variable-length salt, and a variable number of rounds.\n\n    The :meth:`~passlib.ifc.PasswordHash.using` method accepts the following optional keywords:\n\n    :type salt: bytes\n    :param salt:\n        Optional salt bytes.\n        If specified, the length must be between 0-1024 bytes.\n        If not specified, a %(dsc)d byte salt will be autogenerated (this is recommended).\n\n    :type salt_size: int\n    :param salt_size:\n        Optional number of bytes to use when autogenerating new salts.\n        Defaults to %(dsc)d bytes, but can be any value between 0 and 1024.\n\n    :type rounds: int\n    :param rounds:\n        Optional number of rounds to use.\n        Defaults to %(dr)d, but must be within ``range(1,1<<32)``.\n\n    :type relaxed: bool\n    :param relaxed:\n        By default, providing an invalid value for one of the other\n        keywords will result in a :exc:`ValueError`. If ``relaxed=True``,\n        and the error can be corrected, a :exc:`~passlib.exc.PasslibHashWarning`\n        will be issued instead. Correctable errors include ``rounds``\n        that are too small or too large, and ``salt`` strings that are too long.\n\n        .. versionadded:: 1.6\n    \"\"\"%dict(digest=hash_name.upper(),dsc=base.default_salt_size,dr=rounds)\n ))\n \n \n \n \npbkdf2_sha1=create_pbkdf2_hash(\"sha1\",20,131000,ident=u(\"$pbkdf2$\"))\npbkdf2_sha256=create_pbkdf2_hash(\"sha256\",32,29000)\npbkdf2_sha512=create_pbkdf2_hash(\"sha512\",64,25000)\n\nldap_pbkdf2_sha1=uh.PrefixWrapper(\"ldap_pbkdf2_sha1\",pbkdf2_sha1,\"{PBKDF2}\",\"$pbkdf2$\",ident=True )\nldap_pbkdf2_sha256=uh.PrefixWrapper(\"ldap_pbkdf2_sha256\",pbkdf2_sha256,\"{PBKDF2-SHA256}\",\"$pbkdf2-sha256$\",ident=True )\nldap_pbkdf2_sha512=uh.PrefixWrapper(\"ldap_pbkdf2_sha512\",pbkdf2_sha512,\"{PBKDF2-SHA512}\",\"$pbkdf2-sha512$\",ident=True )\n\n\n\n\n\n\nCTA_ALTCHARS=b\"-_\"\n\nclass cta_pbkdf2_sha1(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"cta_pbkdf2_sha1\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$p5k2$\")\n checksum_size=20\n \n \n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n \n \n default_rounds=pbkdf2_sha1.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n \n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,rounds_base=16,handler=cls)\n  salt=b64decode(salt.encode(\"ascii\"),CTA_ALTCHARS)\n  if chk:\n   chk=b64decode(chk.encode(\"ascii\"),CTA_ALTCHARS)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=b64encode(self.salt,CTA_ALTCHARS).decode(\"ascii\")\n  chk=b64encode(self.checksum,CTA_ALTCHARS).decode(\"ascii\")\n  return uh.render_mc3(self.ident,self.rounds,salt,chk,rounds_base=16)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  return pbkdf2_hmac(\"sha1\",secret,self.salt,self.rounds,20)\n  \n  \n  \n  \n  \n  \n  \n  \nclass dlitz_pbkdf2_sha1(uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"dlitz_pbkdf2_sha1\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$p5k2$\")\n _stub_checksum=u(\"0\"*48+\"=\")\n \n \n \n \n \n \n default_salt_size=16\n max_salt_size=1024\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n default_rounds=pbkdf2_sha1.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,rounds_base=16,\n  default_rounds=400,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  rounds=self.rounds\n  if rounds ==400:\n   rounds=None\n  return uh.render_mc3(self.ident,rounds,self.salt,self.checksum,rounds_base=16)\n  \n def _get_config(self):\n  rounds=self.rounds\n  if rounds ==400:\n   rounds=None\n  return uh.render_mc3(self.ident,rounds,self.salt,None ,rounds_base=16)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  salt=self._get_config()\n  result=pbkdf2_hmac(\"sha1\",secret,salt,self.rounds,24)\n  return ab64_encode(result).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \nclass atlassian_pbkdf2_sha1(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n name=\"atlassian_pbkdf2_sha1\"\n setting_kwds=(\"salt\",)\n ident=u(\"{PKCS5S2}\")\n checksum_size=32\n \n \n min_salt_size=max_salt_size=16\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  ident=cls.ident\n  if not hash.startswith(ident):\n   raise uh.exc.InvalidHashError(cls)\n  data=b64decode(hash[len(ident):].encode(\"ascii\"))\n  salt,chk=data[:16],data[16:]\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  data=self.salt+self.checksum\n  hash=self.ident+b64encode(data).decode(\"ascii\")\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n \n \n \n  return pbkdf2_hmac(\"sha1\",secret,self.salt,10000,32)\n  \n  \n  \n  \nclass grub_pbkdf2_sha512(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"grub_pbkdf2_sha512\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n \n ident=u(\"grub.pbkdf2.sha512.\")\n checksum_size=64\n \n \n \n \n \n default_salt_size=64\n max_salt_size=1024\n \n default_rounds=pbkdf2_sha512.default_rounds\n min_rounds=1\n max_rounds=0xffffffff\n rounds_cost=\"linear\"\n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,sep=u(\".\"),\n  handler=cls)\n  salt=unhexlify(salt.encode(\"ascii\"))\n  if chk:\n   chk=unhexlify(chk.encode(\"ascii\"))\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self):\n  salt=hexlify(self.salt).decode(\"ascii\").upper()\n  chk=hexlify(self.checksum).decode(\"ascii\").upper()\n  return uh.render_mc3(self.ident,self.rounds,salt,chk,sep=u(\".\"))\n  \n def _calc_checksum(self,secret):\n \n \n  return pbkdf2_hmac(\"sha512\",secret,self.salt,self.rounds,64)\n  \n  \n  \n  \n", ["base64", "binascii", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.cisco": [".py", "''\n\n\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import right_pad_string,to_unicode,repeat_string,to_bytes\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import unicode,u,join_byte_values,\\\njoin_byte_elems,iter_byte_values,uascii_to_str\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"cisco_pix\",\n\"cisco_asa\",\n\"cisco_type7\",\n]\n\n\n\n\n\n\n_DUMMY_BYTES=b'\\xFF'*32\n\n\n\n\nclass cisco_pix(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_pix\"\n \n truncate_size=16\n \n \n \n truncate_error=True\n truncate_verify_reject=True\n \n \n \n \n checksum_size=16\n checksum_chars=uh.HASH64_CHARS\n \n \n \n \n \n \n _is_asa=False\n \n \n \n \n def _calc_checksum(self,secret):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  asa=self._is_asa\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  spoil_digest=None\n  if len(secret)>self.truncate_size:\n   if self.use_defaults:\n   \n    msg=\"Password too long (%s allows at most %d bytes)\"%\\\n    (self.name,self.truncate_size)\n    raise uh.exc.PasswordSizeError(self.truncate_size,msg=msg)\n   else :\n   \n   \n   \n   \n   \n   \n    spoil_digest=secret+_DUMMY_BYTES\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  user=self.user\n  if user:\n   if isinstance(user,unicode):\n    user=user.encode(\"utf-8\")\n   if not asa or len(secret)<28:\n    secret +=repeat_string(user,4)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n  if asa and len(secret)>16:\n   pad_size=32\n  else :\n   pad_size=16\n  secret=right_pad_string(secret,pad_size)\n  \n  \n  \n  \n  if spoil_digest:\n  \n   secret +=spoil_digest\n  digest=md5(secret).digest()\n  \n  \n  \n  \n  \n  \n  \n  digest=join_byte_elems(c for i,c in enumerate(digest)if (i+1)&3)\n  \n  \n  \n  \n  return h64.encode_bytes(digest).decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass cisco_asa(cisco_pix):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_asa\"\n \n \n \n \n truncate_size=32\n \n \n \n \n _is_asa=True\n \n \n \n \n \n \n \n \nclass cisco_type7(uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"cisco_type7\"\n setting_kwds=(\"salt\",)\n \n \n \n \n checksum_chars=uh.UPPER_HEX_CHARS\n \n \n \n \n \n \n \n min_salt_value=0\n max_salt_value=52\n \n \n \n \n @classmethod\n def using(cls,salt=None ,**kwds):\n  subcls=super(cisco_type7,cls).using(**kwds)\n  if salt is not None :\n   salt=subcls._norm_salt(salt,relaxed=kwds.get(\"relaxed\"))\n   subcls._generate_salt=staticmethod(lambda :salt)\n  return subcls\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if len(hash)<2:\n   raise uh.exc.InvalidHashError(cls)\n  salt=int(hash[:2])\n  return cls(salt=salt,checksum=hash[2:].upper())\n  \n def __init__(self,salt=None ,**kwds):\n  super(cisco_type7,self).__init__(**kwds)\n  if salt is not None :\n   salt=self._norm_salt(salt)\n  elif self.use_defaults:\n   salt=self._generate_salt()\n   assert self._norm_salt(salt)==salt,\"generated invalid salt: %r\"%(salt,)\n  else :\n   raise TypeError(\"no salt specified\")\n  self.salt=salt\n  \n @classmethod\n def _norm_salt(cls,salt,relaxed=False ):\n  ''\n\n\n\n  \n  if not isinstance(salt,int):\n   raise uh.exc.ExpectedTypeError(salt,\"integer\",\"salt\")\n  if 0 <=salt <=cls.max_salt_value:\n   return salt\n  msg=\"salt/offset must be in 0..52 range\"\n  if relaxed:\n   warn(msg,uh.PasslibHashWarning)\n   return 0 if salt <0 else cls.max_salt_value\n  else :\n   raise ValueError(msg)\n   \n @staticmethod\n def _generate_salt():\n  return uh.rng.randint(0,15)\n  \n def to_string(self):\n  return \"%02d%s\"%(self.salt,uascii_to_str(self.checksum))\n  \n def _calc_checksum(self,secret):\n \n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return hexlify(self._cipher(secret,self.salt)).decode(\"ascii\").upper()\n  \n @classmethod\n def decode(cls,hash,encoding=\"utf-8\"):\n  ''\n\n\n\n\n  \n  self=cls.from_string(hash)\n  tmp=unhexlify(self.checksum.encode(\"ascii\"))\n  raw=self._cipher(tmp,self.salt)\n  return raw.decode(encoding)if encoding else raw\n  \n  \n _key=u(\"dsfd;kfoA,.iyewrkldJKDHSUBsgvca69834ncxv9873254k;fg87\")\n \n @classmethod\n def _cipher(cls,data,salt):\n  ''\n  key=cls._key\n  key_size=len(key)\n  return join_byte_values(\n  value ^ord(key[(salt+idx)%key_size])\n  for idx,value in enumerate(iter_byte_values(data))\n  )\n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "warnings"]], "passlib.hash.des_crypt": [".py", "''\n\n\n\n\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import safe_crypt,test_crypt,to_unicode\nfrom passlib.utils.binary import h64,h64big\nfrom passlib.utils.compat import byte_elem_value,u,uascii_to_str,unicode,suppress_cause\nfrom passlib.crypto.des import des_encrypt_int_block\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"des_crypt\",\n\"bsdi_crypt\",\n\"bigcrypt\",\n\"crypt16\",\n]\n\n\n\n\n_BNULL=b'\\x00'\n\ndef _crypt_secret_to_key(secret):\n ''\n\n\n\n\n \n \n \n \n \n return sum((byte_elem_value(c)&0x7f)<<(57 -i *8)\n for i,c in enumerate(secret[:8]))\n \ndef _raw_des_crypt(secret,salt):\n ''\n assert len(salt)==2\n \n \n \n \n \n \n \n salt_value=h64.decode_int12(salt)\n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(\"utf-8\")\n assert isinstance(secret,bytes)\n \n \n if _BNULL in secret:\n  raise uh.exc.NullPasswordError(des_crypt)\n  \n  \n key_value=_crypt_secret_to_key(secret)\n \n \n result=des_encrypt_int_block(key_value,0,salt_value,25)\n \n \n return h64big.encode_int64(result)\n \ndef _bsdi_secret_to_key(secret):\n ''\n key_value=_crypt_secret_to_key(secret)\n idx=8\n end=len(secret)\n while idx <end:\n  next=idx+8\n  tmp_value=_crypt_secret_to_key(secret[idx:next])\n  key_value=des_encrypt_int_block(key_value,key_value)^tmp_value\n  idx=next\n return key_value\n \ndef _raw_bsdi_crypt(secret,rounds,salt):\n ''\n \n \n salt_value=h64.decode_int24(salt)\n \n \n if isinstance(secret,unicode):\n  secret=secret.encode(\"utf-8\")\n assert isinstance(secret,bytes)\n \n \n if _BNULL in secret:\n  raise uh.exc.NullPasswordError(bsdi_crypt)\n  \n  \n key_value=_bsdi_secret_to_key(secret)\n \n \n result=des_encrypt_int_block(key_value,0,salt_value,rounds)\n \n \n return h64big.encode_int64(result)\n \n \n \n \nclass des_crypt(uh.TruncateMixin,uh.HasManyBackends,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"des_crypt\"\n setting_kwds=(\"salt\",\"truncate_error\")\n \n \n \n \n checksum_chars=uh.HASH64_CHARS\n checksum_size=11\n \n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n truncate_size=8\n \n \n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{11})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  salt,chk=hash[:2],hash[2:]\n  return cls(salt=salt,checksum=chk or None )\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n  return self._calc_checksum_backend(secret)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'abgOeLfPimXQo'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n \n \n  hash=safe_crypt(secret,self.salt)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(self.salt)or len(hash)!=13:\n   raise uh.exc.CryptBackendError(self,self.salt,hash)\n  return hash[2:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_des_crypt(secret,self.salt.encode(\"ascii\")).decode(\"ascii\")\n  \n  \n  \n  \n  \nclass bsdi_crypt(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"bsdi_crypt\"\n setting_kwds=(\"salt\",\"rounds\")\n checksum_size=11\n checksum_chars=uh.HASH64_CHARS\n \n \n min_salt_size=max_salt_size=4\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=5001\n min_rounds=1\n max_rounds=16777215\n rounds_cost=\"linear\"\n \n \n \n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        _\n        (?P<rounds>[./a-z0-9]{4})\n        (?P<salt>[./a-z0-9]{4})\n        (?P<chk>[./a-z0-9]{11})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  rounds,salt,chk=m.group(\"rounds\",\"salt\",\"chk\")\n  return cls(\n  rounds=h64.decode_int24(rounds.encode(\"ascii\")),\n  salt=salt,\n  checksum=chk,\n  )\n  \n def to_string(self):\n  hash=u(\"_%s%s%s\")%(h64.encode_int24(self.rounds).decode(\"ascii\"),\n  self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n  \n  \n _avoid_even_rounds=True\n \n @classmethod\n def using(cls,**kwds):\n  subcls=super(bsdi_crypt,cls).using(**kwds)\n  if not subcls.default_rounds&1:\n  \n   warn(\"bsdi_crypt rounds should be odd, as even rounds may reveal weak DES keys\",\n   uh.exc.PasslibSecurityWarning)\n  return subcls\n  \n @classmethod\n def _generate_rounds(cls):\n  rounds=super(bsdi_crypt,cls)._generate_rounds()\n  \n  \n  \n  \n  \n  return rounds |1\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n \n  if not self.rounds&1:\n   return True\n   \n  return super(bsdi_crypt,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'_/...lLDAxARksGCHin.'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string()\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config[:9])or len(hash)!=20:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-11:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  return _raw_bsdi_crypt(secret,self.rounds,self.salt.encode(\"ascii\")).decode(\"ascii\")\n  \n  \n  \n  \n  \nclass bigcrypt(uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"bigcrypt\"\n setting_kwds=(\"salt\",)\n checksum_chars=uh.HASH64_CHARS\n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>([./a-z0-9]{11})+)?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  checksum=super(bigcrypt,self)._norm_checksum(checksum,relaxed=relaxed)\n  if len(checksum)%11:\n   raise uh.exc.InvalidHashError(self)\n  return checksum\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=_raw_des_crypt(secret,self.salt.encode(\"ascii\"))\n  idx=8\n  end=len(secret)\n  while idx <end:\n   next=idx+8\n   chk +=_raw_des_crypt(secret[idx:next],chk[-11:-9])\n   idx=next\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \n  \nclass crypt16(uh.TruncateMixin,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"crypt16\"\n setting_kwds=(\"salt\",\"truncate_error\")\n \n \n \n \n checksum_size=22\n checksum_chars=uh.HASH64_CHARS\n \n \n \n \n min_salt_size=max_salt_size=2\n salt_chars=uh.HASH64_CHARS\n \n \n \n \n truncate_size=16\n \n \n \n \n _hash_regex=re.compile(u(r\"\"\"\n        ^\n        (?P<salt>[./a-z0-9]{2})\n        (?P<chk>[./a-z0-9]{22})?\n        $\"\"\"),re.X |re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk)\n  \n def to_string(self):\n  hash=u(\"%s%s\")%(self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n   \n  try :\n   salt_value=h64.decode_int12(self.salt.encode(\"ascii\"))\n  except ValueError:\n   raise suppress_cause(ValueError(\"invalid chars in salt\"))\n   \n   \n  key1=_crypt_secret_to_key(secret)\n  \n  \n  result1=des_encrypt_int_block(key1,0,salt_value,20)\n  \n  \n  key2=_crypt_secret_to_key(secret[8:16])\n  \n  \n  result2=des_encrypt_int_block(key2,0,salt_value,5)\n  \n  \n  chk=h64big.encode_int64(result1)+h64big.encode_int64(result2)\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \n  \n  \n  \n  \n", ["logging", "passlib.crypto.des", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.hash.postgres": [".py", "''\n\n\n\n\nfrom hashlib import md5\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_bytes\nfrom passlib.utils.compat import str_to_uascii,unicode,u\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"postgres_md5\",\n]\n\n\n\n\nclass postgres_md5(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"postgres_md5\"\n _hash_prefix=u(\"md5\")\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  user=to_bytes(self.user,\"utf-8\",param=\"user\")\n  return str_to_uascii(md5(secret+user).hexdigest())\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.bcrypt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\nfrom __future__ import with_statement,absolute_import\n\nfrom base64 import b64encode\nfrom hashlib import sha256\nimport os\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n_bcrypt=None\n_pybcrypt=None\n_bcryptor=None\n\n_builtin_bcrypt=None\nfrom passlib.crypto.digest import compile_hmac\nfrom passlib.exc import PasslibHashWarning,PasslibSecurityWarning,PasslibSecurityError\nfrom passlib.utils import safe_crypt,repeat_string,to_bytes,parse_version,\\\nrng,getrandstr,test_crypt,to_unicode,\\\nutf8_truncate,utf8_repeat_string,crypt_accepts_bytes\nfrom passlib.utils.binary import bcrypt64\nfrom passlib.utils.compat import get_unbound_method_function\nfrom passlib.utils.compat import u,uascii_to_str,unicode,str_to_uascii,PY3,error_from\nimport passlib.utils.handlers as uh\n\n\n__all__=[\n\"bcrypt\",\n]\n\n\n\n\nIDENT_2=u(\"$2$\")\nIDENT_2A=u(\"$2a$\")\nIDENT_2X=u(\"$2x$\")\nIDENT_2Y=u(\"$2y$\")\nIDENT_2B=u(\"$2b$\")\n_BNULL=b'\\x00'\n\n\nTEST_HASH_2A=\"$2a$04$5BJqKfqMQvV7nS.yUguNcueVirQqDBGaLXSqj.rs.pZPlNR0UX/HK\"\n\ndef _detect_pybcrypt():\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n try :\n  import bcrypt\n except ImportError:\n \n \n  return None\n  \n  \n  \n  \n try :\n  from bcrypt._bcrypt import __version__\n except ImportError:\n  return False\n return True\n \n \n \n \nclass _BcryptCommon(uh.SubclassBackendMixin,uh.TruncateMixin,uh.HasManyIdents,\nuh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"bcrypt\"\n setting_kwds=(\"salt\",\"rounds\",\"ident\",\"truncate_error\")\n \n \n \n \n checksum_size=31\n checksum_chars=bcrypt64.charmap\n \n \n \n \n default_ident=IDENT_2B\n ident_values=(IDENT_2,IDENT_2A,IDENT_2X,IDENT_2Y,IDENT_2B)\n ident_aliases={u(\"2\"):IDENT_2,u(\"2a\"):IDENT_2A,u(\"2y\"):IDENT_2Y,\n u(\"2b\"):IDENT_2B}\n \n \n \n \n min_salt_size=max_salt_size=22\n salt_chars=bcrypt64.charmap\n \n \n final_salt_chars=\".Oeu\"\n \n \n \n \n default_rounds=12\n min_rounds=4\n max_rounds=31\n rounds_cost=\"log2\"\n \n \n \n \n truncate_size=72\n \n \n \n \n \n \n \n _workrounds_initialized=False\n _has_2a_wraparound_bug=False\n _lacks_20_support=False\n _lacks_2y_support=False\n _lacks_2b_support=False\n _fallback_ident=IDENT_2A\n _require_valid_utf8_bytes=False\n \n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  ident,tail=cls._parse_ident(hash)\n  if ident ==IDENT_2X:\n   raise ValueError(\"crypt_blowfish's buggy '2x' hashes are not \"\n   \"currently supported\")\n  rounds_str,data=tail.split(u(\"$\"))\n  rounds=int(rounds_str)\n  if rounds_str !=u('%02d')%(rounds,):\n   raise uh.exc.MalformedHashError(cls,\"malformed cost field\")\n  salt,chk=data[:22],data[22:]\n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chk or None ,\n  ident=ident,\n  )\n  \n def to_string(self):\n  hash=u(\"%s%02d$%s%s\")%(self.ident,self.rounds,self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n def _get_config(self,ident):\n  ''\n  config=u(\"%s%02d$%s\")%(ident,self.rounds,self.salt)\n  return uascii_to_str(config)\n  \n  \n  \n  \n  \n @classmethod\n def needs_update(cls,hash,**kwds):\n \n \n \n  if isinstance(hash,bytes):\n   hash=hash.decode(\"ascii\")\n  if hash.startswith(IDENT_2A)and hash[28]not in cls.final_salt_chars:\n   return True\n   \n   \n   \n   \n  return super(_BcryptCommon,cls).needs_update(hash,**kwds)\n  \n  \n  \n  \n  \n @classmethod\n def normhash(cls,hash):\n  ''\n  if cls.identify(hash):\n   return cls.from_string(hash).to_string()\n  else :\n   return hash\n   \n @classmethod\n def _generate_salt(cls):\n \n \n  salt=super(_BcryptCommon,cls)._generate_salt()\n  return bcrypt64.repair_unused(salt)\n  \n @classmethod\n def _norm_salt(cls,salt,**kwds):\n  salt=super(_BcryptCommon,cls)._norm_salt(salt,**kwds)\n  assert salt is not None ,\"HasSalt didn't generate new salt!\"\n  changed,salt=bcrypt64.check_repair_unused(salt)\n  if changed:\n  \n  \n   warn(\n   \"encountered a bcrypt salt with incorrectly set padding bits; \"\n   \"you may want to use bcrypt.normhash() \"\n   \"to fix this; this will be an error under Passlib 2.0\",\n   PasslibHashWarning)\n  return salt\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  checksum=super(_BcryptCommon,self)._norm_checksum(checksum,relaxed=relaxed)\n  changed,checksum=bcrypt64.check_repair_unused(checksum)\n  if changed:\n   warn(\n   \"encountered a bcrypt hash with incorrectly set padding bits; \"\n   \"you may want to use bcrypt.normhash() \"\n   \"to fix this; this will be an error under Passlib 2.0\",\n   PasslibHashWarning)\n  return checksum\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n _no_backend_suggestion=\" -- recommend you install one (e.g. 'pip install bcrypt')\"\n \n @classmethod\n def _finalize_backend_mixin(mixin_cls,backend,dryrun):\n  ''\n\n\n\n  \n  \n  \n  \n  assert mixin_cls is bcrypt._backend_mixin_map[backend],\\\n  \"_configure_workarounds() invoked from wrong class\"\n  \n  if mixin_cls._workrounds_initialized:\n   return True\n   \n  verify=mixin_cls.verify\n  \n  err_types=(ValueError,uh.exc.MissingBackendError)\n  if _bcryptor:\n   err_types +=(_bcryptor.engine.SaltError,)\n   \n  def safe_verify(secret,hash):\n   ''\n   try :\n    return verify(secret,hash)\n   except err_types:\n   \n   \n   \n   \n   \n   \n   \n   \n    return NotImplemented\n   except uh.exc.InternalBackendError:\n   \n   \n   \n    log.debug(\"trapped unexpected response from %r backend: verify(%r, %r):\",\n    backend,secret,hash,exc_info=True )\n    return NotImplemented\n    \n  def assert_lacks_8bit_bug(ident):\n   ''\n\n\n\n\n\n\n\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   secret=b\"\\xd1\\x91\"\n   bug_hash=ident.encode(\"ascii\")+b\"05$6bNw2HLQYeqHYyBfLMsv/OiwqTymGIGzFsA4hOTWebfehXHNprcAS\"\n   correct_hash=ident.encode(\"ascii\")+b\"05$6bNw2HLQYeqHYyBfLMsv/OUcZd0LKP39b87nBw3.S2tVZSqiQX6eu\"\n   \n   if verify(secret,bug_hash):\n   \n   \n   \n    raise PasslibSecurityError(\n    \"passlib.hash.bcrypt: Your installation of the %r backend is vulnerable to \"\n    \"the crypt_blowfish 8-bit bug (CVE-2011-2483) under %r hashes, \"\n    \"and should be upgraded or replaced with another backend\"%(backend,ident))\n    \n    \n    \n   if not verify(secret,correct_hash):\n    raise RuntimeError(\"%s backend failed to verify %s 8bit hash\"%(backend,ident))\n    \n  def detect_wrap_bug(ident):\n   ''\n\n\n\n\n\n\n\n\n\n\n   \n   \n   secret=(b\"0123456789\"*26)[:255]\n   bug_hash=ident.encode(\"ascii\")+b\"04$R1lJ2gkNaoPGdafE.H.16.nVyh2niHsGJhayOHLMiXlI45o8/DU.6\"\n   if verify(secret,bug_hash):\n    return True\n    \n    \n    \n   correct_hash=ident.encode(\"ascii\")+b\"04$R1lJ2gkNaoPGdafE.H.16.1MKHPvmKwryeulRe225LKProWYwt9Oi\"\n   if not verify(secret,correct_hash):\n    raise RuntimeError(\"%s backend failed to verify %s wraparound hash\"%(backend,ident))\n    \n   return False\n   \n  def assert_lacks_wrap_bug(ident):\n   if not detect_wrap_bug(ident):\n    return\n    \n    \n    \n   raise RuntimeError(\"%s backend unexpectedly has wraparound bug for %s\"%(backend,ident))\n   \n   \n   \n   \n  test_hash_20=b\"$2$04$5BJqKfqMQvV7nS.yUguNcuRfMMOXK0xPWavM7pOzjEi5ze5T1k8/S\"\n  result=safe_verify(\"test\",test_hash_20)\n  if result is NotImplemented:\n   mixin_cls._lacks_20_support=True\n   log.debug(\"%r backend lacks $2$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2$ hash\"%backend)\n   \n   \n   \n   \n  result=safe_verify(\"test\",TEST_HASH_2A)\n  if result is NotImplemented:\n  \n   raise RuntimeError(\"%s lacks support for $2a$ hashes\"%backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2a$ hash\"%backend)\n  else :\n   assert_lacks_8bit_bug(IDENT_2A)\n   if detect_wrap_bug(IDENT_2A):\n    if backend ==\"os_crypt\":\n    \n    \n    \n     log.debug(\"%r backend has $2a$ bsd wraparound bug, enabling workaround\",backend)\n    else :\n    \n    \n     warn(\"passlib.hash.bcrypt: Your installation of the %r backend is vulnerable to \"\n     \"the bsd wraparound bug, \"\n     \"and should be upgraded or replaced with another backend \"\n     \"(enabling workaround for now).\"%backend,\n     uh.exc.PasslibSecurityWarning)\n    mixin_cls._has_2a_wraparound_bug=True\n    \n    \n    \n    \n  test_hash_2y=TEST_HASH_2A.replace(\"2a\",\"2y\")\n  result=safe_verify(\"test\",test_hash_2y)\n  if result is NotImplemented:\n   mixin_cls._lacks_2y_support=True\n   log.debug(\"%r backend lacks $2y$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2y$ hash\"%backend)\n  else :\n  \n  \n   assert_lacks_8bit_bug(IDENT_2Y)\n   assert_lacks_wrap_bug(IDENT_2Y)\n   \n   \n   \n   \n   \n   \n   \n   \n  test_hash_2b=TEST_HASH_2A.replace(\"2a\",\"2b\")\n  result=safe_verify(\"test\",test_hash_2b)\n  if result is NotImplemented:\n   mixin_cls._lacks_2b_support=True\n   log.debug(\"%r backend lacks $2b$ support, enabling workaround\",backend)\n  elif not result:\n   raise RuntimeError(\"%s incorrectly rejected $2b$ hash\"%backend)\n  else :\n   mixin_cls._fallback_ident=IDENT_2B\n   assert_lacks_8bit_bug(IDENT_2B)\n   assert_lacks_wrap_bug(IDENT_2B)\n   \n   \n  mixin_cls._workrounds_initialized=True\n  return True\n  \n  \n  \n  \n  \n  \n  \n def _prepare_digest_args(self,secret):\n  ''\n\n\n  \n  return self._norm_digest_args(secret,self.ident,new=self.use_defaults)\n  \n @classmethod\n def _norm_digest_args(cls,secret,ident,new=False ):\n \n  require_valid_utf8_bytes=cls._require_valid_utf8_bytes\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  elif require_valid_utf8_bytes:\n  \n  \n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n   \n   \n    require_valid_utf8_bytes=False\n    \n    \n  uh.validate_secret(secret)\n  \n  \n  if new:\n   cls._check_truncate_policy(secret)\n   \n   \n   \n   \n  if _BNULL in secret:\n   raise uh.exc.NullPasswordError(cls)\n   \n   \n   \n   \n   \n   \n  if cls._has_2a_wraparound_bug and len(secret)>=255:\n   if require_valid_utf8_bytes:\n   \n   \n   \n   \n   \n    secret=utf8_truncate(secret,72)\n   else :\n    secret=secret[:72]\n    \n    \n  if ident ==IDENT_2A:\n  \n   pass\n   \n  elif ident ==IDENT_2B:\n   if cls._lacks_2b_support:\n   \n   \n   \n   \n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2Y:\n   if cls._lacks_2y_support:\n   \n   \n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2:\n   if cls._lacks_20_support:\n   \n   \n   \n    if secret:\n     if require_valid_utf8_bytes:\n     \n     \n     \n      secret=utf8_repeat_string(secret,72)\n     else :\n      secret=repeat_string(secret,72)\n    ident=cls._fallback_ident\n    \n  elif ident ==IDENT_2X:\n  \n  \n  \n   raise RuntimeError(\"$2x$ hashes not currently supported by passlib\")\n   \n  else :\n   raise AssertionError(\"unexpected ident value: %r\"%ident)\n   \n  return secret,ident\n  \n  \n  \n  \nclass _NoBackend(_BcryptCommon):\n ''\n\n\n \n \n \n \n def _calc_checksum(self,secret):\n  self._stub_requires_backend()\n  \n  \n  return super(bcrypt,self)._calc_checksum(secret)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _BcryptBackend(_BcryptCommon):\n ''\n\n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _bcrypt\n  if _detect_pybcrypt():\n  \n   return False\n  try :\n   import bcrypt as _bcrypt\n  except ImportError:\n   return False\n  try :\n   version=_bcrypt.__about__.__version__\n  except :\n   log.warning(\"(trapped) error reading bcrypt version\",exc_info=True )\n   version='<unknown>'\n   \n  log.debug(\"detected 'bcrypt' backend, version %r\",version)\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  if isinstance(config,unicode):\n   config=config.encode(\"ascii\")\n  hash=_bcrypt.hashpw(secret,config)\n  assert isinstance(hash,bytes)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"`bcrypt` package\")\n  return hash[-31:].decode(\"ascii\")\n  \n  \n  \n  \nclass _BcryptorBackend(_BcryptCommon):\n ''\n\n \n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _bcryptor\n  try :\n   import bcryptor as _bcryptor\n  except ImportError:\n   return False\n   \n   \n  if not dryrun:\n   warn(\"Support for `bcryptor` is deprecated, and will be removed in Passlib 1.8; \"\n   \"Please use `pip install bcrypt` instead\",DeprecationWarning)\n   \n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=_bcryptor.engine.Engine(False ).hash_key(secret,config)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"bcryptor library\")\n  return str_to_uascii(hash[-31:])\n  \n  \n  \n  \nclass _PyBcryptBackend(_BcryptCommon):\n ''\n\n \n \n \n _calc_lock=None\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n \n  global _pybcrypt\n  if not _detect_pybcrypt():\n  \n   return False\n  try :\n   import bcrypt as _pybcrypt\n  except ImportError:\n  \n   return False\n   \n   \n  if not dryrun:\n   warn(\"Support for `py-bcrypt` is deprecated, and will be removed in Passlib 1.8; \"\n   \"Please use `pip install bcrypt` instead\",DeprecationWarning)\n   \n   \n  try :\n   version=_pybcrypt._bcrypt.__version__\n  except :\n   log.warning(\"(trapped) error reading pybcrypt version\",exc_info=True )\n   version=\"<unknown>\"\n  log.debug(\"detected 'pybcrypt' backend, version %r\",version)\n  \n  \n  vinfo=parse_version(version)or (0,0)\n  if vinfo <(0,3):\n   warn(\"py-bcrypt %s has a major security vulnerability, \"\n   \"you should upgrade to py-bcrypt 0.3 immediately.\"\n   %version,uh.exc.PasslibSecurityWarning)\n   if mixin_cls._calc_lock is None :\n    import threading\n    mixin_cls._calc_lock=threading.Lock()\n   mixin_cls._calc_checksum=get_unbound_method_function(mixin_cls._calc_checksum_threadsafe)\n   \n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum_threadsafe(self,secret):\n \n \n \n  with self._calc_lock:\n   return self._calc_checksum_raw(secret)\n   \n def _calc_checksum_raw(self,secret):\n \n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=_pybcrypt.hashpw(secret,config)\n  if not hash.startswith(config)or len(hash)!=len(config)+31:\n   raise uh.exc.CryptBackendError(self,config,hash,source=\"pybcrypt library\")\n  return str_to_uascii(hash[-31:])\n  \n _calc_checksum=_calc_checksum_raw\n \n \n \n \nclass _OsCryptBackend(_BcryptCommon):\n ''\n\n \n \n \n \n _require_valid_utf8_bytes=not crypt_accepts_bytes\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n  if not test_crypt(\"test\",TEST_HASH_2A):\n   return False\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n \n \n \n \n  secret,ident=self._prepare_digest_args(secret)\n  config=self._get_config(ident)\n  hash=safe_crypt(secret,config)\n  if hash is not None :\n   if not hash.startswith(config)or len(hash)!=len(config)+31:\n    raise uh.exc.CryptBackendError(self,config,hash)\n   return hash[-31:]\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if PY3 and isinstance(secret,bytes):\n   try :\n    secret.decode(\"utf-8\")\n   except UnicodeDecodeError:\n    raise error_from(uh.exc.PasswordValueError(\n    \"python3 crypt.crypt() ony supports bytes passwords using UTF8; \"\n    \"passlib recommends running `pip install bcrypt` for general bcrypt support.\",\n    ),None )\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n  debug_only_repr=uh.exc.debug_only_repr\n  raise uh.exc.InternalBackendError(\n  \"crypt.crypt() failed for unknown reason; \"\n  \"passlib recommends running `pip install bcrypt` for general bcrypt support.\"\n  \n  \"(config=%s, secret=%s)\"%(debug_only_repr(config),debug_only_repr(secret)),\n  )\n  \n  \n  \n  \nclass _BuiltinBackend(_BcryptCommon):\n ''\n\n \n @classmethod\n def _load_backend_mixin(mixin_cls,name,dryrun):\n  from passlib.utils import as_bool\n  if not as_bool(os.environ.get(\"PASSLIB_BUILTIN_BCRYPT\")):\n   log.debug(\"bcrypt 'builtin' backend not enabled via $PASSLIB_BUILTIN_BCRYPT\")\n   return False\n  global _builtin_bcrypt\n  from passlib.crypto._blowfish import raw_bcrypt as _builtin_bcrypt\n  return mixin_cls._finalize_backend_mixin(name,dryrun)\n  \n def _calc_checksum(self,secret):\n  secret,ident=self._prepare_digest_args(secret)\n  chk=_builtin_bcrypt(secret,ident[1:-1],\n  self.salt.encode(\"ascii\"),self.rounds)\n  return chk.decode(\"ascii\")\n  \n  \n  \n  \nclass bcrypt(_NoBackend,_BcryptCommon):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n backends=(\"bcrypt\",\"pybcrypt\",\"bcryptor\",\"os_crypt\",\"builtin\")\n \n \n _backend_mixin_target=True\n \n \n _backend_mixin_map={\n None :_NoBackend,\n \"bcrypt\":_BcryptBackend,\n \"pybcrypt\":_PyBcryptBackend,\n \"bcryptor\":_BcryptorBackend,\n \"os_crypt\":_OsCryptBackend,\n \"builtin\":_BuiltinBackend,\n }\n \n \n \n \n \n \n \n \n_UDOLLAR=u(\"$\")\n\n\n\nclass _wrapped_bcrypt(bcrypt):\n ''\n\n\n\n \n setting_kwds=tuple(elem for elem in bcrypt.setting_kwds if elem not in [\"truncate_error\"])\n truncate_size=None\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n @classmethod\n def _check_truncate_policy(cls,secret):\n \n  pass\n  \n  \n  \n  \n  \nclass bcrypt_sha256(_wrapped_bcrypt):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"bcrypt_sha256\"\n \n \n \n \n \n ident_values=(IDENT_2A,IDENT_2B)\n \n \n ident_aliases=(lambda ident_values:dict(item for item in bcrypt.ident_aliases.items()\n if item[1]in ident_values))(ident_values)\n default_ident=IDENT_2B\n \n \n \n \n \n _supported_versions=set([1,2])\n \n \n \n \n \n \n \n \n version=2\n \n \n \n \n \n @classmethod\n def using(cls,version=None ,**kwds):\n  subcls=super(bcrypt_sha256,cls).using(**kwds)\n  if version is not None :\n   subcls.version=subcls._norm_version(version)\n  ident=subcls.default_ident\n  if subcls.version >1 and ident !=IDENT_2B:\n   raise ValueError(\"bcrypt %r hashes not allowed for version %r\"%\n   (ident,subcls.version))\n  return subcls\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n prefix=u('$bcrypt-sha256$')\n \n \n _v2_hash_re=re.compile(r\"\"\"(?x)\n        ^\n        [$]bcrypt-sha256[$]\n        v=(?P<version>\\d+),\n        t=(?P<type>2b),\n        r=(?P<rounds>\\d{1,2})\n        [$](?P<salt>[^$]{22})\n        (?:[$](?P<digest>[^$]{31}))?\n        $\n        \"\"\")\n \n \n _v1_hash_re=re.compile(r\"\"\"(?x)\n        ^\n        [$]bcrypt-sha256[$]\n        (?P<type>2[ab]),\n        (?P<rounds>\\d{1,2})\n        [$](?P<salt>[^$]{22})\n        (?:[$](?P<digest>[^$]{31}))?\n        $\n        \"\"\")\n \n @classmethod\n def identify(cls,hash):\n  hash=uh.to_unicode_for_identify(hash)\n  if not hash:\n   return False\n  return hash.startswith(cls.prefix)\n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  if not hash.startswith(cls.prefix):\n   raise uh.exc.InvalidHashError(cls)\n  m=cls._v2_hash_re.match(hash)\n  if m:\n   version=int(m.group(\"version\"))\n   if version <2:\n    raise uh.exc.MalformedHashError(cls)\n  else :\n   m=cls._v1_hash_re.match(hash)\n   if m:\n    version=1\n   else :\n    raise uh.exc.MalformedHashError(cls)\n  rounds=m.group(\"rounds\")\n  if rounds.startswith(uh._UZERO)and rounds !=uh._UZERO:\n   raise uh.exc.ZeroPaddedRoundsError(cls)\n  return cls(\n  version=version,\n  ident=m.group(\"type\"),\n  rounds=int(rounds),\n  salt=m.group(\"salt\"),\n  checksum=m.group(\"digest\"),\n  )\n  \n _v2_template=u(\"$bcrypt-sha256$v=2,t=%s,r=%d$%s$%s\")\n _v1_template=u(\"$bcrypt-sha256$%s,%d$%s$%s\")\n \n def to_string(self):\n  if self.version ==1:\n   template=self._v1_template\n  else :\n   template=self._v2_template\n  hash=template %(self.ident.strip(_UDOLLAR),self.rounds,self.salt,self.checksum)\n  return uascii_to_str(hash)\n  \n  \n  \n  \n  \n def __init__(self,version=None ,**kwds):\n  if version is not None :\n   self.version=self._norm_version(version)\n  super(bcrypt_sha256,self).__init__(**kwds)\n  \n  \n  \n  \n  \n @classmethod\n def _norm_version(cls,version):\n  if version not in cls._supported_versions:\n   raise ValueError(\"%s: unknown or unsupported version: %r\"%(cls.name,version))\n  return version\n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n \n \n \n \n \n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n  if self.version ==1:\n  \n  \n  \n   digest=sha256(secret).digest()\n  else :\n  \n  \n  \n  \n  \n  \n  \n  \n   salt=self.salt\n   if salt[-1]not in self.final_salt_chars:\n   \n   \n   \n    raise ValueError(\"invalid salt string\")\n   digest=compile_hmac(\"sha256\",salt.encode(\"ascii\"))(secret)\n   \n   \n   \n  key=b64encode(digest)\n  \n  \n  return super(bcrypt_sha256,self)._calc_checksum(key)\n  \n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n  if self.version <type(self).version:\n   return True\n  return super(bcrypt_sha256,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n  \n  \n  \n  \n", ["__future__", "base64", "bcrypt", "bcrypt._bcrypt", "bcryptor", "hashlib", "logging", "os", "passlib.crypto._blowfish", "passlib.crypto.digest", "passlib.exc", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers", "re", "threading", "warnings"]], "passlib.hash.windows": [".py", "''\n\n\n\n\nfrom binascii import hexlify\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_unicode,right_pad_string\nfrom passlib.utils.compat import unicode\nfrom passlib.crypto.digest import lookup_hash\nmd4=lookup_hash(\"md4\").const\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"lmhash\",\n\"nthash\",\n\"bsd_nthash\",\n\"msdcc\",\n\"msdcc2\",\n]\n\n\n\n\nclass lmhash(uh.TruncateMixin,uh.HasEncodingContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n name=\"lmhash\"\n setting_kwds=(\"truncate_error\",)\n \n \n \n \n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n truncate_size=14\n \n \n \n \n default_encoding=\"cp437\"\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n \n  if self.use_defaults:\n   self._check_truncate_policy(secret)\n   \n  return hexlify(self.raw(secret,self.encoding)).decode(\"ascii\")\n  \n  \n _magic=b\"KGS!@#$%\"\n \n @classmethod\n def raw(cls,secret,encoding=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not encoding:\n   encoding=cls.default_encoding\n   \n   \n   \n  from passlib.crypto.des import des_encrypt_block\n  MAGIC=cls._magic\n  if isinstance(secret,unicode):\n  \n  \n  \n   secret=secret.upper().encode(encoding)\n  elif isinstance(secret,bytes):\n  \n  \n  \n  \n   secret=secret.upper()\n  else :\n   raise TypeError(\"secret must be unicode or bytes\")\n  secret=right_pad_string(secret,14)\n  return des_encrypt_block(secret[0:7],MAGIC)+\\\n  des_encrypt_block(secret[7:14],MAGIC)\n  \n  \n  \n  \n  \n  \n  \n  \nclass nthash(uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n \n \n \n \n name=\"nthash\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret):\n  ''\n\n\n\n\n  \n  secret=to_unicode(secret,\"utf-8\",param=\"secret\")\n  \n  return md4(secret.encode(\"utf-16-le\")).digest()\n  \n @classmethod\n def raw_nthash(cls,secret,hex=False ):\n  warn(\"nthash.raw_nthash() is deprecated, and will be removed \"\n  \"in Passlib 1.8, please use nthash.raw() instead\",\n  DeprecationWarning)\n  ret=nthash.raw(secret)\n  return hexlify(ret).decode(\"ascii\")if hex else ret\n  \n  \n  \n  \n  \nbsd_nthash=uh.PrefixWrapper(\"bsd_nthash\",nthash,prefix=\"$3$$\",ident=\"$3$$\",\ndoc=\"\"\"The class support FreeBSD's representation of NTHASH\n    (which is compatible with the :ref:`modular-crypt-format`),\n    and follows the :ref:`password-hash-api`.\n\n    It has no salt and a single fixed round.\n\n    The :meth:`~passlib.ifc.PasswordHash.hash` and :meth:`~passlib.ifc.PasswordHash.genconfig` methods accept no optional keywords.\n    \"\"\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass msdcc(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"msdcc\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret,self.user)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret,user):\n  ''\n\n\n\n\n\n  \n  secret=to_unicode(secret,\"utf-8\",param=\"secret\").encode(\"utf-16-le\")\n  user=to_unicode(user,\"utf-8\",param=\"user\").lower().encode(\"utf-16-le\")\n  return md4(md4(secret).digest()+user).digest()\n  \n  \n  \n  \nclass msdcc2(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"msdcc2\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=32\n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n  return hexlify(self.raw(secret,self.user)).decode(\"ascii\")\n  \n @classmethod\n def raw(cls,secret,user):\n  ''\n\n\n\n\n\n\n\n\n  \n  from passlib.crypto.digest import pbkdf2_hmac\n  secret=to_unicode(secret,\"utf-8\",param=\"secret\").encode(\"utf-16-le\")\n  user=to_unicode(user,\"utf-8\",param=\"user\").lower().encode(\"utf-16-le\")\n  tmp=md4(md4(secret).digest()+user).digest()\n  return pbkdf2_hmac(\"sha1\",tmp,user,10240,16)\n  \n  \n  \n  \n", ["binascii", "logging", "passlib.crypto.des", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "warnings"]], "passlib.hash.oracle": [".py", "''\n\n\n\n\nfrom binascii import hexlify,unhexlify\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode,xor_bytes\nfrom passlib.utils.compat import irange,u,\\\nuascii_to_str,unicode,str_to_uascii\nfrom passlib.crypto.des import des_encrypt_block\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"oracle10g\",\n\"oracle11g\"\n]\n\n\n\n\ndef des_cbc_encrypt(key,value,iv=b'\\x00'*8,pad=b'\\x00'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n value +=pad *(-len(value)%8)\n hash=iv\n for offset in irange(0,len(value),8):\n  chunk=xor_bytes(hash,value[offset:offset+8])\n  hash=des_encrypt_block(key,chunk)\n return hash\n \n \nORACLE10_MAGIC=b\"\\x01\\x23\\x45\\x67\\x89\\xAB\\xCD\\xEF\"\n\nclass oracle10(uh.HasUserContext,uh.StaticHandler):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"oracle10\"\n checksum_chars=uh.HEX_CHARS\n checksum_size=16\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.upper()\n  \n def _calc_checksum(self,secret):\n \n \n \n \n \n \n \n \n \n \n \n  if isinstance(secret,bytes):\n   secret=secret.decode(\"utf-8\")\n  user=to_unicode(self.user,\"utf-8\",param=\"user\")\n  input=(user+secret).upper().encode(\"utf-16-be\")\n  hash=des_cbc_encrypt(ORACLE10_MAGIC,input)\n  hash=des_cbc_encrypt(hash,input)\n  return hexlify(hash).decode(\"ascii\").upper()\n  \n  \n  \n  \n  \n  \n  \n  \nclass oracle11(uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n name=\"oracle11\"\n setting_kwds=(\"salt\",)\n checksum_size=40\n checksum_chars=uh.UPPER_HEX_CHARS\n \n \n min_salt_size=max_salt_size=20\n salt_chars=uh.UPPER_HEX_CHARS\n \n \n \n \n \n _hash_regex=re.compile(u(\"^S:(?P<chk>[0-9a-f]{40})(?P<salt>[0-9a-f]{20})$\"),re.I)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  salt,chk=m.group(\"salt\",\"chk\")\n  return cls(salt=salt,checksum=chk.upper())\n  \n def to_string(self):\n  chk=self.checksum\n  hash=u(\"S:%s%s\")%(chk.upper(),self.salt.upper())\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=sha1(secret+unhexlify(self.salt.encode(\"ascii\"))).hexdigest()\n  return str_to_uascii(chk).upper()\n  \n  \n  \n  \n  \n  \n  \n  \n", ["binascii", "hashlib", "logging", "passlib.crypto.des", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re"]], "passlib.hash.ldap_digests": [".py", "''\n\n\n\n\n\nfrom base64 import b64encode,b64decode\nfrom hashlib import md5,sha1,sha256,sha512\nimport logging ;log=logging.getLogger(__name__)\nimport re\n\n\nfrom passlib.handlers.misc import plaintext\nfrom passlib.utils import unix_crypt_schemes,to_unicode\nfrom passlib.utils.compat import uascii_to_str,unicode,u\nfrom passlib.utils.decor import classproperty\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"ldap_plaintext\",\n\"ldap_md5\",\n\"ldap_sha1\",\n\"ldap_salted_md5\",\n\"ldap_salted_sha1\",\n\"ldap_salted_sha256\",\n\"ldap_salted_sha512\",\n\n\n\"ldap_des_crypt\",\n\"ldap_bsdi_crypt\",\n\"ldap_md5_crypt\",\n\"ldap_sha1_crypt\",\n\"ldap_bcrypt\",\n\"ldap_sha256_crypt\",\n\"ldap_sha512_crypt\",\n]\n\n\n\n\nclass _Base64DigestHelper(uh.StaticHandler):\n ''\n \n \n ident=None\n _hash_func=None\n _hash_regex=None\n checksum_chars=uh.PADDED_BASE64_CHARS\n \n @classproperty\n def _hash_prefix(cls):\n  ''\n  return cls.ident\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  chk=self._hash_func(secret).digest()\n  return b64encode(chk).decode(\"ascii\")\n  \nclass _SaltedBase64DigestHelper(uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n setting_kwds=(\"salt\",\"salt_size\")\n checksum_chars=uh.PADDED_BASE64_CHARS\n \n ident=None\n _hash_func=None\n _hash_regex=None\n min_salt_size=max_salt_size=4\n \n \n \n \n min_salt_size=4\n default_salt_size=4\n max_salt_size=16\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  try :\n   data=b64decode(m.group(\"tmp\").encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n  cs=cls.checksum_size\n  assert cs\n  return cls(checksum=data[:cs],salt=data[cs:])\n  \n def to_string(self):\n  data=self.checksum+self.salt\n  hash=self.ident+b64encode(data).decode(\"ascii\")\n  return uascii_to_str(hash)\n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return self._hash_func(secret+self.salt).digest()\n  \n  \n  \n  \nclass ldap_md5(_Base64DigestHelper):\n ''\n\n\n \n name=\"ldap_md5\"\n ident=u(\"{MD5}\")\n _hash_func=md5\n _hash_regex=re.compile(u(r\"^\\{MD5\\}(?P<chk>[+/a-zA-Z0-9]{22}==)$\"))\n \nclass ldap_sha1(_Base64DigestHelper):\n ''\n\n\n \n name=\"ldap_sha1\"\n ident=u(\"{SHA}\")\n _hash_func=sha1\n _hash_regex=re.compile(u(r\"^\\{SHA\\}(?P<chk>[+/a-zA-Z0-9]{27}=)$\"))\n \nclass ldap_salted_md5(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_md5\"\n ident=u(\"{SMD5}\")\n checksum_size=16\n _hash_func=md5\n _hash_regex=re.compile(u(r\"^\\{SMD5\\}(?P<tmp>[+/a-zA-Z0-9]{27,}={0,2})$\"))\n \nclass ldap_salted_sha1(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha1\"\n ident=u(\"{SSHA}\")\n checksum_size=20\n _hash_func=sha1\n \n _hash_regex=re.compile(u(r\"^\\{SSHA\\}(?P<tmp>[+/a-zA-Z0-9]{32,}={0,2})$\"))\n \n \n \nclass ldap_salted_sha256(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha256\"\n ident=u(\"{SSHA256}\")\n checksum_size=32\n default_salt_size=8\n _hash_func=sha256\n \n _hash_regex=re.compile(u(r\"^\\{SSHA256\\}(?P<tmp>[+/a-zA-Z0-9]{48,}={0,2})$\"))\n \n \nclass ldap_salted_sha512(_SaltedBase64DigestHelper):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n name=\"ldap_salted_sha512\"\n ident=u(\"{SSHA512}\")\n checksum_size=64\n default_salt_size=8\n _hash_func=sha512\n \n _hash_regex=re.compile(u(r\"^\\{SSHA512\\}(?P<tmp>[+/a-zA-Z0-9]{91,}={0,2})$\"))\n \n \nclass ldap_plaintext(plaintext):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n name=\"ldap_plaintext\"\n _2307_pat=re.compile(u(r\"^\\{\\w+\\}.*$\"))\n \n @uh.deprecated_method(deprecated=\"1.7\",removed=\"2.0\")\n @classmethod\n def genconfig(cls):\n \n \n  return \"!\"\n  \n @classmethod\n def identify(cls,hash):\n \n  hash=uh.to_unicode_for_identify(hash)\n  return bool(hash)and cls._2307_pat.match(hash)is None\n  \n  \n  \n  \n  \n  \nldap_crypt_schemes=['ldap_'+name for name in unix_crypt_schemes]\n\ndef _init_ldap_crypt_handlers():\n\n\n g=globals()\n for wname in unix_crypt_schemes:\n  name='ldap_'+wname\n  g[name]=uh.PrefixWrapper(name,wname,prefix=u(\"{CRYPT}\"),lazy=True )\n del g\n_init_ldap_crypt_handlers()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ["base64", "hashlib", "logging", "passlib.handlers.misc", "passlib.utils", "passlib.utils.compat", "passlib.utils.decor", "passlib.utils.handlers", "re"]], "passlib.hash.scram": [".py", "''\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import consteq,saslprep,to_native_str,splitcomma\nfrom passlib.utils.binary import ab64_decode,ab64_encode\nfrom passlib.utils.compat import bascii_to_str,iteritems,u,native_string_types\nfrom passlib.crypto.digest import pbkdf2_hmac,norm_hash_name\nimport passlib.utils.handlers as uh\n\n__all__=[\n\"scram\",\n]\n\n\n\n\nclass scram(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n name=\"scram\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\",\"algs\")\n ident=u(\"$scram$\")\n \n \n default_salt_size=12\n max_salt_size=1024\n \n \n default_rounds=100000\n min_rounds=1\n max_rounds=2 **32 -1\n rounds_cost=\"linear\"\n \n \n \n \n default_algs=[\"sha-1\",\"sha-256\",\"sha-512\"]\n \n \n _verify_algs=[\"sha-256\",\"sha-512\",\"sha-224\",\"sha-384\",\"sha-1\"]\n \n \n \n \n \n \n \n \n \n \n algs=None\n \n \n \n \n @classmethod\n def extract_digest_info(cls,hash,alg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  alg=norm_hash_name(alg,'iana')\n  self=cls.from_string(hash)\n  chkmap=self.checksum\n  if not chkmap:\n   raise ValueError(\"scram hash contains no digests\")\n  return self.salt,self.rounds,chkmap[alg]\n  \n @classmethod\n def extract_digest_algs(cls,hash,format=\"iana\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  algs=cls.from_string(hash).algs\n  if format ==\"iana\":\n   return algs\n  else :\n   return [norm_hash_name(alg,format)for alg in algs]\n   \n @classmethod\n def derive_digest(cls,password,salt,rounds,alg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(password,bytes):\n   password=password.decode(\"utf-8\")\n   \n   \n  return pbkdf2_hmac(alg,saslprep(password),salt,rounds)\n  \n  \n  \n  \n  \n @classmethod\n def from_string(cls,hash):\n  hash=to_native_str(hash,\"ascii\",\"hash\")\n  if not hash.startswith(\"$scram$\"):\n   raise uh.exc.InvalidHashError(cls)\n  parts=hash[7:].split(\"$\")\n  if len(parts)!=3:\n   raise uh.exc.MalformedHashError(cls)\n  rounds_str,salt_str,chk_str=parts\n  \n  \n  rounds=int(rounds_str)\n  if rounds_str !=str(rounds):\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  try :\n   salt=ab64_decode(salt_str.encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n   \n   \n  if not chk_str:\n  \n   raise uh.exc.MalformedHashError(cls)\n  elif \"=\"in chk_str:\n  \n   algs=None\n   chkmap={}\n   for pair in chk_str.split(\",\"):\n    alg,digest=pair.split(\"=\")\n    try :\n     chkmap[alg]=ab64_decode(digest.encode(\"ascii\"))\n    except TypeError:\n     raise uh.exc.MalformedHashError(cls)\n  else :\n  \n   algs=chk_str\n   chkmap=None\n   \n   \n  return cls(\n  rounds=rounds,\n  salt=salt,\n  checksum=chkmap,\n  algs=algs,\n  )\n  \n def to_string(self):\n  salt=bascii_to_str(ab64_encode(self.salt))\n  chkmap=self.checksum\n  chk_str=\",\".join(\n  \"%s=%s\"%(alg,bascii_to_str(ab64_encode(chkmap[alg])))\n  for alg in self.algs\n  )\n  return '$scram$%d$%s$%s'%(self.rounds,salt,chk_str)\n  \n  \n  \n  \n @classmethod\n def using(cls,default_algs=None ,algs=None ,**kwds):\n \n  if algs is not None :\n   assert default_algs is None\n   default_algs=algs\n   \n   \n  subcls=super(scram,cls).using(**kwds)\n  \n  \n  if default_algs is not None :\n   subcls.default_algs=cls._norm_algs(default_algs)\n  return subcls\n  \n  \n  \n  \n def __init__(self,algs=None ,**kwds):\n  super(scram,self).__init__(**kwds)\n  \n  \n  digest_map=self.checksum\n  if algs is not None :\n   if digest_map is not None :\n    raise RuntimeError(\"checksum & algs kwds are mutually exclusive\")\n   algs=self._norm_algs(algs)\n  elif digest_map is not None :\n  \n   algs=self._norm_algs(digest_map.keys())\n  elif self.use_defaults:\n   algs=list(self.default_algs)\n   assert self._norm_algs(algs)==algs,\"invalid default algs: %r\"%(algs,)\n  else :\n   raise TypeError(\"no algs list specified\")\n  self.algs=algs\n  \n def _norm_checksum(self,checksum,relaxed=False ):\n  if not isinstance(checksum,dict):\n   raise uh.exc.ExpectedTypeError(checksum,\"dict\",\"checksum\")\n  for alg,digest in iteritems(checksum):\n   if alg !=norm_hash_name(alg,'iana'):\n    raise ValueError(\"malformed algorithm name in scram hash: %r\"%\n    (alg,))\n   if len(alg)>9:\n    raise ValueError(\"SCRAM limits algorithm names to \"\n    \"9 characters: %r\"%(alg,))\n   if not isinstance(digest,bytes):\n    raise uh.exc.ExpectedTypeError(digest,\"raw bytes\",\"digests\")\n    \n  if 'sha-1'not in checksum:\n  \n   raise ValueError(\"sha-1 must be in algorithm list of scram hash\")\n  return checksum\n  \n @classmethod\n def _norm_algs(cls,algs):\n  ''\n  if isinstance(algs,native_string_types):\n   algs=splitcomma(algs)\n  algs=sorted(norm_hash_name(alg,'iana')for alg in algs)\n  if any(len(alg)>9 for alg in algs):\n   raise ValueError(\"SCRAM limits alg names to max of 9 characters\")\n  if 'sha-1'not in algs:\n  \n   raise ValueError(\"sha-1 must be in algorithm list of scram hash\")\n  return algs\n  \n  \n  \n  \n def _calc_needs_update(self,**kwds):\n \n \n \n  if not set(self.algs).issuperset(self.default_algs):\n   return True\n   \n   \n  return super(scram,self)._calc_needs_update(**kwds)\n  \n  \n  \n  \n def _calc_checksum(self,secret,alg=None ):\n  rounds=self.rounds\n  salt=self.salt\n  hash=self.derive_digest\n  if alg:\n  \n   return hash(secret,salt,rounds,alg)\n  else :\n  \n   return dict(\n   (alg,hash(secret,salt,rounds,alg))\n   for alg in self.algs\n   )\n   \n @classmethod\n def verify(cls,secret,hash,full=False ):\n  uh.validate_secret(secret)\n  self=cls.from_string(hash)\n  chkmap=self.checksum\n  if not chkmap:\n   raise ValueError(\"expected %s hash, got %s config string instead\"%\n   (cls.name,cls.name))\n   \n   \n   \n   \n  if full:\n   correct=failed=False\n   for alg,digest in iteritems(chkmap):\n    other=self._calc_checksum(secret,alg)\n    \n    \n    \n    \n    if len(digest)!=len(other):\n     raise ValueError(\"mis-sized %s digest in scram hash: %r != %r\"\n     %(alg,len(digest),len(other)))\n    if consteq(other,digest):\n     correct=True\n    else :\n     failed=True\n   if correct and failed:\n    raise ValueError(\"scram hash verified inconsistently, \"\n    \"may be corrupted\")\n   else :\n    return correct\n  else :\n  \n  \n   for alg in self._verify_algs:\n    if alg in chkmap:\n     other=self._calc_checksum(secret,alg)\n     return consteq(other,chkmap[alg])\n     \n     \n   raise AssertionError(\"sha-1 digest not found!\")\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n", ["logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.sha1_crypt": [".py", "''\n\n\n\n\n\n\n\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import safe_crypt,test_crypt\nfrom passlib.utils.binary import h64\nfrom passlib.utils.compat import u,unicode,irange\nfrom passlib.crypto.digest import compile_hmac\nimport passlib.utils.handlers as uh\n\n__all__=[\n]\n\n\n\n_BNULL=b'\\x00'\n\nclass sha1_crypt(uh.HasManyBackends,uh.HasRounds,uh.HasSalt,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"sha1_crypt\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\")\n ident=u(\"$sha1$\")\n checksum_size=28\n checksum_chars=uh.HASH64_CHARS\n \n \n default_salt_size=8\n max_salt_size=64\n salt_chars=uh.HASH64_CHARS\n \n \n default_rounds=480000\n min_rounds=1\n max_rounds=4294967295\n rounds_cost=\"linear\"\n \n \n \n \n @classmethod\n def from_string(cls,hash):\n  rounds,salt,chk=uh.parse_mc3(hash,cls.ident,handler=cls)\n  return cls(rounds=rounds,salt=salt,checksum=chk)\n  \n def to_string(self,config=False ):\n  chk=None if config else self.checksum\n  return uh.render_mc3(self.ident,self.rounds,self.salt,chk)\n  \n  \n  \n  \n backends=(\"os_crypt\",\"builtin\")\n \n \n \n \n @classmethod\n def _load_backend_os_crypt(cls):\n  if test_crypt(\"test\",'$sha1$1$Wq3GL2Vp$C8U25GvfHS8qGHim'\n  'ExLaiSFlGkAe'):\n   cls._set_calc_checksum_backend(cls._calc_checksum_os_crypt)\n   return True\n  else :\n   return False\n   \n def _calc_checksum_os_crypt(self,secret):\n  config=self.to_string(config=True )\n  hash=safe_crypt(secret,config)\n  if hash is None :\n  \n  \n   return self._calc_checksum_builtin(secret)\n  if not hash.startswith(config)or len(hash)!=len(config)+29:\n   raise uh.exc.CryptBackendError(self,config,hash)\n  return hash[-28:]\n  \n  \n  \n  \n @classmethod\n def _load_backend_builtin(cls):\n  cls._set_calc_checksum_backend(cls._calc_checksum_builtin)\n  return True\n  \n def _calc_checksum_builtin(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  if _BNULL in secret:\n   raise uh.exc.NullPasswordError(self)\n  rounds=self.rounds\n  \n  result=(u(\"%s$sha1$%s\")%(self.salt,rounds)).encode(\"ascii\")\n  \n  keyed_hmac=compile_hmac(\"sha1\",secret)\n  for _ in irange(rounds):\n   result=keyed_hmac(result)\n  return h64.encode_transposed_bytes(result,self._chk_offsets).decode(\"ascii\")\n  \n _chk_offsets=[\n 2,1,0,\n 5,4,3,\n 8,7,6,\n 11,10,9,\n 14,13,12,\n 17,16,15,\n 0,19,18,\n ]\n \n \n \n \n \n \n \n \n", ["logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.binary", "passlib.utils.compat", "passlib.utils.handlers"]], "passlib.hash.mysql": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom hashlib import sha1\nimport re\nimport logging ;log=logging.getLogger(__name__)\nfrom warnings import warn\n\n\nfrom passlib.utils import to_native_str\nfrom passlib.utils.compat import bascii_to_str,unicode,u,\\\nbyte_elem_value,str_to_uascii\nimport passlib.utils.handlers as uh\n\n__all__=[\n'mysql323',\n'mysq41',\n]\n\n\n\n\nclass mysql323(uh.StaticHandler):\n ''\n\n\n\n\n \n \n \n \n name=\"mysql323\"\n checksum_size=16\n checksum_chars=uh.HEX_CHARS\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.lower()\n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n  MASK_32=0xffffffff\n  MASK_31=0x7fffffff\n  WHITE=b' \\t'\n  \n  nr1=0x50305735\n  nr2=0x12345671\n  add=7\n  for c in secret:\n   if c in WHITE:\n    continue\n   tmp=byte_elem_value(c)\n   nr1 ^=((((nr1&63)+add)*tmp)+(nr1 <<8))&MASK_32\n   nr2=(nr2+((nr2 <<8)^nr1))&MASK_32\n   add=(add+tmp)&MASK_32\n  return u(\"%08x%08x\")%(nr1&MASK_31,nr2&MASK_31)\n  \n  \n  \n  \n  \n  \n  \n  \nclass mysql41(uh.StaticHandler):\n ''\n\n\n\n\n \n \n \n \n name=\"mysql41\"\n _hash_prefix=u(\"*\")\n checksum_chars=uh.HEX_CHARS\n checksum_size=40\n \n \n \n \n @classmethod\n def _norm_hash(cls,hash):\n  return hash.upper()\n  \n def _calc_checksum(self,secret):\n \n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n  return str_to_uascii(sha1(sha1(secret).digest()).hexdigest()).upper()\n  \n  \n  \n  \n  \n  \n  \n  \n", ["hashlib", "logging", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re", "warnings"]], "passlib.hash.fshp": [".py", "''\n\n\n\n\n\n\nfrom base64 import b64encode,b64decode\nimport re\nimport logging ;log=logging.getLogger(__name__)\n\n\nfrom passlib.utils import to_unicode\nimport passlib.utils.handlers as uh\nfrom passlib.utils.compat import bascii_to_str,iteritems,u,\\\nunicode\nfrom passlib.crypto.digest import pbkdf1\n\n__all__=[\n'fshp',\n]\n\n\n\nclass fshp(uh.HasRounds,uh.HasRawSalt,uh.HasRawChecksum,uh.GenericHandler):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n name=\"fshp\"\n setting_kwds=(\"salt\",\"salt_size\",\"rounds\",\"variant\")\n checksum_chars=uh.PADDED_BASE64_CHARS\n ident=u(\"{FSHP\")\n \n \n \n default_salt_size=16\n max_salt_size=None\n \n \n \n \n default_rounds=480000\n min_rounds=1\n max_rounds=4294967295\n rounds_cost=\"linear\"\n \n \n default_variant=1\n _variant_info={\n \n 0:(\"sha1\",20),\n 1:(\"sha256\",32),\n 2:(\"sha384\",48),\n 3:(\"sha512\",64),\n }\n _variant_aliases=dict(\n [(unicode(k),k)for k in _variant_info]+\n [(v[0],k)for k,v in iteritems(_variant_info)]\n )\n \n \n \n \n @classmethod\n def using(cls,variant=None ,**kwds):\n  subcls=super(fshp,cls).using(**kwds)\n  if variant is not None :\n   subcls.default_variant=cls._norm_variant(variant)\n  return subcls\n  \n  \n  \n  \n variant=None\n \n \n \n \n def __init__(self,variant=None ,**kwds):\n \n  self.use_defaults=kwds.get(\"use_defaults\")\n  if variant is not None :\n   variant=self._norm_variant(variant)\n  elif self.use_defaults:\n   variant=self.default_variant\n   assert self._norm_variant(variant)==variant,\"invalid default variant: %r\"%(variant,)\n  else :\n   raise TypeError(\"no variant specified\")\n  self.variant=variant\n  super(fshp,self).__init__(**kwds)\n  \n @classmethod\n def _norm_variant(cls,variant):\n  if isinstance(variant,bytes):\n   variant=variant.decode(\"ascii\")\n  if isinstance(variant,unicode):\n   try :\n    variant=cls._variant_aliases[variant]\n   except KeyError:\n    raise ValueError(\"invalid fshp variant\")\n  if not isinstance(variant,int):\n   raise TypeError(\"fshp variant must be int or known alias\")\n  if variant not in cls._variant_info:\n   raise ValueError(\"invalid fshp variant\")\n  return variant\n  \n @property\n def checksum_alg(self):\n  return self._variant_info[self.variant][0]\n  \n @property\n def checksum_size(self):\n  return self._variant_info[self.variant][1]\n  \n  \n  \n  \n  \n _hash_regex=re.compile(u(r\"\"\"\n            ^\n            \\{FSHP\n            (\\d+)\\| # variant\n            (\\d+)\\| # salt size\n            (\\d+)\\} # rounds\n            ([a-zA-Z0-9+/]+={0,3}) # digest\n            $\"\"\"),re.X)\n \n @classmethod\n def from_string(cls,hash):\n  hash=to_unicode(hash,\"ascii\",\"hash\")\n  m=cls._hash_regex.match(hash)\n  if not m:\n   raise uh.exc.InvalidHashError(cls)\n  variant,salt_size,rounds,data=m.group(1,2,3,4)\n  variant=int(variant)\n  salt_size=int(salt_size)\n  rounds=int(rounds)\n  try :\n   data=b64decode(data.encode(\"ascii\"))\n  except TypeError:\n   raise uh.exc.MalformedHashError(cls)\n  salt=data[:salt_size]\n  chk=data[salt_size:]\n  return cls(salt=salt,checksum=chk,rounds=rounds,variant=variant)\n  \n def to_string(self):\n  chk=self.checksum\n  salt=self.salt\n  data=bascii_to_str(b64encode(salt+chk))\n  return \"{FSHP%d|%d|%d}%s\"%(self.variant,len(salt),self.rounds,data)\n  \n  \n  \n  \n  \n def _calc_checksum(self,secret):\n  if isinstance(secret,unicode):\n   secret=secret.encode(\"utf-8\")\n   \n   \n   \n  return pbkdf1(\n  digest=self.checksum_alg,\n  secret=self.salt,\n  salt=secret,\n  rounds=self.rounds,\n  keylen=self.checksum_size,\n  )\n  \n  \n  \n  \n  \n  \n  \n  \n", ["base64", "logging", "passlib.crypto.digest", "passlib.utils", "passlib.utils.compat", "passlib.utils.handlers", "re"]]}
__BRYTHON__.update_VFS(scripts)
